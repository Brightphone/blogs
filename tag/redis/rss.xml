<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>brightphone.github.io/blogs/</title>
   
   <link></link>
   <description>A beautiful narrative written with the world's most elegant publishing platform. The story begins here.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Sidekiq 如何处理异步任务</title>
	  <link>/blogs//sidekiq</link>
	  <author></author>
	  <pubDate>2017-08-28T00:00:00+00:00</pubDate>
	  <guid>/blogs//sidekiq</guid>
	  <description><![CDATA[
	     <p><a href="https://github.com/mperham/sidekiq">Sidekiq</a> 是 Ruby 和 Rails 项目中常用的后台任务处理系统，其本身提供的 API 十分简洁，源代码也非常易于阅读，是一个轻量级的异步处理组件；虽然其本身没有提供太多复杂的功能，但是它的使用和部署非常简单。在这篇文章中，我们将对 Sidekiq 的实现原理进行介绍和分析。</p>

<p><img src="https://img.draveness.me/2017-08-28-Sidekiq-Cover.jpg-1000width" alt="Sidekiq-Cover" /></p>

<p>文章中并不会详细介绍 Sidekiq 的使用，也并不是一篇 Sidekiq 的教程，在这里我们会介绍任务的入队过程、Sidekiq 任务在 Redis 中的存储方式和消费者对任务的处理过程，除此之外，文章将介绍 Sidekiq 中间件的实现以及任务重试的原理。</p>

<h2 id="概述">概述</h2>

<p>在具体分析介绍 Sidekiq 的实现原理之前，我们需要对整个组件的使用过程进行概述，保证我们对 Sidekiq 的结构有一个总体上的了解。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HardWorker</span>
  <span class="kp">include</span> <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Worker</span>
  <span class="k">def</span> <span class="nf">perform</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
    <span class="c1"># do something</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">HardWorker</span><span class="p">.</span><span class="nf">perform_async</span><span class="p">(</span><span class="s1">'bob'</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</code></pre></div></div>

<p>在这里，我们直接照搬 Sidekiq Wiki 中 <a href="https://github.com/mperham/sidekiq/wiki/Getting-Started">Getting Started</a> 部分的代码简单展示下它是如何使用的，当我们执行 <code class="highlighter-rouge">HardWorker.perform_async</code> 方法时，Sidekiq 的 Worker 会将一个异步任务以 JSON 的形式将相关的信息加入 Redis 中并等待消费者对任务的拉取和处理。</p>

<p><img src="https://img.draveness.me/2017-08-28-Sidekiq-Arch.jpg-1000width" alt="Sidekiq-Arch" /></p>

<p>Sidekiq 的消费者有三个部分组成，分别是 <code class="highlighter-rouge">Manager</code>、<code class="highlighter-rouge">Processor</code> 和 <code class="highlighter-rouge">Poller</code>；他们三者会相互协作共同完成对 Redis 中任务消费的过程。</p>

<blockquote>
  <p>需要注意的是，Sidekiq 中的 <code class="highlighter-rouge">Sidekiq::Worker</code> 并不是真正用于处理任务的 Worker，负责执行执行任务的类型其实是 <code class="highlighter-rouge">Sidekiq::Processor</code>；在文章中，当我们提到 Sidekiq Worker 时，其实说的是 <code class="highlighter-rouge">Sidekiq::Processor</code>，当我们使用了形如 <code class="highlighter-rouge">Sidekiq::Worker</code> 或者 <code class="highlighter-rouge">Worker</code> 的形式时，我们说的就是对应的类。</p>
</blockquote>

<h2 id="异步任务的入队">异步任务的入队</h2>

<p>当我们对需要异步执行的任务调用类似 <code class="highlighter-rouge">Worker.perform_async</code> 的方法时，Sidekiq 其实并不会真正去创建一个 <code class="highlighter-rouge">HardWorker</code> 等 <code class="highlighter-rouge">Worker</code> 的对象，它实际上会调用 <code class="highlighter-rouge">Worker.client_push</code> 方法并将当前的 <code class="highlighter-rouge">class</code> 和 <code class="highlighter-rouge">args</code> 参数传进去，也就是需要异步执行的类和参数：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">perform_async</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">client_push</span><span class="p">(</span><span class="s1">'class'</span><span class="p">.</span><span class="nf">freeze</span> <span class="o">=&gt;</span> <span class="nb">self</span><span class="p">,</span> <span class="s1">'args'</span><span class="p">.</span><span class="nf">freeze</span> <span class="o">=&gt;</span> <span class="n">args</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>除了 <code class="highlighter-rouge">Worker.perform_async</code> 之外，<code class="highlighter-rouge">Worker</code> 还提供了另外一对用于<strong>在一段时间之后或者某个时间点</strong>执行相应任务的方法 <code class="highlighter-rouge">Worker.perform_at</code> 和 <code class="highlighter-rouge">Worker.perform_in</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">perform_in</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">int</span> <span class="o">=</span> <span class="n">interval</span><span class="p">.</span><span class="nf">to_f</span>
  <span class="n">now</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span>
  <span class="n">ts</span> <span class="o">=</span> <span class="p">(</span><span class="n">int</span> <span class="o">&lt;</span> <span class="mi">1_000_000_000</span> <span class="p">?</span> <span class="n">now</span> <span class="o">+</span> <span class="n">int</span> <span class="p">:</span> <span class="n">int</span><span class="p">)</span>
  <span class="n">item</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">'class'</span><span class="p">.</span><span class="nf">freeze</span> <span class="o">=&gt;</span> <span class="nb">self</span><span class="p">,</span> <span class="s1">'args'</span><span class="p">.</span><span class="nf">freeze</span> <span class="o">=&gt;</span> <span class="n">args</span><span class="p">,</span> <span class="s1">'at'</span><span class="p">.</span><span class="nf">freeze</span> <span class="o">=&gt;</span> <span class="n">ts</span> <span class="p">}</span>
  <span class="n">item</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="s1">'at'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">)</span> <span class="k">if</span> <span class="n">ts</span> <span class="o">&lt;=</span> <span class="n">now</span>
  <span class="n">client_push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="k">end</span>
<span class="kp">alias_method</span> <span class="ss">:perform_at</span><span class="p">,</span> <span class="ss">:perform_in</span>
</code></pre></div></div>

<p>为了使用同一个接口支持两种不同的安排方式（时间点和多久之后），方法内部对传入的 <code class="highlighter-rouge">internal</code> 进行了判断，当 <code class="highlighter-rouge">interval.to_f &lt; 1_000_000_000</code> 时就会在一段时间之后执行任务，否则就会以时间点的方式执行任务，虽然 <code class="highlighter-rouge">Worker.perform_at</code> 和 <code class="highlighter-rouge">Worker.perform_in</code> 是完全相同的方法，不过我们在使用时还是尽量遵循方法的语义选择两者中更符合逻辑的方法。</p>

<p><img src="https://img.draveness.me/2017-08-28-Client-Push-Item.jpg-1000width" alt="Client-Push-Item" /></p>

<p>两种创建异步任务的方式，最终都执行了 <code class="highlighter-rouge">Worker.client_push</code> 方法并传入了一个哈希，其中可能包含以上三个部分的内容；在方法的实现中，它获取了上下文中的 Redis 池并将传入的 <code class="highlighter-rouge">item</code> 对象传入 Redis 中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">client_push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
  <span class="n">pool</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">[</span><span class="ss">:sidekiq_via_pool</span><span class="p">]</span> <span class="o">||</span> <span class="n">get_sidekiq_options</span><span class="p">[</span><span class="s1">'pool'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span> <span class="o">||</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">redis_pool</span>
  <span class="n">item</span><span class="p">.</span><span class="nf">keys</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="o">|</span>
    <span class="n">item</span><span class="p">[</span><span class="n">key</span><span class="p">.</span><span class="nf">to_s</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Client</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">pool</span><span class="p">).</span><span class="nf">push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>简单整理一下，从 <code class="highlighter-rouge">Worker.perform_async</code> 方法到 <code class="highlighter-rouge">Client#push</code> 方法整个过程都在对即将加入到 Redis 中队列的哈希进行操作，从添加 <code class="highlighter-rouge">at</code> 字段到字符串化、再到 <code class="highlighter-rouge">Client#normalize_item</code> 方法中添加 <code class="highlighter-rouge">jid</code> 和 <code class="highlighter-rouge">created_at</code> 字段。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
  <span class="n">normed</span> <span class="o">=</span> <span class="n">normalize_item</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
  <span class="n">payload</span> <span class="o">=</span> <span class="n">process_single</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s1">'class'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">],</span> <span class="n">normed</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">payload</span>
    <span class="n">raw_push</span><span class="p">([</span><span class="n">payload</span><span class="p">])</span>
    <span class="n">payload</span><span class="p">[</span><span class="s1">'jid'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>所有添加异步任务的方法最终都调用了私有方法 <code class="highlighter-rouge">Client#raw_push</code> 以及 <code class="highlighter-rouge">Client#atomic_push</code> 向 Redis 中添加数据，在这时会有两种不同的情况发生，当异步任务需要在未来的某一时间点进行安排时，它会加入 Redis 的一个有序集合：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">atomc_push</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">payloads</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">payloads</span><span class="p">.</span><span class="nf">first</span><span class="p">[</span><span class="s1">'at'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
    <span class="n">conn</span><span class="p">.</span><span class="nf">zadd</span><span class="p">(</span><span class="s1">'schedule'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">,</span> <span class="n">payloads</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="nb">hash</span><span class="o">|</span>
                <span class="n">at</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="s1">'at'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">).</span><span class="nf">to_s</span>
                <span class="p">[</span><span class="n">at</span><span class="p">,</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">dump_json</span><span class="p">(</span><span class="nb">hash</span><span class="p">)]</span>
              <span class="k">end</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个有序集合中，Sidekiq 理所应当地将 <code class="highlighter-rouge">schedule</code> 作为权重，而其他的全部字段都以 JSON 的格式作为负载传入；但是当 Sidekiq 遇到需要立即执行的异步任务时，实现就有一些不同了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">atomc_push</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">payloads</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">payloads</span><span class="p">.</span><span class="nf">first</span><span class="p">[</span><span class="s1">'at'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
  <span class="c1"># ...</span>
  <span class="k">else</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">payloads</span><span class="p">.</span><span class="nf">first</span><span class="p">[</span><span class="s1">'queue'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
    <span class="n">now</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span>
    <span class="n">to_push</span> <span class="o">=</span> <span class="n">payloads</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">entry</span><span class="o">|</span>
      <span class="n">entry</span><span class="p">[</span><span class="s1">'enqueued_at'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span> <span class="o">=</span> <span class="n">now</span>
      <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">dump_json</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">conn</span><span class="p">.</span><span class="nf">sadd</span><span class="p">(</span><span class="s1">'queues'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">conn</span><span class="p">.</span><span class="nf">lpush</span><span class="p">(</span><span class="s2">"queue:</span><span class="si">#{</span><span class="n">q</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="n">to_push</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>除了设置当前任务的入队时间 <code class="highlighter-rouge">enqueued_at</code> 之外，Sidekiq 将队列加入到一个大队列 <code class="highlighter-rouge">queues</code> 的集合中，并且将负载直接推到 <code class="highlighter-rouge">"queue:#{q}"</code> 数组中等待消费者的拉取，我们稍微梳理一下两种安排异步队列方法的调用过程：</p>

<p><img src="https://img.draveness.me/2017-08-28-Async-Schedule.jpg-1000width" alt="Async-Schedule" /></p>

<h3 id="redis-中的存储">Redis 中的存储</h3>

<p>无论是立即执行还是需要安排的异步任务都会进入 Redis 的队列中，但是它们之间还是有一些区别的，<code class="highlighter-rouge">Worker.perform_in/at</code> 会将任务以 <code class="highlighter-rouge">[at, args]</code> 的形式加入到 <code class="highlighter-rouge">schedules</code> 有序集中，而
<code class="highlighter-rouge">Worker.perform_async</code> 将负载加入到指定的队列，并向整个 Sidekiq 的队列集合 <code class="highlighter-rouge">queues</code> 中添加该队列。</p>

<p><img src="https://img.draveness.me/2017-08-28-Perform-async-in-Redis.jpg-1000width" alt="Perform-async-in-Redis" /></p>

<p>所有的 <code class="highlighter-rouge">payload</code> 中都包含了一个异步任务需要执行的全部信息，包括该任务的执行的队列 <code class="highlighter-rouge">queue</code>、异步队列的类 <code class="highlighter-rouge">class</code>、参数 <code class="highlighter-rouge">args</code> 以及 <code class="highlighter-rouge">sidekiq_options</code> 中的全部参数。</p>

<p><img src="https://img.draveness.me/2017-08-28-Job-in-Redis.jpg-1000width" alt="Job-in-Redis" /></p>

<p>除了上述参数，一个异步任务还包含诸如 <code class="highlighter-rouge">created_at</code>、<code class="highlighter-rouge">enqueued_at</code> 等信息，也有一个通过 <code class="highlighter-rouge">SecureRandom.hex(12)</code> 生成的任务唯一标识符 <code class="highlighter-rouge">jid</code>。</p>

<h2 id="sidekiq-的启动过程">Sidekiq 的启动过程</h2>

<p>作者对于 Sidekiq 印象最深刻的就是它在命令行启动的时候输出的一个字符画，我们能在 <code class="highlighter-rouge">cli.rb</code> 的 <code class="highlighter-rouge">Cli.banner</code> 方法中找到这个字符画：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>         m,
         `$b
    .ss,  $$:         .,d$
    `$$P,d$P'    .,md$P"'
     ,$$$$$bmmd$$$P^'
   .d$$$$$$$$$$P'
   $$^' `"^$$$'       ____  _     _      _    _
   $:     ,$$:       / ___|(_) __| | ___| | _(_) __ _
   `b     :$$        \___ \| |/ _` |/ _ \ |/ / |/ _` |
          $$:         ___) | | (_| |  __/   &lt;| | (_| |
          $$         |____/|_|\__,_|\___|_|\_\_|\__, |
        .d$$                                       |_|
</code></pre></div></div>

<p>这一节也将介绍 Sidekiq 的启动过程，在 <code class="highlighter-rouge">bin</code> 文件夹中的 sidekiq 文件包含的内容就是在命令行执行 <code class="highlighter-rouge">sidekiq</code> 时执行的代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">begin</span>
  <span class="n">cli</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="o">::</span><span class="no">CLI</span><span class="p">.</span><span class="nf">instance</span>
  <span class="n">cli</span><span class="p">.</span><span class="nf">parse</span>
  <span class="n">cli</span><span class="p">.</span><span class="nf">run</span>
<span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这里的代码就是创建了一个 <code class="highlighter-rouge">CLI</code> 对象，执行 <code class="highlighter-rouge">CLI#parse</code> 方法对参数进行解析，最后调用 <code class="highlighter-rouge">CLI#run</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run</span>
  <span class="n">print_banner</span>

  <span class="n">self_read</span><span class="p">,</span> <span class="n">self_write</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>
  <span class="c1"># ...</span>

  <span class="n">launcher</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Launcher</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
  <span class="k">begin</span>
    <span class="n">launcher</span><span class="p">.</span><span class="nf">run</span>
    <span class="k">while</span> <span class="n">readable_io</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">select</span><span class="p">([</span><span class="n">self_read</span><span class="p">])</span>
      <span class="n">signal</span> <span class="o">=</span> <span class="n">readable_io</span><span class="p">.</span><span class="nf">first</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">gets</span><span class="p">.</span><span class="nf">strip</span>
      <span class="n">handle_signal</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="no">Interrupt</span>
    <span class="n">launcher</span><span class="p">.</span><span class="nf">stop</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="从-launcher-到-manager">从 Launcher 到 Manager</h3>

<p><code class="highlighter-rouge">CLI#run</code> 在执行最开始就会打印 banner，也就是我们在每次启动 Sidekiq 时看到的字符画，而在之后会执行 <code class="highlighter-rouge">Launcher#run</code> 运行用于处理异步任务的 <code class="highlighter-rouge">Processor</code> 等对象。</p>

<p><img src="https://img.draveness.me/2017-08-28-Launcher-Poller-Manager-Processors.jpg-1000width" alt="Launcher-Poller-Manager-Processors" /></p>

<p>每一个 <code class="highlighter-rouge">Launcher</code> 都会启动一个 <code class="highlighter-rouge">Manager</code> 对象和一个 <code class="highlighter-rouge">Poller</code>，其中 <code class="highlighter-rouge">Manager</code> 同时管理了多个 <code class="highlighter-rouge">Processor</code> 对象，这些不同的类之间有着如上图所示的关系。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run</span>
  <span class="vi">@thread</span> <span class="o">=</span> <span class="n">safe_thread</span><span class="p">(</span><span class="s2">"heartbeat"</span><span class="p">,</span> <span class="o">&amp;</span><span class="nb">method</span><span class="p">(</span><span class="ss">:start_heartbeat</span><span class="p">))</span>
  <span class="vi">@poller</span><span class="p">.</span><span class="nf">start</span>
  <span class="vi">@manager</span><span class="p">.</span><span class="nf">start</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Manager</code> 会在初始化时根据传入的 <code class="highlighter-rouge">concurrency</code> 的值创建对应数量的 <code class="highlighter-rouge">Processor</code>，默认的并行数量为 25；当执行 <code class="highlighter-rouge">Manager#start</code> 时，就会启动对应数量的<strong>线程</strong>和处理器开始对任务进行处理：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Manager</span>
  <span class="k">def</span> <span class="nf">start</span>
    <span class="vi">@workers</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
      <span class="n">x</span><span class="p">.</span><span class="nf">start</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Processor</span>
  <span class="k">def</span> <span class="nf">start</span>
    <span class="vi">@thread</span> <span class="o">||=</span> <span class="n">safe_thread</span><span class="p">(</span><span class="s2">"processor"</span><span class="p">,</span> <span class="o">&amp;</span><span class="nb">method</span><span class="p">(</span><span class="ss">:run</span><span class="p">))</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>从 <code class="highlighter-rouge">Launcher</code> 的启动到现在只是一个调用 <code class="highlighter-rouge">initialize</code> 和 <code class="highlighter-rouge">start</code> 方法的过程，再加上 Sidekiq 源代码非常简单，所以阅读起没有丝毫的难度，也就不做太多的解释了。</p>

<h3 id="并行模型">并行模型</h3>

<p>当处理器开始执行 <code class="highlighter-rouge">Processor#run</code> 方法时，就开始对所有的任务进行处理了；从总体来看，Sidekiq 使用了多线程的模型对任务进行处理，每一个 <code class="highlighter-rouge">Processor</code> 都是使用了 <code class="highlighter-rouge">safe_thread</code> 方法在一个新的线程里面运行的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">safe_thread</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">[</span><span class="s1">'sidekiq_label'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span> <span class="o">=</span> <span class="nb">name</span>
    <span class="n">watchdog</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在使用 Sidekiq 时，我们也会在不同的机器上开启多个 Sidekiq Worker，也就是说 Sidekiq 可以以多进程、多线程的方式运行，同时处理大量的异步任务。</p>

<p><img src="https://img.draveness.me/2017-08-28-Sidekiq-Multi-Processes.jpg-1000width" alt="Sidekiq-Multi-Processes" /></p>

<p>到目前为止，我们已经分析了异步任务的入队以及 Sidekiq Worker 的启动过程了，接下来即将分析 Sidekiq 对异步任务的处理过程。</p>

<h3 id="主题的订阅">『主题』的订阅</h3>

<p>作为一个 Sidekiq Worker 进程，它在启动时就会决定选择订阅哪些『主题』去执行，比如当我们使用下面的命令时：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> sidekiq <span class="nt">-q</span> critical,2 <span class="nt">-q</span> default
</code></pre></div></div>

<p><code class="highlighter-rouge">CLI#parse</code> 方法会对传入的 <code class="highlighter-rouge">-q</code> 参数进行解析，但是当执行 <code class="highlighter-rouge">sidekiq</code> 命令却没有传入队列参数时，Sidekiq 只会订阅 <code class="highlighter-rouge">default</code> 队列中的任务：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="no">ARGV</span><span class="p">)</span>
  <span class="c1"># ...</span>
  <span class="n">validate!</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">validate!</span>
  <span class="n">options</span><span class="p">[</span><span class="ss">:queues</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s1">'default'</span> <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="ss">:queues</span><span class="p">].</span><span class="nf">empty?</span>
<span class="k">end</span>
</code></pre></div></div>

<p>同时，默认情况下的队列的优先级都为 <code class="highlighter-rouge">1</code>，高优先级的队列在当前的任务中可以得到更多的执行机会，实现的方法是通过增加同一个 <code class="highlighter-rouge">queues</code> 集合中高优先级队列的数量，我们可以在 <code class="highlighter-rouge">CLI#parse_queue</code> 中找到实现这一功能的代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parse_queue</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kp">nil</span><span class="p">)</span>
  <span class="p">[</span><span class="n">weight</span><span class="p">.</span><span class="nf">to_i</span><span class="p">,</span> <span class="mi">1</span><span class="p">].</span><span class="nf">max</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
    <span class="p">(</span><span class="n">opts</span><span class="p">[</span><span class="ss">:queues</span><span class="p">]</span> <span class="o">||=</span> <span class="p">[])</span> <span class="o">&lt;&lt;</span> <span class="n">q</span>
  <span class="k">end</span>
  <span class="n">opts</span><span class="p">[</span><span class="ss">:strict</span><span class="p">]</span> <span class="o">=</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">weight</span><span class="p">.</span><span class="nf">to_i</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="k">end</span>
</code></pre></div></div>

<p>到这里，其实我们就完成了设置过程中 Sidekiq Worker 『主题』订阅的功能了，我们将在后面 <a href="#执行任务">执行任务</a> 的部分具体介绍 Sidekiq 是如何使用这些参数的。</p>

<h2 id="异步任务的处理">异步任务的处理</h2>

<p>从异步任务的入队一节中，我们可以清楚地看到使用 <code class="highlighter-rouge">#perform_async</code> 和 <code class="highlighter-rouge">#perform_in</code> 两种方法创建的数据结构 <code class="highlighter-rouge">payload</code> 最终以不同的方式进入了 Redis 中，所以在这里我们将异步任务的处理分为定时任务和『立即』任务两个部分，分别对它们不同的处理方式进行分析。</p>

<h3 id="定时任务">定时任务</h3>

<p>Sidekiq 使用 <code class="highlighter-rouge">Scheduled::Poller</code> 对 Redis 中 <code class="highlighter-rouge">schedules</code> 有序集合中的负载进行处理，其中包括 <code class="highlighter-rouge">retry</code> 和 <code class="highlighter-rouge">schedule</code> 两个有序集合中的内容。</p>

<p><img src="https://img.draveness.me/2017-08-28-Redis-Sorted-Set.jpg-1000width" alt="Redis-Sorted-Set" /></p>

<p>在 <code class="highlighter-rouge">Poller</code> 被 <code class="highlighter-rouge">Scheduled::Poller</code> 启动时会调用 <code class="highlighter-rouge">#start</code> 方法开始对上述两个有序集合轮训，<code class="highlighter-rouge">retry</code> 中包含了所有重试的任务，而 <code class="highlighter-rouge">schedule</code> 就是被安排到指定时间执行的定时任务了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">start</span>
  <span class="vi">@thread</span> <span class="o">||=</span> <span class="n">safe_thread</span><span class="p">(</span><span class="s2">"scheduler"</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">initial_wait</span>
    <span class="k">while</span> <span class="o">!</span><span class="vi">@done</span>
      <span class="n">enqueue</span>
      <span class="n">wait</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Scheduled::Poller#start</code> 方法内部执行了一个 <code class="highlighter-rouge">while</code> 循环，在循环内部也只包含入队和等待两个操作，用于入队的方法最终调用了 <code class="highlighter-rouge">Scheduled::Poll::Enq#enqueue_jobs</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">enqueue_jobs</span><span class="p">(</span><span class="n">now</span><span class="o">=</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span><span class="p">.</span><span class="nf">to_s</span><span class="p">,</span> <span class="n">sorted_sets</span><span class="o">=</span><span class="no">SETS</span><span class="p">)</span>
  <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">redis</span> <span class="k">do</span> <span class="o">|</span><span class="n">conn</span><span class="o">|</span>
    <span class="n">sorted_sets</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">sorted_set</span><span class="o">|</span>
      <span class="k">while</span> <span class="n">job</span> <span class="o">=</span> <span class="n">conn</span><span class="p">.</span><span class="nf">zrangebyscore</span><span class="p">(</span><span class="n">sorted_set</span><span class="p">,</span> <span class="s1">'-inf'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="ss">:limit</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]).</span><span class="nf">first</span> <span class="k">do</span>
        <span class="k">if</span> <span class="n">conn</span><span class="p">.</span><span class="nf">zrem</span><span class="p">(</span><span class="n">sorted_set</span><span class="p">,</span> <span class="n">job</span><span class="p">)</span>
          <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Client</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="no">Sidekiq</span><span class="p">.</span><span class="nf">load_json</span><span class="p">(</span><span class="n">job</span><span class="p">))</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>传入的 <code class="highlighter-rouge">SETS</code> 其实就是 <code class="highlighter-rouge">retry</code> 和 <code class="highlighter-rouge">schedule</code> 构成的数组，在上述方法中，Sidekiq 通过一个 <code class="highlighter-rouge">Redis#zrangebyscore</code> 和 <code class="highlighter-rouge">Redis#zrem</code> 将集合中小于当前时间的任务全部加到立即任务中，最终调用是在前面已经提到过的 <code class="highlighter-rouge">Client#push</code> 方法将任务推到指定的队列中。</p>

<p><img src="https://img.draveness.me/2017-08-28-Redis-Sidekiq-Poller.jpg-1000width" alt="Redis-Sidekiq-Poller" /></p>

<p>由于 <code class="highlighter-rouge">Scheduled::Poller</code> 并不是不停地对 Redis 中的数据进行处理的，因为当前进程一直都在执行 <code class="highlighter-rouge">Poller#enqueue</code> 其实是一个非常低效的方式，所以 Sidekiq 会在每次执行 <code class="highlighter-rouge">Poller#enqueue</code> 之后，执行 <code class="highlighter-rouge">Poller#wait</code> 方法，随机等待一段时间：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">wait</span>
  <span class="vi">@sleeper</span><span class="p">.</span><span class="nf">pop</span><span class="p">(</span><span class="n">random_poll_interval</span><span class="p">)</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">random_poll_interval</span>
  <span class="n">poll_interval_average</span> <span class="o">*</span> <span class="nb">rand</span> <span class="o">+</span> <span class="n">poll_interval_average</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">/</span> <span class="mi">2</span>
<span class="k">end</span>
</code></pre></div></div>

<p>随机等待时间的范围在 <code class="highlighter-rouge">[0.5 * poll_interval_average, 1.5 * poll_interval_average]</code> 之间；通过随机的方式，Sidekiq 可以避免在多个线程处理任务时，短时间内 Redis 接受大量的请求发生延迟等问题，能够保证从长期来看 Redis 接受的请求数是平均的；同时因为 <code class="highlighter-rouge">Scheduled::Poller</code> 使用了 <code class="highlighter-rouge">#enqueue</code> 加 <code class="highlighter-rouge">#wait</code> 对 Redis 中的数据进行消费，所以没有办法保证任务会在指定的时间点执行，<strong>执行的时间一定比安排的时间要晚</strong>，这也是我们在使用 Sidekiq 时需要注意的。</p>

<blockquote>
  <p>随机等待的时间其实不止与 <code class="highlighter-rouge">poll_interval_average</code> 有关，在默认情况下，它是当前进程数的 15 倍，在有 30 个 Sidekiq 线程时，每个线程会每隔 225 ~ 675s 的时间请求一次。</p>
</blockquote>

<h3 id="执行任务">执行任务</h3>

<p>定时任务是由 <code class="highlighter-rouge">Scheduled::Poller</code> 进行处理的，将其中需要执行的异步任务加入到指定的队列中，而这些任务最终都会在 <code class="highlighter-rouge">Processor#run</code> 真正被执行：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run</span>
  <span class="k">begin</span>
    <span class="k">while</span> <span class="o">!</span><span class="vi">@done</span>
      <span class="n">process_one</span>
    <span class="k">end</span>
    <span class="vi">@mgr</span><span class="p">.</span><span class="nf">processor_stopped</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
  <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">ex</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当处理结束或者发生异常时会调用 <code class="highlighter-rouge">Manager#processor_stopped</code> 或者 <code class="highlighter-rouge">Manager#processor_died</code> 方法对 <code class="highlighter-rouge">Processor</code> 进行处理；在处理任务时其实也分为两个部分，也就是 <code class="highlighter-rouge">#fetch</code> 和 <code class="highlighter-rouge">#process</code> 两个方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">process_one</span>
  <span class="vi">@job</span> <span class="o">=</span> <span class="n">fetch</span>
  <span class="n">process</span><span class="p">(</span><span class="vi">@job</span><span class="p">)</span> <span class="k">if</span> <span class="vi">@job</span>
  <span class="vi">@job</span> <span class="o">=</span> <span class="kp">nil</span>
<span class="k">end</span>
</code></pre></div></div>

<p>我们先来看一下整个方法的调用栈，任务的获取从 <code class="highlighter-rouge">Processor#process_one</code> 一路调用下来，直到 <code class="highlighter-rouge">BasicFetch#retrive_work</code> 返回了 <code class="highlighter-rouge">UnitOfWork</code> 对象，返回的对象会经过分发最后执行对应类的 <code class="highlighter-rouge">#perform</code> 传入参数真正运行该任务：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Processor#process_one
├── Processor#fetch
│   └── Processor#get_one
│       └── BasicFetch#retrive_work
│           ├── Redis#brpop
│           └── UnitOfWork#new
└── Processor#process
    ├── Processor#dispatch
    ├── Processor#execute_job
    └── Worker#perform
</code></pre></div></div>

<p>对于任务的获取，我们需要关注的就是 <code class="highlighter-rouge">BasicFetch#retrive_work</code> 方法，他会从 Redis 中相应队列的有序数组中 <code class="highlighter-rouge">Redis#brpop</code> 出一个任务，然后封装成 <code class="highlighter-rouge">UnitOfWork</code> 对象后返回。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">retrieve_work</span>
  <span class="n">work</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">redis</span> <span class="p">{</span> <span class="o">|</span><span class="n">conn</span><span class="o">|</span> <span class="n">conn</span><span class="p">.</span><span class="nf">brpop</span><span class="p">(</span><span class="o">*</span><span class="n">queues_cmd</span><span class="p">)</span> <span class="p">}</span>
  <span class="no">UnitOfWork</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="o">*</span><span class="n">work</span><span class="p">)</span> <span class="k">if</span> <span class="n">work</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">#queues_cmd</code> 这个实例方法其实就用到了在主题的订阅一节中的 <code class="highlighter-rouge">queues</code> 参数，该参数会在 <code class="highlighter-rouge">Processor</code> 初始化是创建一个 <code class="highlighter-rouge">BasicFetch</code> 策略对象，最终在 <code class="highlighter-rouge">BasicFetch#queues_cmd</code> 方法调用时返回一个类似下面的数组：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">queue</span><span class="ss">:high</span>
<span class="n">queue</span><span class="ss">:high</span>
<span class="n">queue</span><span class="ss">:high</span>
<span class="n">queue</span><span class="ss">:low</span>
<span class="n">queue</span><span class="ss">:low</span>
<span class="n">queue</span><span class="ss">:default</span>
</code></pre></div></div>

<p>这样就可以实现了队列的优先级这一个功能了，返回的 <code class="highlighter-rouge">UnitOfWork</code> 其实是一个通过 <code class="highlighter-rouge">Struct.new</code> 创建的结构体，它会在 <code class="highlighter-rouge">Processor#process</code> 方法中作为资源被处理：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">work</span><span class="p">)</span>
  <span class="n">jobstr</span> <span class="o">=</span> <span class="n">work</span><span class="p">.</span><span class="nf">job</span>
  <span class="n">queue</span> <span class="o">=</span> <span class="n">work</span><span class="p">.</span><span class="nf">queue_name</span>

  <span class="k">begin</span>
    <span class="c1"># ...</span>

    <span class="n">job_hash</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">load_json</span><span class="p">(</span><span class="n">jobstr</span><span class="p">)</span>
    <span class="n">dispatch</span><span class="p">(</span><span class="n">job_hash</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">worker</span><span class="o">|</span>
      <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">server_middleware</span><span class="p">.</span><span class="nf">invoke</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">job_hash</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="k">do</span>
        <span class="n">execute_job</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">cloned</span><span class="p">(</span><span class="n">job_hash</span><span class="p">[</span><span class="s1">'args'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]))</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">ex</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>该方法对任务的执行其实总共有四个步骤：</p>

<ol>
  <li>将 Redis 中存储的字符串加载为 JSON；</li>
  <li>执行 <code class="highlighter-rouge">Processor#dispatch</code> 方法并在内部提供方法重试等功能，同时也实例化一个 <code class="highlighter-rouge">Sidekiq::Worker</code> 对象；</li>
  <li>依次执行服务端的中间件，可能会对参数进行更新；</li>
  <li>调用 <code class="highlighter-rouge">Processor#execute_job</code> 方法执行任务；</li>
</ol>

<p>而最后调用的时用于执行任务的方法 <code class="highlighter-rouge">Processor#execute_job</code>，它的实现也是到目前为止最为简单的方法之一了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_job</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">cloned_args</span><span class="p">)</span>
  <span class="n">worker</span><span class="p">.</span><span class="nf">perform</span><span class="p">(</span><span class="o">*</span><span class="n">cloned_args</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>该方法在<strong>线程</strong>中执行了客户端创建的 <code class="highlighter-rouge">Worker</code> 类的实例方法 <code class="highlighter-rouge">#perform</code> 并传入了经过两侧中间件处理后的参数。</p>

<h3 id="小结">小结</h3>

<p>到目前为止，Sidekiq Worker 对任务的消费过程就是圆满的了，从客户端创建一个拥有 <code class="highlighter-rouge">#perform</code> 方法的 <code class="highlighter-rouge">Worker</code> 到消费者去执行该方法形成了一个闭环，完成了对任务的调度。</p>

<p><img src="https://img.draveness.me/2017-08-28-Client-Redis-Sidekiq-Worker.jpg-1000width" alt="Client-Redis-Sidekiq-Worker" /></p>

<p>Sidekiq 是一个非常轻量级的任务调度系统，它使用 Redis 作为整个系统的消息队列，在两侧分别建立了生产者和消费者的模块，不过除了这几个比较重要的模块，Sidekiq 中还有一些功能是我们无法忽略的，比如中间件、兼容 ActiveJob 甚至是测试的实现，都是我们需要去了解的；接下来，我们将介绍和分析主干之外的『分叉』功能。</p>

<h2 id="中间件">中间件</h2>

<p>中间件模块是 Sidekiq 为我们在整个任务的处理流程提供的两个钩子，一个是在客户端的钩子，另一个在 Sidekiq Worker 中。</p>

<p><img src="https://img.draveness.me/2017-08-28-Middlewares-Client-Redis-Sidekiq-Worker.jpg-1000width" alt="Middlewares-Client-Redis-Sidekiq-Worker" /></p>

<p>中间件的使用其实非常简单，我们默认所有的中间件都会拥有一个实例方法 <code class="highlighter-rouge">#call</code> 并接受 <code class="highlighter-rouge">worker</code>、<code class="highlighter-rouge">job</code> 和 <code class="highlighter-rouge">queue</code> 三个参数，在使用时也只需要直接调用 <code class="highlighter-rouge">Chain#add</code> 方法将其加入数组就可以了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AcmeCo</span><span class="o">::</span><span class="no">MyMiddleware</span>
  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># config/initializers/sidekiq.rb</span>
<span class="no">Sidekiq</span><span class="p">.</span><span class="nf">configure_server</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">server_middleware</span> <span class="k">do</span> <span class="o">|</span><span class="n">chain</span><span class="o">|</span>
    <span class="n">chain</span><span class="p">.</span><span class="nf">add</span> <span class="no">AcmeCo</span><span class="o">::</span><span class="no">MyMiddleware</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Sidekiq 将中间件分为了客户端和服务端两个部分，这两个部分的中间件其实并不是严格意义上的在执行之前，由于执行时间点的不同，导致它们有不同的功能：</p>

<ul>
  <li>服务端中间件是『包围』了任务执行过程的，我们可以在中间件中使用 <code class="highlighter-rouge">begin</code>、<code class="highlighter-rouge">rescue</code> 语句，这样当任务出现问题时，我们就可以拿到异常了；</li>
  <li>客户端中间件在任务即将被推入 Redis 之前运行，它能够阻止任务进入 Redis 并且允许我们在任务入队前对其进行修改和停止；</li>
</ul>

<p>当我们对 Sidekiq 中间的使用都有一定的了解时，就可以开始分析中间件的实现了。</p>

<h3 id="实现">实现</h3>

<p>无论是异步任务真正进入队列之前，还是在客户端处理，跟任务有关的信息都会先通过一个预处理流程，客户端和服务端两个中间件的链式调用都使用 <code class="highlighter-rouge">Middleware::Chain</code> 中的类进行处理的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Chain</span>
  <span class="kp">include</span> <span class="no">Enumerable</span>
  <span class="nb">attr_reader</span> <span class="ss">:entries</span>

  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@entries</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">yield</span> <span class="nb">self</span> <span class="k">if</span> <span class="nb">block_given?</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="n">klass</span><span class="p">);</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">prepend</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">insert_before</span><span class="p">(</span><span class="n">oldklass</span><span class="p">,</span> <span class="n">newklass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">insert_after</span><span class="p">(</span><span class="n">oldklass</span><span class="p">,</span> <span class="n">newklass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span> <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>每一个 <code class="highlighter-rouge">Middleware::Chain</code> 中都包含一系列的 <code class="highlighter-rouge">Entry</code>，其中存储了中间件的相关信息，无论是客户端还是服务端都会在执行之前对每一个异步任务的参数执行 <code class="highlighter-rouge">invoke</code> 方法调用 <code class="highlighter-rouge">Middleware::Chain</code> 对象中的所有中间件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">invoke</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">chain</span> <span class="o">=</span> <span class="n">retrieve</span><span class="p">.</span><span class="nf">dup</span>
  <span class="n">traverse_chain</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="k">do</span>
    <span class="k">if</span> <span class="n">chain</span><span class="p">.</span><span class="nf">empty?</span>
      <span class="k">yield</span>
    <span class="k">else</span>
      <span class="n">chain</span><span class="p">.</span><span class="nf">shift</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">traverse_chain</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="n">traverse_chain</span><span class="p">.</span><span class="nf">call</span>
<span class="k">end</span>

</code></pre></div></div>

<p><code class="highlighter-rouge">Chain#invoke</code> 会对其持有的每一个中间件都执行 <code class="highlighter-rouge">#call</code> 方法，中间件都可以对异步任务的参数进行改变或者进行一些记录日志等操作，最后执行传入的 block 并返回结果。</p>

<p><img src="https://img.draveness.me/2017-08-28-Sidekiq-Middlewares.jpg-1000width" alt="Sidekiq-Middlewares" /></p>

<p>当异步队列入队时，就会执行 <code class="highlighter-rouge">Client#process_single</code> 方法调用 Sidekiq 载入中的全部中间件最后返回新的 <code class="highlighter-rouge">item</code> 对象：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">process_single</span><span class="p">(</span><span class="n">worker_class</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
  <span class="n">queue</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="s1">'queue'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
  <span class="n">middleware</span><span class="p">.</span><span class="nf">invoke</span><span class="p">(</span><span class="n">worker_class</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="vi">@redis_pool</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">item</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>每一个 Sidekiq Worker 在处理中间件时也基本遵循相同的逻辑，如 <code class="highlighter-rouge">#process</code> 方法先先执行各种中间件，最后再运行 block 中的内容。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">work</span><span class="p">)</span>
  <span class="n">jobstr</span> <span class="o">=</span> <span class="n">work</span><span class="p">.</span><span class="nf">job</span>
  <span class="n">queue</span> <span class="o">=</span> <span class="n">work</span><span class="p">.</span><span class="nf">queue_name</span>

  <span class="k">begin</span>
    <span class="c1"># ...</span>

    <span class="n">job_hash</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">load_json</span><span class="p">(</span><span class="n">jobstr</span><span class="p">)</span>
    <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">server_middleware</span><span class="p">.</span><span class="nf">invoke</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">job_hash</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">execute_job</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">cloned</span><span class="p">(</span><span class="n">job_hash</span><span class="p">[</span><span class="s1">'args'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]))</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">ex</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">#execute_job</code> 方法执行期间，由于异步任务可能抛出异常，在这时，我们注册的中间件就可以根据情况对异常进行捕获并选择是否对异常进行处理或者抛给上层了。</p>

<h2 id="任务的重试">任务的重试</h2>

<p>Sidekiq 中任务的重试是由 <code class="highlighter-rouge">JobRetry</code> 负责的，<code class="highlighter-rouge">Prcessor</code> 中的 <code class="highlighter-rouge">#dispatch</code> 方法中调用了 <code class="highlighter-rouge">JobRetry#global</code> 方法捕获在异步任务执行过程中发生的错误：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="n">job_hash</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span>
  <span class="n">pristine</span> <span class="o">=</span> <span class="n">cloned</span><span class="p">(</span><span class="n">job_hash</span><span class="p">)</span>

  <span class="c1"># ...</span>
  <span class="vi">@retrier</span><span class="p">.</span><span class="nf">global</span><span class="p">(</span><span class="n">pristine</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">klass</span>  <span class="o">=</span> <span class="n">constantize</span><span class="p">(</span><span class="n">job_hash</span><span class="p">[</span><span class="s1">'class'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">])</span>
    <span class="n">worker</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">new</span>
    <span class="n">worker</span><span class="p">.</span><span class="nf">jid</span> <span class="o">=</span> <span class="n">job_hash</span><span class="p">[</span><span class="s1">'jid'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
    <span class="vi">@retrier</span><span class="p">.</span><span class="nf">local</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">pristine</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="k">do</span>
      <span class="k">yield</span> <span class="n">worker</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>任务的执行过程分别调用了两个 <code class="highlighter-rouge">JobRetry</code> 的方法 <code class="highlighter-rouge">#global</code> 和 <code class="highlighter-rouge">#local</code>，这两个方法在实现上差不多，都将执行异步任务的 block 包在了一个 <code class="highlighter-rouge">begin</code>、<code class="highlighter-rouge">rescue</code> 中，选择在合适的时间重试：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">local</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span>
  <span class="k">yield</span>
<span class="c1"># ...</span>
<span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="k">raise</span> <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Shutdown</span> <span class="k">if</span> <span class="n">exception_caused_by_shutdown?</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">msg</span><span class="p">[</span><span class="s1">'retry'</span><span class="p">]</span> <span class="o">==</span> <span class="kp">nil</span>
    <span class="n">msg</span><span class="p">[</span><span class="s1">'retry'</span><span class="p">]</span> <span class="o">=</span> <span class="n">worker</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">get_sidekiq_options</span><span class="p">[</span><span class="s1">'retry'</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">raise</span> <span class="n">e</span> <span class="k">unless</span> <span class="n">msg</span><span class="p">[</span><span class="s1">'retry'</span><span class="p">]</span>
  <span class="n">attempt_retry</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
  <span class="k">raise</span> <span class="no">Skip</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果我们在定义 <code class="highlighter-rouge">Worker</code> 时就禁用了重试，那么在这里就会直接抛出上层的异常，否则就会进入 <code class="highlighter-rouge">#attempt_retry</code> 方法安排任务进行重试：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">attempt_retry</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">exception</span><span class="p">)</span>
  <span class="n">max_retry_attempts</span> <span class="o">=</span> <span class="n">retry_attempts_from</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="s1">'retry'</span><span class="p">],</span> <span class="vi">@max_retries</span><span class="p">)</span>

  <span class="n">msg</span><span class="p">[</span><span class="s1">'queue'</span><span class="p">]</span> <span class="o">=</span> <span class="k">if</span> <span class="n">msg</span><span class="p">[</span><span class="s1">'retry_queue'</span><span class="p">]</span>
                   <span class="n">msg</span><span class="p">[</span><span class="s1">'retry_queue'</span><span class="p">]</span>
                 <span class="k">else</span>
                   <span class="n">queue</span>
                 <span class="k">end</span>

  <span class="n">count</span> <span class="o">=</span> <span class="k">if</span> <span class="n">msg</span><span class="p">[</span><span class="s1">'retry_count'</span><span class="p">]</span>
            <span class="n">msg</span><span class="p">[</span><span class="s1">'retried_at'</span><span class="p">]</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span>
            <span class="n">msg</span><span class="p">[</span><span class="s1">'retry_count'</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
          <span class="k">else</span>
            <span class="n">msg</span><span class="p">[</span><span class="s1">'failed_at'</span><span class="p">]</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span>
            <span class="n">msg</span><span class="p">[</span><span class="s1">'retry_count'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
          <span class="k">end</span>

  <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">max_retry_attempts</span>
    <span class="n">delay</span> <span class="o">=</span> <span class="n">delay_for</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">exception</span><span class="p">)</span>
    <span class="n">retry_at</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">+</span> <span class="n">delay</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">dump_json</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">redis</span> <span class="k">do</span> <span class="o">|</span><span class="n">conn</span><span class="o">|</span>
      <span class="n">conn</span><span class="p">.</span><span class="nf">zadd</span><span class="p">(</span><span class="s1">'retry'</span><span class="p">,</span> <span class="n">retry_at</span><span class="p">.</span><span class="nf">to_s</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">else</span>
    <span class="n">retries_exhausted</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">exception</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在上面其实我们提到过，<code class="highlighter-rouge">Poller</code> 每次会从两个有序集合 <code class="highlighter-rouge">retry</code> 和 <code class="highlighter-rouge">schedule</code> 中查找到时的任务加入到对应的队列中，在 <code class="highlighter-rouge">#attempt_retry</code> 方法中，就可以找到看到 <code class="highlighter-rouge">retry</code> 队列中的元素是如何加入的了。</p>

<p>当任务的重试次数超过了限定的重试次数之后，就会执行 <code class="highlighter-rouge">#retries_exhausted</code> 以及 <code class="highlighter-rouge"># send_to_morgue</code> 这一方法，将任务的负载加入 <code class="highlighter-rouge">DeadSet</code> 对象中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">send_to_morgue</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="n">payload</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">dump_json</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="no">DeadSet</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">kill</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这样整个任务的重试过程就结束了，Sidekiq 使用 <code class="highlighter-rouge">begin</code>、<code class="highlighter-rouge">rescue</code> 捕获整个流程中出现的异常，并根据传入的 <code class="highlighter-rouge">retry_count</code> 参数进行重试，调度过程还是非常简洁也非常容易理解的。</p>

<h2 id="总结">总结</h2>

<p>作为一个 Ruby 社区中广泛被使用的异步任务处理的依赖，它的实现是很简单的并且其源代码非常易于阅读，整体的架构也非常清晰。</p>

<p><img src="https://img.draveness.me/2017-08-28-Middlewares-Client-Redis-Sidekiq-Worker.jpg-1000width" alt="Middlewares-Client-Redis-Sidekiq-Worker" /></p>

<p>使用键值的内存数据库 Redis 作为客户端和 Worker 之间的桥梁，Redis 的使用简化了 Sidekiq 的很多逻辑，同时对中间件的支持也使其有着良好的扩展性，不过正其实现简单，所以例如任务取消以及定时任务这种比较常见的功能其本身都没有实现，有的是 Sidekiq 本身设计问题导致的，有的需要另外的插件，不过在绝大多数情况下，Sidekiq 都能完全满足我们的需要，解决绝大多数的问题。</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://github.com/mperham/sidekiq">Sidekiq</a></li>
  <li><a href="https://ruby-china.org/topics/31470">Sidekiq 任务调度流程分析</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Redis 是如何处理命令的（客户端）</title>
	  <link>/blogs//redis-cli</link>
	  <author></author>
	  <pubDate>2016-12-23T15:23:15+00:00</pubDate>
	  <guid>/blogs//redis-cli</guid>
	  <description><![CDATA[
	     <p>在使用 Redis 的过程中经常会好奇，在 Redis-Cli 中键入 <code class="highlighter-rouge">SET KEY MSG</code> 并回车之后，Redis 客户端和服务是如何对命令进行解析处理的，而在内部的实现过程是什么样的。</p>

<p>这两篇文章会分别介绍 Redis 客户端和服务端分别对命令是如何处理的，本篇文章介绍的是 Redis 客户端如何处理输入的命令、向服务发送命令以及取得服务端回复并输出到终端等过程。</p>

<p><img src="https://img.draveness.me/2016-12-23-redis-client-server.jpg-1000width" alt="redis-client-serve" /></p>

<p>文章中会将 Redis 服务看做一个输入为 Redis 命令，输出为命令执行结果的黑箱，对从命令到结果的过程不做任何解释，只会着眼于客户端的逻辑，也就是上图中的 1 和 4 两个过程。</p>

<h2 id="从-main-函数开始">从 main 函数开始</h2>

<p>与其它的 C 语言框架/服务类似，Redis 的客户端 <code class="highlighter-rouge">redis-cli</code> 也是从 <code class="highlighter-rouge">main</code> 函数开始执行的，位于 <code class="highlighter-rouge">redis-cli.c</code> 文件的最后：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">config</span><span class="p">.</span><span class="n">eval</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">repl</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在一般情况下，Redis 客户端都会进入 <code class="highlighter-rouge">repl</code> 模式，对输入进行解析；</p>

<blockquote>
  <p>Redis 中有好多模式，包括：Latency、Slave、Pipe、Stat、Scan、LRU test 等等模式，不过这些模式都不是这篇文章关注的重点，我们只会关注最常见的 repl 模式。</p>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">repl</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">line</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">argc</span><span class="p">;</span>
    <span class="n">sds</span> <span class="o">*</span><span class="n">argv</span><span class="p">;</span>

    <span class="p">...</span>

    <span class="k">while</span><span class="p">((</span><span class="n">line</span> <span class="o">=</span> <span class="n">linenoise</span><span class="p">(</span><span class="n">context</span> <span class="o">?</span> <span class="n">config</span><span class="p">.</span><span class="n">prompt</span> <span class="o">:</span> <span class="s">"not connected&gt; "</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">argv</span> <span class="o">=</span> <span class="n">cliSplitArgs</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">argv</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"Invalid argument(s)</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s">"???"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="p">...</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">issueCommandRepeat</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在上述代码中，我们省略了大量的实现细节，只保留整个 <code class="highlighter-rouge">repl</code> 中循环的主体部分，方便进行理解和分析，在 <code class="highlighter-rouge">while</code> 循环中的条件你可以看到 <code class="highlighter-rouge">linenoise</code> 方法的调用，通过其中的 <code class="highlighter-rouge">prompt</code> 和 <code class="highlighter-rouge">not connected&gt; </code> 可以判断出，这里向终端中输出了提示符，同时会调用 <code class="highlighter-rouge">fgets</code> 从标准输入中读取字符串：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="o">:</span><span class="mi">6379</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>全局搜一下 <code class="highlighter-rouge">config.prompt</code> 不难发现这一行代码，也就是控制命令行提示的 <code class="highlighter-rouge">prompt</code>：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">anetFormatAddr</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">prompt</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">prompt</span><span class="p">),</span><span class="n">config</span><span class="p">.</span><span class="n">hostip</span><span class="p">,</span> <span class="n">config</span><span class="p">.</span><span class="n">hostport</span><span class="p">);</span>
</code></pre></div></div>

<p>接下来执行的 <code class="highlighter-rouge">cliSplitArgs</code> 函数会将 <code class="highlighter-rouge">line</code> 中的字符串分割成几个不同的参数，然后根据字符串 <code class="highlighter-rouge">argv[0]</code> 的不同执行的命令，在这里省略了很多原有的代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s">"quit"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
    <span class="n">strcasecmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s">"exit"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">':'</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cliSetPreferences</span><span class="p">(</span><span class="n">argv</span><span class="p">,</span><span class="n">argc</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">continue</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s">"restart"</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s">"connect"</span><span class="p">))</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s">"clear"</span><span class="p">))</span> <span class="p">{</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">issueCommandRepeat</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在遇到 <code class="highlighter-rouge">quit</code>、<code class="highlighter-rouge">exit</code> 等跟<strong>客户端状态有关的命令</strong>时，就会直接执行相应的代码；否则就会将命令和参数 <code class="highlighter-rouge">issueCommandRepeat</code> 函数。</p>

<h3 id="追踪一次命令的执行">追踪一次命令的执行</h3>

<blockquote>
  <p>Redis Commit： <code class="highlighter-rouge">790310d89460655305bd615bc442eeaf7f0f1b38</code></p>

  <p>lldb： lldb-360.1.65</p>

  <p>macOS 10.11.6</p>
</blockquote>

<p>在继续分析 <code class="highlighter-rouge">issueCommandRepeat</code> 之前，我们先对 Redis 中的这部分代码进行调试追踪，在使用 <code class="highlighter-rouge">make</code> 编译了 Redis 源代码，启动 <code class="highlighter-rouge">redis-server</code> 之后；启动 lldb 对 Redis 客户端进行调试：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>lldb src/redis-cli
<span class="o">(</span>lldb<span class="o">)</span> target create <span class="s2">"src/redis-cli"</span>
Current executable <span class="nb">set </span>to <span class="s1">'src/redis-cli'</span> <span class="o">(</span>x86_64<span class="o">)</span><span class="nb">.</span>
<span class="o">(</span>lldb<span class="o">)</span> b redis-cli.c:1290
Breakpoint 1: where <span class="o">=</span> redis-cli<span class="sb">`</span>repl + 228 at redis-cli.c:1290, address <span class="o">=</span> 0x0000000100008cd4
<span class="o">(</span>lldb<span class="o">)</span> process launch
Process 8063 launched: <span class="s1">'~/redis/src/redis-cli'</span> <span class="o">(</span>x86_64<span class="o">)</span>
127.0.0.1:6379&gt;
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">redis-cli.c:1290</code> 也就是下面这行代码的地方打断点之后：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">-&gt;</span> <span class="mi">1290</span>	        <span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
</code></pre></div></div>

<p>执行 <code class="highlighter-rouge">process launch</code> 启动 <code class="highlighter-rouge">redis-cli</code>，然后输入 <code class="highlighter-rouge">SET KEY MSG</code> 回车以及 Ctrl-C：</p>

<blockquote>
  <p>在 lldb 中调试时，回车的输入经常会有问题，在这里输入 Ctrl-C 进入信号处理器，在通过 continue 命令进入断点：</p>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">127</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="o">:</span><span class="mi">6379</span><span class="o">&gt;</span> <span class="n">SET</span> <span class="n">KEY</span> <span class="n">MSG</span>
<span class="o">^</span><span class="n">C</span>
<span class="mi">8063</span> <span class="n">stopped</span>
<span class="o">*</span> <span class="kr">thread</span> <span class="err">#</span><span class="mi">1</span><span class="o">:</span> <span class="n">tid</span> <span class="o">=</span> <span class="mh">0xa95147</span><span class="p">,</span> <span class="mh">0x00007fff90923362</span> <span class="n">libsystem_kernel</span><span class="p">.</span><span class="n">dylib</span><span class="err">`</span><span class="n">read</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="n">stop</span> <span class="n">reason</span> <span class="o">=</span> <span class="n">signal</span> <span class="n">SIGSTOP</span>
    <span class="n">frame</span> <span class="err">#</span><span class="mi">0</span><span class="o">:</span> <span class="mh">0x00007fff90923362</span> <span class="n">libsystem_kernel</span><span class="p">.</span><span class="n">dylib</span><span class="err">`</span><span class="n">read</span> <span class="o">+</span> <span class="mi">10</span>
<span class="n">libsystem_kernel</span><span class="p">.</span><span class="n">dylib</span><span class="err">`</span><span class="n">read</span><span class="o">:</span>
<span class="o">-&gt;</span>  <span class="mh">0x7fff90923362</span> <span class="o">&lt;+</span><span class="mi">10</span><span class="o">&gt;:</span> <span class="n">jae</span>    <span class="mh">0x7fff9092336c</span>            <span class="p">;</span> <span class="o">&lt;+</span><span class="mi">20</span><span class="o">&gt;</span>
    <span class="mh">0x7fff90923364</span> <span class="o">&lt;+</span><span class="mi">12</span><span class="o">&gt;:</span> <span class="n">movq</span>   <span class="o">%</span><span class="n">rax</span><span class="p">,</span> <span class="o">%</span><span class="n">rdi</span>
    <span class="mh">0x7fff90923367</span> <span class="o">&lt;+</span><span class="mi">15</span><span class="o">&gt;:</span> <span class="n">jmp</span>    <span class="mh">0x7fff9091c7f2</span>            <span class="p">;</span> <span class="n">cerror</span>
    <span class="mh">0x7fff9092336c</span> <span class="o">&lt;+</span><span class="mi">20</span><span class="o">&gt;:</span> <span class="n">retq</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">c</span>
<span class="n">Process</span> <span class="mi">8063</span> <span class="n">resuming</span>

<span class="n">Process</span> <span class="mi">8063</span> <span class="n">stopped</span>
<span class="o">*</span> <span class="kr">thread</span> <span class="err">#</span><span class="mi">1</span><span class="o">:</span> <span class="n">tid</span> <span class="o">=</span> <span class="mh">0xa95147</span><span class="p">,</span> <span class="mh">0x0000000100008cd4</span> <span class="n">redis</span><span class="o">-</span><span class="n">cli</span><span class="err">`</span><span class="n">repl</span> <span class="o">+</span> <span class="mi">228</span> <span class="n">at</span> <span class="n">redis</span><span class="o">-</span><span class="n">cli</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">1290</span><span class="p">,</span> <span class="n">queue</span> <span class="o">=</span> <span class="err">'</span><span class="n">com</span><span class="p">.</span><span class="n">apple</span><span class="p">.</span><span class="n">main</span><span class="o">-</span><span class="kr">thread</span><span class="err">'</span><span class="p">,</span> <span class="n">stop</span> <span class="n">reason</span> <span class="o">=</span> <span class="n">breakpoint</span> <span class="mi">1</span><span class="p">.</span><span class="mi">1</span>
    <span class="n">frame</span> <span class="err">#</span><span class="mi">0</span><span class="o">:</span> <span class="mh">0x0000000100008cd4</span> <span class="n">redis</span><span class="o">-</span><span class="n">cli</span><span class="err">`</span><span class="n">repl</span> <span class="o">+</span> <span class="mi">228</span> <span class="n">at</span> <span class="n">redis</span><span class="o">-</span><span class="n">cli</span><span class="p">.</span><span class="n">c</span><span class="o">:</span><span class="mi">1290</span>
   <span class="mi">1287</span>
   <span class="mi">1288</span>	    <span class="n">cliRefreshPrompt</span><span class="p">();</span>
   <span class="mi">1289</span>	    <span class="nf">while</span><span class="p">((</span><span class="n">line</span> <span class="o">=</span> <span class="n">linenoise</span><span class="p">(</span><span class="n">context</span> <span class="o">?</span> <span class="n">config</span><span class="p">.</span><span class="n">prompt</span> <span class="o">:</span> <span class="s">"not connected&gt; "</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="o">-&gt;</span> <span class="mi">1290</span>	        <span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
   <span class="mi">1291</span>	            <span class="n">argv</span> <span class="o">=</span> <span class="n">cliSplitArgs</span><span class="p">(</span><span class="n">line</span><span class="p">,</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">);</span>
   <span class="mi">1292</span>	            <span class="k">if</span> <span class="p">(</span><span class="n">history</span><span class="p">)</span> <span class="n">linenoiseHistoryAdd</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
   <span class="mi">1293</span>	            <span class="k">if</span> <span class="p">(</span><span class="n">historyfile</span><span class="p">)</span> <span class="n">linenoiseHistorySave</span><span class="p">(</span><span class="n">historyfile</span><span class="p">);</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span>
</code></pre></div></div>

<p>输入两次 <code class="highlighter-rouge">n</code> 之后，打印 <code class="highlighter-rouge">argv</code> 和 <code class="highlighter-rouge">argc</code> 的值：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">p</span> <span class="n">argc</span>
<span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="err">$</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">3</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">p</span> <span class="o">*</span><span class="n">argv</span>
<span class="p">(</span><span class="n">sds</span><span class="p">)</span> <span class="err">$</span><span class="mi">2</span> <span class="o">=</span> <span class="mh">0x0000000100106cc3</span> <span class="s">"SET"</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">p</span> <span class="o">*</span><span class="p">(</span><span class="n">argv</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="n">sds</span><span class="p">)</span> <span class="err">$</span><span class="mi">3</span> <span class="o">=</span> <span class="mh">0x0000000100106ce3</span> <span class="s">"KEY"</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">p</span> <span class="o">*</span><span class="p">(</span><span class="n">argv</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="n">sds</span><span class="p">)</span> <span class="err">$</span><span class="mi">4</span> <span class="o">=</span> <span class="mh">0x0000000100106cf3</span> <span class="s">"MSG"</span>
<span class="p">(</span><span class="n">lldb</span><span class="p">)</span> <span class="n">p</span> <span class="n">line</span>
<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="err">$</span><span class="mi">5</span> <span class="o">=</span> <span class="mh">0x0000000100303430</span> <span class="s">"SET KEY MSG</span><span class="se">\n</span><span class="s">"</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">cliSplitArgs</code> 方法成功将 <code class="highlighter-rouge">line</code> 中的字符串分隔成字符串参数，在多次执行 <code class="highlighter-rouge">n</code> 之后，进入 <code class="highlighter-rouge">issueCommandRepeat</code> 方法：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">-&gt;</span> <span class="mi">1334</span>	                    <span class="n">issueCommandRepeat</span><span class="p">(</span><span class="n">argc</span><span class="o">-</span><span class="n">skipargs</span><span class="p">,</span> <span class="n">argv</span><span class="o">+</span><span class="n">skipargs</span><span class="p">,</span> <span class="n">repeat</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="对输入命令的处理">对输入命令的处理</h2>

<p>上一阶段执行 <code class="highlighter-rouge">issueCommandRepeat</code> 的函数调用栈中，会发现 Redis 并不会直接把所有的命令发送到服务端：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">issueCommandRepeat</span>
    <span class="n">cliSendCommand</span>
        <span class="n">redisAppendCommandArgv</span>
            <span class="n">redisFormatCommandArgv</span>
            <span class="n">__redisAppendCommand</span>
</code></pre></div></div>

<p>而是会在 <code class="highlighter-rouge">redisFormatCommandArgv</code> 中对所有的命令进行格式化处理，将字符串转换为符合 RESP 协议的数据。</p>

<h3 id="resp-协议">RESP 协议</h3>

<p>Redis 客户端与 Redis 服务进行通讯时，会使用名为 <strong>RESP</strong>（REdis Serialization Protocol） 的协议，它的使用非常简单，并且可以序列化多种数据类型包括整数、字符串以及数组等。</p>

<p>对于 RESP 协议的详细介绍可以看官方文档中的 <a href="https://redis.io/topics/protocol">Redis Protocol specification</a>，在这里对这个协议进行简单的介绍。</p>

<p>在将不同的数据类型序列化时，会使用第一个 byte 来表示当前数据的数据类型，以便在客户端或服务器在处理时能恢复原来的数据格式。</p>

<p><img src="https://img.draveness.me/2016-12-23-redis-resp-data-byte.jpg-1000width" alt="redis-resp-data-byte" /></p>

<p>举一个简单的例子，字符串 <code class="highlighter-rouge">OK</code> 以及错误<code class="highlighter-rouge">Error Message</code> 等不同种类的信息的 RESP 表示如下：</p>

<p><img src="https://img.draveness.me/2016-12-23-redis-resp-type-and-examples.jpg-1000width" alt="redis-resp-type-and-examples" /></p>

<p>在这篇文章中我们需要简单了解的就是 RESP “数据格式”的<strong>第一个字节用来表示数据类型</strong>，然后<strong>逻辑上属于不同部分的内容通过 CRLF（\r\n）分隔</strong>。</p>

<h3 id="数据格式的转换">数据格式的转换</h3>

<p>在 <code class="highlighter-rouge">redisFormatCommandArgv</code> 方法中几乎没有需要删减的代码，所有的命令都会以字符串数组的形式发送到客户端：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">redisFormatCommandArgv</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">target</span><span class="p">,</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">argvlen</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">cmd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">pos</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">totlen</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>

    <span class="n">totlen</span> <span class="o">=</span> <span class="mi">1</span><span class="o">+</span><span class="n">intlen</span><span class="p">(</span><span class="n">argc</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">argvlen</span> <span class="o">?</span> <span class="n">argvlen</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">:</span> <span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="n">totlen</span> <span class="o">+=</span> <span class="n">bulklen</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">cmd</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">totlen</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">pos</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span><span class="s">"*%d</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span><span class="n">argc</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">len</span> <span class="o">=</span> <span class="n">argvlen</span> <span class="o">?</span> <span class="n">argvlen</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">:</span> <span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="n">pos</span> <span class="o">+=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">cmd</span><span class="o">+</span><span class="n">pos</span><span class="p">,</span><span class="s">"$%zu</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span><span class="n">len</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">cmd</span><span class="o">+</span><span class="n">pos</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">len</span><span class="p">);</span>
        <span class="n">pos</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
        <span class="n">cmd</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\r'</span><span class="p">;</span>
        <span class="n">cmd</span><span class="p">[</span><span class="n">pos</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">pos</span> <span class="o">==</span> <span class="n">totlen</span><span class="p">);</span>
    <span class="n">cmd</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

    <span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="n">cmd</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">totlen</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">SET KEY MSG</code> 这一命令，经过这个方法的处理会变成：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">*</span><span class="mi">3</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span><span class="err">$</span><span class="mi">3</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">nSET</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span><span class="err">$</span><span class="mi">3</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">nKEY</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span><span class="err">$</span><span class="mi">3</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">nMSG</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span>
</code></pre></div></div>

<p>你可以这么理解上面的结果：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">*</span><span class="mi">3</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span>
    <span class="err">$</span><span class="mi">3</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">nSET</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span>
    <span class="err">$</span><span class="mi">3</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">nKEY</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span>
    <span class="err">$</span><span class="mi">3</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">nMSG</span><span class="err">\</span><span class="n">r</span><span class="err">\</span><span class="n">n</span>
</code></pre></div></div>

<p>这是一个由三个字符串组成的数组，数组中的元素是 <code class="highlighter-rouge">SET</code>、<code class="highlighter-rouge">KEY</code> 以及 <code class="highlighter-rouge">MSG</code> 三个字符串。</p>

<p>如果在这里打一个断点并输出 <code class="highlighter-rouge">target</code> 中的内容：</p>

<p><img src="https://img.draveness.me/2016-12-23-redis-lldb-cmd.png-1000width" alt="redis-lldb-cmd" /></p>

<p>到这里就完成了对输入命令的格式化，在格式化之后还会将当前命令写入全局的 <code class="highlighter-rouge">redisContext</code> 的 <code class="highlighter-rouge">write</code> 缓冲区 <code class="highlighter-rouge">obuf</code> 中，也就是在上面的缓冲区看到的第二个方法：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">__redisAppendCommand</span><span class="p">(</span><span class="n">redisContext</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmd</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sds</span> <span class="n">newbuf</span><span class="p">;</span>

    <span class="n">newbuf</span> <span class="o">=</span> <span class="n">sdscatlen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">obuf</span><span class="p">,</span><span class="n">cmd</span><span class="p">,</span><span class="n">len</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">newbuf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">__redisSetError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">REDIS_ERR_OOM</span><span class="p">,</span><span class="s">"Out of memory"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">c</span><span class="o">-&gt;</span><span class="n">obuf</span> <span class="o">=</span> <span class="n">newbuf</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="rediscontext">redisContext</h3>

<p>再继续介绍下一部分之前需要简单介绍一下 <code class="highlighter-rouge">redisContext</code> 结构体：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">redisContext</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">errstr</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">obuf</span><span class="p">;</span>
    <span class="n">redisReader</span> <span class="o">*</span><span class="n">reader</span><span class="p">;</span>
<span class="p">}</span> <span class="n">redisContext</span><span class="p">;</span>
</code></pre></div></div>

<p>每一个 <code class="highlighter-rouge">redisContext</code> 的结构体都表示一个 Redis 客户端对服务的连接，而这个上下文会在每一个 redis-cli 中作为静态变量仅保存一个：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">redisContext</span> <span class="o">*</span><span class="n">context</span><span class="p">;</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">obuf</code> 中包含了客户端未写到服务端的数据；而 <code class="highlighter-rouge">reader</code> 是用来处理 RESP 协议的结构体；<code class="highlighter-rouge">fd</code> 就是 Redis 服务对应的文件描述符；其他的内容就不多做解释了。</p>

<p>到这里，对命令的格式化处理就结束了，接下来就到了向服务端发送命令的过程了。</p>

<h2 id="向服务器发送命令">向服务器发送命令</h2>

<p>与对输入命令的处理差不多，向服务器发送命令的方法也在 <code class="highlighter-rouge">issueCommandRepeat</code> 的调用栈中，而且藏得更深，如果不仔细阅读源代码其实很难发现：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">issueCommandRepeat</span>
    <span class="n">cliSendCommand</span>
        <span class="n">cliReadReply</span>
            <span class="n">redisGetReply</span>
               <span class="n">redisBufferWrite</span>
</code></pre></div></div>

<p>Redis 在 <code class="highlighter-rouge">redisGetReply</code> 中完成对命令的发送：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">redisGetReply</span><span class="p">(</span><span class="n">redisContext</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">reply</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">wdone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">aux</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">aux</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_BLOCK</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">redisBufferWrite</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="o">&amp;</span><span class="n">wdone</span><span class="p">)</span> <span class="o">==</span> <span class="n">REDIS_ERR</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">wdone</span><span class="p">);</span>

        <span class="p">...</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">aux</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">*</span><span class="n">reply</span> <span class="o">=</span> <span class="n">aux</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面的代码向 <code class="highlighter-rouge">redisBufferWrite</code> 函数中传递了全局的静态变量 <code class="highlighter-rouge">redisContext</code>，其中的 <code class="highlighter-rouge">obuf</code> 中存储了没有向 Redis 服务发送的命令：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">redisBufferWrite</span><span class="p">(</span><span class="n">redisContext</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">nwritten</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">obuf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">nwritten</span> <span class="o">=</span> <span class="n">write</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">obuf</span><span class="p">,</span><span class="n">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">obuf</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nwritten</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EAGAIN</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_BLOCK</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">))</span> <span class="p">{</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">__redisSetError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">REDIS_ERR_IO</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nwritten</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">nwritten</span> <span class="o">==</span> <span class="p">(</span><span class="kt">signed</span><span class="p">)</span><span class="n">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">obuf</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">sdsfree</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">obuf</span><span class="p">);</span>
                <span class="n">c</span><span class="o">-&gt;</span><span class="n">obuf</span> <span class="o">=</span> <span class="n">sdsempty</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">sdsrange</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">obuf</span><span class="p">,</span><span class="n">nwritten</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">done</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">*</span><span class="n">done</span> <span class="o">=</span> <span class="p">(</span><span class="n">sdslen</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">obuf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>代码的逻辑其实十分清晰，调用 <code class="highlighter-rouge">write</code> 向 Redis 服务代表的文件描述符发送写缓冲区 <code class="highlighter-rouge">obuf</code> 中的数据，然后根据返回值做出相应的处理，如果命令发送成功就会清空 <code class="highlighter-rouge">obuf</code> 并将 <code class="highlighter-rouge">done</code> 指针标记为真，然后返回，这样就完成了向服务器发送命令这一过程。</p>

<p><img src="https://img.draveness.me/2016-12-23-redis-lldb-nwritten.png-1000width" alt="redis-lldb-nwritten" /></p>

<h2 id="获取服务器回复">获取服务器回复</h2>

<p>其实获取服务器回复和上文中的发送命令过程基本上差不多，调用栈也几乎完全一样：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">issueCommandRepeat</span>
    <span class="n">cliSendCommand</span>
        <span class="n">cliReadReply</span>
            <span class="n">redisGetReply</span>
                <span class="n">redisBufferRead</span>
                <span class="n">redisGetReplyFromReader</span>
            <span class="n">cliFormatReplyRaw</span>
            <span class="n">fwrite</span>
</code></pre></div></div>

<p>同样地，在 <code class="highlighter-rouge">redisGetReply</code> 中获取服务器的响应：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">redisGetReply</span><span class="p">(</span><span class="n">redisContext</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">reply</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">wdone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">aux</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">aux</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_BLOCK</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">redisBufferWrite</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="o">&amp;</span><span class="n">wdone</span><span class="p">)</span> <span class="o">==</span> <span class="n">REDIS_ERR</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">wdone</span><span class="p">);</span>

        <span class="k">do</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">redisBufferRead</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">==</span> <span class="n">REDIS_ERR</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">redisGetReplyFromReader</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="o">&amp;</span><span class="n">aux</span><span class="p">)</span> <span class="o">==</span> <span class="n">REDIS_ERR</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">aux</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">reply</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">*</span><span class="n">reply</span> <span class="o">=</span> <span class="n">aux</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">redisBufferWrite</code> 成功发送命令并返回之后，就会开始等待服务端的回复，总共分为两个部分，一是使用 <code class="highlighter-rouge">redisBufferRead</code> 从服务端读取原始格式的回复（符合 RESP 协议）：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">redisBufferRead</span><span class="p">(</span><span class="n">redisContext</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1024</span><span class="o">*</span><span class="mi">16</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">nread</span><span class="p">;</span>

    <span class="n">nread</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EAGAIN</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">REDIS_BLOCK</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">))</span> <span class="p">{</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">__redisSetError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">REDIS_ERR_IO</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">__redisSetError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">REDIS_ERR_EOF</span><span class="p">,</span><span class="s">"Server closed the connection"</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">redisReaderFeed</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reader</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">nread</span><span class="p">)</span> <span class="o">!=</span> <span class="n">REDIS_OK</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">__redisSetError</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reader</span><span class="o">-&gt;</span><span class="n">err</span><span class="p">,</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">reader</span><span class="o">-&gt;</span><span class="n">errstr</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">read</code> 从文件描述符中成功读取数据并返回之后，我们可以打印 <code class="highlighter-rouge">buf</code> 中的内容：</p>

<p><img src="https://img.draveness.me/2016-12-23-redis-lldb-read.png-1000width" alt="redis-lldb-read" /></p>

<p>刚刚向 <code class="highlighter-rouge">buf</code> 中写入的数据还需要经过 <code class="highlighter-rouge">redisReaderFeed</code> 方法的处理，截取正确的长度；然后存入 <code class="highlighter-rouge">redisReader</code> 中：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">redisReaderFeed</span><span class="p">(</span><span class="n">redisReader</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sds</span> <span class="n">newbuf</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">maxbuf</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sdsavail</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">maxbuf</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sdsfree</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
            <span class="n">r</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">sdsempty</span><span class="p">();</span>
            <span class="n">r</span><span class="o">-&gt;</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">assert</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">newbuf</span> <span class="o">=</span> <span class="n">sdscatlen</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="n">len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">newbuf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">__redisReaderSetErrorOOM</span><span class="p">(</span><span class="n">r</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">REDIS_ERR</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">r</span><span class="o">-&gt;</span><span class="n">buf</span> <span class="o">=</span> <span class="n">newbuf</span><span class="p">;</span>
        <span class="n">r</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">sdslen</span><span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">REDIS_OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>最后的 <code class="highlighter-rouge">redisGetReplyFromReader</code> 方法会从 <code class="highlighter-rouge">redisContext</code> 中取出 <code class="highlighter-rouge">reader</code>，然后反序列化 RESP 对象，最后打印出来。</p>

<p><img src="https://img.draveness.me/2016-12-23-process-end.png-1000width" alt="process-end" /></p>

<p>当我们从终端的输出中看到了 OK 以及这个命令的执行的时间时，<code class="highlighter-rouge">SET KEY MSG</code> 这一命令就已经处理完成了。</p>

<h2 id="总结">总结</h2>

<p>处理命令的过程在客户端还是比较简单的：</p>

<ol>
  <li>在一个 <code class="highlighter-rouge">while</code> 循环中，输出提示符；</li>
  <li>接收到输入命令时，对输入命令进行格式化处理；</li>
  <li>通过 <code class="highlighter-rouge">write</code> 发送到 Redis 服务，并调用 <code class="highlighter-rouge">read</code> 阻塞当前进程直到服务端返回为止；</li>
  <li>对服务端返回的数据反序列化；</li>
  <li>将结果打印到终端。</li>
</ol>

<p>用一个简单的图表示，大概是这样的：</p>

<p><img src="https://img.draveness.me/2016-12-23-redis-client-process-commands.jpg-1000width" alt="redis-client-process-commands" /></p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://redis.io/topics/protocol">Redis Protocol specification</a></li>
  <li><a href="http://draveness.me/redis-io-multiplexing/">Redis 和 I/O 多路复用</a></li>
  <li><a href="http://draveness.me/redis-eventloop">Redis 中的事件循环</a></li>
</ul>

<blockquote>

  <p>Source: http://draveness.me/redis-cli</p>
</blockquote>

	  ]]></description>
	</item>

	<item>
	  <title>Redis 中的事件循环</title>
	  <link>/blogs//redis-eventloop</link>
	  <author></author>
	  <pubDate>2016-12-09T15:42:05+00:00</pubDate>
	  <guid>/blogs//redis-eventloop</guid>
	  <description><![CDATA[
	     <p>在目前的很多服务中，由于需要持续接受客户端或者用户的输入，所以需要一个事件循环来等待并处理外部事件，这篇文章主要会介绍 Redis 中的事件循环是如何处理事件的。</p>

<p>在文章中，我们会先从 Redis 的实现中分析事件是如何被处理的，然后用更具象化的方式了解服务中的不同模块是如何交流的。</p>

<h2 id="aeeventloop">aeEventLoop</h2>

<p>在分析具体代码之前，先了解一下在事件处理中处于核心部分的 <code class="highlighter-rouge">aeEventLoop</code> 到底是什么：</p>

<p><img src="https://img.draveness.me/2016-12-09-reids-eventloop.png-1000width" alt="reids-eventloop" /></p>

<p><code class="highlighter-rouge">aeEventLoop</code> 在 Redis 就是负责保存待处理文件事件和时间事件的结构体，其中保存大量事件执行的上下文信息，同时持有三个事件数组：</p>

<ul>
  <li><code class="highlighter-rouge">aeFileEvent</code></li>
  <li><code class="highlighter-rouge">aeTimeEvent</code></li>
  <li><code class="highlighter-rouge">aeFiredEvent</code></li>
</ul>

<p><code class="highlighter-rouge">aeFileEvent</code> 和 <code class="highlighter-rouge">aeTimeEvent</code> 中会存储监听的文件事件和时间事件，而最后的 <code class="highlighter-rouge">aeFiredEvent</code> 用于存储待处理的文件事件，我们会在后面的章节中介绍它们是如何工作的。</p>

<h3 id="redis-服务中的-eventloop">Redis 服务中的 EventLoop</h3>

<p>在 <code class="highlighter-rouge">redis-server</code> 启动时，首先会初始化一些 redis 服务的配置，最后会调用 <code class="highlighter-rouge">aeMain</code> 函数陷入 <code class="highlighter-rouge">aeEventLoop</code> 循环中，等待外部事件的发生：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>

    <span class="n">aeMain</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">aeMain</code> 函数其实就是一个封装的 <code class="highlighter-rouge">while</code> 循环，循环中的代码会一直运行直到 <code class="highlighter-rouge">eventLoop</code> 的 <code class="highlighter-rouge">stop</code> 被设置为 <code class="highlighter-rouge">true</code>：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">aeMain</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">beforesleep</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">beforesleep</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">);</span>
        <span class="n">aeProcessEvents</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">AE_ALL_EVENTS</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>它会不停尝试调用 <code class="highlighter-rouge">aeProcessEvents</code> 对可能存在的多种事件进行处理，而 <code class="highlighter-rouge">aeProcessEvents</code> 就是实际用于处理事件的函数：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">aeProcessEvents</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">processed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">numevents</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_TIME_EVENTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_FILE_EVENTS</span><span class="p">))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">maxfd</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span>
        <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_TIME_EVENTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_DONT_WAIT</span><span class="p">)))</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">tvp</span><span class="p">;</span>

        <span class="cp">#1：计算 I/O 多路复用的等待时间 tvp
</span>
        <span class="n">numevents</span> <span class="o">=</span> <span class="n">aeApiPoll</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">tvp</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numevents</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">aeFileEvent</span> <span class="o">*</span><span class="n">fe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">fd</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">mask</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">fd</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">rfired</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_READABLE</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">rfired</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">fe</span><span class="o">-&gt;</span><span class="n">rfileProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">,</span><span class="n">mask</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_WRITABLE</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rfired</span> <span class="o">||</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">wfileProc</span> <span class="o">!=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">rfileProc</span><span class="p">)</span>
                    <span class="n">fe</span><span class="o">-&gt;</span><span class="n">wfileProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">,</span><span class="n">mask</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">processed</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_TIME_EVENTS</span><span class="p">)</span> <span class="n">processed</span> <span class="o">+=</span> <span class="n">processTimeEvents</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">processed</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面的代码省略了 I/O 多路复用函数的等待时间，不过不会影响我们对代码的理解，整个方法大体由两部分代码组成，一部分处理文件事件，另一部分处理时间事件。</p>

<blockquote>
  <p>Redis 中会处理两种事件：时间事件和文件事件。</p>
</blockquote>

<h3 id="文件事件">文件事件</h3>

<p>在一般情况下，<code class="highlighter-rouge">aeProcessEvents</code> 都会先<strong>计算最近的时间事件发生所需要等待的时间</strong>，然后调用 <code class="highlighter-rouge">aeApiPoll</code> 方法在这段时间中等待事件的发生，在这段时间中如果发生了文件事件，就会优先处理文件事件，否则就会一直等待，直到最近的时间事件需要触发：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numevents</span> <span class="o">=</span> <span class="n">aeApiPoll</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">tvp</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numevents</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">aeFileEvent</span> <span class="o">*</span><span class="n">fe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">fd</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">mask</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">fd</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rfired</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_READABLE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rfired</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">fe</span><span class="o">-&gt;</span><span class="n">rfileProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">,</span><span class="n">mask</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_WRITABLE</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rfired</span> <span class="o">||</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">wfileProc</span> <span class="o">!=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">rfileProc</span><span class="p">)</span>
            <span class="n">fe</span><span class="o">-&gt;</span><span class="n">wfileProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">,</span><span class="n">mask</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">processed</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>文件事件如果绑定了对应的读/写事件，就会执行对应的对应的代码，并传入事件循环、文件描述符、数据以及掩码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fe</span><span class="o">-&gt;</span><span class="n">rfileProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">,</span><span class="n">mask</span><span class="p">);</span>
<span class="n">fe</span><span class="o">-&gt;</span><span class="n">wfileProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">,</span><span class="n">mask</span><span class="p">);</span>
</code></pre></div></div>

<p>其中 <code class="highlighter-rouge">rfileProc</code> 和 <code class="highlighter-rouge">wfileProc</code> 就是在文件事件被创建时传入的函数指针：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">aeCreateFileEvent</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="n">aeFileProc</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">clientData</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">aeFileEvent</span> <span class="o">*</span><span class="n">fe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">fd</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">aeApiAddEvent</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">AE_ERR</span><span class="p">;</span>
    <span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_READABLE</span><span class="p">)</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">rfileProc</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_WRITABLE</span><span class="p">)</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">wfileProc</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span>
    <span class="n">fe</span><span class="o">-&gt;</span><span class="n">clientData</span> <span class="o">=</span> <span class="n">clientData</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&gt;</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">maxfd</span><span class="p">)</span>
        <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">maxfd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">AE_OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>需要注意的是，传入的 <code class="highlighter-rouge">proc</code> 函数会在对应的 <code class="highlighter-rouge">mask</code> 位事件发生时执行。</p>

<h3 id="时间事件">时间事件</h3>

<p>在 Redis 中会发生两种时间事件：</p>

<ul>
  <li>一种是定时事件，每隔一段时间会执行一次；</li>
  <li>另一种是非定时事件，只会在某个时间点执行一次；</li>
</ul>

<p>时间事件的处理在 <code class="highlighter-rouge">processTimeEvents</code> 中进行，我们会分三部分分析这个方法的实现：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">processTimeEvents</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">processed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">aeTimeEvent</span> <span class="o">*</span><span class="n">te</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">maxId</span><span class="p">;</span>
    <span class="kt">time_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">&lt;</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">lastTime</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">te</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">timeEventHead</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">te</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">te</span><span class="o">-&gt;</span><span class="n">when_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">te</span> <span class="o">=</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">lastTime</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
</code></pre></div></div>

<p>由于对系统时间的调整会影响当前时间的获取，进而影响时间事件的执行；如果系统时间先被设置到了未来的时间，又设置成正确的值，这就会导致<strong>时间事件会随机延迟一段时间执行</strong>，也就是说，时间事件不会按照预期的安排尽早执行，而 <code class="highlighter-rouge">eventLoop</code> 中的 <code class="highlighter-rouge">lastTime</code> 就是用于检测上述情况的变量：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">aeEventLoop</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">time_t</span> <span class="n">lastTime</span><span class="p">;</span>     <span class="cm">/* Used to detect system clock skew */</span>
    <span class="p">...</span>
<span class="p">}</span> <span class="n">aeEventLoop</span><span class="p">;</span>
</code></pre></div></div>

<p>如果发现了系统时间被改变（小于上次 <code class="highlighter-rouge">processTimeEvents</code> 函数执行的开始时间），就会强制所有时间事件尽早执行。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">te</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">timeEventHead</span><span class="p">;</span>
    <span class="n">maxId</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">timeEventNextId</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">te</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">long</span> <span class="n">now_sec</span><span class="p">,</span> <span class="n">now_ms</span><span class="p">;</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">id</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">te</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">AE_DELETED_EVENT_ID</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">aeTimeEvent</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
                <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">timeEventHead</span> <span class="o">=</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">te</span><span class="o">-&gt;</span><span class="n">finalizerProc</span><span class="p">)</span>
                <span class="n">te</span><span class="o">-&gt;</span><span class="n">finalizerProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">);</span>
            <span class="n">zfree</span><span class="p">(</span><span class="n">te</span><span class="p">);</span>
            <span class="n">te</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>Redis 处理时间事件时，不会在当前循环中直接移除不再需要执行的事件，而是会在当前循环中将时间事件的 <code class="highlighter-rouge">id</code> 设置为 <code class="highlighter-rouge">AE_DELETED_EVENT_ID</code>，然后再下一个循环中删除，并执行绑定的 <code class="highlighter-rouge">finalizerProc</code>。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">aeGetTime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now_sec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now_ms</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">now_sec</span> <span class="o">&gt;</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">when_sec</span> <span class="o">||</span>
            <span class="p">(</span><span class="n">now_sec</span> <span class="o">==</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">when_sec</span> <span class="o">&amp;&amp;</span> <span class="n">now_ms</span> <span class="o">&gt;=</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">when_ms</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

            <span class="n">id</span> <span class="o">=</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">timeProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">);</span>
            <span class="n">processed</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">AE_NOMORE</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">aeAddMillisecondsToNow</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span><span class="o">&amp;</span><span class="n">te</span><span class="o">-&gt;</span><span class="n">when_sec</span><span class="p">,</span><span class="o">&amp;</span><span class="n">te</span><span class="o">-&gt;</span><span class="n">when_ms</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">te</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">AE_DELETED_EVENT_ID</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">te</span><span class="p">;</span>
        <span class="n">te</span> <span class="o">=</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">processed</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在移除不需要执行的时间事件之后，我们就开始通过比较时间来判断是否需要调用 <code class="highlighter-rouge">timeProc</code> 函数，<code class="highlighter-rouge">timeProc</code> 函数的返回值 <code class="highlighter-rouge">retval</code> 为时间事件执行的时间间隔：</p>

<ul>
  <li><code class="highlighter-rouge">retval == AE_NOMORE</code>：将时间事件的 <code class="highlighter-rouge">id</code> 设置为 <code class="highlighter-rouge">AE_DELETED_EVENT_ID</code>，等待下次 <code class="highlighter-rouge">aeProcessEvents</code> 执行时将事件清除；</li>
  <li><code class="highlighter-rouge">retval != AE_NOMORE</code>：修改当前时间事件的执行时间并重复利用当前的时间事件；</li>
</ul>

<p>以使用 <code class="highlighter-rouge">aeCreateTimeEvent</code> 一个创建的简单时间事件为例：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">aeCreateTimeEvent</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">showThroughput</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="nb">NULL</span><span class="p">)</span>
</code></pre></div></div>

<p>时间事件对应的函数 <code class="highlighter-rouge">showThroughput</code> 在每次执行时会返回一个数字，也就是该事件发生的时间间隔：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">showThroughput</span><span class="p">(</span><span class="k">struct</span> <span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">clientData</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">float</span> <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)(</span><span class="n">mstime</span><span class="p">()</span><span class="o">-</span><span class="n">config</span><span class="p">.</span><span class="n">start</span><span class="p">)</span><span class="o">/</span><span class="mi">1000</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">rps</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">config</span><span class="p">.</span><span class="n">requests_finished</span><span class="o">/</span><span class="n">dt</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s: %.2f</span><span class="se">\r</span><span class="s">"</span><span class="p">,</span> <span class="n">config</span><span class="p">.</span><span class="n">title</span><span class="p">,</span> <span class="n">rps</span><span class="p">);</span>
    <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">250</span><span class="p">;</span> <span class="cm">/* every 250ms */</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这样就不需要重新 <code class="highlighter-rouge">malloc</code> 一块相同大小的内存，提高了时间事件处理的性能，并减少了内存的使用量。</p>

<p>我们对 Redis 中对时间事件的处理以流程图的形式简单总结一下：</p>

<p><img src="https://img.draveness.me/2016-12-09-process-time-event.png-1000width" alt="process-time-event" /></p>

<p>创建时间事件的方法实现其实非常简单，在这里不想过多分析这个方法，唯一需要注意的就是时间事件的 <code class="highlighter-rouge">id</code> 跟数据库中的大多数主键都是递增的：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="kt">long</span> <span class="nf">aeCreateTimeEvent</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">milliseconds</span><span class="p">,</span>
        <span class="n">aeTimeProc</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">clientData</span><span class="p">,</span>
        <span class="n">aeEventFinalizerProc</span> <span class="o">*</span><span class="n">finalizerProc</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">id</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">timeEventNextId</span><span class="o">++</span><span class="p">;</span>
    <span class="n">aeTimeEvent</span> <span class="o">*</span><span class="n">te</span><span class="p">;</span>

    <span class="n">te</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">te</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">te</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">AE_ERR</span><span class="p">;</span>
    <span class="n">te</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
    <span class="n">aeAddMillisecondsToNow</span><span class="p">(</span><span class="n">milliseconds</span><span class="p">,</span><span class="o">&amp;</span><span class="n">te</span><span class="o">-&gt;</span><span class="n">when_sec</span><span class="p">,</span><span class="o">&amp;</span><span class="n">te</span><span class="o">-&gt;</span><span class="n">when_ms</span><span class="p">);</span>
    <span class="n">te</span><span class="o">-&gt;</span><span class="n">timeProc</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span>
    <span class="n">te</span><span class="o">-&gt;</span><span class="n">finalizerProc</span> <span class="o">=</span> <span class="n">finalizerProc</span><span class="p">;</span>
    <span class="n">te</span><span class="o">-&gt;</span><span class="n">clientData</span> <span class="o">=</span> <span class="n">clientData</span><span class="p">;</span>
    <span class="n">te</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">timeEventHead</span><span class="p">;</span>
    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">timeEventHead</span> <span class="o">=</span> <span class="n">te</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="事件的处理">事件的处理</h2>

<blockquote>
  <p>上一章节我们已经从代码的角度对 Redis 中事件的处理有一定的了解，在这里，我想从更高的角度来观察 Redis 对于事件的处理是怎么进行的。</p>
</blockquote>

<p>整个 Redis 服务在启动之后会陷入一个巨大的 while 循环，不停地执行 <code class="highlighter-rouge">processEvents</code> 方法处理文件事件 fe 和时间事件 te 。</p>

<blockquote>
  <p>有关 Redis 中的 I/O 多路复用模块可以看这篇文章 <a href="http://draveness.me/redis-io-multiplexing/">Redis 和 I/O 多路复用</a>。</p>
</blockquote>

<p>当文件事件触发时会被标记为 “红色” 交由 <code class="highlighter-rouge">processEvents</code> 方法处理，而时间事件的处理都会交给 <code class="highlighter-rouge">processTimeEvents</code> 这一子方法：</p>

<p><img src="https://img.draveness.me/2016-12-09-redis-eventloop-proces-event.png-1000width" alt="redis-eventloop-proces-event" /></p>

<p>在每个事件循环中 Redis 都会先处理文件事件，然后再处理时间事件直到整个循环停止，<code class="highlighter-rouge">processEvents</code> 和 <code class="highlighter-rouge">processTimeEvents</code> 作为 Redis 中发生事件的消费者，每次都会从“事件池”中拉去待处理的事件进行消费。</p>

<h3 id="文件事件的处理">文件事件的处理</h3>

<p>由于文件事件触发条件较多，并且 OS 底层实现差异性较大，底层的 I/O 多路复用模块使用了 <code class="highlighter-rouge">eventLoop-&gt;aeFiredEvent</code> 保存对应的文件描述符以及事件，将信息传递给上层进行处理，并抹平了底层实现的差异。</p>

<p>整个 I/O 多路复用模块在事件循环看来就是一个输入事件、输出 <code class="highlighter-rouge">aeFiredEvent</code> 数组的一个黑箱：</p>

<p><img src="https://img.draveness.me/2016-12-09-eventloop-file-event-in-redis.png-1000width" alt="eventloop-file-event-in-redis" /></p>

<p>在这个黑箱中，我们使用 <code class="highlighter-rouge">aeCreateFileEvent</code>、 <code class="highlighter-rouge">aeDeleteFileEvent</code> 来添加删除需要监听的文件描述符以及事件。</p>

<p>在对应事件发生时，当前单元格会“变色”表示发生了可读（黄色）或可写（绿色）事件，调用 <code class="highlighter-rouge">aeApiPoll</code> 时会把对应的文件描述符和事件放入 <code class="highlighter-rouge">aeFiredEvent</code> 数组，并在 <code class="highlighter-rouge">processEvents</code> 方法中执行事件对应的回调。</p>

<h3 id="时间事件的处理">时间事件的处理</h3>

<p>时间事件的处理相比文件事件就容易多了，每次 <code class="highlighter-rouge">processTimeEvents</code> 方法调用时都会对整个 <code class="highlighter-rouge">timeEventHead</code> 数组进行遍历：</p>

<p><img src="https://img.draveness.me/2016-12-09-process-time-events-in-redis.png-1000width" alt="process-time-events-in-redis" /></p>

<p>遍历的过程中会将时间的触发时间与当前时间比较，然后执行时间对应的 <code class="highlighter-rouge">timeProc</code>，并根据 <code class="highlighter-rouge">timeProc</code> 的返回值修改当前事件的参数，并在下一个循环的遍历中移除不再执行的时间事件。</p>

<h2 id="总结">总结</h2>

<blockquote>
  <p>笔者对于文章中两个模块的展示顺序考虑了比较久的时间，最后还是觉得，目前这样的顺序更易于理解。</p>
</blockquote>

<p>Redis 对于事件的处理方式十分精巧，通过传入函数指针以及返回值的方式，将时间事件移除的控制权交给了需要执行的处理器 <code class="highlighter-rouge">timeProc</code>，在 <code class="highlighter-rouge">processTimeEvents</code> 设置 <code class="highlighter-rouge">aeApiPoll</code> 超时时间也十分巧妙，充分地利用了每一次事件循环，防止过多的无用的空转，并且保证了该方法不会阻塞太长时间。</p>

<p>事件循环的机制并不能时间事件准确地在某一个时间点一定执行，往往会比实际约定处理的时间稍微晚一些。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://redis.io/topics/internals-rediseventlib">Redis Event Library</a></li>
  <li><a href="http://key-value-stories.blogspot.com/2015/01/redis-core-implementation.html">Redis Core Implementation</a></li>
  <li><a href="http://draveness.me/redis-io-multiplexing/">Redis 和 I/O 多路复用</a></li>
  <li><a href="http://redisbook.com">Redis 设计与实现</a></li>
</ul>

<h2 id="其它">其它</h2>

<blockquote>

  <p>Source: http://draveness.me/redis-eventloop</p>
</blockquote>

	  ]]></description>
	</item>

	<item>
	  <title>Redis 和 I/O 多路复用</title>
	  <link>/blogs//redis-io-multiplexing</link>
	  <author></author>
	  <pubDate>2016-11-26T06:07:18+00:00</pubDate>
	  <guid>/blogs//redis-io-multiplexing</guid>
	  <description><![CDATA[
	     <p>最近在看 UNIX 网络编程并研究了一下 Redis 的实现，感觉 Redis 的源代码十分适合阅读和分析，其中 I/O 多路复用（mutiplexing）部分的实现非常干净和优雅，在这里想对这部分的内容进行简单的整理。</p>

<h2 id="几种-io-模型">几种 I/O 模型</h2>

<p>为什么 Redis 中要使用 I/O 多路复用这种技术呢？</p>

<p>首先，Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 <strong>I/O 多路复用</strong>就是为了解决这个问题而出现的。</p>

<h3 id="blocking-io">Blocking I/O</h3>

<p>先来看一下传统的阻塞 I/O 模型到底是如何工作的：当使用 <code class="highlighter-rouge">read</code> 或者 <code class="highlighter-rouge">write</code> 对某一个<strong>文件描述符（File Descriptor 以下简称 FD)</strong>进行读写时，如果当前 FD 不可读或不可写，整个 Redis 服务就不会对其它的操作作出响应，导致整个服务不可用。</p>

<p>这也就是传统意义上的，也就是我们在编程中使用最多的阻塞模型：</p>

<p><img src="https://img.draveness.me/2016-11-26-blocking-io.png-1000width" alt="blocking-io" /></p>

<p>阻塞模型虽然开发中非常常见也非常易于理解，但是由于它会影响其他 FD 对应的服务，所以在需要处理多个客户端任务的时候，往往都不会使用阻塞模型。</p>

<h3 id="io-多路复用">I/O 多路复用</h3>

<blockquote>
  <p>虽然还有很多其它的 I/O 模型，但是在这里都不会具体介绍。</p>
</blockquote>

<p>阻塞式的 I/O 模型并不能满足这里的需求，我们需要一种效率更高的 I/O 模型来支撑 Redis 的多个客户（redis-cli），这里涉及的就是 I/O 多路复用模型了：</p>

<p><img src="https://img.draveness.me/2016-11-26-I:O-Multiplexing-Model.png-1000width" alt="I:O-Multiplexing-Mode" /></p>

<p>在 I/O 多路复用模型中，最重要的函数调用就是 <code class="highlighter-rouge">select</code>，该方法的能够同时监控多个文件描述符的可读可写情况，当其中的某些文件描述符可读或者可写时，<code class="highlighter-rouge">select</code> 方法就会返回可读以及可写的文件描述符个数。</p>

<blockquote>
  <p>关于 <code class="highlighter-rouge">select</code> 的具体使用方法，在网络上资料很多，这里就不过多展开介绍了；</p>

  <p>与此同时也有其它的 I/O 多路复用函数 <code class="highlighter-rouge">epoll/kqueue/evport</code>，它们相比 <code class="highlighter-rouge">select</code> 性能更优秀，同时也能支撑更多的服务。</p>
</blockquote>

<h2 id="reactor-设计模式">Reactor 设计模式</h2>

<p>Redis 服务采用 Reactor 的方式来实现文件事件处理器（每一个网络连接其实都对应一个文件描述符）</p>

<p><img src="https://img.draveness.me/2016-11-26-redis-reactor-pattern.png-1000width" alt="redis-reactor-pattern" /></p>

<p>文件事件处理器使用 I/O 多路复用模块同时监听多个 FD，当 <code class="highlighter-rouge">accept</code>、<code class="highlighter-rouge">read</code>、<code class="highlighter-rouge">write</code> 和 <code class="highlighter-rouge">close</code> 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器。</p>

<p>虽然整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，提高了网络通信模型的性能，同时也可以保证整个 Redis 服务实现的简单。</p>

<h2 id="io-多路复用模块">I/O 多路复用模块</h2>

<p>I/O 多路复用模块封装了底层的 <code class="highlighter-rouge">select</code>、<code class="highlighter-rouge">epoll</code>、<code class="highlighter-rouge">avport</code> 以及 <code class="highlighter-rouge">kqueue</code> 这些 I/O 多路复用函数，为上层提供了相同的接口。</p>

<p><img src="https://img.draveness.me/2016-11-26-ae-module.jpg-1000width" alt="ae-module" /></p>

<p>在这里我们简单介绍 Redis 是如何包装 <code class="highlighter-rouge">select</code> 和 <code class="highlighter-rouge">epoll</code> 的，简要了解该模块的功能，整个 I/O 多路复用模块抹平了不同平台上 I/O 多路复用函数的差异性，提供了相同的接口：</p>

<ul>
  <li><code class="highlighter-rouge">static int  aeApiCreate(aeEventLoop *eventLoop)</code></li>
  <li><code class="highlighter-rouge">static int  aeApiResize(aeEventLoop *eventLoop, int setsize)</code></li>
  <li><code class="highlighter-rouge">static void aeApiFree(aeEventLoop *eventLoop)</code></li>
  <li><code class="highlighter-rouge">static int  aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask)</code></li>
  <li><code class="highlighter-rouge">static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) </code></li>
  <li><code class="highlighter-rouge">static int  aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp)</code></li>
</ul>

<p>同时，因为各个函数所需要的参数不同，我们在每一个子模块内部通过一个 <code class="highlighter-rouge">aeApiState</code> 来存储需要的上下文信息：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// select
</span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">aeApiState</span> <span class="p">{</span>
    <span class="n">fd_set</span> <span class="n">rfds</span><span class="p">,</span> <span class="n">wfds</span><span class="p">;</span>
    <span class="n">fd_set</span> <span class="n">_rfds</span><span class="p">,</span> <span class="n">_wfds</span><span class="p">;</span>
<span class="p">}</span> <span class="n">aeApiState</span><span class="p">;</span>

<span class="c1">// epoll
</span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">aeApiState</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">epfd</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">events</span><span class="p">;</span>
<span class="p">}</span> <span class="n">aeApiState</span><span class="p">;</span>
</code></pre></div></div>

<p>这些上下文信息会存储在 <code class="highlighter-rouge">eventLoop</code> 的 <code class="highlighter-rouge">void *state</code> 中，不会暴露到上层，只在当前子模块中使用。</p>

<h3 id="封装-select-函数">封装 select 函数</h3>

<blockquote>
  <p><code class="highlighter-rouge">select</code> 可以监控 FD 的可读、可写以及出现错误的情况。</p>
</blockquote>

<p>在介绍 I/O 多路复用模块如何对 <code class="highlighter-rouge">select</code> 函数封装之前，先来看一下 <code class="highlighter-rouge">select</code> 函数使用的大致流程：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="cm">/* file descriptor */</span>

<span class="n">fd_set</span> <span class="n">rfds</span><span class="p">;</span>
<span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfds</span><span class="p">);</span>
<span class="n">FD_SET</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rfds</span><span class="p">)</span>

<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">select</span><span class="p">(</span><span class="n">fd</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rfds</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FD_ISSET</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rfds</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* file descriptor `fd` becomes readable */</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>初始化一个可读的 <code class="highlighter-rouge">fd_set</code> 集合，保存需要监控可读性的 FD；</li>
  <li>使用 <code class="highlighter-rouge">FD_SET</code> 将 <code class="highlighter-rouge">fd</code> 加入 <code class="highlighter-rouge">rfds</code>；</li>
  <li>调用 <code class="highlighter-rouge">select</code> 方法监控 <code class="highlighter-rouge">rfds</code> 中的 FD 是否可读；</li>
  <li>当 <code class="highlighter-rouge">select</code> 返回时，检查 FD 的状态并完成对应的操作。</li>
</ol>

<p>而在 Redis 的 <code class="highlighter-rouge">ae_select</code> 文件中代码的组织顺序也是差不多的，首先在 <code class="highlighter-rouge">aeApiCreate</code> 函数中初始化 <code class="highlighter-rouge">rfds</code> 和 <code class="highlighter-rouge">wfds</code>：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">aeApiCreate</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">aeApiState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">aeApiState</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rfds</span><span class="p">);</span>
    <span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">wfds</span><span class="p">);</span>
    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">apidata</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>而 <code class="highlighter-rouge">aeApiAddEvent</code> 和 <code class="highlighter-rouge">aeApiDelEvent</code> 会通过 <code class="highlighter-rouge">FD_SET</code> 和 <code class="highlighter-rouge">FD_CLR</code> 修改 <code class="highlighter-rouge">fd_set</code> 中对应 FD 的标志位：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">aeApiAddEvent</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">aeApiState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">apidata</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_READABLE</span><span class="p">)</span> <span class="n">FD_SET</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rfds</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_WRITABLE</span><span class="p">)</span> <span class="n">FD_SET</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">wfds</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>整个 <code class="highlighter-rouge">ae_select</code> 子模块中最重要的函数就是 <code class="highlighter-rouge">aeApiPoll</code>，它是实际调用 <code class="highlighter-rouge">select</code> 函数的部分，其作用就是在 I/O 多路复用函数返回时，将对应的 FD 加入 <code class="highlighter-rouge">aeEventLoop</code> 的 <code class="highlighter-rouge">fired</code> 数组中，并返回事件的个数：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">aeApiPoll</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">tvp</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">aeApiState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">apidata</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">numevents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">_rfds</span><span class="p">,</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rfds</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">fd_set</span><span class="p">));</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">_wfds</span><span class="p">,</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">wfds</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">fd_set</span><span class="p">));</span>

    <span class="n">retval</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">maxfd</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">_rfds</span><span class="p">,</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">_wfds</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">tvp</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">maxfd</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">aeFileEvent</span> <span class="o">*</span><span class="n">fe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">==</span> <span class="n">AE_NONE</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_READABLE</span> <span class="o">&amp;&amp;</span> <span class="n">FD_ISSET</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">_rfds</span><span class="p">))</span>
                <span class="n">mask</span> <span class="o">|=</span> <span class="n">AE_READABLE</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_WRITABLE</span> <span class="o">&amp;&amp;</span> <span class="n">FD_ISSET</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">_wfds</span><span class="p">))</span>
                <span class="n">mask</span> <span class="o">|=</span> <span class="n">AE_WRITABLE</span><span class="p">;</span>
            <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">numevents</span><span class="p">].</span><span class="n">fd</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">numevents</span><span class="p">].</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
            <span class="n">numevents</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">numevents</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="封装-epoll-函数">封装 epoll 函数</h3>

<p>Redis 对 <code class="highlighter-rouge">epoll</code> 的封装其实也是类似的，使用 <code class="highlighter-rouge">epoll_create</code> 创建 <code class="highlighter-rouge">epoll</code> 中使用的 <code class="highlighter-rouge">epfd</code>：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">aeApiCreate</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">aeApiState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">aeApiState</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">epoll_event</span><span class="p">)</span><span class="o">*</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">setsize</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">zfree</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">epfd</span> <span class="o">=</span> <span class="n">epoll_create</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span> <span class="cm">/* 1024 is just a hint for the kernel */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">epfd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">zfree</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">);</span>
        <span class="n">zfree</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">apidata</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">aeApiAddEvent</code> 中使用 <code class="highlighter-rouge">epoll_ctl</code> 向 <code class="highlighter-rouge">epfd</code> 中添加需要监控的 FD 以及监听的事件：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">aeApiAddEvent</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">aeApiState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">apidata</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">ee</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="cm">/* avoid valgrind warning */</span>
    <span class="cm">/* If the fd was already monitored for some event, we need a MOD
     * operation. Otherwise we need an ADD operation. */</span>
    <span class="kt">int</span> <span class="n">op</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">fd</span><span class="p">].</span><span class="n">mask</span> <span class="o">==</span> <span class="n">AE_NONE</span> <span class="o">?</span>
            <span class="n">EPOLL_CTL_ADD</span> <span class="o">:</span> <span class="n">EPOLL_CTL_MOD</span><span class="p">;</span>

    <span class="n">ee</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">mask</span> <span class="o">|=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">fd</span><span class="p">].</span><span class="n">mask</span><span class="p">;</span> <span class="cm">/* Merge old events */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_READABLE</span><span class="p">)</span> <span class="n">ee</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">EPOLLIN</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_WRITABLE</span><span class="p">)</span> <span class="n">ee</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">EPOLLOUT</span><span class="p">;</span>
    <span class="n">ee</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">epoll_ctl</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">epfd</span><span class="p">,</span><span class="n">op</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ee</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>由于 <code class="highlighter-rouge">epoll</code> 相比 <code class="highlighter-rouge">select</code> 机制略有不同，在 <code class="highlighter-rouge">epoll_wait</code> 函数返回时并不需要遍历所有的 FD 查看读写情况；在 <code class="highlighter-rouge">epoll_wait</code> 函数返回时会提供一个 <code class="highlighter-rouge">epoll_event</code> 数组：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">union</span> <span class="n">epoll_data</span> <span class="p">{</span>
    <span class="kt">void</span>    <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
    <span class="kt">int</span>      <span class="n">fd</span><span class="p">;</span> <span class="cm">/* 文件描述符 */</span>
    <span class="kt">uint32_t</span> <span class="n">u32</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>
<span class="p">}</span> <span class="n">epoll_data_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">epoll_event</span> <span class="p">{</span>
    <span class="kt">uint32_t</span>     <span class="n">events</span><span class="p">;</span> <span class="cm">/* Epoll 事件 */</span>
    <span class="n">epoll_data_t</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<blockquote>
  <p>其中保存了发生的 <code class="highlighter-rouge">epoll</code> 事件（<code class="highlighter-rouge">EPOLLIN</code>、<code class="highlighter-rouge">EPOLLOUT</code>、<code class="highlighter-rouge">EPOLLERR</code> 和 <code class="highlighter-rouge">EPOLLHUP</code>）以及发生该事件的 FD。</p>
</blockquote>

<p><code class="highlighter-rouge">aeApiPoll</code> 函数只需要将 <code class="highlighter-rouge">epoll_event</code> 数组中存储的信息加入 <code class="highlighter-rouge">eventLoop</code> 的 <code class="highlighter-rouge">fired</code> 数组中，将信息传递给上层模块：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">aeApiPoll</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">tvp</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">aeApiState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">apidata</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">numevents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">retval</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">epfd</span><span class="p">,</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">,</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">setsize</span><span class="p">,</span>
            <span class="n">tvp</span> <span class="o">?</span> <span class="p">(</span><span class="n">tvp</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="o">*</span><span class="mi">1000</span> <span class="o">+</span> <span class="n">tvp</span><span class="o">-&gt;</span><span class="n">tv_usec</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

        <span class="n">numevents</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numevents</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">events</span><span class="o">+</span><span class="n">j</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLIN</span><span class="p">)</span> <span class="n">mask</span> <span class="o">|=</span> <span class="n">AE_READABLE</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLOUT</span><span class="p">)</span> <span class="n">mask</span> <span class="o">|=</span> <span class="n">AE_WRITABLE</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLERR</span><span class="p">)</span> <span class="n">mask</span> <span class="o">|=</span> <span class="n">AE_WRITABLE</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLHUP</span><span class="p">)</span> <span class="n">mask</span> <span class="o">|=</span> <span class="n">AE_WRITABLE</span><span class="p">;</span>
            <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">fd</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">;</span>
            <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">numevents</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="子模块的选择">子模块的选择</h3>

<p>因为 Redis 需要在多个平台上运行，同时为了最大化执行的效率与性能，所以会根据编译平台的不同选择不同的 I/O 多路复用函数作为子模块，提供给上层统一的接口；在 Redis 中，我们通过宏定义的使用，合理的选择不同的子模块：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifdef HAVE_EVPORT
#include "ae_evport.c"
#else
</span>    <span class="cp">#ifdef HAVE_EPOLL
</span>    <span class="cp">#include "ae_epoll.c"
</span>    <span class="cp">#else
</span>        <span class="cp">#ifdef HAVE_KQUEUE
</span>        <span class="cp">#include "ae_kqueue.c"
</span>        <span class="cp">#else
</span>        <span class="cp">#include "ae_select.c"
</span>        <span class="cp">#endif
</span>    <span class="cp">#endif
#endif
</span></code></pre></div></div>

<p>因为 <code class="highlighter-rouge">select</code> 函数是作为 POSIX 标准中的系统调用，在不同版本的操作系统上都会实现，所以将其作为保底方案：</p>

<p><img src="https://img.draveness.me/2016-11-26-redis-choose-io-function.jpg-1000width" alt="redis-choose-io-function" /></p>

<p>Redis 会优先选择时间复杂度为 $O(1)$ 的 I/O 多路复用函数作为底层实现，包括 Solaries 10 中的 <code class="highlighter-rouge">evport</code>、Linux 中的 <code class="highlighter-rouge">epoll</code> 和 macOS/FreeBSD 中的 <code class="highlighter-rouge">kqueue</code>，上述的这些函数都使用了内核内部的结构，并且能够服务几十万的文件描述符。</p>

<p>但是如果当前编译环境没有上述函数，就会选择 <code class="highlighter-rouge">select</code> 作为备选方案，由于其在使用时会扫描全部监听的描述符，所以其时间复杂度较差 $O(n)$，并且只能同时服务 1024 个文件描述符，所以一般并不会以 <code class="highlighter-rouge">select</code> 作为第一方案使用。</p>

<h2 id="总结">总结</h2>

<p>Redis 对于 I/O 多路复用模块的设计非常简洁，通过宏保证了 I/O 多路复用模块在不同平台上都有着优异的性能，将不同的 I/O 多路复用函数封装成相同的 API 提供给上层使用。</p>

<p>整个模块使 Redis 能以单进程运行的同时服务成千上万个文件描述符，避免了由于多进程应用的引入导致代码实现复杂度的提升，减少了出错的可能性。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="http://man7.org/linux/man-pages/man2/select.2.html">Select-Man-Pages</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Reactor_pattern">Reactor-Pattern</a></li>
  <li><a href="https://people.eecs.berkeley.edu/~sangjin/2012/12/21/epoll-vs-kqueue.html">epoll vs kqueue</a></li>
</ul>

<h2 id="其它">其它</h2>

<blockquote>

  <p>Source: http://draveness.me/redis-io-multiplexing</p>
</blockquote>

	  ]]></description>
	</item>


</channel>
</rss>
