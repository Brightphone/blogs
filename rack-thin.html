<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>浅谈 Thin 的事件驱动模型</title>
    <meta name="description" content="A beautiful narrative written with the world's most elegant publishing platform. The story begins here." />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/blogs/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/blogs/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/blogs/assets/css/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="/blogs//rack-thin" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/blogs/page2/" />

    <meta property="og:site_name" content="Brightness" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="浅谈 Thin 的事件驱动模型" />
    <meta property="og:description" content="A beautiful narrative written with the world's most elegant publishing platform. The story begins here." />
    <meta property="og:url" content="/blogs//rack-thin" />
    <meta property="og:image" content="/blogs/assets/images/cover1.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="浅谈 Thin 的事件驱动模型" />
    <meta name="twitter:description" content="A beautiful narrative written with the world's most elegant publishing platform. The story begins here." />
    <meta name="twitter:url" content="/blogs//rack-thin" />
    <meta name="twitter:image:src" content="/blogs/assets/images/cover1.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "Brightness",
    "name": "浅谈 Thin 的事件驱动模型",
    "url": "/blogs//rack-thin",
    "image": "/blogs/assets/images/cover1.jpg",
    "description": "A beautiful narrative written with the world's most elegant publishing platform. The story begins here."
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="Brightness" href="/blogs/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/blogs/">Home</a></li>
        <li class="nav-about " role="presentation"><a href="/blogs/about">About</a></li>
        <li class="nav-fables " role="presentation"><a href="/blogs/tag/fables">Fables</a></li>
        <li class="nav-speeches " role="presentation"><a href="/blogs/tag/speeches">Speeches</a></li>
        <li class="nav-fiction " role="presentation"><a href="/blogs/tag/fiction">Fiction</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/casper">Casper</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/edgar">Edgar</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/abraham">Abraham</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/martin">Martin</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/lewis">Lewis</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/blogs/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        
        
    </nav>
</header>

<main class="content" role="main">

    <article class="">

        <header class="post-header">
            <h1 class="post-title">浅谈 Thin 的事件驱动模型</h1>
            <section class="post-meta">
            <!-- <a href='/blogs/'></a> -->

            
                
            
                
            
                
            
                
            
                
            
            <time class="post-date" datetime="2017-11-04">04 Nov 2017</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/blogs/tag/Rack系列'>Rack系列</a>,
                    
                
                    
                       <a href='/blogs/tag/Thin'>Thin</a>,
                    
                
                    
                       <a href='/blogs/tag/Reactor'>Reactor</a>,
                    
                
                    
                       <a href='/blogs/tag/EventMachine'>Eventmachine</a>,
                    
                
                    
                       <a href='/blogs/tag/rack'>Rack</a>,
                    
                
                    
                       <a href='/blogs/tag/ruby'>Ruby</a>,
                    
                
                    
                       <a href='/blogs/tag/server'>Server</a>
                    
                
                
            </section>
        </header>

        <section class="post-content">

            <ul>
  <li><a href="https://draveness.me/rack">谈谈 Rack 协议与实现</a></li>
  <li><a href="https://draveness.me/rack-webrick">浅谈 WEBrick 的多线程模型</a></li>
  <li><a href="https://draveness.me/rack-thin">浅谈 Thin 的事件驱动模型</a></li>
  <li><a href="https://draveness.me/rack-unicorn">浅谈 Unicorn 的多进程模型</a></li>
  <li><a href="https://draveness.me/rack-puma">浅谈 Puma 的并发模型与实现</a></li>
  <li><a href="https://draveness.me/ruby-webserver">Ruby Web 服务器的并发模型与性能</a></li>
</ul>

<p>在上一篇文章中我们已经介绍了 WEBrick 的实现，它的 handler 是写在 Rack 工程中的，而在这篇文章介绍的 webserver <a href="https://github.com/macournoyer/thin">thin</a> 的 Rack 处理器也是写在 Rack 中的；与 WEBrick 相同，Thin 的实现也非常简单，官方对它的介绍是：</p>

<blockquote>
  <p>A very fast &amp; simple Ruby web server.</p>
</blockquote>

<p>它将 <a href="https://zedshaw.com/archive/ragel-state-charts/">Mongrel</a>、<a href="https://github.com/eventmachine/eventmachine">EventMachine</a> 和 <a href="http://rack.github.io">Rack</a> 三者进行组合，在其中起到胶水的作用，所以在理解 Thin 的实现的过程中我们也需要分析 EventMachine 到底是如何工作的。</p>

<h2 id="thin-的实现">Thin 的实现</h2>

<p>在这一节中我们将从源代码来分析介绍 Thin 的实现原理，因为部分代码仍然是在 Rack 工程中实现的，所以我们要从 Rack 工程的代码开始理解 Thin 的实现。</p>

<h3 id="从-rack-开始">从 Rack 开始</h3>

<p>Thin 的处理器 <code class="highlighter-rouge">Rack::Handler::Thin</code> 与其他遵循 Rack 协议的 webserver 一样都实现了 <code class="highlighter-rouge">.run</code> 方法，接受 Rack 应用和 <code class="highlighter-rouge">options</code> 作为输入：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Rack</span>
  <span class="k">module</span> <span class="nn">Handler</span>
    <span class="k">class</span> <span class="nc">Thin</span>
      <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">run</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{})</span>
        <span class="n">environment</span>  <span class="o">=</span> <span class="no">ENV</span><span class="p">[</span><span class="s1">'RACK_ENV'</span><span class="p">]</span> <span class="o">||</span> <span class="s1">'development'</span>
        <span class="n">default_host</span> <span class="o">=</span> <span class="n">environment</span> <span class="o">==</span> <span class="s1">'development'</span> <span class="p">?</span> <span class="s1">'localhost'</span> <span class="p">:</span> <span class="s1">'0.0.0.0'</span>

        <span class="n">host</span> <span class="o">=</span> <span class="n">options</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="ss">:Host</span><span class="p">)</span> <span class="o">||</span> <span class="n">default_host</span>
        <span class="n">port</span> <span class="o">=</span> <span class="n">options</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="ss">:Port</span><span class="p">)</span> <span class="o">||</span> <span class="mi">8080</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">app</span><span class="p">,</span> <span class="n">options</span><span class="p">]</span>
        <span class="n">args</span><span class="p">.</span><span class="nf">pop</span> <span class="k">if</span> <span class="o">::</span><span class="no">Thin</span><span class="o">::</span><span class="no">VERSION</span><span class="o">::</span><span class="no">MAJOR</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">::</span><span class="no">Thin</span><span class="o">::</span><span class="no">VERSION</span><span class="o">::</span><span class="no">MINOR</span> <span class="o">&lt;</span> <span class="mi">8</span>
        <span class="n">server</span> <span class="o">=</span> <span class="o">::</span><span class="no">Thin</span><span class="o">::</span><span class="no">Server</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">server</span> <span class="k">if</span> <span class="nb">block_given?</span>
        <span class="n">server</span><span class="p">.</span><span class="nf">start</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法仍然会从 <code class="highlighter-rouge">options</code> 中取出 ip 地址和端口号，然后初始化一个 <code class="highlighter-rouge">Thin::Server</code> 的实例后，执行 <code class="highlighter-rouge">#start</code> 方法在 8080 端口上监听来自用户的请求。</p>

<h3 id="初始化服务">初始化服务</h3>

<p>Thin 服务的初始化由以下的代码来处理，首先会处理在 <code class="highlighter-rouge">Rack::Handler::Thin.run</code> 中传入的几个参数 <code class="highlighter-rouge">host</code>、<code class="highlighter-rouge">port</code>、<code class="highlighter-rouge">app</code> 和 <code class="highlighter-rouge">options</code>，将 Rack 应用存储在临时变量中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">100</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="no">DEFAULT_HOST</span><span class="p">,</span> <span class="no">DEFAULT_PORT</span><span class="p">,</span> <span class="p">{}</span>

  <span class="n">args</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">arg</span><span class="o">|</span>
    <span class="k">case</span> <span class="n">arg</span>
    <span class="k">when</span> <span class="mi">0</span><span class="p">.</span><span class="nf">class</span><span class="p">,</span> <span class="sr">/^\d+$/</span> <span class="k">then</span> <span class="n">port</span>    <span class="o">=</span> <span class="n">arg</span><span class="p">.</span><span class="nf">to_i</span>
    <span class="k">when</span> <span class="no">String</span>           <span class="k">then</span> <span class="n">host</span>    <span class="o">=</span> <span class="n">arg</span>
    <span class="k">when</span> <span class="no">Hash</span>             <span class="k">then</span> <span class="n">options</span> <span class="o">=</span> <span class="n">arg</span>
    <span class="k">else</span>
      <span class="vi">@app</span> <span class="o">=</span> <span class="n">arg</span> <span class="k">if</span> <span class="n">arg</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:call</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="vi">@backend</span> <span class="o">=</span> <span class="n">select_backend</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
  <span class="vi">@backend</span><span class="p">.</span><span class="nf">server</span> <span class="o">=</span> <span class="nb">self</span>
  <span class="vi">@backend</span><span class="p">.</span><span class="nf">maximum_connections</span>            <span class="o">=</span> <span class="no">DEFAULT_MAXIMUM_CONNECTIONS</span>
  <span class="vi">@backend</span><span class="p">.</span><span class="nf">maximum_persistent_connections</span> <span class="o">=</span> <span class="no">DEFAULT_MAXIMUM_PERSISTENT_CONNECTIONS</span>
  <span class="vi">@backend</span><span class="p">.</span><span class="nf">timeout</span>                        <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:timeout</span><span class="p">]</span> <span class="o">||</span> <span class="no">DEFAULT_TIMEOUT</span>

  <span class="vi">@app</span> <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">).</span><span class="nf">to_app</span> <span class="k">if</span> <span class="n">block</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在初始化服务的过程中，总共只做了三件事情，处理参数、选择并配置 <code class="highlighter-rouge">backend</code>，创建新的应用：</p>

<p><img src="https://img.draveness.me/2017-11-04-thin-initialize-server.png" alt="thin-initialize-serve" /></p>

<p>处理参数的过程自然不用多说，只是这里判断的方式并不是按照顺序处理的，而是按照参数的类型；在初始化器的最后，如果向初始化器传入了 block，那么就会使用 <code class="highlighter-rouge">Rack::Builder</code> 和 block 中的代码初始化一个新的 Rack 应用。</p>

<h3 id="选择后端">选择后端</h3>

<p>在选择后端时 Thin 使用了 <code class="highlighter-rouge">#select_backend</code> 方法，这里使用 <code class="highlighter-rouge">case</code> 语句替代多个 <code class="highlighter-rouge">if</code>、<code class="highlighter-rouge">else</code>，也是一个我们可以使用的小技巧：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">261</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">select_backend</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
  <span class="k">case</span>
  <span class="k">when</span> <span class="n">options</span><span class="p">.</span><span class="nf">has_key?</span><span class="p">(</span><span class="ss">:backend</span><span class="p">)</span>
    <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">":backend must be a class"</span> <span class="k">unless</span> <span class="n">options</span><span class="p">[</span><span class="ss">:backend</span><span class="p">].</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Class</span><span class="p">)</span>
    <span class="n">options</span><span class="p">[</span><span class="ss">:backend</span><span class="p">].</span><span class="nf">new</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
  <span class="k">when</span> <span class="n">options</span><span class="p">.</span><span class="nf">has_key?</span><span class="p">(</span><span class="ss">:swiftiply</span><span class="p">)</span>
    <span class="no">Backends</span><span class="o">::</span><span class="no">SwiftiplyClient</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
  <span class="k">when</span> <span class="n">host</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span>
    <span class="no">Backends</span><span class="o">::</span><span class="no">UnixServer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="no">Backends</span><span class="o">::</span><span class="no">TcpServer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在大多数时候，我们只会选择 <code class="highlighter-rouge">UnixServer</code> 和 <code class="highlighter-rouge">TcpServer</code> 两种后端中的一个，而后者又是两者中使用更为频繁的后端：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">backends</span><span class="o">/</span><span class="n">tcp_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">8</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Backends</span><span class="o">::</span><span class="no">TcpServer</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
  <span class="vi">@host</span> <span class="o">=</span> <span class="n">host</span>
  <span class="vi">@port</span> <span class="o">=</span> <span class="n">port</span>
  <span class="k">super</span><span class="p">()</span>
<span class="k">end</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">backends</span><span class="o">/</span><span class="n">base</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">47</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Backends</span><span class="o">::</span><span class="no">Base</span>

<span class="k">def</span> <span class="nf">initialize</span>
  <span class="vi">@connections</span>                    <span class="o">=</span> <span class="p">{}</span>
  <span class="vi">@timeout</span>                        <span class="o">=</span> <span class="no">Server</span><span class="o">::</span><span class="no">DEFAULT_TIMEOUT</span>
  <span class="vi">@persistent_connection_count</span>    <span class="o">=</span> <span class="mi">0</span>
  <span class="vi">@maximum_connections</span>            <span class="o">=</span> <span class="no">Server</span><span class="o">::</span><span class="no">DEFAULT_MAXIMUM_CONNECTIONS</span>
  <span class="vi">@maximum_persistent_connections</span> <span class="o">=</span> <span class="no">Server</span><span class="o">::</span><span class="no">DEFAULT_MAXIMUM_PERSISTENT_CONNECTIONS</span>
  <span class="vi">@no_epoll</span>                       <span class="o">=</span> <span class="kp">false</span>
  <span class="vi">@ssl</span>                            <span class="o">=</span> <span class="kp">nil</span>
  <span class="vi">@threaded</span>                       <span class="o">=</span> <span class="kp">nil</span>
  <span class="vi">@started_reactor</span>                <span class="o">=</span> <span class="kp">false</span>
<span class="k">end</span>
</code></pre></div></div>

<p>初始化的过程中只是对属性设置默认值，比如 <code class="highlighter-rouge">host</code>、<code class="highlighter-rouge">port</code> 以及超时时间等等，并没有太多值得注意的代码。</p>

<h3 id="启动服务">启动服务</h3>

<p>在启动服务时会直接调用 <code class="highlighter-rouge">TcpServer#start</code> 方法并在其中传入一个用于处理信号的 block：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">152</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">start</span>
  <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s1">'app required'</span> <span class="k">unless</span> <span class="vi">@app</span>
  
  <span class="n">log_info</span>  <span class="s2">"Thin web server (v</span><span class="si">#{</span><span class="no">VERSION</span><span class="o">::</span><span class="no">STRING</span><span class="si">}</span><span class="s2"> codename </span><span class="si">#{</span><span class="no">VERSION</span><span class="o">::</span><span class="no">CODENAME</span><span class="si">}</span><span class="s2">)"</span>
  <span class="n">log_debug</span> <span class="s2">"Debugging ON"</span>
  <span class="n">trace</span>     <span class="s2">"Tracing ON"</span>
  
  <span class="n">log_info</span> <span class="s2">"Maximum connections set to </span><span class="si">#{</span><span class="vi">@backend</span><span class="p">.</span><span class="nf">maximum_connections</span><span class="si">}</span><span class="s2">"</span>
  <span class="n">log_info</span> <span class="s2">"Listening on </span><span class="si">#{</span><span class="vi">@backend</span><span class="si">}</span><span class="s2">, CTRL+C to stop"</span>

  <span class="vi">@backend</span><span class="p">.</span><span class="nf">start</span> <span class="p">{</span> <span class="n">setup_signals</span> <span class="k">if</span> <span class="vi">@setup_signals</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>虽然这里的 <code class="highlighter-rouge">backend</code> 其实已经被选择成了 <code class="highlighter-rouge">TcpServer</code>，但是该子类并没有覆写 <code class="highlighter-rouge">#start</code> 方法，这里执行的方法其实是从父类继承的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">backends</span><span class="o">/</span><span class="n">base</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">60</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Backends</span><span class="o">::</span><span class="no">Base</span>

<span class="k">def</span> <span class="nf">start</span>
  <span class="vi">@stopping</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="n">starter</span>   <span class="o">=</span> <span class="nb">proc</span> <span class="k">do</span>
    <span class="n">connect</span>
    <span class="k">yield</span> <span class="k">if</span> <span class="nb">block_given?</span>
    <span class="vi">@running</span> <span class="o">=</span> <span class="kp">true</span>
  <span class="k">end</span>
  
  <span class="c1"># Allow for early run up of eventmachine.</span>
  <span class="k">if</span> <span class="no">EventMachine</span><span class="p">.</span><span class="nf">reactor_running?</span>
    <span class="n">starter</span><span class="p">.</span><span class="nf">call</span>
  <span class="k">else</span>
    <span class="vi">@started_reactor</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="no">EventMachine</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="n">starter</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法在构建一个 <code class="highlighter-rouge">starter</code> block 之后，将该 block 传入 <code class="highlighter-rouge">EventMachine.run</code> 方法，随后执行的 <code class="highlighter-rouge">#connect</code> 会启动一个 <code class="highlighter-rouge">EventMachine</code> 的服务器用于处理用户的网络请求：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">backends</span><span class="o">/</span><span class="n">tcp_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">15</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Backends</span><span class="o">::</span><span class="no">TcpServer</span>

<span class="k">def</span> <span class="nf">connect</span>
  <span class="vi">@signature</span> <span class="o">=</span> <span class="no">EventMachine</span><span class="p">.</span><span class="nf">start_server</span><span class="p">(</span><span class="vi">@host</span><span class="p">,</span> <span class="vi">@port</span><span class="p">,</span> <span class="no">Connection</span><span class="p">,</span> <span class="o">&amp;</span><span class="nb">method</span><span class="p">(</span><span class="ss">:initialize_connection</span><span class="p">))</span>
  <span class="n">binary_name</span> <span class="o">=</span> <span class="no">EventMachine</span><span class="p">.</span><span class="nf">get_sockname</span><span class="p">(</span> <span class="vi">@signature</span> <span class="p">)</span>
  <span class="n">port_name</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">unpack_sockaddr_in</span><span class="p">(</span> <span class="n">binary_name</span> <span class="p">)</span>
  <span class="vi">@port</span> <span class="o">=</span> <span class="n">port_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="vi">@host</span> <span class="o">=</span> <span class="n">port_name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="vi">@signature</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 EventMachine 的文档中，<code class="highlighter-rouge">.start_server</code> 方法被描述成一个在指定的地址和端口上初始化 TCP 服务的方法，正如这里所展示的，它经常在 <code class="highlighter-rouge">.run</code> 方法的 block 中执行；该方法的参数 <code class="highlighter-rouge">Connection</code> 作为处理 TCP 请求的类，会实现不同的方法接受各种各样的回调，传入的 <code class="highlighter-rouge">initialize_connection</code> block 会在有请求需要处理时对 <code class="highlighter-rouge">Connection</code> 对象进行初始化：</p>

<blockquote>
  <p><code class="highlighter-rouge">Connection</code> 对象继承自 <code class="highlighter-rouge">EventMachine::Connection</code>，是 EventMachine 与外界的接口，在 EventMachine 中的大部分事件都会调用 <code class="highlighter-rouge">Connection</code> 的一个实例方法来传递数据和参数。</p>
</blockquote>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">backends</span><span class="o">/</span><span class="n">base</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">145</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Backends</span><span class="o">::</span><span class="no">Base</span>

<span class="k">def</span> <span class="nf">initialize_connection</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">backend</span>                 <span class="o">=</span> <span class="nb">self</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">app</span>                     <span class="o">=</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">app</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">comm_inactivity_timeout</span> <span class="o">=</span> <span class="vi">@timeout</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">threaded</span>                <span class="o">=</span> <span class="vi">@threaded</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">start_tls</span><span class="p">(</span><span class="vi">@ssl_options</span><span class="p">)</span> <span class="k">if</span> <span class="vi">@ssl</span>

  <span class="k">if</span> <span class="vi">@persistent_connection_count</span> <span class="o">&lt;</span> <span class="vi">@maximum_persistent_connections</span>
    <span class="n">connection</span><span class="p">.</span><span class="nf">can_persist!</span>
    <span class="vi">@persistent_connection_count</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">end</span>
  <span class="vi">@connections</span><span class="p">[</span><span class="n">connection</span><span class="p">.</span><span class="nf">__id__</span><span class="p">]</span> <span class="o">=</span> <span class="n">connection</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="处理请求的连接">处理请求的连接</h3>

<p><code class="highlighter-rouge">Connection</code> 类中有很多的方法 <code class="highlighter-rouge">#post_init</code>、<code class="highlighter-rouge">#receive_data</code> 方法等等都是由 EventMachine 在接收到请求时调用的，当 Thin 的服务接收到来自客户端的数据时就会调用 <code class="highlighter-rouge">#receive_data</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">connection</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">36</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Connection</span>

<span class="k">def</span> <span class="nf">receive_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="vi">@idle</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="n">trace</span> <span class="n">data</span>
  <span class="n">process</span> <span class="k">if</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="k">rescue</span> <span class="no">InvalidRequest</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="n">log_error</span><span class="p">(</span><span class="s2">"Invalid request"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
  <span class="n">post_process</span> <span class="no">Response</span><span class="o">::</span><span class="no">BAD_REQUEST</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这里我们看到了与 WEBrick 在处理来自客户端的原始数据时使用的方法 <code class="highlighter-rouge">#parse</code>，它会解析客户端请求的原始数据并执行 <code class="highlighter-rouge">#process</code> 来处理 HTTP 请求：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">connection</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">47</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Connection</span>

<span class="k">def</span> <span class="nf">process</span>
  <span class="k">if</span> <span class="n">threaded?</span>
    <span class="vi">@request</span><span class="p">.</span><span class="nf">threaded</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="no">EventMachine</span><span class="p">.</span><span class="nf">defer</span> <span class="p">{</span> <span class="n">post_process</span><span class="p">(</span><span class="n">pre_process</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">else</span>
    <span class="vi">@request</span><span class="p">.</span><span class="nf">threaded</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="n">post_process</span><span class="p">(</span><span class="n">pre_process</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果当前的连接允许并行处理多个用户的请求，那么就会在 <code class="highlighter-rouge">EventMachine.defer</code> 的 block 中执行两个方法 <code class="highlighter-rouge">#pre_process</code> 和 <code class="highlighter-rouge">#post_process</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">connection</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">63</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Connection</span>

<span class="k">def</span> <span class="nf">pre_process</span>
  <span class="vi">@request</span><span class="p">.</span><span class="nf">remote_address</span> <span class="o">=</span> <span class="n">remote_address</span>
  <span class="vi">@request</span><span class="p">.</span><span class="nf">async_callback</span> <span class="o">=</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:post_process</span><span class="p">)</span>

  <span class="n">response</span> <span class="o">=</span> <span class="no">AsyncResponse</span>
  <span class="kp">catch</span><span class="p">(</span><span class="ss">:async</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">response</span> <span class="o">=</span> <span class="vi">@app</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="vi">@request</span><span class="p">.</span><span class="nf">env</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">response</span>
<span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="n">unexpected_error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
  <span class="n">can_persist?</span> <span class="o">&amp;&amp;</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">persistent?</span> <span class="p">?</span> <span class="no">Response</span><span class="o">::</span><span class="no">PERSISTENT_ERROR</span> <span class="p">:</span> <span class="no">Response</span><span class="o">::</span><span class="no">ERROR</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">#pre_process</code> 中没有做太多的事情，只是调用了 Rack 应用的 <code class="highlighter-rouge">#call</code> 方法，得到一个三元组 <code class="highlighter-rouge">response</code>，在这之后将这个数组传入 <code class="highlighter-rouge">#post_process</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">connection</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">95</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Connection</span>

<span class="k">def</span> <span class="nf">post_process</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
  <span class="k">return</span> <span class="k">unless</span> <span class="n">result</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="nf">to_a</span>
  <span class="k">return</span> <span class="k">if</span> <span class="n">result</span><span class="p">.</span><span class="nf">first</span> <span class="o">==</span> <span class="no">AsyncResponse</span><span class="p">.</span><span class="nf">first</span>

  <span class="vi">@response</span><span class="p">.</span><span class="nf">status</span><span class="p">,</span> <span class="vi">@response</span><span class="p">.</span><span class="nf">headers</span><span class="p">,</span> <span class="vi">@response</span><span class="p">.</span><span class="nf">body</span> <span class="o">=</span> <span class="o">*</span><span class="n">result</span>
  <span class="vi">@response</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">chunk</span><span class="o">|</span>
    <span class="n">send_data</span> <span class="n">chunk</span>
  <span class="k">end</span>
<span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="n">unexpected_error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
  <span class="n">close_connection</span>
<span class="k">ensure</span>
  <span class="k">if</span> <span class="vi">@response</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:callback</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="vi">@response</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:errback</span><span class="p">)</span>
    <span class="vi">@response</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">callback</span> <span class="p">{</span> <span class="n">terminate_request</span> <span class="p">}</span>
    <span class="vi">@response</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">errback</span>  <span class="p">{</span> <span class="n">terminate_request</span> <span class="p">}</span>
  <span class="k">else</span>
    <span class="n">terminate_request</span> <span class="k">unless</span> <span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">result</span><span class="p">.</span><span class="nf">first</span> <span class="o">==</span> <span class="no">AsyncResponse</span><span class="p">.</span><span class="nf">first</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">#post_response</code> 方法将传入的数组赋值给 <code class="highlighter-rouge">response</code> 的 <code class="highlighter-rouge">status</code>、<code class="highlighter-rouge">headers</code> 和 <code class="highlighter-rouge">body</code> 这三部分，在这之后通过 <code class="highlighter-rouge">#send_data</code> 方法将 HTTP 响应以块的形式写回 Socket；写回结束后可能会调用对应的 <code class="highlighter-rouge">callback</code> 并关闭持有的 <code class="highlighter-rouge">request</code> 和 <code class="highlighter-rouge">response</code> 两个实例变量。</p>

<blockquote>
  <p>上述方法中调用的 <code class="highlighter-rouge">#send_data</code> 继承自 <code class="highlighter-rouge">EventMachine::Connection</code> 类。</p>
</blockquote>

<h3 id="小结">小结</h3>

<p>到此为止，我们对于 Thin 是如何处理来自用户的 HTTP 请求的就比较清楚了，我们可以看到 Thin 本身并没有做一些类似解析 HTTP 数据包以及发送数据的问题，它使用了来自 Rack 和 EventMachine 两个开源框架中很多已有的代码逻辑，确实只做了一些胶水的事情。</p>

<p>对于 Rack 是如何工作的我们在前面的文章 <a href="https://draveness.me/rack">谈谈 Rack 协议与实现</a> 中已经介绍过了；虽然我们看到了很多与 EventMachine 相关的代码，但是到这里我们仍然对 EventMachine 不是太了解。</p>

<h2 id="eventmachine-和-reactor-模式">EventMachine 和 Reactor 模式</h2>

<p>为了更好地理解 Thin 的工作原理，在这里我们会介绍一个 EventMachine 和 Reactor 模式。</p>

<p>EventMachine 其实是一个使用 Ruby 实现的事件驱动的并行框架，它使用 Reactor 模式提供了事件驱动的 IO 模型，如果你对 Node.js 有所了解的话，那么你一定对事件驱动这个词并不陌生，EventMachine 的出现主要是为了解决两个核心问题：</p>

<ul>
  <li>为生产环境提供更高的可伸缩性、更好的性能和稳定性；</li>
  <li>为上层提供了一些能够减少高性能的网络编程复杂性的 API；</li>
</ul>

<p>其实 EventMachine 的主要作用就是将所有同步的 IO 都变成异步的，调度都通过事件来进行，这样用于监听用户请求的进程不会被其他代码阻塞，能够同时为更多的客户端提供服务；在这一节中，我们需要了解一下在 Thin 中使用的 EventMachine 中几个常用方法的实现。</p>

<h3 id="启动事件循环">启动事件循环</h3>

<p>EventMachine 其实就是一个事件循环（Event Loop），当我们想使用 EventMachine 来处理某些任务时就一定需要调用 <code class="highlighter-rouge">.run</code> 方法启动这个事件循环来接受外界触发的各种事件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">eventmachine</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">149</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:EventMachine&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">run</span> <span class="n">blk</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span> <span class="n">tail</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span>
  <span class="c1"># ...</span>
  <span class="k">begin</span>
    <span class="vi">@reactor_pid</span> <span class="o">=</span> <span class="no">Process</span><span class="p">.</span><span class="nf">pid</span>
    <span class="vi">@reactor_running</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="n">initialize_event_machine</span>
    <span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">blk</span> <span class="o">||</span> <span class="n">block</span><span class="p">)</span> <span class="n">and</span> <span class="n">add_timer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">if</span> <span class="vi">@next_tick_queue</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="vi">@next_tick_queue</span><span class="p">.</span><span class="nf">empty?</span>
      <span class="n">add_timer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">signal_loopbreak</span> <span class="p">}</span>
    <span class="k">end</span>
    <span class="vi">@reactor_thread</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span>

    <span class="n">run_machine</span>
  <span class="k">ensure</span>
    <span class="k">until</span> <span class="vi">@tails</span><span class="p">.</span><span class="nf">empty?</span>
      <span class="vi">@tails</span><span class="p">.</span><span class="nf">pop</span><span class="p">.</span><span class="nf">call</span>
    <span class="k">end</span>

    <span class="n">release_machine</span>
    <span class="n">cleanup_machine</span>
    <span class="vi">@reactor_running</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="vi">@reactor_thread</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这里我们会使用 <code class="highlighter-rouge">.initialize_event_machine</code> 初始化当前的事件循环，其实也就是一个全局的 <code class="highlighter-rouge">Reactor</code> 的单例，最终会执行 <code class="highlighter-rouge">Reactor#initialize_for_run</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">522</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">EventMachine</span><span class="o">::</span><span class="no">Reactor</span>

<span class="k">def</span> <span class="nf">initialize_for_run</span>
  <span class="vi">@running</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="vi">@stop_scheduled</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="vi">@selectables</span> <span class="o">||=</span> <span class="p">{};</span> <span class="vi">@selectables</span><span class="p">.</span><span class="nf">clear</span>
  <span class="vi">@timers</span> <span class="o">=</span> <span class="no">SortedSet</span><span class="p">.</span><span class="nf">new</span> <span class="c1"># []</span>
  <span class="n">set_timer_quantum</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
  <span class="vi">@current_loop_time</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span>
  <span class="vi">@next_heartbeat</span> <span class="o">=</span> <span class="vi">@current_loop_time</span> <span class="o">+</span> <span class="no">HeartbeatInterval</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在启动事件循环的过程中，它还会将传入的 block 与一个 <code class="highlighter-rouge">interval</code> 为 0 的键组成键值对存到 <code class="highlighter-rouge">@timers</code> 字典中，所有加入的键值对都会在大约 <code class="highlighter-rouge">interval</code> 的时间过后执行一次 block。</p>

<p>随后执行的 <code class="highlighter-rouge">#run_machine</code> 在最后也会执行 <code class="highlighter-rouge">Reactor</code> 的 <code class="highlighter-rouge">#run</code> 方法，该方法中包含一个 loop 语句，也就是我们一直说的事件循环：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">540</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">EventMachine</span><span class="o">::</span><span class="no">Reactor</span>

<span class="k">def</span> <span class="nf">run</span>
  <span class="k">raise</span> <span class="no">Error</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span> <span class="s2">"already running"</span> <span class="p">)</span> <span class="k">if</span> <span class="vi">@running</span>
  <span class="vi">@running</span> <span class="o">=</span> <span class="kp">true</span>

  <span class="k">begin</span>
    <span class="n">open_loopbreaker</span>

    <span class="kp">loop</span> <span class="p">{</span>
      <span class="vi">@current_loop_time</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span>

      <span class="k">break</span> <span class="k">if</span> <span class="vi">@stop_scheduled</span>
      <span class="n">run_timers</span>
      <span class="k">break</span> <span class="k">if</span> <span class="vi">@stop_scheduled</span>
      <span class="n">crank_selectables</span>
      <span class="k">break</span> <span class="k">if</span> <span class="vi">@stop_scheduled</span>
      <span class="n">run_heartbeats</span>
    <span class="p">}</span>
  <span class="k">ensure</span>
    <span class="n">close_loopbreaker</span>
    <span class="vi">@selectables</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span><span class="o">|</span><span class="n">k</span><span class="p">,</span> <span class="n">io</span><span class="o">|</span> <span class="n">io</span><span class="p">.</span><span class="nf">close</span><span class="p">}</span>
    <span class="vi">@selectables</span><span class="p">.</span><span class="nf">clear</span>

    <span class="vi">@running</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在启动事件循环之间会在 <code class="highlighter-rouge">#open_loopbreaker</code> 中创建一个 <code class="highlighter-rouge">LoopbreakReader</code> 的实例绑定在 <code class="highlighter-rouge">127.0.0.1</code> 和随机的端口号组成的地址上，然后开始运行事件循环。</p>

<p><img src="https://img.draveness.me/2017-11-04-reactor-eventloop.png" alt="reactor-eventloop" /></p>

<p>在事件循环中，Reactor 总共需要执行三部分的任务，分别是执行定时器、处理 Socket 上的事件以及运行心跳方法。</p>

<p>无论是运行定时器还是执行心跳方法其实都非常简单，只要与当前时间进行比较，如果到了触发的时间就调用正确的方法或者回调，最后的 <code class="highlighter-rouge">#crank_selectables</code> 方法就是用于处理 Socket 上读写事件的方法了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">540</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">EventMachine</span><span class="o">::</span><span class="no">Reactor</span>

<span class="k">def</span> <span class="nf">crank_selectables</span>
  <span class="n">readers</span> <span class="o">=</span> <span class="vi">@selectables</span><span class="p">.</span><span class="nf">values</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">io</span><span class="o">|</span> <span class="n">io</span><span class="p">.</span><span class="nf">select_for_reading?</span> <span class="p">}</span>
  <span class="n">writers</span> <span class="o">=</span> <span class="vi">@selectables</span><span class="p">.</span><span class="nf">values</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">io</span><span class="o">|</span> <span class="n">io</span><span class="p">.</span><span class="nf">select_for_writing?</span> <span class="p">}</span>

  <span class="n">s</span> <span class="o">=</span> <span class="nb">select</span><span class="p">(</span><span class="n">readers</span><span class="p">,</span> <span class="n">writers</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="vi">@timer_quantum</span><span class="p">)</span>

  <span class="n">s</span> <span class="n">and</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">and</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">w</span><span class="o">|</span> <span class="n">w</span><span class="p">.</span><span class="nf">eventable_write</span> <span class="p">}</span>
  <span class="n">s</span> <span class="n">and</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">and</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">r</span><span class="o">|</span> <span class="n">r</span><span class="p">.</span><span class="nf">eventable_read</span> <span class="p">}</span>

  <span class="vi">@selectables</span><span class="p">.</span><span class="nf">delete_if</span> <span class="p">{</span><span class="o">|</span><span class="n">k</span><span class="p">,</span><span class="n">io</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">io</span><span class="p">.</span><span class="nf">close_scheduled?</span>
      <span class="n">io</span><span class="p">.</span><span class="nf">close</span>
      <span class="k">begin</span>
        <span class="no">EventMachine</span><span class="o">::</span><span class="n">event_callback</span> <span class="n">io</span><span class="p">.</span><span class="nf">uuid</span><span class="p">,</span> <span class="no">ConnectionUnbound</span><span class="p">,</span> <span class="kp">nil</span>
      <span class="k">rescue</span> <span class="no">ConnectionNotBound</span><span class="p">;</span> <span class="k">end</span>
      <span class="kp">true</span>
    <span class="k">end</span>
  <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法会在 Socket 变成可读或者可写时执行 <code class="highlighter-rouge">#eventable_write</code> 或 <code class="highlighter-rouge">#eventable_read</code> 执行事件的回调，我们暂时放下这两个方法，先来了解一下 EventMachine 是如何启动服务的。</p>

<h3 id="启动服务-1">启动服务</h3>

<p>在启动服务的过程中，最重要的目的就是创建一个 Socket 并绑定在指定的 ip 和端口上，在实现这个目的的过程中，我们使用了以下的几个方法，首先是 <code class="highlighter-rouge">EventMachine.start_server</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">eventmachine</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">516</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:EventMachine&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">start_server</span> <span class="n">server</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span>
  <span class="n">port</span> <span class="o">=</span> <span class="no">Integer</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>
  <span class="n">klass</span> <span class="o">=</span> <span class="n">klass_from_handler</span><span class="p">(</span><span class="no">Connection</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

  <span class="n">s</span> <span class="o">=</span> <span class="k">if</span> <span class="n">port</span>
        <span class="n">start_tcp_server</span> <span class="n">server</span><span class="p">,</span> <span class="n">port</span>
      <span class="k">else</span>
        <span class="n">start_unix_server</span> <span class="n">server</span>
      <span class="k">end</span>
  <span class="vi">@acceptors</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">klass</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">block</span><span class="p">]</span>
  <span class="n">s</span>
<span class="k">end</span>
</code></pre></div></div>

<p>该方法其实使我们在使用 EventMachine 时常见的接口，只要我们想要启动一个新的 TCP 或者 UNIX 服务器，就可以上述方法，在这里会根据端口号是否存在，选择执行 <code class="highlighter-rouge">.start_tcp_server</code> 或者 <code class="highlighter-rouge">.start_unix_server</code> 创建一个新的 Socket 并存储在 <code class="highlighter-rouge">@acceptors</code> 中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">184</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:EventMachine&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">start_tcp_server</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span>
  <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="no">EvmaTCPServer</span><span class="p">.</span><span class="nf">start_server</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span> <span class="n">or</span> <span class="k">raise</span> <span class="s2">"no acceptor"</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">uuid</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">EventMachine.start_tcp_server</code> 在这里也只做了个『转发』方法的作用的，直接调用 <code class="highlighter-rouge">EvmaTCPServer.start_server</code> 创建一个新的 Socket 对象并绑定到传入的 <code class="highlighter-rouge">&lt;host, port&gt;</code> 上：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">1108</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:EventMachine::EvmaTCPServer&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">start_server</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span>
  <span class="n">sd</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span> <span class="no">Socket</span><span class="o">::</span><span class="no">AF_LOCAL</span><span class="p">,</span> <span class="no">Socket</span><span class="o">::</span><span class="no">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span>
  <span class="n">sd</span><span class="p">.</span><span class="nf">setsockopt</span><span class="p">(</span> <span class="no">Socket</span><span class="o">::</span><span class="no">SOL_SOCKET</span><span class="p">,</span> <span class="no">Socket</span><span class="o">::</span><span class="no">SO_REUSEADDR</span><span class="p">,</span> <span class="kp">true</span> <span class="p">)</span>
  <span class="n">sd</span><span class="p">.</span><span class="nf">bind</span><span class="p">(</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">pack_sockaddr_in</span><span class="p">(</span> <span class="n">port</span><span class="p">,</span> <span class="n">host</span> <span class="p">))</span>
  <span class="n">sd</span><span class="p">.</span><span class="nf">listen</span><span class="p">(</span> <span class="mi">50</span> <span class="p">)</span> <span class="c1"># 5 is what you see in all the books. Ain't enough.</span>
  <span class="no">EvmaTCPServer</span><span class="p">.</span><span class="nf">new</span> <span class="n">sd</span>
<span class="k">end</span>
</code></pre></div></div>

<p>方法的最后会创建一个新的 <code class="highlighter-rouge">EvmaTCPServer</code> 实例的过程中，我们需要通过 <code class="highlighter-rouge">#fcntl</code> 将 Socket 变成非阻塞式的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">687</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">EventMachine</span><span class="o">::</span><span class="no">Selectable</span>

<span class="k">def</span> <span class="nf">initialize</span> <span class="n">io</span>
  <span class="vi">@io</span> <span class="o">=</span> <span class="n">io</span>
  <span class="vi">@uuid</span> <span class="o">=</span> <span class="no">UuidGenerator</span><span class="p">.</span><span class="nf">generate</span>
  <span class="vi">@is_server</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="vi">@last_activity</span> <span class="o">=</span> <span class="no">Reactor</span><span class="p">.</span><span class="nf">instance</span><span class="p">.</span><span class="nf">current_loop_time</span>

  <span class="n">m</span> <span class="o">=</span> <span class="vi">@io</span><span class="p">.</span><span class="nf">fcntl</span><span class="p">(</span><span class="no">Fcntl</span><span class="o">::</span><span class="no">F_GETFL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="vi">@io</span><span class="p">.</span><span class="nf">fcntl</span><span class="p">(</span><span class="no">Fcntl</span><span class="o">::</span><span class="no">F_SETFL</span><span class="p">,</span> <span class="no">Fcntl</span><span class="o">::</span><span class="no">O_NONBLOCK</span> <span class="o">|</span> <span class="n">m</span><span class="p">)</span>

  <span class="vi">@close_scheduled</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="vi">@close_requested</span> <span class="o">=</span> <span class="kp">false</span>

  <span class="n">se</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span> <span class="vi">@io</span><span class="p">.</span><span class="nf">instance_eval</span> <span class="p">{</span> <span class="vi">@my_selectable</span> <span class="o">=</span> <span class="n">se</span> <span class="p">}</span>
  <span class="no">Reactor</span><span class="p">.</span><span class="nf">instance</span><span class="p">.</span><span class="nf">add_selectable</span> <span class="vi">@io</span>
<span class="k">end</span>
</code></pre></div></div>

<p>不只是 <code class="highlighter-rouge">EvmaTCPServer</code>，所有的 <code class="highlighter-rouge">Selectable</code> 子类在初始化的最后都会将新的 Socket 以 <code class="highlighter-rouge">uuid</code> 为键存储到 <code class="highlighter-rouge">Reactor</code> 单例对象的 <code class="highlighter-rouge">@selectables</code> 字典中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">532</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">EventMachine</span><span class="o">::</span><span class="no">Reactor</span>

<span class="k">def</span> <span class="nf">add_selectable</span> <span class="n">io</span>
  <span class="vi">@selectables</span><span class="p">[</span><span class="n">io</span><span class="p">.</span><span class="nf">uuid</span><span class="p">]</span> <span class="o">=</span> <span class="n">io</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在整个事件循环的大循环中，这里存入的所有 Socket 都会被 <code class="highlighter-rouge">#select</code> 方法监听，在响应的事件发生时交给合适的回调处理，作者在 <a href="https://draveness.me/redis-eventloop">Redis 中的事件循环</a> 一文中也介绍过非常相似的处理过程。</p>

<p><img src="https://img.draveness.me/2017-11-04-eventmachine-select.png" alt="eventmachine-select" /></p>

<p>所有的 Socket 都会存储在一个 <code class="highlighter-rouge">@selectables</code> 的哈希中并由 <code class="highlighter-rouge">#select</code> 方法监听所有的读写事件，一旦相应的事件触发就会通过 <code class="highlighter-rouge">eventable_read</code> 或者 <code class="highlighter-rouge">eventable_write</code> 方法来响应该事件。</p>

<h3 id="处理读写事件">处理读写事件</h3>

<p>所有的读写事件都是通过 <code class="highlighter-rouge">Selectable</code> 和它的子类来处理的，在 EventMachine 中，总共有以下的几种子类：</p>

<p><img src="https://img.draveness.me/2017-11-04-selectable-and-subclasses.png" alt="selectable-and-subclasses" /></p>

<p>所有处理服务端读写事件的都是 <code class="highlighter-rouge">Selectable</code> 的子类，也就是 <code class="highlighter-rouge">EvmaTCPServer</code> 和 <code class="highlighter-rouge">EvmaUNIXServer</code>，而所有处理客户端读写事件的都是 <code class="highlighter-rouge">StreamObject</code> 的子类 <code class="highlighter-rouge">EvmaTCPServer</code> 和 <code class="highlighter-rouge">EvmaUNIXClient</code>。</p>

<p>当我们初始化的绑定在 <code class="highlighter-rouge">&lt;host, port&gt;</code> 上的 Socket 对象监听到了来自用户的 TCP 请求时，当前的 Socket 就会变得可读，事件循环中的 <code class="highlighter-rouge">#select</code> 方法就会调用 <code class="highlighter-rouge">EvmaTCPClient#eventable_read</code> 通知由一个请求需要处理：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">1130</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">EventMachine</span><span class="o">::</span><span class="no">EvmaTCPServer</span>

<span class="k">def</span> <span class="nf">eventable_read</span>
  <span class="k">begin</span>
    <span class="mi">10</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span>
      <span class="n">descriptor</span><span class="p">,</span> <span class="n">peername</span> <span class="o">=</span> <span class="n">io</span><span class="p">.</span><span class="nf">accept_nonblock</span>
      <span class="n">sd</span> <span class="o">=</span> <span class="no">EvmaTCPClient</span><span class="p">.</span><span class="nf">new</span> <span class="n">descriptor</span>
      <span class="n">sd</span><span class="p">.</span><span class="nf">is_server</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="no">EventMachine</span><span class="o">::</span><span class="n">event_callback</span> <span class="n">uuid</span><span class="p">,</span> <span class="no">ConnectionAccepted</span><span class="p">,</span> <span class="n">sd</span><span class="p">.</span><span class="nf">uuid</span>
    <span class="p">}</span>
  <span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">EWOULDBLOCK</span><span class="p">,</span> <span class="no">Errno</span><span class="o">::</span><span class="no">EAGAIN</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这里会尝试多次 <code class="highlighter-rouge">#accept_non_block</code> 当前的 Socket 并会创建一个 TCP 的客户端对象 <code class="highlighter-rouge">EvmaTCPClient</code>，同时通过 <code class="highlighter-rouge">.event_callback</code> 方法发送 <code class="highlighter-rouge">ConnectionAccepted</code> 消息。</p>

<p><code class="highlighter-rouge">EventMachine::event_callback</code> 就像是一个用于处理所有事件的中心方法，所有的回调都要通过这个中继器进行调度，在实现上就是一个庞大的 <code class="highlighter-rouge">if</code>、<code class="highlighter-rouge">else</code> 语句，里面处理了 EventMachine 中可能出现的 10 种状态和操作：</p>

<p><img src="https://img.draveness.me/2017-11-04-event-callback.png" alt="event-callback" /></p>

<p>大多数事件在触发时，都会从 <code class="highlighter-rouge">@conns</code> 中取出相应的 <code class="highlighter-rouge">Connection</code> 对象，最后执行合适的方法来处理，而这里触发的 <code class="highlighter-rouge">ConnectionAccepted</code> 事件是通过以下的代码来处理的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">eventmachine</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">1462</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:EventMachine&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">event_callback</span> <span class="n">conn_binding</span><span class="p">,</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">data</span>
  <span class="k">if</span> <span class="n">opcode</span> <span class="o">==</span> <span class="c1"># ...</span>
    <span class="c1"># ...</span>
  <span class="k">elsif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="no">ConnectionAccepted</span>
    <span class="n">accep</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">blk</span> <span class="o">=</span> <span class="vi">@acceptors</span><span class="p">[</span><span class="n">conn_binding</span><span class="p">]</span>
    <span class="k">raise</span> <span class="no">NoHandlerForAcceptedConnection</span> <span class="k">unless</span> <span class="n">accep</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">accep</span><span class="p">.</span><span class="nf">new</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span>
    <span class="vi">@conns</span><span class="p">[</span><span class="n">data</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
    <span class="n">blk</span> <span class="n">and</span> <span class="n">blk</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="n">c</span>
  <span class="k">else</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述的 <code class="highlighter-rouge">accep</code> 变量就是我们在 Thin 调用 <code class="highlighter-rouge">.start_server</code> 时传入的 <code class="highlighter-rouge">Connection</code> 类，在这里我们初始化了一个新的实例，同时以 Socket 的 <code class="highlighter-rouge">uuid</code> 作为键存到 <code class="highlighter-rouge">@conns</code> 中。</p>

<p>在这之后 <code class="highlighter-rouge">#select</code> 方法就会监听更多 Socket 上的事件了，当这个 “accept” 后创建的 Socket 接收到数据时，就会触发下面的 <code class="highlighter-rouge">#eventable_read</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">1130</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">EventMachine</span><span class="o">::</span><span class="no">StreamObject</span>

<span class="k">def</span> <span class="nf">eventable_read</span>
  <span class="vi">@last_activity</span> <span class="o">=</span> <span class="no">Reactor</span><span class="p">.</span><span class="nf">instance</span><span class="p">.</span><span class="nf">current_loop_time</span>
  <span class="k">begin</span>
    <span class="k">if</span> <span class="n">io</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:read_nonblock</span><span class="p">)</span>
      <span class="mi">10</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">io</span><span class="p">.</span><span class="nf">read_nonblock</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
        <span class="no">EventMachine</span><span class="o">::</span><span class="n">event_callback</span> <span class="n">uuid</span><span class="p">,</span> <span class="no">ConnectionData</span><span class="p">,</span> <span class="n">data</span>
      <span class="p">}</span>
    <span class="k">else</span>
      <span class="n">data</span> <span class="o">=</span> <span class="n">io</span><span class="p">.</span><span class="nf">sysread</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
      <span class="no">EventMachine</span><span class="o">::</span><span class="n">event_callback</span> <span class="n">uuid</span><span class="p">,</span> <span class="no">ConnectionData</span><span class="p">,</span> <span class="n">data</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">EAGAIN</span><span class="p">,</span> <span class="no">Errno</span><span class="o">::</span><span class="no">EWOULDBLOCK</span><span class="p">,</span> <span class="no">SSLConnectionWaitReadable</span>
  <span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">ECONNRESET</span><span class="p">,</span> <span class="no">Errno</span><span class="o">::</span><span class="no">ECONNREFUSED</span><span class="p">,</span> <span class="no">EOFError</span><span class="p">,</span> <span class="no">Errno</span><span class="o">::</span><span class="no">EPIPE</span><span class="p">,</span> <span class="no">OpenSSL</span><span class="o">::</span><span class="no">SSL</span><span class="o">::</span><span class="no">SSLError</span>
    <span class="vi">@close_scheduled</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="no">EventMachine</span><span class="o">::</span><span class="n">event_callback</span> <span class="n">uuid</span><span class="p">,</span> <span class="no">ConnectionUnbound</span><span class="p">,</span> <span class="kp">nil</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>方法会从 Socket 中读取数据并通过 <code class="highlighter-rouge">.event_callback</code> 发送 <code class="highlighter-rouge">ConnectionData</code> 事件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">eventmachine</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">1462</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:EventMachine&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">event_callback</span> <span class="n">conn_binding</span><span class="p">,</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">data</span>
  <span class="k">if</span> <span class="n">opcode</span> <span class="o">==</span> <span class="c1"># ...</span>
    <span class="c1"># ...</span>
  <span class="k">elsif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="no">ConnectionData</span>
    <span class="n">c</span> <span class="o">=</span> <span class="vi">@conns</span><span class="p">[</span><span class="n">conn_binding</span><span class="p">]</span> <span class="n">or</span> <span class="k">raise</span> <span class="no">ConnectionNotBound</span><span class="p">,</span> <span class="s2">"received data </span><span class="si">#{</span><span class="n">data</span><span class="si">}</span><span class="s2"> for unknown signature: </span><span class="si">#{</span><span class="n">conn_binding</span><span class="si">}</span><span class="s2">"</span>
    <span class="n">c</span><span class="p">.</span><span class="nf">receive_data</span> <span class="n">data</span>
  <span class="k">else</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>从上述方法对 <code class="highlighter-rouge">ConnectionData</code> 事件的处理就可以看到通过传入 Socket 的 <code class="highlighter-rouge">uuid</code> 和数据，就可以找到上面初始化的 <code class="highlighter-rouge">Connection</code> 对象，<code class="highlighter-rouge">#receive_data</code> 方法就能够将数据传递到上层，让用户在自定义的 <code class="highlighter-rouge">Connection</code> 中实现自己的处理逻辑，这也就是 Thin 需要覆写 <code class="highlighter-rouge">#receive_data</code> 方法来接受数据的原因了。</p>

<p>当 Thin 以及 Rack 应用已经接收到了来自用户的请求、完成处理并返回之后经过一系列复杂的调用栈就会执行 <code class="highlighter-rouge">Connection#send_data</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">connection</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">324</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">EventMachine</span><span class="o">::</span><span class="no">Connection</span>

<span class="k">def</span> <span class="nf">send_data</span> <span class="n">data</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">to_s</span>
  <span class="n">size</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">bytesize</span> <span class="k">if</span> <span class="n">data</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:bytesize</span><span class="p">)</span>
  <span class="n">size</span> <span class="o">||=</span> <span class="n">data</span><span class="p">.</span><span class="nf">size</span>
  <span class="no">EventMachine</span><span class="o">::</span><span class="n">send_data</span> <span class="vi">@signature</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span>
<span class="k">end</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">172</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:EventMachine&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">send_data</span> <span class="n">target</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">datalength</span>
  <span class="n">selectable</span> <span class="o">=</span> <span class="no">Reactor</span><span class="p">.</span><span class="nf">instance</span><span class="p">.</span><span class="nf">get_selectable</span><span class="p">(</span> <span class="n">target</span> <span class="p">)</span> <span class="n">or</span> <span class="k">raise</span> <span class="s2">"unknown send_data target"</span>
  <span class="n">selectable</span><span class="p">.</span><span class="nf">send_data</span> <span class="n">data</span>
<span class="k">end</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">851</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">EventMachine</span><span class="o">::</span><span class="no">StreamObject</span>

<span class="k">def</span> <span class="nf">send_data</span> <span class="n">data</span>
  <span class="k">unless</span> <span class="vi">@close_scheduled</span> <span class="n">or</span> <span class="vi">@close_requested</span> <span class="n">or</span> <span class="o">!</span><span class="n">data</span> <span class="n">or</span> <span class="n">data</span><span class="p">.</span><span class="nf">length</span> <span class="o">&lt;=</span> <span class="mi">0</span>
    <span class="vi">@outbound_q</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">.</span><span class="nf">to_s</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>经过一系列同名方法的调用，在调用栈末尾的 <code class="highlighter-rouge">StreamObject#send_data</code> 中，将所有需要写入的数据全部加入 <code class="highlighter-rouge">@outbound_q</code> 中，这其实就是一个待写入数据的队列。</p>

<p>当 Socket 变得可写之后，就会由 <code class="highlighter-rouge">#select</code> 方法触发 <code class="highlighter-rouge">#eventable_write</code> 将 <code class="highlighter-rouge">@outbound_q</code> 队列中的数据通过 <code class="highlighter-rouge">#write_nonblock</code> 或者 <code class="highlighter-rouge">syswrite</code> 写入 Socket，也就是将请求返回给客户端。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">823</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">EventMachine</span><span class="o">::</span><span class="no">StreamObject</span>

<span class="k">def</span> <span class="nf">eventable_write</span>
  <span class="vi">@last_activity</span> <span class="o">=</span> <span class="no">Reactor</span><span class="p">.</span><span class="nf">instance</span><span class="p">.</span><span class="nf">current_loop_time</span>
  <span class="k">while</span> <span class="n">data</span> <span class="o">=</span> <span class="vi">@outbound_q</span><span class="p">.</span><span class="nf">shift</span> <span class="k">do</span>
    <span class="k">begin</span>
      <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">to_s</span>
      <span class="n">w</span> <span class="o">=</span> <span class="k">if</span> <span class="n">io</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:write_nonblock</span><span class="p">)</span>
            <span class="n">io</span><span class="p">.</span><span class="nf">write_nonblock</span> <span class="n">data</span>
          <span class="k">else</span>
            <span class="n">io</span><span class="p">.</span><span class="nf">syswrite</span> <span class="n">data</span>
          <span class="k">end</span>

      <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">.</span><span class="nf">length</span>
        <span class="vi">@outbound_q</span><span class="p">.</span><span class="nf">unshift</span> <span class="n">data</span><span class="p">[</span><span class="n">w</span><span class="o">..-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">break</span>
      <span class="k">end</span>
    <span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">EAGAIN</span><span class="p">,</span> <span class="no">SSLConnectionWaitReadable</span><span class="p">,</span> <span class="no">SSLConnectionWaitWritable</span>
      <span class="vi">@outbound_q</span><span class="p">.</span><span class="nf">unshift</span> <span class="n">data</span>
      <span class="k">break</span>
    <span class="k">rescue</span> <span class="no">EOFError</span><span class="p">,</span> <span class="no">Errno</span><span class="o">::</span><span class="no">ECONNRESET</span><span class="p">,</span> <span class="no">Errno</span><span class="o">::</span><span class="no">ECONNREFUSED</span><span class="p">,</span> <span class="no">Errno</span><span class="o">::</span><span class="no">EPIPE</span><span class="p">,</span> <span class="no">OpenSSL</span><span class="o">::</span><span class="no">SSL</span><span class="o">::</span><span class="no">SSLError</span>
      <span class="vi">@close_scheduled</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="vi">@outbound_q</span><span class="p">.</span><span class="nf">clear</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="关闭-socket">关闭 Socket</h3>

<p>当数据写入时发生了 <code class="highlighter-rouge">EOFError</code> 或者其他错误时就会将 <code class="highlighter-rouge">close_scheduled</code> 标记为 <code class="highlighter-rouge">true</code>，在随后的事件循环中会关闭 Socket 并发送 <code class="highlighter-rouge">ConnectionUnbound</code> 事件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">540</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">EventMachine</span><span class="o">::</span><span class="no">Reactor</span>

<span class="k">def</span> <span class="nf">crank_selectables</span>
  <span class="c1"># ...</span>

  <span class="vi">@selectables</span><span class="p">.</span><span class="nf">delete_if</span> <span class="p">{</span><span class="o">|</span><span class="n">k</span><span class="p">,</span><span class="n">io</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">io</span><span class="p">.</span><span class="nf">close_scheduled?</span>
      <span class="n">io</span><span class="p">.</span><span class="nf">close</span>
      <span class="k">begin</span>
        <span class="no">EventMachine</span><span class="o">::</span><span class="n">event_callback</span> <span class="n">io</span><span class="p">.</span><span class="nf">uuid</span><span class="p">,</span> <span class="no">ConnectionUnbound</span><span class="p">,</span> <span class="kp">nil</span>
      <span class="k">rescue</span> <span class="no">ConnectionNotBound</span><span class="p">;</span> <span class="k">end</span>
      <span class="kp">true</span>
    <span class="k">end</span>
  <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">.event_callback</code> 在处理 <code class="highlighter-rouge">ConnectionUnbound</code> 事件时会在 <code class="highlighter-rouge">@conns</code> 中将结束的 <code class="highlighter-rouge">Connection</code> 剔除：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">event_callback</span> <span class="n">conn_binding</span><span class="p">,</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">data</span>
  <span class="k">if</span> <span class="n">opcode</span> <span class="o">==</span> <span class="no">ConnectionUnbound</span>
    <span class="k">if</span> <span class="n">c</span> <span class="o">=</span> <span class="vi">@conns</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span> <span class="n">conn_binding</span> <span class="p">)</span>
      <span class="n">c</span><span class="p">.</span><span class="nf">unbind</span>
      <span class="n">io</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="nf">instance_variable_get</span><span class="p">(</span><span class="ss">:@io</span><span class="p">)</span>
      <span class="k">begin</span>
        <span class="n">io</span><span class="p">.</span><span class="nf">close</span>
      <span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">EBADF</span><span class="p">,</span> <span class="no">IOError</span>
      <span class="k">end</span>
    <span class="k">elsif</span> <span class="n">c</span> <span class="o">=</span> <span class="vi">@acceptors</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span> <span class="n">conn_binding</span> <span class="p">)</span>
    <span class="k">else</span>
      <span class="k">raise</span> <span class="no">ConnectionNotBound</span><span class="p">,</span> <span class="s2">"received ConnectionUnbound for an unknown signature: </span><span class="si">#{</span><span class="n">conn_binding</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>
  <span class="k">elsif</span> <span class="n">opcode</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1">#...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这之后会调用 <code class="highlighter-rouge">Connection</code> 的 <code class="highlighter-rouge">#unbind</code> 方法，再次执行 <code class="highlighter-rouge">#close</code> 确保 Socket 连接已经断掉了。</p>

<h3 id="小结-1">小结</h3>

<p>EventMachine 在处理用户的请求时，会通过一个事件循环和一个中心化的事件处理中心 <code class="highlighter-rouge">.event_callback</code> 来响应所有的事件，你可以看到在使用 EventMachine 时所有的响应都是异步的，尤其是对 Socket 的读写，所有外部的输入在 EventMachine 看来都是一个事件，它们会被 EventMachine 选择合适的处理器进行转发。</p>

<h2 id="io-模型">I/O 模型</h2>

<p>Thin 本身其实没有实现任何的 I/O 模型，它通过对 EventMachine 进行封装，使用了其事件驱动的特点，为上层提供了处理并发 I/O 的 Reactor 模型，在不同的阶段有着不同的工作流程，在启动 Thin 的服务时，Thin 会直接通过 <code class="highlighter-rouge">.start_server</code> 创建一个 Socket 监听一个 <code class="highlighter-rouge">&lt;host, port&gt;</code> 组成的元组：</p>

<p><img src="https://img.draveness.me/2017-11-04-thin-start-server.png" alt="thin-start-server" /></p>

<p>当服务启动之后，就可以接受来自客户端的 HTTP 请求了，处理 HTTP 请求总共需要三个模块的合作，分别是 EventMachine、Thin 以及 Rack 应用：</p>

<p><img src="https://img.draveness.me/2017-11-04-thin-handle-request.png" alt="thin-handle-request" /></p>

<p>在上图中省略了 Rack 的处理部分，不过对于其他部分的展示还是比较详细的，EventMachine 负责对 TCP Socket 进行监听，在发生事件时通过 <code class="highlighter-rouge">.event_callback</code> 进行处理，将消息转发给位于 Thin 中的 <code class="highlighter-rouge">Connection</code>，该类以及模块负责处理 HTTP 协议相关的内容，将整个请求包装成一个 <code class="highlighter-rouge">env</code> 对象，调用 <code class="highlighter-rouge">#call</code> 方法。</p>

<p>在这时就开始了返回响应的逻辑了，<code class="highlighter-rouge">#call</code> 方法会返回一个三元组，经过 Thin 中的 <code class="highlighter-rouge">#send_data</code> 最终将数据写入 <code class="highlighter-rouge">outbound_q</code> 队列中等待处理：</p>

<p><img src="https://img.draveness.me/2017-11-04-thin-send-response.png" alt="thin-send-response" /></p>

<p>EventMachine 会通过一个事件循环，使用 <code class="highlighter-rouge">#select</code> 监听当前 Socket 的可读写状态，并在合适的时候触发 <code class="highlighter-rouge">#eventable_write</code> 从 <code class="highlighter-rouge">outbound_q</code> 队列中读取数据写入 Socket，在写入结束后 Socket 就会被关闭，整个请求的响应也就结束了。</p>

<p><img src="https://img.draveness.me/2017-11-04-thin-io-model.png" alt="thin-io-model" /></p>

<p>Thin 使用了 EventMachine 作为底层处理 TCP 协议的框架，提供了事件驱动的 I/O 模型，也就是我们理解的 Reactor 模型，对于每一个 HTTP 请求都会创建一个对应的 <code class="highlighter-rouge">Connection</code> 对象，所有的事件都由 EventMachine 来派发，最大程度做到了 I/O 的读写都是异步的，不会阻塞当前的线程，这也是 Thin 以及 Node.js 能够并发处理大量请求的原因。</p>

<h2 id="总结">总结</h2>

<p>Thin 作为一个 Ruby 社区中简单的 webserver，其实本身没有做太多的事情，只是使用了 EventMachine 提供的事件驱动的 I/O 模型，为上层提供了更加易用的 API，相比于其他同步处理请求的 webserver，Reactor 模式的优点就是 Thin 的优点，主程序只负责监听事件和分发事件，一旦涉及到 I/O 的工作都尽量使用回调的方式处理，当回调完成后再发送通知，这种方式能够减少进程的等待时间，时刻都在处理用户的请求和事件。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://zedshaw.com/archive/ragel-state-charts/">Ragel State Charts</a></li>
  <li><a href="http://www.colm.net/open-source/ragel/">Ragel State Machine Compiler</a></li>
  <li><a href="https://www.igvita.com/2008/05/27/ruby-eventmachine-the-speed-demon/">Ruby EventMachine - The Speed Demon</a></li>
</ul>



        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
            
                
            
                
            
                
            
                
            

            <!-- Add Disqus Comments -->
            

        </footer>

    </article>

</main>
<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story no-cover" href="/blogs/rack-unicorn">
            <section class="post">
                <h2>浅谈 Unicorn 的多进程模型</h2>
                <p>+ [谈谈 Rack 协议与实现](https://draveness.me/rack) + [浅谈 WEBrick 的多线程模型](https://draveness.me/rack-webrick) + [浅谈 Thin 的事件驱动模型](https://draveness.me/rack-thin) + [浅谈 Unicorn...</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev no-cover" href="/blogs/rack-webrick">
            <section class="post">
                <h2>浅谈 WEBrick 的多线程模型</h2>
                <p>谈谈 Rack 协议与实现 浅谈 WEBrick 的多线程模型 浅谈 Thin 的事件驱动模型 浅谈 Unicorn 的多进程模型 浅谈 Puma 的并发模型与实现...</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/blogs/">Brightness</a> &copy; 2018</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-69281367-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/blogs/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/blogs/assets/js/index.js"></script>

</body>
</html>
