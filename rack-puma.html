<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>浅谈 Puma 的并发模型与实现</title>
    <meta name="description" content="A beautiful narrative written with the world's most elegant publishing platform. The story begins here." />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/blogs/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/blogs/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/blogs/assets/css/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="/blogs//rack-puma" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/blogs/page2/" />

    <meta property="og:site_name" content="Brightness" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="浅谈 Puma 的并发模型与实现" />
    <meta property="og:description" content="A beautiful narrative written with the world's most elegant publishing platform. The story begins here." />
    <meta property="og:url" content="/blogs//rack-puma" />
    <meta property="og:image" content="/blogs/assets/images/cover1.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="浅谈 Puma 的并发模型与实现" />
    <meta name="twitter:description" content="A beautiful narrative written with the world's most elegant publishing platform. The story begins here." />
    <meta name="twitter:url" content="/blogs//rack-puma" />
    <meta name="twitter:image:src" content="/blogs/assets/images/cover1.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "Brightness",
    "name": "浅谈 Puma 的并发模型与实现",
    "url": "/blogs//rack-puma",
    "image": "/blogs/assets/images/cover1.jpg",
    "description": "A beautiful narrative written with the world's most elegant publishing platform. The story begins here."
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="Brightness" href="/blogs/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/blogs/">Home</a></li>
        <li class="nav-about " role="presentation"><a href="/blogs/about">About</a></li>
        <li class="nav-fables " role="presentation"><a href="/blogs/tag/fables">Fables</a></li>
        <li class="nav-speeches " role="presentation"><a href="/blogs/tag/speeches">Speeches</a></li>
        <li class="nav-fiction " role="presentation"><a href="/blogs/tag/fiction">Fiction</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/casper">Casper</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/edgar">Edgar</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/abraham">Abraham</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/martin">Martin</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/lewis">Lewis</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/blogs/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        
        
    </nav>
</header>

<main class="content" role="main">

    <article class="">

        <header class="post-header">
            <h1 class="post-title">浅谈 Puma 的并发模型与实现</h1>
            <section class="post-meta">
            <!-- <a href='/blogs/'></a> -->

            
                
            
                
            
                
            
                
            
                
            
            <time class="post-date" datetime="2017-11-10">10 Nov 2017</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/blogs/tag/Rack系列'>Rack系列</a>,
                    
                
                    
                       <a href='/blogs/tag/Puma'>Puma</a>,
                    
                
                    
                       <a href='/blogs/tag/rack'>Rack</a>,
                    
                
                    
                       <a href='/blogs/tag/ruby'>Ruby</a>,
                    
                
                    
                       <a href='/blogs/tag/server'>Server</a>
                    
                
                
            </section>
        </header>

        <section class="post-content">

            <ul>
  <li><a href="https://draveness.me/rack">谈谈 Rack 协议与实现</a></li>
  <li><a href="https://draveness.me/rack-webrick">浅谈 WEBrick 的多线程模型</a></li>
  <li><a href="https://draveness.me/rack-thin">浅谈 Thin 的事件驱动模型</a></li>
  <li><a href="https://draveness.me/rack-unicorn">浅谈 Unicorn 的多进程模型</a></li>
  <li><a href="https://draveness.me/rack-puma">浅谈 Puma 的并发模型与实现</a></li>
  <li><a href="https://draveness.me/ruby-webserver">Ruby Web 服务器的并发模型与性能</a></li>
</ul>

<p>这篇文章已经是整个 Rack 系列文章的第五篇了，在前面的文章中我们见到了多线程模型、多进程模型以及事件驱动的 I/O 模型，对于几种常见的 webserver 已经很了解了，其实无论是 Ruby 还是其他社区对于 webserver 的实现也就是这么几种方式：多线程、多线程和 Reactor。</p>

<p><img src="https://img.draveness.me/2017-11-10-puma-logo.png" alt="puma-logo" /></p>

<p>在这篇文章中要介绍的 Puma 只是混合了两种 I/O 模型，同时使用多进程和多线程来提高应用的并行能力。</p>

<blockquote>
  <p>文中使用的 Puma 版本是 v3.10.0，如果你使用了不同版本的 Puma，原理上的区别不会太大，只是在一些方法的实现上会有一些细微的不同。</p>
</blockquote>

<h2 id="rack-默认处理器">Rack 默认处理器</h2>

<p>Puma 是目前 Rack 中优先级最高的默认 webserver，如果直接使用 <code class="highlighter-rouge">rackup</code> 命令并且当前机器上安装了 <code class="highlighter-rouge">puma</code>，那么 Rack 会自动选择 Puma 作为当前处理 HTTP 请求的服务器：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">default</span>
  <span class="n">pick</span> <span class="p">[</span><span class="s1">'puma'</span><span class="p">,</span> <span class="s1">'thin'</span><span class="p">,</span> <span class="s1">'webrick'</span><span class="p">]</span>
<span class="k">end</span>

<span class="err">$</span> <span class="n">rackup</span>
<span class="no">Puma</span> <span class="n">starting</span> <span class="k">in</span> <span class="n">single</span> <span class="n">mode</span><span class="o">...</span>
<span class="o">*</span> <span class="no">Version</span> <span class="mf">3.10</span><span class="o">.</span><span class="mi">0</span> <span class="p">(</span><span class="n">ruby</span> <span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span><span class="o">-</span><span class="n">p222</span><span class="p">),</span> <span class="ss">codename: </span><span class="no">Russell</span><span class="err">'</span><span class="n">s</span> <span class="no">Teapot</span>
<span class="o">*</span> <span class="no">Min</span> <span class="ss">threads: </span><span class="mi">0</span><span class="p">,</span> <span class="n">max</span> <span class="ss">threads: </span><span class="mi">16</span>
<span class="o">*</span> <span class="no">Environment</span><span class="p">:</span> <span class="n">development</span>
<span class="o">*</span> <span class="no">Listening</span> <span class="n">on</span> <span class="n">tcp</span><span class="ss">:/</span><span class="o">/</span><span class="n">localhost</span><span class="p">:</span><span class="mi">9292</span>
<span class="no">Use</span> <span class="no">Ctrl</span><span class="o">-</span><span class="no">C</span> <span class="n">to</span> <span class="n">stop</span>
</code></pre></div></div>

<p>通过在 <code class="highlighter-rouge">Rack::Handler</code> 下创建一个新的 <code class="highlighter-rouge">module Puma</code> 再实现类方法 <code class="highlighter-rouge">.run</code>，我们就可以直接将启动的过程转交给 <code class="highlighter-rouge">Puma::Launcher</code> 处理：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Rack</span>
  <span class="k">module</span> <span class="nn">Handler</span>
    <span class="k">module</span> <span class="nn">Puma</span>
      <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">run</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
        <span class="n">conf</span>   <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">config</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">options</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="ss">:Silent</span><span class="p">)</span> <span class="p">?</span> <span class="o">::</span><span class="no">Puma</span><span class="o">::</span><span class="no">Events</span><span class="p">.</span><span class="nf">strings</span> <span class="p">:</span> <span class="o">::</span><span class="no">Puma</span><span class="o">::</span><span class="no">Events</span><span class="p">.</span><span class="nf">stdio</span>
        <span class="n">launcher</span> <span class="o">=</span> <span class="o">::</span><span class="no">Puma</span><span class="o">::</span><span class="no">Launcher</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="ss">:events</span> <span class="o">=&gt;</span> <span class="n">events</span><span class="p">)</span>

        <span class="k">yield</span> <span class="n">launcher</span> <span class="k">if</span> <span class="nb">block_given?</span>
        <span class="k">begin</span>
          <span class="n">launcher</span><span class="p">.</span><span class="nf">run</span>
        <span class="k">rescue</span> <span class="no">Interrupt</span>
          <span class="nb">puts</span> <span class="s2">"* Gracefully stopping, waiting for requests to finish"</span>
          <span class="n">launcher</span><span class="p">.</span><span class="nf">stop</span>
          <span class="nb">puts</span> <span class="s2">"* Goodbye!"</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="启动器-launcher">启动器 Launcher</h2>

<p>Puma 中的启动器确实没有做太多的工作，大部分的代码其实都是在做配置，从 <code class="highlighter-rouge">ENV</code> 和上下文的环境中读取参数，而整个初始化方法中需要注意的地方也只有不同 <code class="highlighter-rouge">@runner</code> 的初始化了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">launcher</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">44</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Launcher</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">launcher_args</span><span class="o">=</span><span class="p">{})</span>
  <span class="vi">@runner</span>        <span class="o">=</span> <span class="kp">nil</span>
  <span class="vi">@events</span>        <span class="o">=</span> <span class="n">launcher_args</span><span class="p">[</span><span class="ss">:events</span><span class="p">]</span> <span class="o">||</span> <span class="no">Events</span><span class="o">::</span><span class="no">DEFAULT</span>
  <span class="vi">@argv</span>          <span class="o">=</span> <span class="n">launcher_args</span><span class="p">[</span><span class="ss">:argv</span><span class="p">]</span> <span class="o">||</span> <span class="p">[]</span>
  <span class="vi">@config</span>        <span class="o">=</span> <span class="n">conf</span>
  <span class="vi">@config</span><span class="p">.</span><span class="nf">load</span>

  <span class="no">Dir</span><span class="p">.</span><span class="nf">chdir</span><span class="p">(</span><span class="vi">@restart_dir</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">clustered?</span>
    <span class="vi">@events</span><span class="p">.</span><span class="nf">formatter</span> <span class="o">=</span> <span class="no">Events</span><span class="o">::</span><span class="no">PidFormatter</span><span class="p">.</span><span class="nf">new</span>
    <span class="vi">@options</span><span class="p">[</span><span class="ss">:logger</span><span class="p">]</span> <span class="o">=</span> <span class="vi">@events</span>

    <span class="vi">@runner</span> <span class="o">=</span> <span class="no">Cluster</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="vi">@events</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="vi">@runner</span> <span class="o">=</span> <span class="no">Single</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="vi">@events</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="vi">@status</span> <span class="o">=</span> <span class="ss">:run</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">#initialize</code> 方法中，<code class="highlighter-rouge">@runner</code> 的初始化是根据当前配置中的 worker 数决定的，如果当前的 <code class="highlighter-rouge">worker &gt; 0</code>，那么就会选择 <code class="highlighter-rouge">Cluster</code> 作为 <code class="highlighter-rouge">@runner</code>，否则就会选择 <code class="highlighter-rouge">Single</code>，在初始化结束之后会执行 <code class="highlighter-rouge">Launcher#run</code> 方法启动当前的 Puma 进程：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">launcher</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">165</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Launcher</span>

<span class="k">def</span> <span class="nf">run</span>
  <span class="n">previous_env</span> <span class="o">=</span> <span class="no">ENV</span><span class="p">.</span><span class="nf">to_h</span>

  <span class="n">setup_signals</span>
  <span class="vi">@runner</span><span class="p">.</span><span class="nf">run</span>

  <span class="k">case</span> <span class="vi">@status</span>
  <span class="k">when</span> <span class="ss">:halt</span>
    <span class="n">log</span> <span class="s2">"* Stopping immediately!"</span>
  <span class="k">when</span> <span class="ss">:run</span><span class="p">,</span> <span class="ss">:stop</span>
    <span class="n">graceful_stop</span>
  <span class="k">when</span> <span class="ss">:restart</span>
    <span class="n">log</span> <span class="s2">"* Restarting..."</span>
    <span class="no">ENV</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="n">previous_env</span><span class="p">)</span>
    <span class="vi">@runner</span><span class="p">.</span><span class="nf">before_restart</span>
    <span class="n">restart!</span>
  <span class="k">when</span> <span class="ss">:exit</span>
    <span class="c1"># nothing</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个简单的 <code class="highlighter-rouge">#run</code> 方法中，Puma 通过 <code class="highlighter-rouge">#setup_singals</code> 设置了一些信号的响应过程，在这之后执行 <code class="highlighter-rouge">Runner#run</code> 启动 Puma 的服务。</p>

<h2 id="启动服务">启动服务</h2>

<p>根据配置文件中不同的配置项，Puma 在启动时有两种不同的选择，一种是当前的 worker 数为 0，这时会通过 <code class="highlighter-rouge">Single</code> 启动单机模式的 Puma 进程，另一种情况是 worker 数大于 0，它使用 <code class="highlighter-rouge">Cluster</code> 的 runner 启动一组 Puma 进程。</p>

<p><img src="https://img.draveness.me/2017-11-10-single-cluster.png" alt="single-cluster" /></p>

<p>在这一节中文章将会简单介绍不同的 runner 是如何启动 Puma 进程的。</p>

<h3 id="单机模式">单机模式</h3>

<p>Puma 单机模式的启动通过 <code class="highlighter-rouge">Single</code> 类来处理，而定义这个类的文件 single.rb 中其实并没有多少代码，我们从中就可以看到单机模式下 Puma 的启动其实并不复杂：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">single</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">40</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Single</span>

<span class="k">def</span> <span class="nf">run</span>
  <span class="n">output_header</span> <span class="s2">"single"</span>

  <span class="k">if</span> <span class="n">daemon?</span>
    <span class="n">log</span> <span class="s2">"* Daemonizing..."</span>
    <span class="no">Process</span><span class="p">.</span><span class="nf">daemon</span><span class="p">(</span><span class="kp">true</span><span class="p">)</span>
    <span class="n">redirect_io</span>
  <span class="k">end</span>

  <span class="n">load_and_bind</span>
  <span class="vi">@launcher</span><span class="p">.</span><span class="nf">write_state</span>
  <span class="vi">@server</span> <span class="o">=</span> <span class="n">server</span> <span class="o">=</span> <span class="n">start_server</span>

  <span class="k">begin</span>
    <span class="n">server</span><span class="p">.</span><span class="nf">run</span><span class="p">.</span><span class="nf">join</span>
  <span class="k">rescue</span> <span class="no">Interrupt</span>
    <span class="c1"># Swallow it</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果我们启动了后台模式，就会通过 Puma 为 Process 模块扩展的方法 <code class="highlighter-rouge">.daemon</code> 在后台启动新的 Puma 进程，启动的过程其实和 Unicorn 中的差不多：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">daemon_ext</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">12</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Process&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">daemon</span><span class="p">(</span><span class="n">nochdir</span><span class="o">=</span><span class="kp">false</span><span class="p">,</span> <span class="n">noclose</span><span class="o">=</span><span class="kp">false</span><span class="p">)</span>
  <span class="nb">exit</span> <span class="k">if</span> <span class="nb">fork</span>
  <span class="no">Process</span><span class="p">.</span><span class="nf">setsid</span>
  <span class="nb">exit</span> <span class="k">if</span> <span class="nb">fork</span>

  <span class="no">Dir</span><span class="p">.</span><span class="nf">chdir</span> <span class="s2">"/"</span> <span class="k">unless</span> <span class="n">nochdir</span>

  <span class="k">if</span> <span class="o">!</span><span class="n">noclose</span>
    <span class="no">STDIN</span><span class="p">.</span><span class="nf">reopen</span> <span class="no">File</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="s2">"/dev/null"</span><span class="p">,</span> <span class="s2">"r"</span><span class="p">)</span>
    <span class="n">null_out</span> <span class="o">=</span> <span class="no">File</span><span class="p">.</span><span class="nf">open</span> <span class="s2">"/dev/null"</span><span class="p">,</span> <span class="s2">"w"</span>
    <span class="no">STDOUT</span><span class="p">.</span><span class="nf">reopen</span> <span class="n">null_out</span>
    <span class="no">STDERR</span><span class="p">.</span><span class="nf">reopen</span> <span class="n">null_out</span>
  <span class="k">end</span>

  <span class="mi">0</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 Puma 中通过两次 <code class="highlighter-rouge">fork</code> 同时将当前进程从终端中分离出来，最终就可以得到一个独立的 Puma 进程，你可以通过下面的图片简单理解这个过程：</p>

<p><img src="https://img.draveness.me/2017-11-10-puma-daemonize.png" alt="puma-daemonize" /></p>

<p>当我们在后台启动了一个 Puma 的 master 进程之后就可以开始启动 Puma 的服务器了，也就是 <code class="highlighter-rouge">Puma::Server</code> 的实例：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">runner</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">151</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Runner</span>

<span class="k">def</span> <span class="nf">start_server</span>
  <span class="n">min_t</span> <span class="o">=</span> <span class="vi">@options</span><span class="p">[</span><span class="ss">:min_threads</span><span class="p">]</span>
  <span class="n">max_t</span> <span class="o">=</span> <span class="vi">@options</span><span class="p">[</span><span class="ss">:max_threads</span><span class="p">]</span>

  <span class="n">server</span> <span class="o">=</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Server</span><span class="p">.</span><span class="nf">new</span> <span class="n">app</span><span class="p">,</span> <span class="vi">@launcher</span><span class="p">.</span><span class="nf">events</span><span class="p">,</span> <span class="vi">@options</span>
  <span class="n">server</span><span class="p">.</span><span class="nf">min_threads</span> <span class="o">=</span> <span class="n">min_t</span>
  <span class="n">server</span><span class="p">.</span><span class="nf">max_threads</span> <span class="o">=</span> <span class="n">max_t</span>
  <span class="n">server</span><span class="p">.</span><span class="nf">inherit_binder</span> <span class="vi">@launcher</span><span class="p">.</span><span class="nf">binder</span>

  <span class="k">if</span> <span class="vi">@options</span><span class="p">[</span><span class="ss">:mode</span><span class="p">]</span> <span class="o">==</span> <span class="ss">:tcp</span>
    <span class="n">server</span><span class="p">.</span><span class="nf">tcp_mode!</span>
  <span class="k">end</span>

  <span class="k">unless</span> <span class="n">development?</span>
    <span class="n">server</span><span class="p">.</span><span class="nf">leak_stack_on_error</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="k">end</span>

  <span class="n">server</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这里有很多不是特别重要的代码，需要注意的是 <code class="highlighter-rouge">Server</code> 初始化的过程以及最大、最小线程数的设置，这些信息都是通过命令行或者配置文件传入的，例如 <code class="highlighter-rouge">puma -t 8:32</code> 表示当前的最小线程数为 8、最大线程数为 32 个，Puma 会根据当前的流量自动调节同一个进程中的线程个数。</p>

<p>服务在启动时会创建一个线程池 <code class="highlighter-rouge">ThreadPool</code> 并传入一个用于处理请求的 block，这个方法的实现其实非常长，这里省略了很多代码；</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">255</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">background</span><span class="o">=</span><span class="kp">true</span><span class="p">)</span>
  <span class="n">queue_requests</span> <span class="o">=</span> <span class="vi">@queue_requests</span>

  <span class="vi">@thread_pool</span> <span class="o">=</span> <span class="no">ThreadPool</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@min_threads</span><span class="p">,</span>
                                <span class="vi">@max_threads</span><span class="p">,</span>
                                <span class="no">IOBuffer</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">client</span><span class="p">,</span> <span class="n">buffer</span><span class="o">|</span>
    <span class="n">process_now</span> <span class="o">=</span> <span class="kp">false</span>

    <span class="k">begin</span>
      <span class="k">if</span> <span class="n">queue_requests</span>
        <span class="n">process_now</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">eagerly_finish</span>
      <span class="k">else</span>
        <span class="n">client</span><span class="p">.</span><span class="nf">finish</span>
        <span class="n">process_now</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="k">end</span>
    <span class="k">rescue</span> <span class="no">MiniSSL</span><span class="o">::</span><span class="no">SSLError</span><span class="p">,</span> <span class="no">HttpParserError</span> <span class="o">=&gt;</span> <span class="n">e</span>
      <span class="c1"># ...</span>
    <span class="k">rescue</span> <span class="no">ConnectionError</span>
      <span class="n">client</span><span class="p">.</span><span class="nf">close</span>
    <span class="k">else</span>
      <span class="k">if</span> <span class="n">process_now</span>
        <span class="n">process_client</span> <span class="n">client</span><span class="p">,</span> <span class="n">buffer</span>
      <span class="k">else</span>
        <span class="n">client</span><span class="p">.</span><span class="nf">set_timeout</span> <span class="vi">@first_data_timeout</span>
        <span class="vi">@reactor</span><span class="p">.</span><span class="nf">add</span> <span class="n">client</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">if</span> <span class="n">queue_requests</span>
    <span class="vi">@reactor</span> <span class="o">=</span> <span class="no">Reactor</span><span class="p">.</span><span class="nf">new</span> <span class="nb">self</span><span class="p">,</span> <span class="vi">@thread_pool</span>
    <span class="vi">@reactor</span><span class="p">.</span><span class="nf">run_in_thread</span>
  <span class="k">end</span>

  <span class="vi">@thread</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="n">handle_servers</span> <span class="p">}</span>
  <span class="vi">@thread</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述代码创建了一个新的 <code class="highlighter-rouge">Reactor</code> 对象并在一个新的线程中执行 <code class="highlighter-rouge">#handle_servers</code> 接受客户端的请求，文章会在后面介绍请求的处理。</p>

<h3 id="集群模式">集群模式</h3>

<p>如果在启动 puma 进程时使用 <code class="highlighter-rouge">-w</code> 参数，例如下面的命令：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>puma <span class="nt">-w</span> 3
<span class="o">[</span>20904] Puma starting <span class="k">in </span>cluster mode...
<span class="o">[</span>20904] <span class="k">*</span> Version 3.10.0 <span class="o">(</span>ruby 2.3.3-p222<span class="o">)</span>, codename: Russell<span class="s1">'s Teapot
[20904] * Min threads: 0, max threads: 16
[20904] * Environment: development
[20904] * Process workers: 3
[20904] * Phased restart available
[20904] * Listening on tcp://0.0.0.0:9292
[20904] Use Ctrl-C to stop
[20904] - Worker 2 (pid: 20907) booted, phase: 0
[20904] - Worker 1 (pid: 20906) booted, phase: 0
[20904] - Worker 0 (pid: 20905) booted, phase: 0

$ ps aux | grep puma
draveness        20909   0.0  0.0  4296440    952 s001  S+   10:23AM   0:00.01 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn puma
draveness        20907   0.0  0.1  4358888  12128 s003  S+   10:23AM   0:00.07 puma: cluster worker 2: 20904 [Desktop]
draveness        20906   0.0  0.1  4358888  12148 s003  S+   10:23AM   0:00.07 puma: cluster worker 1: 20904 [Desktop]
draveness        20905   0.0  0.1  4358888  12196 s003  S+   10:23AM   0:00.07 puma: cluster worker 0: 20904 [Desktop]
draveness        20904   0.0  0.2  4346784  25632 s003  S+   10:23AM   0:00.67 puma 3.10.0 (tcp://0.0.0.0:9292) [Desktop]
</span></code></pre></div></div>

<p>上述命令就会启动一个 Puma 的 master 进程和三个 worker 进程，Puma 集群模式就是通过 <code class="highlighter-rouge">Puma::Cluster</code> 类来启动的，而启动集群的方法 <code class="highlighter-rouge">#run</code> 仍然是一个非常长的方法，在这里仍然省去了很多的代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">cluster</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">386</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Cluster</span>

<span class="k">def</span> <span class="nf">run</span>
  <span class="vi">@status</span> <span class="o">=</span> <span class="ss">:run</span>

  <span class="n">output_header</span> <span class="s2">"cluster"</span>
  <span class="n">log</span> <span class="s2">"* Process workers: </span><span class="si">#{</span><span class="vi">@options</span><span class="p">[</span><span class="ss">:workers</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span>

  <span class="n">read</span><span class="p">,</span> <span class="vi">@wakeup</span> <span class="o">=</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Util</span><span class="p">.</span><span class="nf">pipe</span>

  <span class="no">Process</span><span class="p">.</span><span class="nf">daemon</span><span class="p">(</span><span class="kp">true</span><span class="p">)</span>
  <span class="n">spawn_workers</span>

  <span class="k">begin</span>
    <span class="k">while</span> <span class="vi">@status</span> <span class="o">==</span> <span class="ss">:run</span>
      <span class="k">begin</span>
        <span class="n">res</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">select</span><span class="p">([</span><span class="n">read</span><span class="p">],</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="no">WORKER_CHECK_INTERVAL</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">res</span>
          <span class="n">req</span> <span class="o">=</span> <span class="n">read</span><span class="p">.</span><span class="nf">read_nonblock</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
          <span class="n">result</span> <span class="o">=</span> <span class="n">read</span><span class="p">.</span><span class="nf">gets</span>
          <span class="n">pid</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="nf">to_i</span>

          <span class="k">if</span> <span class="n">w</span> <span class="o">=</span> <span class="vi">@workers</span><span class="p">.</span><span class="nf">find</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="p">.</span><span class="nf">pid</span> <span class="o">==</span> <span class="n">pid</span> <span class="p">}</span>
            <span class="k">case</span> <span class="n">req</span>
            <span class="k">when</span> <span class="s2">"b"</span>
              <span class="n">w</span><span class="p">.</span><span class="nf">boot!</span>
            <span class="k">when</span> <span class="s2">"t"</span>
              <span class="n">w</span><span class="p">.</span><span class="nf">dead!</span>
            <span class="k">when</span> <span class="s2">"p"</span>
              <span class="n">w</span><span class="p">.</span><span class="nf">ping!</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="nf">sub</span><span class="p">(</span><span class="sr">/^\d+/</span><span class="p">,</span><span class="s1">''</span><span class="p">).</span><span class="nf">chomp</span><span class="p">)</span>
            <span class="k">end</span>
          <span class="k">else</span>
            <span class="n">log</span> <span class="s2">"! Out-of-sync worker list, no </span><span class="si">#{</span><span class="n">pid</span><span class="si">}</span><span class="s2"> worker"</span>
          <span class="k">end</span>
        <span class="k">end</span>

      <span class="k">rescue</span> <span class="no">Interrupt</span>
        <span class="vi">@status</span> <span class="o">=</span> <span class="ss">:stop</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">stop_workers</span> <span class="k">unless</span> <span class="vi">@status</span> <span class="o">==</span> <span class="ss">:halt</span>
  <span class="k">ensure</span>
    <span class="n">read</span><span class="p">.</span><span class="nf">close</span>
    <span class="vi">@wakeup</span><span class="p">.</span><span class="nf">close</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在使用 <code class="highlighter-rouge">#spawn_workers</code> 之后，当前 master 进程就开始通过 Socket 监听所有来自worker 的消息，例如当前的状态以及心跳检查等等。</p>

<p><code class="highlighter-rouge">#spawn_workers</code> 方法会通过 fork 创建当前集群中缺少的 worker 数，在新的进程中执行 <code class="highlighter-rouge">#worker</code> 方法并将 worker 保存在 master 的 <code class="highlighter-rouge">@workers</code> 数组中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">cluster</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">116</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Cluster</span>

<span class="k">def</span> <span class="nf">spawn_workers</span>
  <span class="n">diff</span> <span class="o">=</span> <span class="vi">@options</span><span class="p">[</span><span class="ss">:workers</span><span class="p">]</span> <span class="o">-</span> <span class="vi">@workers</span><span class="p">.</span><span class="nf">size</span>
  <span class="k">return</span> <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="mi">1</span>

  <span class="n">master</span> <span class="o">=</span> <span class="no">Process</span><span class="p">.</span><span class="nf">pid</span>

  <span class="n">diff</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">next_worker_index</span>
    <span class="n">pid</span> <span class="o">=</span> <span class="nb">fork</span> <span class="p">{</span> <span class="n">worker</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">master</span><span class="p">)</span> <span class="p">}</span>

    <span class="n">debug</span> <span class="s2">"Spawned worker: </span><span class="si">#{</span><span class="n">pid</span><span class="si">}</span><span class="s2">"</span>
    <span class="vi">@workers</span> <span class="o">&lt;&lt;</span> <span class="no">Worker</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="vi">@phase</span><span class="p">,</span> <span class="vi">@options</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 fork 出的新进程中，<code class="highlighter-rouge">#worker</code> 方法与单机模式中一样都创建了新的 <code class="highlighter-rouge">Server</code> 实例，调用 <code class="highlighter-rouge">#run</code> 和 <code class="highlighter-rouge">#join</code> 方法启动服务：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">cluster</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">231</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Cluster</span>

<span class="k">def</span> <span class="nf">worker</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">master</span><span class="p">)</span>
  <span class="n">title</span>  <span class="o">=</span> <span class="s2">"puma: cluster worker </span><span class="si">#{</span><span class="n">index</span><span class="si">}</span><span class="s2">: </span><span class="si">#{</span><span class="n">master</span><span class="si">}</span><span class="s2">"</span>
  <span class="vg">$0</span> <span class="o">=</span> <span class="n">title</span>

  <span class="n">server</span> <span class="o">=</span> <span class="n">start_server</span>
  <span class="n">server</span><span class="p">.</span><span class="nf">run</span><span class="p">.</span><span class="nf">join</span>
<span class="k">end</span>
</code></pre></div></div>

<p>与 Unicorn 完全相同，Puma 使用了一个 master 进程来管理所有的 worker 进程：</p>

<p><img src="https://img.draveness.me/2017-11-10-puma-cluster-mode.png" alt="puma-cluster-mode" /></p>

<p>虽然 Puma 集群中的所有节点也都是由 master 管理的，但是所有的事件和信号会由各个接受信号的进程处理的，只有在特定事件发生时会通知主进程。</p>

<h2 id="处理请求">处理请求</h2>

<p>在 Puma 中所有的请求都是通过 <code class="highlighter-rouge">Server</code> 和 <code class="highlighter-rouge">ThreadPool</code> 协作来响应的，我们在 <code class="highlighter-rouge">#handler_servers</code> 方法中通过 <code class="highlighter-rouge">IO.select</code> 监听一组套接字上的读写事件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">334</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">handle_servers</span>
  <span class="k">begin</span>
    <span class="n">sockets</span> <span class="o">=</span> <span class="vi">@binder</span><span class="p">.</span><span class="nf">ios</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="vi">@thread_pool</span>

    <span class="k">while</span> <span class="vi">@status</span> <span class="o">==</span> <span class="ss">:run</span>
      <span class="k">begin</span>
        <span class="n">ios</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">select</span> <span class="n">sockets</span>
        <span class="n">ios</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">sock</span><span class="o">|</span>
          <span class="k">begin</span>
            <span class="k">if</span> <span class="n">io</span> <span class="o">=</span> <span class="n">sock</span><span class="p">.</span><span class="nf">accept_nonblock</span>
              <span class="n">client</span> <span class="o">=</span> <span class="no">Client</span><span class="p">.</span><span class="nf">new</span> <span class="n">io</span><span class="p">,</span> <span class="vi">@binder</span><span class="p">.</span><span class="nf">env</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
              <span class="n">pool</span> <span class="o">&lt;&lt;</span> <span class="n">client</span>
              <span class="n">pool</span><span class="p">.</span><span class="nf">wait_until_not_full</span>
            <span class="k">end</span>
          <span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">ECONNABORTED</span>
            <span class="n">io</span><span class="p">.</span><span class="nf">close</span> <span class="k">rescue</span> <span class="kp">nil</span>
          <span class="k">end</span>
        <span class="k">rescue</span> <span class="no">Object</span> <span class="o">=&gt;</span> <span class="n">e</span>
          <span class="vi">@events</span><span class="p">.</span><span class="nf">unknown_error</span> <span class="nb">self</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="s2">"Listen loop"</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
      <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当有读写事件发生时会非阻塞的接受 Socket，创建新的 <code class="highlighter-rouge">Client</code> 对象最后加入到线程池中交给线程池来处理接下来的请求。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">thread_pool</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">140</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">ThreadPool</span>

<span class="k">def</span> <span class="nf">&lt;&lt;</span><span class="p">(</span><span class="n">work</span><span class="p">)</span>
  <span class="vi">@mutex</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
    <span class="k">if</span> <span class="vi">@shutdown</span>
      <span class="k">raise</span> <span class="s2">"Unable to add work while shutting down"</span>
    <span class="k">end</span>

    <span class="vi">@todo</span> <span class="o">&lt;&lt;</span> <span class="n">work</span>

    <span class="k">if</span> <span class="vi">@waiting</span> <span class="o">&lt;</span> <span class="vi">@todo</span><span class="p">.</span><span class="nf">size</span> <span class="n">and</span> <span class="vi">@spawned</span> <span class="o">&lt;</span> <span class="vi">@max</span>
      <span class="n">spawn_thread</span>
    <span class="k">end</span>

    <span class="vi">@not_empty</span><span class="p">.</span><span class="nf">signal</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">ThreadPool</code> 覆写了 <code class="highlighter-rouge">#&lt;&lt;</code> 方法，在这个方法中它将 <code class="highlighter-rouge">Client</code> 对象加入到 <code class="highlighter-rouge">@todo</code> 数组中，通过对比几个参数选择是否创建一个新的线程来处理当前队列中的任务。</p>

<p>重新回到 <code class="highlighter-rouge">ThreadPool</code> 的初始化方法 <code class="highlighter-rouge">#initialize</code> 中，线程池在初始化时就会创建最低数量的线程保证当前的 worker 进程中有足够的工作线程能够处理客户端的请求：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">thread_pool</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">21</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">ThreadPool</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="o">*</span><span class="n">extra</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="vi">@mutex</span> <span class="o">=</span> <span class="no">Mutex</span><span class="p">.</span><span class="nf">new</span>

  <span class="vi">@todo</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="vi">@spawned</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="vi">@waiting</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="vi">@min</span> <span class="o">=</span> <span class="no">Integer</span><span class="p">(</span><span class="n">min</span><span class="p">)</span>
  <span class="vi">@max</span> <span class="o">=</span> <span class="no">Integer</span><span class="p">(</span><span class="n">max</span><span class="p">)</span>
  <span class="vi">@block</span> <span class="o">=</span> <span class="n">block</span>
  <span class="vi">@extra</span> <span class="o">=</span> <span class="n">extra</span>

  <span class="vi">@workers</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="vi">@mutex</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
    <span class="vi">@min</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span> <span class="n">spawn_thread</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>每一个线程都是通过 <code class="highlighter-rouge">Thread.new</code> 创建的，我们会在这个线程执行的过程中执行传入的 block：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">thread_pool</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">21</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">ThreadPool</span>

<span class="k">def</span> <span class="nf">spawn_thread</span>
  <span class="vi">@spawned</span> <span class="o">+=</span> <span class="mi">1</span>

  <span class="n">th</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@spawned</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">spawned</span><span class="o">|</span>
    <span class="n">todo</span>  <span class="o">=</span> <span class="vi">@todo</span>
    <span class="n">block</span> <span class="o">=</span> <span class="vi">@block</span>
    <span class="n">mutex</span> <span class="o">=</span> <span class="vi">@mutex</span>

    <span class="n">extra</span> <span class="o">=</span> <span class="vi">@extra</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span><span class="p">.</span><span class="nf">new</span> <span class="p">}</span>

    <span class="k">while</span> <span class="kp">true</span>
      <span class="n">work</span> <span class="o">=</span> <span class="kp">nil</span>

      <span class="n">continue</span> <span class="o">=</span> <span class="kp">true</span>

      <span class="n">mutex</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
        <span class="n">work</span> <span class="o">=</span> <span class="n">todo</span><span class="p">.</span><span class="nf">shift</span>
      <span class="k">end</span>

      <span class="k">begin</span>
        <span class="n">block</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="o">*</span><span class="n">extra</span><span class="p">)</span>
      <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
        <span class="no">STDERR</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"Error reached top of thread-pool: </span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">message</span><span class="si">}</span><span class="s2"> (</span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">class</span><span class="si">}</span><span class="s2">)"</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">mutex</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
      <span class="vi">@spawned</span> <span class="o">-=</span> <span class="mi">1</span>
      <span class="vi">@workers</span><span class="p">.</span><span class="nf">delete</span> <span class="n">th</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="vi">@workers</span> <span class="o">&lt;&lt;</span> <span class="n">th</span>
  <span class="n">th</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在每一个工作完成之后，也会在一个互斥锁内部使用 <code class="highlighter-rouge">#delete</code> 方法将当前线程从数组中删除，在这里执行的 block 中将客户端对象 <code class="highlighter-rouge">Client</code> 加入了 <code class="highlighter-rouge">Reactor</code> 中等待之后的处理。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@thread_pool</span> <span class="o">=</span> <span class="no">ThreadPool</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@min_threads</span><span class="p">,</span>
                              <span class="vi">@max_threads</span><span class="p">,</span>
                              <span class="no">IOBuffer</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">client</span><span class="p">,</span> <span class="n">buffer</span><span class="o">|</span>
  <span class="k">begin</span>
    <span class="n">client</span><span class="p">.</span><span class="nf">finish</span>
  <span class="k">rescue</span> <span class="no">MiniSSL</span><span class="o">::</span><span class="no">SSLError</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="c1"># ...</span>
  <span class="k">else</span>
    <span class="n">process_client</span> <span class="n">client</span><span class="p">,</span> <span class="n">buffer</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如过当前任务不需要立即处理，就会向 <code class="highlighter-rouge">Reactor</code> 加入任务等待一段时间，否则就会立即由 <code class="highlighter-rouge">#process_client</code> 方法进行处理，其中调用了 <code class="highlighter-rouge">#handle_request</code> 方法尝试处理当前的网络请求：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">439</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">process_client</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buffer</span><span class="p">)</span>
  <span class="k">begin</span>
    <span class="k">while</span> <span class="kp">true</span>
      <span class="k">case</span> <span class="n">handle_request</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buffer</span><span class="p">)</span>
      <span class="k">when</span> <span class="kp">false</span>
        <span class="k">return</span>
      <span class="k">when</span> <span class="kp">true</span>
        <span class="k">return</span> <span class="k">unless</span> <span class="vi">@queue_requests</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">reset</span>
        <span class="k">unless</span> <span class="n">client</span><span class="p">.</span><span class="nf">reset</span><span class="p">(</span><span class="vi">@status</span> <span class="o">==</span> <span class="ss">:run</span><span class="p">)</span>
          <span class="n">client</span><span class="p">.</span><span class="nf">set_timeout</span> <span class="vi">@persistent_timeout</span>
          <span class="vi">@reactor</span><span class="p">.</span><span class="nf">add</span> <span class="n">client</span>
          <span class="k">return</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="no">StandardError</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="c1"># ...</span>
  <span class="k">ensure</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>用于处理网络请求的方法 <code class="highlighter-rouge">#handle_request</code> 足足有 200 多行，代码中处理非常多的实现细节，在这里实在是不想一行一行代码看过去，也就简单梳理一下这段代码的脉络了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">574</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">handle_request</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">lines</span><span class="p">)</span>
  <span class="n">env</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="nf">env</span>
  <span class="n">client</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="nf">io</span>

  <span class="c1"># ...</span>

  <span class="k">begin</span>
    <span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">res_body</span> <span class="o">=</span> <span class="vi">@app</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>

    <span class="n">headers</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">k</span><span class="p">,</span> <span class="n">vs</span><span class="o">|</span>
      <span class="c1"># ...</span>
    <span class="k">end</span>

    <span class="n">fast_write</span> <span class="n">client</span><span class="p">,</span> <span class="n">lines</span><span class="p">.</span><span class="nf">to_s</span>
    <span class="n">res_body</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">part</span><span class="o">|</span>
      <span class="n">fast_write</span> <span class="n">client</span><span class="p">,</span> <span class="n">part</span>
      <span class="n">client</span><span class="p">.</span><span class="nf">flush</span>
    <span class="k">end</span>
  <span class="k">ensure</span>
    <span class="n">body</span><span class="p">.</span><span class="nf">close</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>我们在这里直接将这段代码压缩至 20 行左右，你可以看到与其他的 webserver 完全相同，这里也调用了 Rack 应用的 <code class="highlighter-rouge">#call</code> 方法获得了一个三元组，然后通过 <code class="highlighter-rouge">#fast_write</code> 将请求写回客户端的 Socket 结束这个 HTTP 请求。</p>

<h2 id="并发模型">并发模型</h2>

<p>到目前为止，我们已经对 Puma 是如何处理 HTTP 请求的有一个比较清晰的认识了，对于每一个 HTTP 请求都会由操作系统选择不同的进程来处理，这部分的负载均衡完全是由 OS 层来做的，当请求被分配给某一个进程时，当前进程会根据持有的线程数选择是否对请求进行处理，在这时可能会创建新的 <code class="highlighter-rouge">Thread</code> 对象来处理这个请求，也可能会把当前请求暂时扔到 <code class="highlighter-rouge">Reactor</code> 中进行等待。</p>

<p><img src="https://img.draveness.me/2017-11-10-puma-concurrency-model.png" alt="puma-concurrency-model" /></p>

<p><code class="highlighter-rouge">Reactor</code> 主要是为了提高 Puma 服务的性能存在的产物，它能够让当前的 worker 接受所有请求并将它们以队列的形式传入处理器中；如果当前的系统中存在慢客户端，那么也会占用处理请求的资源，不过由于 Puma 是多进程多线程模型的，所以影响没有那么严重，但是我们也经常会通过反向代理来解决慢客户端的问题。</p>

<h2 id="总结">总结</h2>

<p>相比于多进程单线程的 Unicorn，Puma 提供了更灵活的配置功能，每一个进程的线程数都能在一定范围内进行收缩，目前也是绝大多数的 Ruby 项目使用的 webserver，从不同 webserver 的发展我们其实可以看出混合方式的并发模型虽然实现更加复杂，但是确实能够提供更高的性能和容错。</p>

<p>Puma 项目使用了 Rubocop 来规范项目中的代码风格，相比其他的 webserver 来说确实有更好的阅读体验，只是偶尔出现的长方法会让代码在理解时出现一些问题。</p>



        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
            
                
            
                
            
                
            
                
            

            <!-- Add Disqus Comments -->
            

        </footer>

    </article>

</main>
<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story no-cover" href="/blogs/ruby-webserver">
            <section class="post">
                <h2>Ruby Web 服务器的并发模型与性能</h2>
                <p>+ [谈谈 Rack 协议与实现](https://draveness.me/rack) + [浅谈 WEBrick 的多线程模型](https://draveness.me/rack-webrick) + [浅谈 Thin 的事件驱动模型](https://draveness.me/rack-thin) + [浅谈 Unicorn...</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev no-cover" href="/blogs/rack-unicorn">
            <section class="post">
                <h2>浅谈 Unicorn 的多进程模型</h2>
                <p>谈谈 Rack 协议与实现 浅谈 WEBrick 的多线程模型 浅谈 Thin 的事件驱动模型 浅谈 Unicorn 的多进程模型 浅谈 Puma 的并发模型与实现...</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/blogs/">Brightness</a> &copy; 2018</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-69281367-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/blogs/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/blogs/assets/js/index.js"></script>

</body>
</html>
