<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>MySQL 索引性能分析概要</title>
    <meta name="description" content="A beautiful narrative written with the world's most elegant publishing platform. The story begins here." />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/blogs/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/blogs/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/blogs/assets/css/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="/blogs//sql-index-performance" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/blogs/page2/" />

    <meta property="og:site_name" content="Brightness" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="MySQL 索引性能分析概要" />
    <meta property="og:description" content="A beautiful narrative written with the world's most elegant publishing platform. The story begins here." />
    <meta property="og:url" content="/blogs//sql-index-performance" />
    <meta property="og:image" content="/blogs/assets/images/cover1.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="MySQL 索引性能分析概要" />
    <meta name="twitter:description" content="A beautiful narrative written with the world's most elegant publishing platform. The story begins here." />
    <meta name="twitter:url" content="/blogs//sql-index-performance" />
    <meta name="twitter:image:src" content="/blogs/assets/images/cover1.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "Brightness",
    "name": "MySQL 索引性能分析概要",
    "url": "/blogs//sql-index-performance",
    "image": "/blogs/assets/images/cover1.jpg",
    "description": "A beautiful narrative written with the world's most elegant publishing platform. The story begins here."
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="Brightness" href="/blogs/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/blogs/">Home</a></li>
        <li class="nav-about " role="presentation"><a href="/blogs/about">About</a></li>
        <li class="nav-fables " role="presentation"><a href="/blogs/tag/fables">Fables</a></li>
        <li class="nav-speeches " role="presentation"><a href="/blogs/tag/speeches">Speeches</a></li>
        <li class="nav-fiction " role="presentation"><a href="/blogs/tag/fiction">Fiction</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/casper">Casper</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/edgar">Edgar</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/abraham">Abraham</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/martin">Martin</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/lewis">Lewis</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/blogs/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        
        
    </nav>
</header>

<main class="content" role="main">

    <article class="">

        <header class="post-header">
            <h1 class="post-title">MySQL 索引性能分析概要</h1>
            <section class="post-meta">
            <!-- <a href='/blogs/'></a> -->

            
                
            
                
            
                
            
                
            
                
            
            <time class="post-date" datetime="2017-09-16">16 Sep 2017</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/blogs/tag/mysql'>Mysql</a>,
                    
                
                    
                       <a href='/blogs/tag/database'>Database</a>,
                    
                
                    
                       <a href='/blogs/tag/index'>Index</a>,
                    
                
                    
                       <a href='/blogs/tag/server'>Server</a>
                    
                
                
            </section>
        </header>

        <section class="post-content">

            <p>上一篇文章 <a href="http://draveness.me/sql-index-intro.html">MySQL 索引设计概要</a> 介绍了影响索引设计的几大因素，包括过滤因子、索引片的宽窄与大小以及匹配列和过滤列。在文章的后半部分介绍了 <a href="https://www.amazon.cn/图书/dp/B00ZH27RH0">数据库索引设计与优化</a> 一书中，理想的三星索引的设计流程和套路，到目前为止虽然我们掌握了单表索引的设计方法，但是却没有分析预估索引耗时的能力。</p>

<p><img src="https://img.draveness.me/2017-09-16-Proactive-Index-Design.jpg-1000width" alt="Proactive-Index-Design" /></p>

<p>在本文中，我们将介绍书中提到的两种分析索引性能的方法：基本问题法（BQ）和快速估算上限法（QUBE），这两种方法能够帮助我们快速分析、估算索引的性能，及时发现问题。</p>

<h2 id="基本问题法">基本问题法</h2>

<p>当我们需要考虑对现有的 SELECT 查询进行分析时，哪怕没有足够的时间，也应该使用基本问题法对查询进行评估，评估的内容非常简单：现有的索引或者即将添加的索引是否包含了 WHERE 中使用的全部列，也就是对于当前查询来说，是否有一个索引是半宽索引。</p>

<p><img src="https://img.draveness.me/2017-09-16-Semifat-Index-and-Fat-Index.jpg-1000width" alt="Semifat-Index-and-Fat-Index" /></p>

<p>在上一篇文章中，我们介绍过宽索引和窄索引，窄索引 (username) 其实就叫做半宽索引，其中包含了 WHERE 中的全部的列 username，当前索引的对于该查询只有一颗星，它虽然避免了无效的回表查询造成的随机 IO，但是如果当前的索引的性能仍然无法满足需要，就可以添加 age 将该索引变成宽索引 (username, age) 以此来避免回表访问造成的性能影响；对于上图中的简单查询，索引 (username, age) 其实已经是一个三星索引了，但是对于包含 ORDER BY 或者更加复杂的查询，(username, age) 可能就只是二星索引：</p>

<p><img src="https://img.draveness.me/2017-09-16-Complicated-Query-with-Order-By.jpg-1000width" alt="Complicated-Query-with-Order-By" /></p>

<p>在这时如果该索引仍然不能满足性能的需要，就可以考虑按照上一篇文章 <a href="http://draveness.me/sql-index-intro.html">MySQL 索引设计概要</a> 中提供的索引设计方法重新设计了。</p>

<blockquote>
  <p>虽然基本问题法能够快速解决一些由于索引造成的问题，但是它并不能保证足够的性能，当表中有 (city, username, age) 索引，谓词为 <code class="highlighter-rouge">WHERE username="draveness" AND age="21"</code> 时，使用基本问题法并不能得出正确的结果。</p>
</blockquote>

<h2 id="快速估算上限法">快速估算上限法</h2>

<p>基本问题法非常简单，它能够最短的时间内帮助我们评估一个查询的性能，但是它并不能准确地反映一个索引相关的性能问题，而快速估算上限法就是一种更加准确、复杂的方法了；其目的在于在程序开发期间就能将访问路径缓慢的问题暴露出来，这个估算方法的输出就是本地响应时间（Local Response Time）：</p>

<p><img src="https://img.draveness.me/2017-09-16-QUBE-LRT.jpg-1000width" alt="QUBE-LRT" /></p>

<p>本地响应时间就是查询在数据库服务器中的耗时，不包括任何的网络延迟和多层环境的通信时间，仅包括执行查询任务的耗时。</p>

<h3 id="响应时间">响应时间</h3>

<p>本地响应时间等于服务时间和排队时间的总和，一次查询请求需要在数据库中等待 CPU 以及磁盘的响应，也可能会因为其他事务正在对同样的数据进行读写，导致当前查询需要等待锁的获取，不过组成响应时间中的主要部分还是磁盘的服务时间：</p>

<p><img src="https://img.draveness.me/2017-09-16-Local-Response-Time.jpg-1000width" alt="Local-Response-Time" /></p>

<p>QUBE 在计算的过程中会忽略除了磁盘排队时间的其他排队时间，这样能够简化整个评估流程，而磁盘的服务时间主要还是包括同步读写以及异步读几个部分：</p>

<p><img src="https://img.draveness.me/2017-09-16-Disk-Service-Time.jpg-1000width" alt="Disk-Service-Time" /></p>

<p>在排除了上述多个部分的内容，我们得到了一个非常简单的估算过程，整个估算时间的输入仅为随机读和顺序读以及数据获取的三个输入，而它们也是影响查询的主要因素：</p>

<p><img src="https://img.draveness.me/2017-09-16-Local-Response-Time-Calculation.jpg-1000width" alt="Local-Response-Time-Calculation" /></p>

<p>其中数据获取的过程在比较不同的索引对同一查询的影响是不需要考虑的，因为同一查询使用不同的索引也会得到相同的结果集，获取的数据也是完全相同的。</p>

<h3 id="访问">访问</h3>

<p>当 MySQL 读取一个索引行或者一个表行时，就会发生一次访问，当使用全表扫描或者扫描索引片时，读取的第一个行就是随机访问，随机访问需要磁盘进行寻道和旋转，所以其代价巨大，而接下来顺序读取的所有行都是通过顺序访问读取的，代价只有随机访问的千分之一。</p>

<p>如果大量的顺序读取索引行和表行，在原理上可能会造成一些额外的零星的随机访问，不过这对于整个查询的估算来说其实并不重要；在计算本地响应时间时，仍然会把它们当做顺序访问进行估算。</p>

<h3 id="示例">示例</h3>

<p>在这里，我们简单地举一个例子来展示如何计算查询在使用某个索引时所需要的本地响应时间，假设我们有一张 <code class="highlighter-rouge">users</code> 表，其中有一千万条数据：</p>

<p><img src="https://img.draveness.me/2017-09-16-User-Table.jpg-1000width" alt="User-Table" /></p>

<p>在该 <code class="highlighter-rouge">users</code> 表中除了主键索引之外，还具有以下 (username, city)、(username, age) 和 (username) 几个辅助索引，当我们使用如下所示的查询时：</p>

<p><img src="https://img.draveness.me/2017-09-16-Filter-Factor.jpg-1000width" alt="Filter-Facto" /></p>

<p>两个查询条件分别有着 0.05% 和 12% 的过滤因子，该查询可以直接使用已有的辅助索引 (username, city)，接下来我们根据表中的总行数和过滤因子开始估算这一步骤 SQL 的执行时间：</p>

<p><img src="https://img.draveness.me/2017-09-16-Index-Slice-Scan.jpg-1000width" alt="Index-Slice-Scan" /></p>

<p>该查询在开始时会命中 (username, city) 索引，扫描符合条件的索引片，该索引总共会访问 10,000,000 * 0.05% * 12% = 600 条数据，其中包括 1 次的随机访问和 599 次的顺序访问，因为该索引中的列并不能满足查询的需要，所以对于每一个索引行都会产生一次表的随机访问，以获取剩余列 age 的信息：</p>

<p><img src="https://img.draveness.me/2017-09-16-Index-Table-Touch.jpg-1000width" alt="Index-Table-Touch" /></p>

<p>在这个过程中总共产生了 600 次随机访问，最后取回结果集的过程中也会有 600 次 FETCH 操作，从总体上来看这一次 SQL 查询共进行了 <strong>601 次随机访问</strong>、599 次顺序访问和 600 次 FETCH，根据上一节中的公式我们可以得到这个查询的用时约为 6075.99ms 也就是 6s 左右，这个时间对于绝大多数应用都是无法接受的。</p>

<p><img src="https://img.draveness.me/2017-09-16-SQL-Query-Time.jpg-1000width" alt="SQL-Query-Time" /></p>

<p>在整个查询的过程中，回表查询的 600 次随机访问成为了这个超级慢的查询的主要贡献，为了解决这个问题，我们只需要添加一个 (username, city, age) 索引或者在已有的 (username, city) 后添加新的 age 列就可以避免 600 次的随机访问：</p>

<p><img src="https://img.draveness.me/2017-09-16-SQL-Query-Time-After-Optimization.jpg-1000width" alt="SQL-Query-Time-After-Optimization" /></p>

<p>(username, city, age) 索引对于该查询其实就是一个三星索引了，有关索引设计的内容可以阅读上一篇文章 <a href="http://draveness.me/sql-index-intro.html">MySQL 索引设计概要</a> 如果读者有充足的时间依然强烈推荐 <a href="https://www.amazon.cn/图书/dp/B00ZH27RH0">数据库索引设计与优化</a> 这本书。</p>

<h2 id="总结">总结</h2>

<p>这篇文章是这一年来写的最短的一篇文章了，本来想详细介绍一下 <a href="https://www.amazon.cn/图书/dp/B00ZH27RH0">数据库索引设计与优化</a> 书中对于索引性能分析的预估方法，仔细想了一下这部分的内容实在太多，例子也非常丰富，只通过一篇文章很难完整地介绍其中的全部内容，所以只选择了其中的一部分知识点简单介绍，这也是这篇文章叫概要的原因。</p>

<p>如果对文章的内容有疑问，可以在评论中留言。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://www.amazon.cn/图书/dp/B00ZH27RH0">数据库索引设计与优化</a></li>
</ul>


        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
            
                
            
                
            
                
            
                
            

            <!-- Add Disqus Comments -->
            

        </footer>

    </article>

</main>
<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story no-cover" href="/blogs/database-concurrency-control">
            <section class="post">
                <h2>浅谈数据库并发控制 - 锁和 MVCC</h2>
                <p>在学习几年编程之后，你会发现所有的问题都没有简单、快捷的解决方案，很多问题都需要权衡和妥协，而本文介绍的就是数据库在并发性能和可串行化之间做的权衡和妥协 - 并发控制机制。 ![tradeoff-between-performance-and-serializability](https://img.draveness.me/2017-10-02-tradeoff-between-performance-and-serializability.png) 如果数据库中的所有事务都是串行执行的，那么它非常容易成为整个应用的性能瓶颈，虽然说没法水平扩展的节点在最后都会成为瓶颈，但是串行执行事务的数据库会加速这一过程；而并发（Concurrency）使一切事情的发生都有了可能，它能够解决一定的性能问题，但是它会带来更多诡异的错误。 引入了并发事务之后，如果不对事务的执行进行控制就会出现各种各样的问题，你可能没有享受到并发带来的性能提升就已经被各种奇怪的问题折磨的欲仙欲死了。 ## 概述 如何控制并发是数据库领域中非常重要的问题之一，不过到今天为止事务并发的控制已经有了很多成熟的解决方案，而这些方案的原理就是这篇文章想要介绍的内容，文章中会介绍最为常见的三种并发控制机制： ![pessimistic-optimistic-multiversion-conccurency-control](https://img.draveness.me/2017-10-02-pessimistic-optimistic-multiversion-conccurency-control.png) 分别是悲观并发控制、乐观并发控制和多版本并发控制，其中悲观并发控制其实是最常见的并发控制机制，也就是锁；而乐观并发控制其实也有另一个名字：乐观锁，乐观锁其实并不是一种真实存在的锁，我们会在文章后面的部分中具体介绍；最后就是多版本并发控制（MVCC）了，与前两者对立的命名不同，MVCC 可以与前两者中的任意一种机制结合使用，以提高数据库的读性能。 既然这篇文章介绍了不同的并发控制机制，那么一定会涉及到不同事务的并发，我们会通过示意图的方式分析各种机制是如何工作的。 ## 悲观并发控制...</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev no-cover" href="/blogs/sql-index-intro">
            <section class="post">
                <h2>MySQL 索引设计概要</h2>
                <p>在关系型数据库中设计索引其实并不是复杂的事情，很多开发者都觉得设计索引能够提升数据库的性能，相关的知识一定非常复杂。 然而这种想法是不正确的，索引其实并不是一个多么高深莫测的东西，只要我们掌握一定的方法，理解索引的实现就能在不需要 DBA 的情况下设计出高效的索引。 本文会介绍 数据库索引设计与优化 中设计索引的一些方法，让各位读者能够快速的在现有的工程中设计出合适的索引。 磁盘 IO 一个数据库必须保证其中存储的所有数据都是可以随时读写的，同时因为 MySQL 中所有的数据其实都是以文件的形式存储在磁盘上的，而从磁盘上随机访问对应的数据非常耗时，所以数据库程序和操作系统提供了缓冲池和内存以提高数据的访问速度。 除此之外，我们还需要知道数据库对数据的读取并不是以行为单位进行的，无论是读取一行还是多行，都会将该行或者多行所在的页全部加载进来，然后再读取对应的数据记录；也就是说，读取所耗费的时间与行数无关，只与页数有关。 在 MySQL...</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/blogs/">Brightness</a> &copy; 2018</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-69281367-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/blogs/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/blogs/assets/js/index.js"></script>

</body>
</html>
