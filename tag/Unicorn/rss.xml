<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>brightphone.github.io/blogs/</title>
   
   <link></link>
   <description>A beautiful narrative written with the world's most elegant publishing platform. The story begins here.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>浅谈 Unicorn 的多进程模型</title>
	  <link>/blogs//rack-unicorn</link>
	  <author></author>
	  <pubDate>2017-11-08T00:00:00+00:00</pubDate>
	  <guid>/blogs//rack-unicorn</guid>
	  <description><![CDATA[
	     <ul>
  <li><a href="https://draveness.me/rack">谈谈 Rack 协议与实现</a></li>
  <li><a href="https://draveness.me/rack-webrick">浅谈 WEBrick 的多线程模型</a></li>
  <li><a href="https://draveness.me/rack-thin">浅谈 Thin 的事件驱动模型</a></li>
  <li><a href="https://draveness.me/rack-unicorn">浅谈 Unicorn 的多进程模型</a></li>
  <li><a href="https://draveness.me/rack-puma">浅谈 Puma 的并发模型与实现</a></li>
  <li><a href="https://draveness.me/ruby-webserver">Ruby Web 服务器的并发模型与性能</a></li>
</ul>

<p>作为 Ruby 社区中老牌的 webserver，在今天也有很多开发者在生产环境使用 Unicorn 处理客户端的发出去的 HTTP 请求，与 WEBrick 和 Thin 不同，Unicorn 使用了完全不同的模型，提供了多进程模型批量处理来自客户端的请求。</p>

<p><img src="https://img.draveness.me/2017-11-08-unicorn.jpeg" alt="unicorn" /></p>

<p>Unicorn 为 Rails 应用提供并发的方式是使用 <code class="highlighter-rouge">fork</code> 创建多个 worker 线程，监听同一个 Socket 上的输入。</p>

<blockquote>
  <p>本文中使用的是 5.3.1 的 Unicorn，如果你使用了不同版本的 Unicorn，原理上的区别不会太大，只是在一些方法的实现上会有一些细微的不同。</p>
</blockquote>

<h2 id="实现原理">实现原理</h2>

<p>Unicorn 虽然也是一个遵循 Rack 协议的 Ruby webserver，但是因为它本身并没有提供 Rack 处理器，所以没有办法直接通过 <code class="highlighter-rouge">rackup -s Unicorn</code> 来启动 Unicorn 的进程。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">unicorn</span> <span class="o">-</span><span class="n">c</span> <span class="n">unicorn</span><span class="p">.</span><span class="nf">rb</span>
<span class="no">I</span><span class="p">,</span> <span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mo">06</span><span class="no">T08</span><span class="p">:</span><span class="mo">05</span><span class="p">:</span><span class="mo">03</span><span class="o">.</span><span class="mi">082116</span> <span class="c1">#33222]  INFO -- : listening on addr=0.0.0.0:8080 fd=10</span>
<span class="no">I</span><span class="p">,</span> <span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mo">06</span><span class="no">T08</span><span class="p">:</span><span class="mo">05</span><span class="p">:</span><span class="mo">03</span><span class="o">.</span><span class="mi">082290</span> <span class="c1">#33222]  INFO -- : worker=0 spawning...</span>
<span class="no">I</span><span class="p">,</span> <span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mo">06</span><span class="no">T08</span><span class="p">:</span><span class="mo">05</span><span class="p">:</span><span class="mo">03</span><span class="o">.</span><span class="mi">083505</span> <span class="c1">#33222]  INFO -- : worker=1 spawning...</span>
<span class="no">I</span><span class="p">,</span> <span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mo">06</span><span class="no">T08</span><span class="p">:</span><span class="mo">05</span><span class="p">:</span><span class="mo">03</span><span class="o">.</span><span class="mi">083989</span> <span class="c1">#33222]  INFO -- : master process ready</span>
<span class="no">I</span><span class="p">,</span> <span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mo">06</span><span class="no">T08</span><span class="p">:</span><span class="mo">05</span><span class="p">:</span><span class="mo">03</span><span class="o">.</span><span class="mi">084610</span> <span class="c1">#33223]  INFO -- : worker=0 spawned pid=33223</span>
<span class="no">I</span><span class="p">,</span> <span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mo">06</span><span class="no">T08</span><span class="p">:</span><span class="mo">05</span><span class="p">:</span><span class="mo">03</span><span class="o">.</span><span class="mi">085100</span> <span class="c1">#33223]  INFO -- : Refreshing Gem list</span>
<span class="no">I</span><span class="p">,</span> <span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mo">06</span><span class="no">T08</span><span class="p">:</span><span class="mo">05</span><span class="p">:</span><span class="mo">03</span><span class="o">.</span><span class="mi">084902</span> <span class="c1">#33224]  INFO -- : worker=1 spawned pid=33224</span>
<span class="no">I</span><span class="p">,</span> <span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mo">06</span><span class="no">T08</span><span class="p">:</span><span class="mo">05</span><span class="p">:</span><span class="mo">03</span><span class="o">.</span><span class="mi">085457</span> <span class="c1">#33224]  INFO -- : Refreshing Gem list</span>
<span class="no">I</span><span class="p">,</span> <span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mo">06</span><span class="no">T08</span><span class="p">:</span><span class="mo">05</span><span class="p">:</span><span class="mo">03</span><span class="o">.</span><span class="mi">123611</span> <span class="c1">#33224]  INFO -- : worker=1 ready</span>
<span class="no">I</span><span class="p">,</span> <span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mo">06</span><span class="no">T08</span><span class="p">:</span><span class="mo">05</span><span class="p">:</span><span class="mo">03</span><span class="o">.</span><span class="mi">123670</span> <span class="c1">#33223]  INFO -- : worker=0 ready</span>
</code></pre></div></div>

<p>在使用 Unicorn 时，我们需要直接使用 <code class="highlighter-rouge">unicorn</code> 命令来启动一个 Unicorn 服务，在使用时可以通过 <code class="highlighter-rouge">-c</code> 传入一个配置文件，文件中的内容其实都是 Ruby 代码，每一个方法调用都是 Unicorn 的一条配置项：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cat</span> <span class="n">unicorn</span><span class="p">.</span><span class="nf">rb</span>
<span class="n">worker_processes</span> <span class="mi">2</span>
</code></pre></div></div>

<h3 id="可执行文件">可执行文件</h3>

<p><code class="highlighter-rouge">unicorn</code> 这个命令位于 <code class="highlighter-rouge">bin/unicorn</code> 中，在这个可执行文件中，大部分的代码都是对命令行参数的配置和说明，整个文件可以简化为以下的几行代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rackup_opts</span> <span class="o">=</span> <span class="c1"># ...</span>
<span class="n">app</span> <span class="o">=</span> <span class="no">Unicorn</span><span class="p">.</span><span class="nf">builder</span><span class="p">(</span><span class="no">ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="s1">'config.ru'</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
<span class="no">Unicorn</span><span class="o">::</span><span class="no">Launcher</span><span class="p">.</span><span class="nf">daemonize!</span><span class="p">(</span><span class="n">options</span><span class="p">)</span> <span class="k">if</span> <span class="n">rackup_opts</span><span class="p">[</span><span class="ss">:daemonize</span><span class="p">]</span>
<span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span><span class="p">).</span><span class="nf">start</span><span class="p">.</span><span class="nf">join</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">unicorn</code> 命令会从 Rack 应用的标配 config.ru 文件或者传入的文件中加载代码构建一个新的 Rack 应用；初始化 Rack 应用后会使用 <code class="highlighter-rouge">.daemonize!</code> 方法将 unicorn 进程启动在后台运行；最后会创建并启动一个新的 <code class="highlighter-rouge">HttpServer</code> 的实例。</p>

<h3 id="构建应用">构建应用</h3>

<p>读取 config.ru 文件并解析的过程其实就是直接使用了 Rack 的 <code class="highlighter-rouge">Builder</code> 模块，通过 <code class="highlighter-rouge">eval</code> 运行一段代码得到一个 Rack 应用：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">39</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Unicorn&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">builder</span><span class="p">(</span><span class="n">ru</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
  <span class="n">raw</span> <span class="o">=</span> <span class="no">File</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">ru</span><span class="p">)</span>
  <span class="n">inner_app</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s2">"Rack::Builder.new {(</span><span class="se">\n</span><span class="si">#{</span><span class="n">raw</span><span class="si">}</span><span class="se">\n</span><span class="s2">)}.to_app"</span><span class="p">,</span> <span class="no">TOPLEVEL_BINDING</span><span class="p">,</span> <span class="n">ru</span><span class="p">)</span>

  <span class="n">middleware</span> <span class="o">=</span> <span class="p">{</span>
    <span class="no">ContentLength</span><span class="p">:</span> <span class="kp">nil</span><span class="p">,</span>
    <span class="no">Chunked</span><span class="p">:</span> <span class="kp">nil</span><span class="p">,</span>
    <span class="no">CommonLogger</span><span class="p">:</span> <span class="p">[</span> <span class="vg">$stderr</span> <span class="p">],</span>
    <span class="no">ShowExceptions</span><span class="p">:</span> <span class="kp">nil</span><span class="p">,</span>
    <span class="no">Lint</span><span class="p">:</span> <span class="kp">nil</span><span class="p">,</span>
    <span class="no">TempfileReaper</span><span class="p">:</span> <span class="kp">nil</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="n">middleware</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="p">,</span> <span class="n">args</span><span class="o">|</span>
      <span class="n">use</span><span class="p">(</span><span class="no">Rack</span><span class="p">.</span><span class="nf">const_get</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="k">if</span> <span class="no">Rack</span><span class="p">.</span><span class="nf">const_defined?</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">run</span> <span class="n">inner_app</span>
  <span class="k">end</span><span class="p">.</span><span class="nf">to_app</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在该方法中会执行两次 <code class="highlighter-rouge">Rack::Builder.new</code> 方法，第一次会运行 config.ru 中的代码，第二次会添加一些默认的中间件，最终会返回一个接受 <code class="highlighter-rouge">#call</code> 方法返回三元组的 Rack 应用。</p>

<h3 id="守护进程">守护进程</h3>

<p>在默认情况下，Unicorn 的进程都是以前台进程的形式运行的，但是在生产环境我们往往需要在后台运行 Unicorn 进程，这也就是 <code class="highlighter-rouge">Unicorn::Launcher</code> 所做的工作。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">23</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Unicorn::Launcher&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">daemonize!</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
  <span class="n">cfg</span> <span class="o">=</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">Configurator</span>
  <span class="vg">$stdin</span><span class="p">.</span><span class="nf">reopen</span><span class="p">(</span><span class="s2">"/dev/null"</span><span class="p">)</span>

  <span class="k">unless</span> <span class="no">ENV</span><span class="p">[</span><span class="s1">'UNICORN_FD'</span><span class="p">]</span>
    <span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>
    <span class="n">grandparent</span> <span class="o">=</span> <span class="vg">$$</span>
    <span class="k">if</span> <span class="nb">fork</span>
      <span class="n">wr</span><span class="p">.</span><span class="nf">close</span>
    <span class="k">else</span>
      <span class="n">rd</span><span class="p">.</span><span class="nf">close</span>
      <span class="no">Process</span><span class="p">.</span><span class="nf">setsid</span>
      <span class="nb">exit</span> <span class="k">if</span> <span class="nb">fork</span>
    <span class="k">end</span>

    <span class="k">if</span> <span class="n">grandparent</span> <span class="o">==</span> <span class="vg">$$</span>
      <span class="n">master_pid</span> <span class="o">=</span> <span class="p">(</span><span class="n">rd</span><span class="p">.</span><span class="nf">readpartial</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="k">rescue</span> <span class="kp">nil</span><span class="p">).</span><span class="nf">to_i</span>
      <span class="k">unless</span> <span class="n">master_pid</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="nb">warn</span> <span class="s2">"master failed to start, check stderr log for details"</span>
        <span class="nb">exit!</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="k">end</span>
      <span class="nb">exit</span> <span class="mi">0</span>
    <span class="k">else</span>
      <span class="n">options</span><span class="p">[</span><span class="ss">:ready_pipe</span><span class="p">]</span> <span class="o">=</span> <span class="n">wr</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="n">cfg</span><span class="o">::</span><span class="no">DEFAULTS</span><span class="p">[</span><span class="ss">:stderr_path</span><span class="p">]</span> <span class="o">||=</span> <span class="s2">"/dev/null"</span>
  <span class="n">cfg</span><span class="o">::</span><span class="no">DEFAULTS</span><span class="p">[</span><span class="ss">:stdout_path</span><span class="p">]</span> <span class="o">||=</span> <span class="s2">"/dev/null"</span>
  <span class="n">cfg</span><span class="o">::</span><span class="no">RACKUP</span><span class="p">[</span><span class="ss">:daemonized</span><span class="p">]</span> <span class="o">=</span> <span class="kp">true</span>
<span class="k">end</span>
</code></pre></div></div>

<p>想要真正理解上述代码的工作，我们需要理解广义上的 daemonize 过程，在 Unix-like 的系统中，一个 <a href="https://en.wikipedia.org/wiki/Daemon_(computing)">daemon</a>（守护进程）是运行在后台不直接被用户操作的进程；一个进程想要变成守护进程通常需要做以下的事情：</p>

<ol>
  <li>执行 <code class="highlighter-rouge">fork</code> 和 <code class="highlighter-rouge">exit</code> 来创建一个后台任务；</li>
  <li>从 tty 的控制中分离、创建一个新的 session 并成为新的 session 和进程组的管理者；</li>
  <li>将根目录 <code class="highlighter-rouge">/</code> 设置为当前进程的工作目录；</li>
  <li>将 umask 更新成 <code class="highlighter-rouge">0</code> 以提供自己的权限管理掩码；</li>
  <li>使用日志文件、控制台或者 <code class="highlighter-rouge">/dev/null</code> 设备作为标准输入、输出和错误；</li>
</ol>

<p>在 <code class="highlighter-rouge">.daemonize!</code> 方法中我们总共使用 fork 创建了两个进程，整个过程涉及三个进程的协作，其中 grandparent 是启动 Unicorn 的进程一般指终端，parent 是用来启动 Unicorn 服务的进程，master 就是 Unicorn 服务中的主进程，三个进程有以下的关系：</p>

<p><img src="https://img.draveness.me/2017-11-08-unicorn-daemonize.png" alt="unicorn-daemonize" /></p>

<p>上述的三个进程中，grandparent 表示用于启动 Unicorn 进程的终端，parent 只是一个用于设置进程状态和掩码的中间进程，它在启动 Unicorn 的 master 进程后就会立刻退出。</p>

<p>在这里，我们会分三个部分分别介绍 grandparent、parent 和 master 究竟做了哪些事情；首先，对于 grandparent 进程来说，我们实际上运行了以下的代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">daemonize!</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
  <span class="vg">$stdin</span><span class="p">.</span><span class="nf">reopen</span><span class="p">(</span><span class="s2">"/dev/null"</span><span class="p">)</span>
  <span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>
  <span class="n">wr</span><span class="p">.</span><span class="nf">close</span>

  <span class="c1"># fork</span>

  <span class="n">master_pid</span> <span class="o">=</span> <span class="p">(</span><span class="n">rd</span><span class="p">.</span><span class="nf">readpartial</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="k">rescue</span> <span class="kp">nil</span><span class="p">).</span><span class="nf">to_i</span>
  <span class="k">unless</span> <span class="n">master_pid</span> <span class="o">&gt;</span> <span class="mi">1</span>
    <span class="nb">warn</span> <span class="s2">"master failed to start, check stderr log for details"</span>
    <span class="nb">exit!</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>通过 <code class="highlighter-rouge">IO.pipe</code> 方法创建了一对 Socket 节点，其中一个用于读，另一个用于写，在这里由于当前进程 grantparent 不需要写，所以直接将写的一端 <code class="highlighter-rouge">#close</code>，保留读的一端等待 Unicorn master 进程发送它的 <code class="highlighter-rouge">pid</code>，如果 master 没有成功启动就会报错，这也是 grandparent 进程的主要作用。</p>

<p>对于 parent 进程来说做的事情其实就更简单了，在 <code class="highlighter-rouge">fork</code> 之后会直接将读的一端执行 <code class="highlighter-rouge">#close</code>，这样无论是当前进程 parent 还是 parent fork 出来的进程都无法通过 <code class="highlighter-rouge">rd</code> 读取数据：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">daemonize!</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
  <span class="vg">$stdin</span><span class="p">.</span><span class="nf">reopen</span><span class="p">(</span><span class="s2">"/dev/null"</span><span class="p">)</span>
  <span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>

  <span class="c1"># fork</span>

  <span class="n">rd</span><span class="p">.</span><span class="nf">close</span>
  <span class="no">Process</span><span class="p">.</span><span class="nf">setsid</span>
  <span class="nb">exit</span> <span class="k">if</span> <span class="nb">fork</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 parent 进程中，我们通过 <code class="highlighter-rouge">Process.setsid</code> 将当前的进程设置为新的 session 和进程组的管理者，从 tty 中分离；最后直接执行 <code class="highlighter-rouge">fork</code> 创建一个新的进程 master 并退出 parent 进程，parent 进程的作用其实就是为了启动新 Unicorn master 进程。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">daemonize!</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
  <span class="n">cfg</span> <span class="o">=</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">Configurator</span>
  <span class="vg">$stdin</span><span class="p">.</span><span class="nf">reopen</span><span class="p">(</span><span class="s2">"/dev/null"</span><span class="p">)</span>

  <span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>
  <span class="n">rd</span><span class="p">.</span><span class="nf">close</span>

  <span class="no">Process</span><span class="p">.</span><span class="nf">setsid</span>

  <span class="c1"># fork</span>

  <span class="n">options</span><span class="p">[</span><span class="ss">:ready_pipe</span><span class="p">]</span> <span class="o">=</span> <span class="n">wr</span>
  <span class="n">cfg</span><span class="o">::</span><span class="no">DEFAULTS</span><span class="p">[</span><span class="ss">:stderr_path</span><span class="p">]</span> <span class="o">||=</span> <span class="s2">"/dev/null"</span>
  <span class="n">cfg</span><span class="o">::</span><span class="no">DEFAULTS</span><span class="p">[</span><span class="ss">:stdout_path</span><span class="p">]</span> <span class="o">||=</span> <span class="s2">"/dev/null"</span>
  <span class="n">cfg</span><span class="o">::</span><span class="no">RACKUP</span><span class="p">[</span><span class="ss">:daemonized</span><span class="p">]</span> <span class="o">=</span> <span class="kp">true</span>
<span class="k">end</span>
</code></pre></div></div>

<p>新的进程 Unicorn master 就是一个不关联在任何 tty 的一个后台进程，不过到这里为止也仅仅创建另一个进程，Unicorn 还无法对外提供服务，我们将可读的 Socket <code class="highlighter-rouge">wr</code> 写入 <code class="highlighter-rouge">options</code> 中，在 webserver 成功启动后将通过 <code class="highlighter-rouge">IO.pipe</code> 创建的一对 Socket 将信息回传给 grandparent 进程通知服务启动的结果。</p>

<h3 id="初始化服务">初始化服务</h3>

<p>HTTP 服务在初始化时其实也没有做太多的事情，只是对 Rack 应用进行存储并初始化了一些实例变量：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="o">/</span><span class="n">http_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">69</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="vi">@app</span> <span class="o">=</span> <span class="n">app</span>
  <span class="vi">@request</span> <span class="o">=</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpRequest</span><span class="p">.</span><span class="nf">new</span>
  <span class="vi">@reexec_pid</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="vi">@ready_pipe</span> <span class="o">=</span> <span class="n">options</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="ss">:ready_pipe</span><span class="p">)</span>
  <span class="vi">@init_listeners</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:listeners</span><span class="p">]</span> <span class="p">?</span> <span class="n">options</span><span class="p">[:</span><span class="n">listeners</span><span class="p">].</span><span class="nf">dup</span> <span class="p">:</span> <span class="p">[]</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">config</span> <span class="o">=</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">Configurator</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">listener_opts</span> <span class="o">=</span> <span class="p">{}</span>

  <span class="vi">@self_pipe</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="vi">@workers</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="vi">@sig_queue</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="vi">@pid</span> <span class="o">=</span> <span class="kp">nil</span>

  <span class="n">config</span><span class="p">.</span><span class="nf">commit!</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="ss">:skip</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="ss">:listeners</span><span class="p">,</span> <span class="ss">:pid</span><span class="p">])</span>
  <span class="vi">@orig_app</span> <span class="o">=</span> <span class="n">app</span>
  <span class="vi">@queue_sigs</span> <span class="o">=</span> <span class="p">[</span><span class="ss">:WINCH</span><span class="p">,</span> <span class="ss">:QUIT</span><span class="p">,</span> <span class="ss">:INT</span><span class="p">,</span> <span class="ss">:TERM</span><span class="p">,</span> <span class="ss">:USR1</span><span class="p">,</span> <span class="ss">:USR2</span><span class="p">,</span> <span class="ss">:HUP</span><span class="p">,</span> <span class="ss">:TTIN</span><span class="p">,</span> <span class="ss">:TTOU</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">.daemonize!</code> 方法中存储的 <code class="highlighter-rouge">ready_pipe</code> 在这时被当前的 <code class="highlighter-rouge">HttpServer</code> 对象持有，之后会通过这个管道上传数据。</p>

<h3 id="启动服务">启动服务</h3>

<p><code class="highlighter-rouge">HttpServer</code> 服务的启动一看就是这个 <code class="highlighter-rouge">#start</code> 实例方法控制的，在这个方法中总过做了两件比较重要的事情：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="o">/</span><span class="n">http_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">120</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span>

<span class="k">def</span> <span class="nf">start</span>
  <span class="vi">@queue_sigs</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">sig</span><span class="o">|</span> <span class="nb">trap</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="p">{</span> <span class="vi">@sig_queue</span> <span class="o">&lt;&lt;</span> <span class="n">sig</span><span class="p">;</span> <span class="n">awaken_master</span> <span class="p">}</span> <span class="p">}</span>
  <span class="nb">trap</span><span class="p">(</span><span class="ss">:CHLD</span><span class="p">)</span> <span class="p">{</span> <span class="n">awaken_master</span> <span class="p">}</span>

  <span class="nb">self</span><span class="p">.</span><span class="nf">pid</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="ss">:pid</span><span class="p">]</span>

  <span class="n">spawn_missing_workers</span>
  <span class="nb">self</span>
<span class="k">end</span>
</code></pre></div></div>

<p>第一件事情是将构造器中初始化的 <code class="highlighter-rouge">queue_sigs</code> 实例变量中的全部信号，通过 <code class="highlighter-rouge">trap</code> 为信号提供用于响应事件的代码。</p>

<p>第二件事情就是通过 <code class="highlighter-rouge">#spawn_missing_workers</code> 方法 <code class="highlighter-rouge">fork</code> 当前 master 进程创建一系列的 worker 进程：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="o">/</span><span class="n">http_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">531</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span>

<span class="k">def</span> <span class="nf">spawn_missing_workers</span>
  <span class="n">worker_nr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
  <span class="k">until</span> <span class="p">(</span><span class="n">worker_nr</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="vi">@worker_processes</span>
    <span class="n">worker</span> <span class="o">=</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">Worker</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">worker_nr</span><span class="p">)</span>
    <span class="n">before_fork</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">)</span>

    <span class="n">pid</span> <span class="o">=</span> <span class="nb">fork</span>

    <span class="k">unless</span> <span class="n">pid</span>
      <span class="n">after_fork_internal</span>
      <span class="n">worker_loop</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span>
      <span class="nb">exit</span>
    <span class="k">end</span>

    <span class="vi">@workers</span><span class="p">[</span><span class="n">pid</span><span class="p">]</span> <span class="o">=</span> <span class="n">worker</span>
    <span class="n">worker</span><span class="p">.</span><span class="nf">atfork_parent</span>
  <span class="k">end</span>
<span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="vi">@logger</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">rescue</span> <span class="kp">nil</span>
  <span class="nb">exit!</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这种调用了 <code class="highlighter-rouge">fork</code> 的方法中，我们还是将其一分为二来看，在这里就是 master 和 worker 进程，对于 master 进程来说：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="o">/</span><span class="n">http_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">531</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span>

<span class="k">def</span> <span class="nf">spawn_missing_workers</span>
  <span class="n">worker_nr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
  <span class="k">until</span> <span class="p">(</span><span class="n">worker_nr</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="vi">@worker_processes</span>
    <span class="n">worker</span> <span class="o">=</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">Worker</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">worker_nr</span><span class="p">)</span>
    <span class="n">before_fork</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">)</span>

    <span class="n">pid</span> <span class="o">=</span> <span class="nb">fork</span>
    
    <span class="c1"># ...</span>

    <span class="vi">@workers</span><span class="p">[</span><span class="n">pid</span><span class="p">]</span> <span class="o">=</span> <span class="n">worker</span>
  <span class="k">end</span>
<span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="vi">@logger</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">rescue</span> <span class="kp">nil</span>
  <span class="nb">exit!</span>
<span class="k">end</span>
</code></pre></div></div>

<p>通过一个 until 循环，master 进程能够创建 <code class="highlighter-rouge">worker_processes</code> 个 worker 进程，在每个循环中，上述方法都会创建一个 <code class="highlighter-rouge">Unicorn::Worker</code> 对象并在 <code class="highlighter-rouge">fork</code> 之后，将子进程的 <code class="highlighter-rouge">pid</code> 和 <code class="highlighter-rouge">worker</code> 以键值对的形式存到 <code class="highlighter-rouge">workers</code> 这个实例变量中。</p>

<p><code class="highlighter-rouge">before_fork</code> 中存储的 block 是我们非常熟悉的，其实就是向服务器的日志中追加内容：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">DEFAULTS</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1"># ...</span>
  <span class="ss">:after_fork</span> <span class="o">=&gt;</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">server</span><span class="p">,</span> <span class="n">worker</span><span class="o">|</span>
    <span class="n">server</span><span class="p">.</span><span class="nf">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s2">"worker=</span><span class="si">#{</span><span class="n">worker</span><span class="p">.</span><span class="nf">nr</span><span class="si">}</span><span class="s2"> spawned pid=</span><span class="si">#{</span><span class="vg">$$</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
  <span class="p">},</span>
  <span class="ss">:before_fork</span> <span class="o">=&gt;</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">server</span><span class="p">,</span> <span class="n">worker</span><span class="o">|</span>
    <span class="n">server</span><span class="p">.</span><span class="nf">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s2">"worker=</span><span class="si">#{</span><span class="n">worker</span><span class="p">.</span><span class="nf">nr</span><span class="si">}</span><span class="s2"> spawning..."</span><span class="p">)</span>
  <span class="p">},</span>
  <span class="ss">:before_exec</span> <span class="o">=&gt;</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">server</span><span class="o">|</span>
    <span class="n">server</span><span class="p">.</span><span class="nf">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s2">"forked child re-executing..."</span><span class="p">)</span>
  <span class="p">},</span>
  <span class="ss">:after_worker_exit</span> <span class="o">=&gt;</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">server</span><span class="p">,</span> <span class="n">worker</span><span class="p">,</span> <span class="n">status</span><span class="o">|</span>
    <span class="n">m</span> <span class="o">=</span> <span class="s2">"reaped </span><span class="si">#{</span><span class="n">status</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2"> worker=</span><span class="si">#{</span><span class="n">worker</span><span class="p">.</span><span class="nf">nr</span> <span class="k">rescue</span> <span class="s1">'unknown'</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">if</span> <span class="n">status</span><span class="p">.</span><span class="nf">success?</span>
      <span class="n">server</span><span class="p">.</span><span class="nf">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="n">server</span><span class="p">.</span><span class="nf">logger</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="p">},</span>
  <span class="ss">:after_worker_ready</span> <span class="o">=&gt;</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">server</span><span class="p">,</span> <span class="n">worker</span><span class="o">|</span>
    <span class="n">server</span><span class="p">.</span><span class="nf">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s2">"worker=</span><span class="si">#{</span><span class="n">worker</span><span class="p">.</span><span class="nf">nr</span><span class="si">}</span><span class="s2"> ready"</span><span class="p">)</span>
  <span class="p">},</span>
  <span class="c1"># ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>所有日志相关的输出大都在 <code class="highlighter-rouge">Unicorn::Configurator</code> 类中作为常量定义起来，并在初始化时作为缺省值赋值到 <code class="highlighter-rouge">HttpServer</code> 相应的实例变量上。而对于真正处理 HTTP 请求的 worker 进程来说，就会进入更加复杂的逻辑了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">spawn_missing_workers</span>
  <span class="n">worker_nr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
  <span class="k">until</span> <span class="p">(</span><span class="n">worker_nr</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="vi">@worker_processes</span>
    <span class="n">worker</span> <span class="o">=</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">Worker</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">worker_nr</span><span class="p">)</span>
    <span class="n">before_fork</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">)</span>

    <span class="c1"># fork</span>

    <span class="n">after_fork_internal</span>
    <span class="n">worker_loop</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span>
    <span class="nb">exit</span>
  <span class="k">end</span>
<span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="vi">@logger</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">rescue</span> <span class="kp">nil</span>
  <span class="nb">exit!</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这里调用了两个实例方法，其中一个是 <code class="highlighter-rouge">#after_fork_internal</code>，另一个是 <code class="highlighter-rouge">#worker_loop</code> 方法，前者用于处理一些 <code class="highlighter-rouge">fork</code> 之后收尾的逻辑，比如关闭仅在 master 进程中使用的 <code class="highlighter-rouge">self_pipe</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">after_fork_internal</span>
  <span class="vi">@self_pipe</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:close</span><span class="p">).</span><span class="nf">clear</span>
  <span class="vi">@ready_pipe</span><span class="p">.</span><span class="nf">close</span> <span class="k">if</span> <span class="vi">@ready_pipe</span>
  <span class="no">Unicorn</span><span class="o">::</span><span class="no">Configurator</span><span class="o">::</span><span class="no">RACKUP</span><span class="p">.</span><span class="nf">clear</span>
  <span class="vi">@ready_pipe</span> <span class="o">=</span> <span class="vi">@init_listeners</span> <span class="o">=</span> <span class="vi">@before_exec</span> <span class="o">=</span> <span class="vi">@before_fork</span> <span class="o">=</span> <span class="kp">nil</span>
<span class="k">end</span>
</code></pre></div></div>

<p>而后者就是 worker 持续监听 Socket 输入并处理请求的循环了。</p>

<h3 id="循环">循环</h3>

<p>当我们开始运行 worker 中的循环时，就开始监听 Socket 上的事件，整个过程还是比较直观的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="o">/</span><span class="n">http_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">681</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span>

<span class="k">def</span> <span class="nf">worker_loop</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span>
  <span class="n">ppid</span> <span class="o">=</span> <span class="vi">@master_pid</span>
  <span class="n">readers</span> <span class="o">=</span> <span class="n">init_worker_process</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span>
  <span class="n">ready</span> <span class="o">=</span> <span class="n">readers</span><span class="p">.</span><span class="nf">dup</span>
  <span class="vi">@after_worker_ready</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">)</span>

  <span class="k">begin</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">ready</span><span class="p">.</span><span class="nf">dup</span>
    <span class="k">while</span> <span class="n">sock</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">.</span><span class="nf">shift</span>
      <span class="k">if</span> <span class="n">client</span> <span class="o">=</span> <span class="n">sock</span><span class="p">.</span><span class="nf">kgio_tryaccept</span>
        <span class="n">process_client</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">unless</span> <span class="n">nr</span> <span class="o">==</span> <span class="mi">0</span>
      <span class="n">tmp</span> <span class="o">=</span> <span class="n">ready</span><span class="p">.</span><span class="nf">dup</span>
      <span class="k">redo</span>
    <span class="k">end</span>

    <span class="n">ppid</span> <span class="o">==</span> <span class="no">Process</span><span class="p">.</span><span class="nf">ppid</span> <span class="n">or</span> <span class="k">return</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="n">readers</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="vi">@timeout</span><span class="p">)</span> <span class="n">and</span> <span class="n">ready</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="c1"># ...</span>
  <span class="k">end</span> <span class="k">while</span> <span class="n">readers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果当前 Socket 上有等待处理的 HTTP 请求，就会执行 <code class="highlighter-rouge">#process_client</code> 方法队请求进行处理，在这里调用了 Rack 应用的 <code class="highlighter-rouge">#call</code> 方法得到了三元组：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="o">/</span><span class="n">http_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">605</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span>

<span class="k">def</span> <span class="nf">process_client</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>
  <span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">body</span> <span class="o">=</span> <span class="vi">@app</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">env</span> <span class="o">=</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">client</span><span class="p">))</span>

  <span class="k">begin</span>
    <span class="k">return</span> <span class="k">if</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">hijacked?</span>

    <span class="vi">@request</span><span class="p">.</span><span class="nf">headers?</span> <span class="n">or</span> <span class="n">headers</span> <span class="o">=</span> <span class="kp">nil</span>
    <span class="n">http_response_write</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span>
                        <span class="vi">@request</span><span class="p">.</span><span class="nf">response_start_sent</span><span class="p">)</span>
  <span class="k">ensure</span>
    <span class="n">body</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:close</span><span class="p">)</span> <span class="n">and</span> <span class="n">body</span><span class="p">.</span><span class="nf">close</span>
  <span class="k">end</span>

  <span class="k">unless</span> <span class="n">client</span><span class="p">.</span><span class="nf">closed?</span>
    <span class="n">client</span><span class="p">.</span><span class="nf">shutdown</span>
    <span class="n">client</span><span class="p">.</span><span class="nf">close</span>
  <span class="k">end</span>
<span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="n">handle_error</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>请求的解析是通过 <code class="highlighter-rouge">Request#read</code> 处理的，而向 Socket 写 HTTP 响应是通过 <code class="highlighter-rouge">#http_response_write</code> 方法来完成的，在这里有关 HTTP 请求的解析和响应的处理都属于一些不重要的实现细节，在这里也就不展开介绍了；当我们已经响应了用户的请求就可以将当前 Socket 直接关掉，断掉这个 TCP 连接了。</p>

<h2 id="调度">调度</h2>

<p>我们在上面已经通过多次 <code class="highlighter-rouge">fork</code> 启动了用于管理 Unicorn worker 进程的 master 以及多个 worker 进程，由于 Unicorn webserver 涉及了多个进程，所以需要进程之间进行调度。</p>

<p>在 Unix 中，进程的调度往往都是通过信号来进行的，<code class="highlighter-rouge">HttpServer#join</code> 就在 Unicorn 的 master 进程上监听外界发送的各种信号，不过在监听信号之前，要通过 <code class="highlighter-rouge">ready_pipe</code> 通知 grandparent 进程当前 master 进程已经启动完毕：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="o">/</span><span class="n">http_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">267</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span>

<span class="k">def</span> <span class="nf">join</span>
  <span class="n">respawn</span> <span class="o">=</span> <span class="kp">true</span>
  <span class="n">last_check</span> <span class="o">=</span> <span class="n">time_now</span>

  <span class="n">proc_name</span> <span class="s1">'master'</span>
  <span class="n">logger</span><span class="p">.</span><span class="nf">info</span> <span class="s2">"master process ready"</span> <span class="c1"># test_exec.rb relies on this message</span>
  <span class="k">if</span> <span class="vi">@ready_pipe</span>
    <span class="k">begin</span>
      <span class="vi">@ready_pipe</span><span class="p">.</span><span class="nf">syswrite</span><span class="p">(</span><span class="vg">$$</span><span class="p">.</span><span class="nf">to_s</span><span class="p">)</span>
    <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
      <span class="n">logger</span><span class="p">.</span><span class="nf">warn</span><span class="p">(</span><span class="s2">"grandparent died too soon?: </span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">message</span><span class="si">}</span><span class="s2"> (</span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">class</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="vi">@ready_pipe</span> <span class="o">=</span> <span class="vi">@ready_pipe</span><span class="p">.</span><span class="nf">close</span> <span class="k">rescue</span> <span class="kp">nil</span>
  <span class="k">end</span>

  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当 grandparent 进程，也就是执行 Unicorn 命令的进程接收到命令退出之后，就可以继续做其他的操作了，而 master 进程会进入一个 while 循环持续监听外界发送的信号：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">join</span>
  <span class="c1"># ...</span>

  <span class="k">begin</span>
    <span class="n">reap_all_workers</span>
    <span class="k">case</span> <span class="vi">@sig_queue</span><span class="p">.</span><span class="nf">shift</span>
    <span class="c1"># ...</span>
    <span class="k">when</span> <span class="ss">:WINCH</span>
      <span class="n">respawn</span> <span class="o">=</span> <span class="kp">false</span>
      <span class="n">soft_kill_each_worker</span><span class="p">(</span><span class="ss">:QUIT</span><span class="p">)</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">worker_processes</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">when</span> <span class="ss">:TTIN</span>
      <span class="n">respawn</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">worker_processes</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">when</span> <span class="ss">:TTOU</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">worker_processes</span> <span class="o">-=</span> <span class="mi">1</span> <span class="k">if</span> <span class="nb">self</span><span class="p">.</span><span class="nf">worker_processes</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">when</span> <span class="c1"># ...</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="no">Unicorn</span><span class="p">.</span><span class="nf">log_error</span><span class="p">(</span><span class="vi">@logger</span><span class="p">,</span> <span class="s2">"master loop error"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
  <span class="k">end</span> <span class="k">while</span> <span class="kp">true</span>

  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这一部分的几个信号都会改变当前 Unicorn worker 的进程数，无论是 <code class="highlighter-rouge">TTIN</code>、<code class="highlighter-rouge">TTOU</code> 还是 <code class="highlighter-rouge">WINCH</code> 信号最终都修改了 <code class="highlighter-rouge">worker_processes</code> 变量，其中 <code class="highlighter-rouge">#soft_kill_each_worker</code> 方法向所有的 Unicorn worker 进程发送了 <code class="highlighter-rouge">QUIT</code> 信号。</p>

<p>除了一些用于改变当前 worker 数量的信号，Unicorn 的 master 进程还监听了一些用于终止 master 进程或者更新配置文件的信号。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">join</span>
  <span class="c1"># ...</span>

  <span class="k">begin</span>
    <span class="n">reap_all_workers</span>
    <span class="k">case</span> <span class="vi">@sig_queue</span><span class="p">.</span><span class="nf">shift</span>
    <span class="c1"># ...</span>
    <span class="k">when</span> <span class="ss">:QUIT</span>
      <span class="k">break</span>
    <span class="k">when</span> <span class="ss">:TERM</span><span class="p">,</span> <span class="ss">:INT</span>
      <span class="n">stop</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span>
      <span class="k">break</span>
    <span class="k">when</span> <span class="ss">:HUP</span>
      <span class="n">respawn</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="k">if</span> <span class="n">config</span><span class="p">.</span><span class="nf">config_file</span>
        <span class="n">load_config!</span>
      <span class="k">else</span> <span class="c1"># exec binary and exit if there's no config file</span>
        <span class="n">reexec</span>
      <span class="k">end</span>
    <span class="k">when</span> <span class="c1"># ...</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="no">Unicorn</span><span class="p">.</span><span class="nf">log_error</span><span class="p">(</span><span class="vi">@logger</span><span class="p">,</span> <span class="s2">"master loop error"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
  <span class="k">end</span> <span class="k">while</span> <span class="kp">true</span>

  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>无论是 <code class="highlighter-rouge">QUIT</code> 信号还是 <code class="highlighter-rouge">TERM</code>、<code class="highlighter-rouge">INT</code> 最终都执行了 <code class="highlighter-rouge">#stop</code> 方法，选择使用不同的信号干掉当前 master 管理的 worker 进程：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="o">/</span><span class="n">http_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">339</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span>

<span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="n">graceful</span> <span class="o">=</span> <span class="kp">true</span><span class="p">)</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">listeners</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">limit</span> <span class="o">=</span> <span class="n">time_now</span> <span class="o">+</span> <span class="n">timeout</span>
  <span class="k">until</span> <span class="vi">@workers</span><span class="p">.</span><span class="nf">empty?</span> <span class="o">||</span> <span class="n">time_now</span> <span class="o">&gt;</span> <span class="n">limit</span>
    <span class="k">if</span> <span class="n">graceful</span>
      <span class="n">soft_kill_each_worker</span><span class="p">(</span><span class="ss">:QUIT</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="n">kill_each_worker</span><span class="p">(</span><span class="ss">:TERM</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="nb">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="n">reap_all_workers</span>
  <span class="k">end</span>
  <span class="n">kill_each_worker</span><span class="p">(</span><span class="ss">:KILL</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法其实非常容易理解，它会根据传入的参数选择强制终止或者正常停止所有的 worker 进程，这样整个 Unicorn 服务才真正停止并不再为外界提供服务了。</p>

<p>当我们向 master 发送 <code class="highlighter-rouge">TTIN</code> 或者 <code class="highlighter-rouge">TTOU</code> 信号时只是改变了实例变量 <code class="highlighter-rouge">worker_process</code> 的值，还并没有 <code class="highlighter-rouge">fork</code> 出新的进程，这些操作都是在 <code class="highlighter-rouge">nil</code> 条件中完成的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">join</span>
  <span class="c1"># ...</span>

  <span class="k">begin</span>
    <span class="n">reap_all_workers</span>
    <span class="k">case</span> <span class="vi">@sig_queue</span><span class="p">.</span><span class="nf">shift</span>
    <span class="k">when</span> <span class="kp">nil</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">last_check</span> <span class="o">+</span> <span class="vi">@timeout</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">last_check</span> <span class="o">=</span> <span class="n">time_now</span><span class="p">)</span>
        <span class="n">sleep_time</span> <span class="o">=</span> <span class="n">murder_lazy_workers</span>
      <span class="k">else</span>
        <span class="n">sleep_time</span> <span class="o">=</span> <span class="vi">@timeout</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="k">end</span>
      <span class="n">maintain_worker_count</span> <span class="k">if</span> <span class="n">respawn</span>
      <span class="n">master_sleep</span><span class="p">(</span><span class="n">sleep_time</span><span class="p">)</span>
    <span class="k">when</span> <span class="c1"># ...</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="no">Unicorn</span><span class="p">.</span><span class="nf">log_error</span><span class="p">(</span><span class="vi">@logger</span><span class="p">,</span> <span class="s2">"master loop error"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
  <span class="k">end</span> <span class="k">while</span> <span class="kp">true</span>

  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当 <code class="highlighter-rouge">@sig_queue.shift</code> 返回 <code class="highlighter-rouge">nil</code> 时也就代表当前没有需要处理的信号，如果需要创建新的进程或者停掉进程就会通过 <code class="highlighter-rouge">#maintain_worker_count</code> 方法，之后 master 进程会陷入睡眠直到被再次唤醒。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="o">/</span><span class="n">http_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">561</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span>

<span class="k">def</span> <span class="nf">maintain_worker_count</span>
  <span class="p">(</span><span class="n">off</span> <span class="o">=</span> <span class="vi">@workers</span><span class="p">.</span><span class="nf">size</span> <span class="o">-</span> <span class="n">worker_processes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="n">and</span> <span class="k">return</span>
  <span class="n">off</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="n">and</span> <span class="k">return</span> <span class="n">spawn_missing_workers</span>
  <span class="vi">@workers</span><span class="p">.</span><span class="nf">each_value</span> <span class="p">{</span> <span class="o">|</span><span class="n">w</span><span class="o">|</span> <span class="n">w</span><span class="p">.</span><span class="nf">nr</span> <span class="o">&gt;=</span> <span class="n">worker_processes</span> <span class="n">and</span> <span class="n">w</span><span class="p">.</span><span class="nf">soft_kill</span><span class="p">(</span><span class="ss">:QUIT</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>通过创建缺失的进程并关闭多余的进程，我们能够实时的保证整个 Unicorn 服务中的进程数与期望的配置完全相同。</p>

<p>在 Unicorn 的服务中，不仅 master 进程能够接收到来自用户或者其他进程的各种信号，worker 进程也能通过以下的方式将接受到的信号交给 master 处理： </p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="o">/</span><span class="n">http_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">120</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span>

<span class="k">def</span> <span class="nf">start</span>
  <span class="c1"># ...</span>
  <span class="vi">@queue_sigs</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">sig</span><span class="o">|</span> <span class="nb">trap</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="p">{</span> <span class="vi">@sig_queue</span> <span class="o">&lt;&lt;</span> <span class="n">sig</span><span class="p">;</span> <span class="n">awaken_master</span> <span class="p">}</span> <span class="p">}</span>
  <span class="nb">trap</span><span class="p">(</span><span class="ss">:CHLD</span><span class="p">)</span> <span class="p">{</span> <span class="n">awaken_master</span> <span class="p">}</span>
<span class="k">end</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="o">/</span><span class="n">http_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">391</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span>

<span class="k">def</span> <span class="nf">awaken_master</span>
  <span class="k">return</span> <span class="k">if</span> <span class="vg">$$</span> <span class="o">!=</span> <span class="vi">@master_pid</span>
  <span class="vi">@self_pipe</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">kgio_trywrite</span><span class="p">(</span><span class="s1">'.'</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>所以即使向 worker 进程发送 <code class="highlighter-rouge">TTIN</code> 或者 <code class="highlighter-rouge">TTOU</code> 等信号也能够改变整个 Unicorn 服务中 worker 进程的个数。</p>

<h2 id="多进程模型">多进程模型</h2>

<p>总的来说，Unicorn 作为 Web 服务使用了多进程的模型，通过一个 master 进程来管理多个 worker 进程，其中 master 进程不负责处理客户端的 HTTP 请求，多个 worker 进程监听同一组 Socket：</p>

<p><img src="https://img.draveness.me/2017-11-08-unicorn-io-model.png" alt="unicorn-io-mode" /></p>

<p>一组 worker 进程在监听 Socket 时，如果发现当前的 Socket 有等待处理的请求时就会在当前的进程中直接通过 <code class="highlighter-rouge">#process_client</code> 方法处理，整个过程会阻塞当前的进程，而多进程阻塞 I/O 的方式没有办法接受慢客户端造成的性能损失，只能通过反向代理 nginx 才可以解决这个问题。</p>

<p><img src="https://img.draveness.me/2017-11-08-unicorn-multi-processes.png" alt="unicorn-multi-processes" /></p>

<p>在 Unicorn 中，worker 之间的负载均衡是由操作系统解决的，所有的 worker 是通过 <code class="highlighter-rouge">.select</code> 方法等待共享 Socket 上的请求，一旦出现可用的 worker，就可以立即进行处理，避开了其他负载均衡算法没有考虑到请求处理时间的问题。</p>

<h2 id="总结">总结</h2>

<p>Unicorn 的源代码其实是作者读过的可读性最差的 Ruby 代码了，很多 Ruby 代码的风格写得跟 C 差不多，看起来也比较头疼，可能是需要处理很多边界条件以及信号，涉及较多底层的进程问题；虽然代码风格上看起来确实让人头疼，不过实现还是值得一看的，重要的代码大都包含在 unicorn.rb 和 http_server.rb 两个文件中，阅读时也不需要改变太多的上下文。</p>

<p>相比于 WEBrick 的单进程多线程的 I/O 模型，Unicorn 的多进程模型有很多优势，一是能够充分利用多核 CPU 的性能，其次能够通过 master 来管理并监控 Unicorn 中包含的一组 worker 并提供了零宕机部署的功能，除此之外，多进程的 I/O 模型还不在乎当前的应用是否是线程安全的，所以不会出现线程竞争等问题，不过 Unicorn 由于 <code class="highlighter-rouge">fork</code> 了大量的 worker 进程，如果长时间的在 Unicorn 上运行内存泄露的应用会非常耗费内存资源，可以考虑使用 <a href="https://github.com/kzk/unicorn-worker-killer">unicorn-worker-killer</a> 来自动重启。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://www.digitalocean.com/community/tutorials/how-to-optimize-unicorn-workers-in-a-ruby-on-rails-app">How To Optimize Unicorn Workers in a Ruby on Rails App</a></li>
  <li><a href="https://read01.com/zh-hk/zm5B.html#.Wf0oLduB0sk">Ruby Web 服务器：这十五年</a></li>
  <li><a href="https://github.com/kzk/unicorn-worker-killer">unicorn-worker-killer</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Daemon_(computing)">Daemon (computing)</a></li>
  <li><a href="http://jiangpeng.info/blogs/2014/03/10/nginx-unicorn.html">Nginx 与 Unicorn</a></li>
  <li><a href="https://github.com/blog/517-unicorn">Unicorn!</a></li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>
