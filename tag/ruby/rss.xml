<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>brightphone.github.io/blogs/</title>
   
   <link></link>
   <description>A beautiful narrative written with the world's most elegant publishing platform. The story begins here.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>谈元编程与表达能力</title>
	  <link>/blogs//metaprogramming</link>
	  <author></author>
	  <pubDate>2017-12-10T00:00:00+00:00</pubDate>
	  <guid>/blogs//metaprogramming</guid>
	  <description><![CDATA[
	     <p>在这篇文章中，作者会介绍不同的编程语言如何增强自身的表达能力，在写这篇文章的时候其实就已经想到这可能不是一篇有着较多受众和读者的文章。不过作者仍然想跟各位读者分享一下对不同编程语言的理解，同时也对自己的知识体系进行简单的总结。</p>

<p><img src="https://img.draveness.me/2017-12-10-metaprogramming.png" alt="metaprogramming" /></p>

<p>当我们刚刚开始学习和了解编程这门手艺或者说技巧时，一切的知识与概念看起来都非常有趣，随着学习的深入和对语言的逐渐了解，我们可能会发现原来看起来无所不能的编程语言成为了我们的限制，尤其是在我们想要使用一些<strong>元编程</strong>技巧的时候，你会发现有时候语言限制了我们的能力，我们只能一遍一遍地写重复的代码来解决本可以轻松搞定的问题。</p>

<h2 id="元编程">元编程</h2>

<p>元编程（Metaprogramming）是计算机编程中一个非常重要、有趣的概念，<a href="https://en.wikipedia.org/wiki/Metaprogramming">维基百科</a> 上将元编程描述成一种计算机程序可以<strong>将代码看待成数据</strong>的能力。</p>

<blockquote>
  <p>Metaprogramming is a programming technique in which computer programs have the ability to treat programs as their data.</p>
</blockquote>

<p>如果能够将代码看做数据，那么代码就可以像数据一样在运行时被修改、更新和替换；元编程赋予了编程语言更加强大的表达能力，能够让我们将一些计算过程从运行时挪到编译时、通过编译期间的展开生成代码或者允许程序在运行时改变自身的行为。</p>

<p><img src="https://img.draveness.me/2017-12-10-metaprogramming-usage.png" alt="metaprogramming-usage" /></p>

<p>总而言之，<strong>元编程其实是一种使用代码生成代码的方式</strong>，无论是编译期间生成代码，还是在运行时改变代码的行为都是『生成代码』的一种，下面的代码其实就可以看作一种最简单的元编程技巧：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">echo</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">));</span>
        <span class="n">sprintf</span><span class="p">(</span><span class="n">echo</span><span class="p">,</span> <span class="s">"echo %d"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">system</span><span class="p">(</span><span class="n">echo</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里的代码其实等价于执行了以下的 shell 脚本，也可以说这里使用了 C 语言的代码生成来生成 shell 脚本：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo </span>0
<span class="nb">echo </span>1
...
<span class="nb">echo </span>9
</code></pre></div></div>

<h2 id="编译时和运行时">编译时和运行时</h2>

<p>现代的编程语言大都会为我们提供不同的元编程能力，从总体来看，根据『生成代码』的时机不同，我们将元编程能力分为两种类型，其中一种是编译期间的元编程，例如：宏和模板；另一种是运行期间的元编程，也就是运行时，它赋予了编程语言在运行期间修改行为的能力，当然也有一些特性既可以在编译期实现，也可以在运行期间实现。</p>

<p><img src="https://img.draveness.me/2017-12-10-compile-and-execute.png" alt="compile-and-execute" /></p>

<p>不同的语言对于泛型就有不一样的实现，Java 的泛型就是在编译期间实现的，它的泛型其实是伪泛型，在编译期间所有的泛型就会被编译器擦除（type erasure），生成的 Java 字节码是不包含任何的泛型信息的，但是 C# 对于泛型就有着不同的实现了，它的泛型类型在运行时进行替换，为实例化的对象保留了泛型的类型信息。</p>

<blockquote>
  <p>C++ 的模板其实与这里讨论的泛型有些类似，它会为每一个具体类型生成一份独立的代码，而 Java 的泛型只会生成一份经过类型擦除后的代码，总而言之 C++ 的模板完全是在编译期间实现的，而 Java 的泛型是编译期间和运行期间协作产生的；模板和泛型虽然非常类似，但是在这里提到的模板大都特指 C++ 的模板，而泛型这一概念其实包含了 C++ 的模板。</p>
</blockquote>

<p>虽然泛型和模板为各种编程语言提供了非常强大的表达能力，但是在这篇文章中，我们会介绍另外两种元编程能力：<em>宏</em>和<em>运行时</em>，前者是在编译期间完成的，而后者是在代码运行期间才发生的。</p>

<h2 id="宏macro">宏（Macro）</h2>

<p>宏是很多编程语言具有的特性之一，它是一个将输入的字符串映射成其他字符串的过程，这个映射的过程也被我们称作宏展开。</p>

<p><img src="https://img.draveness.me/2017-12-10-macro-expansion.png" alt="macro-expansion" /></p>

<p>宏其实就是一个在编译期间中定义的展开过程，通过预先定义好的宏，我们可以使用少量的代码完成更多的逻辑和工作，能够减少应用程序中大量的重复代码。</p>

<p>很多编程语言，尤其是编译型语言都实现了宏这个特性，包括 C、Elixir 和 Rust，然而这些语言却使用了不同的方式来实现宏；我们在这里会介绍两种不同的宏，一种是基于文本替换的宏，另一种是基于语法的宏。</p>

<p><img src="https://img.draveness.me/2017-12-10-different-kinds-of-macros.png" alt="different-kinds-of-macros" /></p>

<p>C、C++ 等语言使用基于文本替换的宏，而类似于 Elixir、Rust 等语言的宏系统其实都是基于语法树和语法元素的，它的实现会比前者复杂很多，应用也更加广泛。</p>

<p>在这一节的剩余部分，我们会分别介绍 C、Elixir 和 Rust 三种不同的编程语言实现的宏系统，它们的使用方法、适用范围和优缺点。</p>

<h3 id="c">C</h3>

<p>作者相信很多工程师入门使用的编程语言其实都是 C 语言，而 C 语言的宏系统看起来还是相对比较简单的，虽然在实际使用时会遇到很多非常诡异的问题。C 语言的宏使用的就是文本替换的方式，所有的宏其实并不是通过编译器展开的，而是由预编译器来处理的。</p>

<p><img src="https://img.draveness.me/2017-12-10-preprocessor.png" alt="preprocesso" /></p>

<p>编译器 GCC 根据『长相』将 C 语言中的宏分为两种，其中的一种宏与编程语言中定义变量非常类似：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define BUFFER_SIZE 1024
</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">BUFFER_SIZE</span><span class="p">);</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>
</code></pre></div></div>

<p>这些宏的定义就是一个简单的标识符，它们会在预编译的阶段被预编译器替换成定义后半部分出现的<strong>字符</strong>，这种宏定义其实比较类似于变量的声明，我们经常会使用这种宏定义替代一些无意义的数字，能够让程序变得更容易理解。</p>

<p>另一种宏定义就比较像对函数的定义了，与其他 C 语言的函数一样，这种宏在定义时也会包含一些宏的参数：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define plus(a, b) a + b
#define multiply(a, b) a * b
</span></code></pre></div></div>

<p>通过在宏的定义中引入参数，宏定义的内部就可以直接使用对应的标识符引入外界传入的参数，在定义之后我们就可以像使用函数一样使用它们：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define plus(a, b) a + b
#define multiply(a, b) a * b
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">plus</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>       <span class="c1">// =&gt; 3
</span>    <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">multiply</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>   <span class="c1">// =&gt; 6
</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面使用宏的代码与下面的代码是完全等价的，在预编译阶段之后，上面的代码就会被替换成下面的代码，也就是编译器其实是不负责宏展开的过程：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>    <span class="c1">// =&gt; 3
</span>    <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>    <span class="c1">// =&gt; 6
</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>宏的作用其实非常强大，基于文本替换的宏能做到很多函数无法做到的事情，比如使用宏根据传入的参数创建类并声明新的方法：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define pickerify(KLASS, PROPERTY) interface \
    KLASS (Night_ ## PROPERTY ## _Picker) \
    @property (nonatomic, copy, setter = dk_set ## PROPERTY ## Picker:) DKColorPicker dk_ ## PROPERTY ## Picker; \
    @end \
    @implementation \
    KLASS (Night_ ## PROPERTY ## _Picker) \
    - (DKColorPicker)dk_ ## PROPERTY ## Picker { \
        return objc_getAssociatedObject(self, @selector(dk_ ## PROPERTY ## Picker)); \
    } \
    - (void)dk_set ## PROPERTY ## Picker:(DKColorPicker)picker { \
        objc_setAssociatedObject(self, @selector(dk_ ## PROPERTY ## Picker), picker, OBJC_ASSOCIATION_COPY_NONATOMIC); \
        [self setValue:picker(self.dk_manager.themeVersion) forKeyPath:@keypath(self, PROPERTY)];\
        NSMutableDictionary *pickers = [self valueForKeyPath:@"pickers"];\
        [pickers setValue:[picker copy] forKey:_DKSetterWithPROPERTYerty(@#PROPERTY)]; \
    } \
    @end
</span>
<span class="err">@</span><span class="n">pickerify</span><span class="p">(</span><span class="n">Button</span><span class="p">,</span> <span class="n">backgroundColor</span><span class="p">);</span>
</code></pre></div></div>

<p>上面的代码是我在一个 iOS 的开源库 <a href="https://github.com/Draveness/DKNightVersion/blob/master/DKNightVersion/DKNightVersion.h#L57-L72">DKNightVersion</a> 中使用的代码，通过宏的文本替换功能，我们在这里创建了类、属性并且定义了属性的 getter/setter 方法，然而使用者对此其实是一无所知的。</p>

<p>C 语言中的宏只是提供了一些文本替换的功能再加上一些高级的 API，虽然它非常强大，但是强大的事物都是一把双刃剑，再加上 C 语言的宏从实现原理上就有一些无法避免的缺陷，所以在使用时还是要非常小心。</p>

<p>由于预处理器只是对宏进行替换，并没有做任何的语法检查，所以在宏出现问题时，编译器的报错往往会让我们摸不到头脑，不知道哪里出现了问题，还需要脑内对宏进行展开分析出现错误的原因；除此之外，类似于 <code class="highlighter-rouge">multiply(1+2, 3)</code> 的展开问题导致人和机器对于同一段代码的理解偏差，作者相信也广为人知了；更高级一些的<strong>分号吞噬</strong>、<strong>参数的重复调用</strong>以及<strong>递归引用时不会递归展开</strong>等问题其实在这里也不想多谈。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">multiply</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">// #=&gt; 1+2 * 3
</span></code></pre></div></div>

<h4 id="卫生宏">卫生宏</h4>

<p>然而 C 语言宏的实现导致的另一个问题却是非常严重的：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define inc(i) do { int a = 0; ++i; } while(0)
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="n">inc</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">inc</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d, %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// =&gt; 4, 9 !!
</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>这一小节与卫生宏有关的 C 语言代码取自 <a href="https://en.wikipedia.org/wiki/Hygienic_macro">Hygienic macro</a> 中的代码示例。</p>
</blockquote>

<p>上述代码中的 <code class="highlighter-rouge">printf</code> 函数理应打印出 <code class="highlighter-rouge">5, 9</code> 然而却打印出了 <code class="highlighter-rouge">4, 9</code>，我们来将上述代码中使用宏的部分展开来看一下：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">++</span><span class="n">a</span><span class="p">;</span> <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">do</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">++</span><span class="n">b</span><span class="p">;</span> <span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d, %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// =&gt; 4, 9 !!
</span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这里的 <code class="highlighter-rouge">a = 0</code> 按照逻辑应该不发挥任何的作用，但是在这里却覆盖了上下文中 <code class="highlighter-rouge">a</code> 变量的值，导致父作用域中变量 <code class="highlighter-rouge">a</code> 的值并没有 <code class="highlighter-rouge">+1</code>，这其实就是因为 C 语言中实现的宏不是<em>卫生宏</em>（Hygiene macro）。</p>

<p>作者认为卫生宏（Hygiene macro）是一个非常让人困惑的翻译，它其实指一些<strong>在宏展开之后不会意外捕获上下文中标识符的宏</strong>，从定义中我们就可以看到 C 语言中的宏明显不是卫生宏，而接下来要介绍的两种语言的宏系统就实现了卫生宏。</p>

<h3 id="elixir">Elixir</h3>

<p>Elixir 是一门动态的函数式编程语言，它被设计用来构建可扩展、可维护的应用，所有的 Elixir 代码最终都会被编译成二进制文件运行在 Erlang 的虚拟机 Beam 上，构建在 Erlang 上的 Elixir 也继承了很多 Erlang 的优秀特性。然而在这篇文章中并不会展开介绍 Elixir 语言以及它的某些特点和应用，我们只想了解 Elixir 中的宏系统是如何使用和实现的。</p>

<p><img src="https://img.draveness.me/2017-12-10-elixir-logo.png" alt="elixir-logo" /></p>

<p>宏是 Elixir 具有强大表达能力的一个重要原因，通过内置的宏系统可以减少系统中非常多的重复代码，我们可以使用 <code class="highlighter-rouge">defmacro</code> 定义一个宏来实现 <code class="highlighter-rouge">unless</code> 关键字：</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">Unless</span> <span class="k">do</span>
  <span class="k">defmacro</span> <span class="n">macro_unless</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="k">do</span><span class="p">:</span> <span class="n">expression</span><span class="p">)</span> <span class="k">do</span>
    <span class="kn">quote</span> <span class="k">do</span>
      <span class="k">if</span><span class="p">(</span><span class="n">!unquote</span><span class="p">(</span><span class="n">clause</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="kn">unquote</span><span class="p">(</span><span class="n">expression</span><span class="p">))</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这里的 <code class="highlighter-rouge">quote</code> 和 <code class="highlighter-rouge">unquote</code> 是宏系统中最重要的两个函数，你可以从字面上理解 <code class="highlighter-rouge">quote</code> 其实就是在一段代码的两侧加上双引号，让这段代码变成字符串，而 <code class="highlighter-rouge">unquote</code> 会将传入的多个参数的文本<strong>原封不动</strong>的插入到相应的位置，你可以理解为 <code class="highlighter-rouge">unquote</code> 只是将 <code class="highlighter-rouge">clause</code> 和 <code class="highlighter-rouge">expression</code> 代表的字符串当做了返回值。</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Unless</span><span class="o">.</span><span class="n">macro_unless</span> <span class="no">true</span><span class="p">,</span> <span class="k">do</span><span class="p">:</span> <span class="no">IO</span><span class="o">.</span><span class="n">puts</span> <span class="sd">"</span><span class="s2">this should never be printed"</span>
</code></pre></div></div>

<p>上面的 Elixir 代码在真正执行之前会被替换成一个使用 <code class="highlighter-rouge">if</code> 的表达式，我们可以使用下面的方法获得宏展开之后的代码：</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="n">expr</span> <span class="o">=</span> <span class="kn">quote</span> <span class="k">do</span><span class="p">:</span> <span class="no">Unless</span><span class="o">.</span><span class="n">macro_unless</span> <span class="no">true</span><span class="p">,</span> <span class="k">do</span><span class="p">:</span> <span class="no">IO</span><span class="o">.</span><span class="n">puts</span> <span class="sd">"</span><span class="s2">this should never be printed"</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">expr</span> <span class="o">|&gt;</span> <span class="no">Macro</span><span class="o">.</span><span class="n">expand_once</span><span class="p">(</span><span class="n">__ENV__</span><span class="p">)</span> <span class="o">|&gt;</span> <span class="no">Macro</span><span class="o">.</span><span class="n">to_string</span> <span class="o">|&gt;</span> <span class="no">IO</span><span class="o">.</span><span class="n">puts</span>
<span class="k">if</span><span class="p">(</span><span class="n">!true</span><span class="p">)</span> <span class="k">do</span>
  <span class="no">IO</span><span class="o">.</span><span class="n">puts</span><span class="p">(</span><span class="sd">"</span><span class="s2">this should never be printed"</span><span class="p">)</span>
<span class="k">end</span>
<span class="ss">:ok</span>
</code></pre></div></div>

<p>当我们为 <code class="highlighter-rouge">quote</code> 函数传入一个表达式的时候，它会将当前的表达式转换成一个抽象语法树：</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{{:</span><span class="o">.</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[{</span><span class="ss">:__aliases__</span><span class="p">,</span> <span class="p">[</span><span class="ss">alias:</span> <span class="no">false</span><span class="p">],</span> <span class="p">[</span><span class="ss">:Unless</span><span class="p">]},</span> <span class="ss">:macro_unless</span><span class="p">]},</span> <span class="p">[],</span>
 <span class="p">[</span><span class="no">true</span><span class="p">,</span>
  <span class="p">[</span><span class="k">do</span><span class="p">:</span> <span class="p">{{:</span><span class="o">.</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[{</span><span class="ss">:__aliases__</span><span class="p">,</span> <span class="p">[</span><span class="ss">alias:</span> <span class="no">false</span><span class="p">],</span> <span class="p">[</span><span class="ss">:IO</span><span class="p">]},</span> <span class="ss">:puts</span><span class="p">]},</span> <span class="p">[],</span>
    <span class="p">[</span><span class="sd">"</span><span class="s2">this should never be printed"</span><span class="p">]}]]}</span>
</code></pre></div></div>

<p>在 Elixir 中，抽象语法数是可以直接通过下面的 <code class="highlighter-rouge">Code.eval_quoted</code> 方法运行：</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">iex</span><span class="o">&gt;</span> <span class="no">Code</span><span class="o">.</span><span class="n">eval_quoted</span> <span class="p">[</span><span class="n">expr</span><span class="p">]</span>
<span class="o">**</span> <span class="p">(</span><span class="no">CompileError</span><span class="p">)</span> <span class="ss">nofile:</span><span class="m">1</span><span class="p">:</span> <span class="n">you</span> <span class="n">must</span> <span class="kn">require</span> <span class="no">Unless</span> <span class="n">before</span> <span class="n">invoking</span> <span class="n">the</span> <span class="n">macro</span> <span class="no">Unless</span><span class="o">.</span><span class="n">macro_unless</span><span class="o">/</span><span class="m">2</span>
    <span class="p">(</span><span class="n">elixir</span><span class="p">)</span> <span class="n">src</span><span class="o">/</span><span class="n">elixir_dispatch</span><span class="o">.</span><span class="ss">erl:</span><span class="m">97</span><span class="p">:</span> <span class="ss">:elixir_dispatch</span><span class="o">.</span><span class="n">dispatch_require</span><span class="o">/</span><span class="m">6</span>
    <span class="p">(</span><span class="n">elixir</span><span class="p">)</span> <span class="n">lib</span><span class="o">/</span><span class="n">code</span><span class="o">.</span><span class="ss">ex:</span><span class="m">213</span><span class="p">:</span> <span class="no">Code</span><span class="o">.</span><span class="n">eval_quoted</span><span class="o">/</span><span class="m">3</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="no">Code</span><span class="o">.</span><span class="n">eval_quoted</span> <span class="p">[</span><span class="kn">quote</span><span class="p">(</span><span class="k">do</span><span class="p">:</span> <span class="kn">require</span> <span class="no">Unless</span><span class="p">),</span> <span class="n">expr</span><span class="p">]</span>
<span class="p">{[</span><span class="no">Unless</span><span class="p">,</span> <span class="no">nil</span><span class="p">],</span> <span class="p">[]}</span>
</code></pre></div></div>

<p>我们只运行当前的语法树，我们会发现当前的代码由于 <code class="highlighter-rouge">Unless</code> 模块没有加载导致宏找不到报错，所以我们在执行 <code class="highlighter-rouge">Unless.macro_unless</code> 之前需要先 <code class="highlighter-rouge">require</code> 对应的模块。</p>

<p><img src="https://img.draveness.me/2017-12-10-elixir-macro.png" alt="elixir-macro" /></p>

<p>在最开始对当前的宏进行定义时，我们就会发现宏其实输入的是一些语法元素，实现内部也通过 <code class="highlighter-rouge">quote</code> 和 <code class="highlighter-rouge">unquote</code> 方法对当前的语法树进行修改，最后返回新的语法树：</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmacro</span> <span class="n">macro_unless</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="k">do</span><span class="p">:</span> <span class="n">expression</span><span class="p">)</span> <span class="k">do</span>
  <span class="kn">quote</span> <span class="k">do</span>
    <span class="k">if</span><span class="p">(</span><span class="n">!unquote</span><span class="p">(</span><span class="n">clause</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="kn">unquote</span><span class="p">(</span><span class="n">expression</span><span class="p">))</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">iex</span><span class="o">&gt;</span> <span class="n">expr</span> <span class="o">=</span> <span class="kn">quote</span> <span class="k">do</span><span class="p">:</span> <span class="no">Unless</span><span class="o">.</span><span class="n">macro_unless</span> <span class="no">true</span><span class="p">,</span> <span class="k">do</span><span class="p">:</span> <span class="no">IO</span><span class="o">.</span><span class="n">puts</span> <span class="sd">"</span><span class="s2">this should never be printed"</span>
<span class="p">{{:</span><span class="o">.</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[{</span><span class="ss">:__aliases__</span><span class="p">,</span> <span class="p">[</span><span class="ss">alias:</span> <span class="no">false</span><span class="p">],</span> <span class="p">[</span><span class="ss">:Unless</span><span class="p">]},</span> <span class="ss">:macro_unless</span><span class="p">]},</span> <span class="p">[],</span>
 <span class="p">[</span><span class="no">true</span><span class="p">,</span>
  <span class="p">[</span><span class="k">do</span><span class="p">:</span> <span class="p">{{:</span><span class="o">.</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[{</span><span class="ss">:__aliases__</span><span class="p">,</span> <span class="p">[</span><span class="ss">alias:</span> <span class="no">false</span><span class="p">],</span> <span class="p">[</span><span class="ss">:IO</span><span class="p">]},</span> <span class="ss">:puts</span><span class="p">]},</span> <span class="p">[],</span>
    <span class="p">[</span><span class="sd">"</span><span class="s2">this should never be printed"</span><span class="p">]}]]}</span>

<span class="n">iex</span><span class="o">&gt;</span> <span class="no">Macro</span><span class="o">.</span><span class="n">expand_once</span> <span class="n">expr</span><span class="p">,</span> <span class="n">__ENV__</span>
<span class="p">{</span><span class="ss">:if</span><span class="p">,</span> <span class="p">[</span><span class="ss">context:</span> <span class="no">Unless</span><span class="p">,</span> <span class="kn">import</span><span class="p">:</span> <span class="no">Kernel</span><span class="p">],</span>
 <span class="p">[{</span><span class="ss">:!</span><span class="p">,</span> <span class="p">[</span><span class="ss">context:</span> <span class="no">Unless</span><span class="p">,</span> <span class="kn">import</span><span class="p">:</span> <span class="no">Kernel</span><span class="p">],</span> <span class="p">[</span><span class="no">true</span><span class="p">]},</span>
  <span class="p">[</span><span class="k">do</span><span class="p">:</span> <span class="p">{{:</span><span class="o">.</span><span class="p">,</span> <span class="p">[],</span>
     <span class="p">[{</span><span class="ss">:__aliases__</span><span class="p">,</span> <span class="p">[</span><span class="ss">alias:</span> <span class="no">false</span><span class="p">,</span> <span class="ss">counter:</span> <span class="o">-</span><span class="m">576460752303422687</span><span class="p">],</span> <span class="p">[</span><span class="ss">:IO</span><span class="p">]},</span>
      <span class="ss">:puts</span><span class="p">]},</span> <span class="p">[],</span> <span class="p">[</span><span class="sd">"</span><span class="s2">this should never be printed"</span><span class="p">]}]]}</span>
</code></pre></div></div>

<p>Elixir 中的宏相比于 C 语言中的宏更强大，这是因为它不是对代码中的文本直接进行替换，它能够为我们直接提供操作 Elixir 抽象语法树的能力，让我们能够参与到 Elixir 的编译过程，影响编译的结果；除此之外，Elixir 中的宏还是卫生宏（Hygiene Macro），宏中定义的参数并不会影响当前代码执行的上下文。</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">Example</span> <span class="k">do</span>
  <span class="k">defmacro</span> <span class="n">hygienic</span> <span class="k">do</span>
    <span class="kn">quote</span> <span class="k">do</span>
      <span class="n">val</span> <span class="o">=</span> <span class="m">1</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">iex</span><span class="o">&gt;</span> <span class="n">val</span> <span class="o">=</span> <span class="m">42</span>
<span class="m">42</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="no">Example</span><span class="o">.</span><span class="n">hygienic</span>
<span class="m">1</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">val</span>
<span class="m">42</span>
</code></pre></div></div>

<p>在上述代码中，虽然宏内部的变量与当前环境上下文中的变量重名了，但是宏内部的变量并没有影响上下文中 <code class="highlighter-rouge">val</code> 变量的变化，所以 Elixir 中宏系统是『卫生的』，如果我们真的想要改变上下文中的变量，可以使用 <code class="highlighter-rouge">var!</code> 来做这件事情：</p>

<div class="language-elixir highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">defmodule</span> <span class="no">Example</span> <span class="k">do</span>
  <span class="k">defmacro</span> <span class="n">unhygienic</span> <span class="k">do</span>
    <span class="kn">quote</span> <span class="k">do</span>
      <span class="n">var!</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">=</span> <span class="m">2</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">iex</span><span class="o">&gt;</span> <span class="n">val</span> <span class="o">=</span> <span class="m">42</span>
<span class="m">42</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="no">Example</span><span class="o">.</span><span class="n">unhygienic</span>
<span class="m">2</span>
<span class="n">iex</span><span class="o">&gt;</span> <span class="n">val</span>
<span class="m">2</span>
</code></pre></div></div>

<p>相比于使用文本替换的 C 语言宏，Elixir 的宏系统解决了很多问题，例如：卫生宏，不仅如此，Elixir 的宏还允许我们修改当前的代码中的语法树，提供了更加强大的表达能力。</p>

<h3 id="rust">Rust</h3>

<p>Elixir 的宏系统其实已经足够强大了，不止避免了基于文本替换的宏带来的各种问题，我们还可以直接使用宏操作上下文的语法树，作者在一段时间内都觉得 Elixir 的宏系统是接触到的最强大的宏系统，直到开始学习 <a href="https://www.rust-lang.org/en-US/">Rust</a> 才发现更复杂的宏系统。</p>

<p><img src="https://img.draveness.me/2017-12-10-rust-logo.png" alt="rust-logo" /></p>

<p>Rust 是一门非常有趣的编程语言，它是一门有着极高的性能的系统级的编程语言，能够避免当前应用中发生的段错误并且保证线程安全和内存安全，但是这些都不是我们今天想要关注的事情，与 Elixir 一样，在这篇文章中我们仅仅关心 Rust 的宏系统到底是什么样的：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="nv">$e:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="nd">println!</span><span class="p">(</span><span class="s">"mode X: {}"</span><span class="p">,</span> <span class="nv">$e</span><span class="p">));</span>
    <span class="p">(</span><span class="n">y</span> <span class="k">=&gt;</span> <span class="nv">$e:expr</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="nd">println!</span><span class="p">(</span><span class="s">"mode Y: {}"</span><span class="p">,</span> <span class="nv">$e</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面的 Rust 代码定义了一个名为 <code class="highlighter-rouge">foo</code> 的宏，我们在代码中需要使用 <code class="highlighter-rouge">foo!</code> 来调用上面定义的宏：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">foo!</span><span class="p">(</span><span class="n">y</span> <span class="k">=&gt;</span> <span class="mi">3</span><span class="p">);</span> <span class="c">// =&gt; mode Y: 3</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上述的宏 <code class="highlighter-rouge">foo</code> 的主体部分其实会将传入的<strong>语法元素</strong>与宏中的条件进行模式匹配，如果匹配到了，就会返回条件右侧的表达式，到这里其实与 Elixir 的宏系统没有太大的区别，Rust 宏相比 Elixir 更强大主要在于其提供了更加灵活的匹配系统，在宏 <code class="highlighter-rouge">foo</code> 的定义中使用的 <code class="highlighter-rouge">$e:expr</code> 就会匹配一个表达式并将表达式绑定到 <code class="highlighter-rouge">$e</code> 这个上下文的变量中，除此之外，在 Rust 中我们还可以组合使用以下的匹配符：</p>

<p><img src="https://img.draveness.me/2017-12-10-rust-macro-matcher-and-example.png" alt="rust-macro-matcher-and-example" /></p>

<p>为了实现功能更强大的宏系统，Rust 的宏还提供了重复操作符和递归宏的功能，结合这两个宏系统的特性，我们能直接使用宏构建一个生成 HTML 的 DSL：</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">macro_rules!</span> <span class="n">write_html</span> <span class="p">{</span>
    <span class="p">(</span><span class="nv">$w:expr</span><span class="p">,</span> <span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(());</span>

    <span class="p">(</span><span class="nv">$w:expr</span><span class="p">,</span> <span class="nv">$e:tt</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="nd">write!</span><span class="p">(</span><span class="nv">$w</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="nv">$e</span><span class="p">));</span>

    <span class="p">(</span><span class="nv">$w:expr</span><span class="p">,</span> <span class="nv">$tag:ident</span> <span class="p">[</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$inner:tt</span><span class="p">)</span><span class="o">*</span> <span class="p">]</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$rest:tt</span><span class="p">)</span><span class="o">*</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{{</span>
        <span class="nd">write!</span><span class="p">(</span><span class="nv">$w</span><span class="p">,</span> <span class="s">"&lt;{}&gt;"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$tag</span><span class="p">));</span>
        <span class="nd">write_html!</span><span class="p">(</span><span class="nv">$w</span><span class="p">,</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$inner</span><span class="p">)</span><span class="o">*</span><span class="p">);</span>
        <span class="nd">write!</span><span class="p">(</span><span class="nv">$w</span><span class="p">,</span> <span class="s">"&lt;/{}&gt;"</span><span class="p">,</span> <span class="nd">stringify!</span><span class="p">(</span><span class="nv">$tag</span><span class="p">));</span>
        <span class="nd">write_html!</span><span class="p">(</span><span class="nv">$w</span><span class="p">,</span> <span class="nv">$</span><span class="p">(</span><span class="nv">$rest</span><span class="p">)</span><span class="o">*</span><span class="p">);</span>
    <span class="p">}};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在上述的 <code class="highlighter-rouge">write_html</code> 宏中，我们总共有三个匹配条件，其中前两个是宏的终止条件，第一个条件不会做任何的操作，第二个条件会将匹配到的 Token 树求值并写回到传入的字符串引用 <code class="highlighter-rouge">$w</code> 中，最后的条件就是最有意思的部分了，在这里我们使用了形如的 <code class="highlighter-rouge">$(...)*</code> 语法来<strong>匹配零个或多个相同的语法元素</strong>，例如 <code class="highlighter-rouge">$($inner:tt)*</code> 就是匹配零个以上的 Token 树（tt）；在右侧的代码中递归调用了 <code class="highlighter-rouge">write_html</code> 宏并分别传入 <code class="highlighter-rouge">$($inner)*</code> 和 <code class="highlighter-rouge">$($rest)*</code> 两个参数，这样我们的 <code class="highlighter-rouge">write_html</code> 就能够解析 DSL 了。</p>

<p>有了 <code class="highlighter-rouge">write_html</code> 宏，我们就可以直接使用形如 <code class="highlighter-rouge">html[head[title["Macros guide"]]</code> 的代码返回如下所示的 HTML：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;html&gt;&lt;head&gt;&lt;title&gt;</span>Macros guide<span class="nt">&lt;/title&gt;&lt;/head&gt;&lt;/html&gt;</span>
</code></pre></div></div>

<blockquote>
  <p>这一节中提供的与 Rust 宏相关的例子都取自 <a href="https://doc.rust-lang.org/book/first-edition/macros.html">官方文档</a> 中对宏的介绍这一部分内容。</p>
</blockquote>

<p>Rust 的宏系统其实是基于一篇 1986 年的论文 <a href="https://www.cs.indiana.edu/ftp/techreports/TR206.pdf">Macro-by-Example</a> 实现的，如果想要深入了解 Rust 的宏系统可以阅读这篇论文；Rust 的宏系统确实非常完备也足够强大，能够做很多我们使用 C 语言宏时无法做到的事情，极大地提高了语言的表达能力。</p>

<h2 id="运行时runtime">运行时（Runtime）</h2>

<p>宏是一种能在程序执行的预编译或者编译期间改变代码行为的能力，通过编译期的处理过程赋予编程语言元编程能力；而运行时，顾名思义一般是指<strong>面向对象</strong>的编程语言在程序运行的某一个时间的上下文，在这里我们想要介绍的运行时可以理解为<strong>能够在运行期间改变对象行为的机制</strong>。</p>

<p><img src="https://img.draveness.me/2017-12-10-phases.png" alt="phases" /></p>

<p>当相应的行为在当前对象上没有被找到时，运行时会提供一个改变当前对象行为的入口，在篇文章中提到的运行时不是广义上的运行时系统，它特指<strong>面向对象语言在方法决议的过程中为外界提供的入口，让工程师提供的代码也能参与到当前的方法决议和信息发送的过程</strong>。</p>

<p>在这一节中，我们将介绍的两个使用了运行时的面向对象编程语言 Objective-C 和 Ruby，它们有着相似的消息发送的流程，但是由于 OOP 模型实现的不同导致方法调用的过程稍微有一些差别；除此之外，由于 Objective-C 是需要通过编译器编译成二进制文件才能执行的，而 Ruby 可以直接被各种解释器运行，所以两者的元编程能力也会受到这一差别的影响，我们会在下面展开进行介绍。</p>

<h3 id="objective-c">Objective-C</h3>

<p>Objective-C 是一种通用的面向对象编程语言，它将 Smalltalk 消息发送的语法引入了 C 语言；ObjC 语言的面向对象模型其实都是运行在 ObjC Runtime 上的，整个运行时也为 ObjC 提供了方法查找的策略。</p>

<p><img src="https://img.draveness.me/2017-12-10-objc-class-hierachy.png" alt="objc-class-hierachy" /></p>

<p>如上图所示，我们有一个 <code class="highlighter-rouge">Dog</code> 类的实例，当我们执行了 <code class="highlighter-rouge">dog.wtf</code> 方法时，运行时会先向右再向上的方式在整个继承链中查找相应的方法是否存在，如果当前方法在整个继承链中都完全不存在就会进入<strong>动态方法决议</strong>和<strong>消息转发</strong>的过程。</p>

<p><img src="https://img.draveness.me/2017-12-10-objc-message-resolution-and-forwarding.png" alt="objc-message-resolution-and-forwarding" /></p>

<blockquote>
  <p>上述图片取自 <a href="https://draveness.me/racdelegateproxy">从代理到 RACSignal</a>，使用时对图片中的颜色以及字号稍作修改。</p>
</blockquote>

<p>当 ObjC 的运行时在方法查找的过程中已经查找到了上帝类 <code class="highlighter-rouge">NSObject</code> 时，仍然没有找到方法的实现就会进入上面的流程，先执行的 <code class="highlighter-rouge">+resolveInstanceMethod:</code> 方法就是一个可以为当前的类添加方法的入口：</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">dynamicMethodIMP</span><span class="p">(</span><span class="n">id</span> <span class="n">self</span><span class="p">,</span> <span class="n">SEL</span> <span class="n">_cmd</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">+</span> <span class="p">(</span><span class="n">BOOL</span><span class="p">)</span><span class="nf">resolveInstanceMethod</span><span class="p">:(</span><span class="n">SEL</span><span class="p">)</span><span class="nv">aSEL</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">aSEL</span> <span class="o">==</span> <span class="k">@selector</span><span class="p">(</span><span class="n">resolveThisMethodDynamically</span><span class="p">))</span> <span class="p">{</span>
          <span class="n">class_addMethod</span><span class="p">([</span><span class="n">self</span> <span class="nf">class</span><span class="p">],</span> <span class="n">aSEL</span><span class="p">,</span> <span class="p">(</span><span class="n">IMP</span><span class="p">)</span> <span class="n">dynamicMethodIMP</span><span class="p">,</span> <span class="s">"v@:"</span><span class="p">);</span>
          <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">super</span> <span class="nf">resolveInstanceMethod</span><span class="p">:</span><span class="n">aSel</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在这里可以通过 <code class="highlighter-rouge">class_addMethod</code> 动态的为当前的类添加新的方法和对应的实现，如果错过了这个入口，我们就进入了消息转发的流程；在这里，我们有两种选择，一种情况是通过 <code class="highlighter-rouge">-forwardTargetForSelector:</code> 将当前方法的调用直接转发到其他方法上，另一种就是组合 <code class="highlighter-rouge">-methodSignatureForSelector:</code> 和 <code class="highlighter-rouge">-forwardInvocation:</code> 两个方法，直接执行一个 <code class="highlighter-rouge">NSInvocation</code> 对象。</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">forwardInvocation</span><span class="p">:(</span><span class="n">NSInvocation</span> <span class="o">*</span><span class="p">)</span><span class="nv">anInvocation</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">([</span><span class="n">someOtherObject</span> <span class="nf">respondsToSelector</span><span class="p">:[</span><span class="n">anInvocation</span> <span class="nf">selector</span><span class="p">]])</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">anInvocation</span> <span class="nf">invokeWithTarget</span><span class="p">:</span><span class="n">someOtherObject</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="p">[</span><span class="n">super</span> <span class="nf">forwardInvocation</span><span class="p">:</span><span class="n">anInvocation</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">-forwardTargetForSelector:</code> 方法只能简单地将方法直接转发给其他的对象，但是在 <code class="highlighter-rouge">-forwardInvocation:</code> 中我们可以得到一个 <code class="highlighter-rouge">NSInvocation</code> 实例，可以自由地选择需要执行哪些方法，并修改当前方法调用的上下文，包括：方法名、参数和目标对象。</p>

<p>虽然 Objective-C 的运行时系统能够为我们提供动态方法决议的功能，也就是某一个方法在编译期间哪怕不存在，我们也可以在运行时进行调用，这虽然听起来很不错，在很多时候我们都可以通过 <code class="highlighter-rouge">-performSelector:</code> 调用<strong>编译器看起来不存的方法</strong>，但是作为一门执行之前需要编译的语言，如果我们在 <code class="highlighter-rouge">+resolveInstanceMethod:</code> 中确实动态实现了一些方法，但是编译器在编译期间对这一切都毫不知情。</p>

<pre><code class="language-objectivec">void dynamicMethodIMP(id self, SEL _cmd) { }
+ (BOOL)resolveInstanceMethod:(SEL)aSEL {
    NSString *selector = NSStringFromSelector(aSEL);
    if ([selector hasPrefix:@"find"]) {
          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, "v@:");
          return YES;
    }
    return [super resolveInstanceMethod:aSel];
}

- (void)func {
    [self findFoo];
    [self findBar];
    [self find];
}
</code></pre>

<p>从 <code class="highlighter-rouge">-func</code> 中调用的三个以 <code class="highlighter-rouge">find</code> 开头的方法其实会在运行期间添加到当前类上，但是编译器在编译期间对此一无所知，所以它会提示编译错误，在编译期间将可以运行的代码拦截了下来，这样的代码如果跳过编译器检查，直接运行是不会出问题的，但是代码的执行必须通过编译器编译，这一过程是无法跳过的。</p>

<p><img src="https://img.draveness.me/2017-12-10-objc-compile-and-execute.png" alt="objc-compile-and-execute" /></p>

<p>我们只能通过 <code class="highlighter-rouge">-performSelector:</code> 方法绕过编译器的检查，不过使用 <code class="highlighter-rouge">-performSelector:</code> 会为代码添加非常多的噪音：</p>

<pre><code class="language-objectivec">- (void)func {
    [self performSelector:@selector(findFoo)];
    [self performSelector:@selector(findBar)];
    [self performSelector:@selector(find)];
}
</code></pre>

<p>所以虽然 Objective-C 通过运行时提供了比较强大的元编程能力，但是由于代码执行时需要经过编译器的检查，所以在很多时候我们都没有办法直接发挥运行时为我们带来的好处，需要通过其他的方式完成方法的调用。</p>

<h3 id="ruby">Ruby</h3>

<p>除了 Objective-C 之外，Ruby 也提供了一些相似的运行时修改行为的特性，它能够在运行时修改自身特性的功能还是建立在它的 OOP 模型之上；Ruby 提供了一些在运行期间能够改变自身行为的入口和 API 可以帮助我们快速为当前的类添加方法或者实例变量。</p>

<p><img src="https://img.draveness.me/2017-12-10-ruby-class-hierachy.png" alt="ruby-class-hierachy" /></p>

<p>当我们调用 <code class="highlighter-rouge">Dog</code> 实例的一个方法时，Ruby 会先找到当前对象的类，然后在由 <code class="highlighter-rouge">superclass</code> 构成的链上查找并调用相应的方法，这是 OOP 中非常常见的，<strong>向右再向上</strong>的方法查找过程。</p>

<p>与 Objective-C 几乎相同，Ruby 也提供了类似与 <code class="highlighter-rouge">+resolveInstanceMethod:</code> 的方法，如果方法在整个继承链上都完全不存在时，就会调用 <code class="highlighter-rouge">#method_missing</code> 方法，并传入与这次方法调用有关的参数：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="nb">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>传入的参数包括方法的符号，调用原方法时传入的参数和 block，在这里我们就可以为当前的类添加方法了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Dog</span>
  <span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">start_with?</span> <span class="s1">'find'</span>
      <span class="n">define_singleton_method</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">do</span> <span class="o">|*</span><span class="n">args</span><span class="o">|</span>
        <span class="nb">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="s2">, </span><span class="si">#{</span><span class="n">args</span><span class="si">}</span><span class="s2">"</span>
      <span class="k">end</span>
      <span class="nb">send</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="k">super</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>通过 Ruby 提供的一些 API，例如 <code class="highlighter-rouge">define_method</code>、<code class="highlighter-rouge">define_singleton_method</code> 我们可以直接在运行期间快速改变对象的行为，在使用时也非常简单：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="no">Dog</span><span class="p">.</span><span class="nf">new</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Dog:0x007fe31e3f87a8&gt;</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">.</span><span class="nf">find_by_name</span> <span class="s2">"dog"</span>
<span class="n">find_by_name</span><span class="p">,</span> <span class="p">[</span><span class="s2">"dog"</span><span class="p">]</span>
<span class="o">=&gt;</span> <span class="kp">nil</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">.</span><span class="nf">find_by_name</span> <span class="s2">"dog"</span><span class="p">,</span> <span class="s2">"another_dog"</span>
<span class="n">find_by_name</span><span class="p">,</span> <span class="p">[</span><span class="s2">"dog"</span><span class="p">,</span> <span class="s2">"another_dog"</span><span class="p">]</span>
<span class="o">=&gt;</span> <span class="kp">nil</span>
</code></pre></div></div>

<p>当我们调用以 <code class="highlighter-rouge">find</code> 开头的实例方法时，由于在当前实例的类以及父类上没有实现，所以就会进入 <code class="highlighter-rouge">#method_missing</code> 方法并为<strong>当前实例</strong>定义新的方法 <code class="highlighter-rouge">#find_by_name</code>。</p>

<blockquote>
  <p>注意：当前的 <code class="highlighter-rouge">#find_by_name</code> 方法只是定义在当前实例上的，存储在当前实例的单类上。</p>
</blockquote>

<p>由于 Ruby 是脚本语言，解释器在脚本执行之前不会对代码进行检查，所以哪怕在未执行期间并不存在的 <code class="highlighter-rouge">#find_by_name</code> 方法也不会导致解释器报错，在运行期间通过 <code class="highlighter-rouge">#define_singleton_method</code> 动态地
定义了新的 <code class="highlighter-rouge">#find_by_name</code> 方法修改了对象的行为，达到了为对象批量添加相似功能的目的。</p>

<h2 id="总结">总结</h2>

<p>在文章中介绍的两种不同的元编程能力，宏系统和运行时，前者通过预先定义好的一些宏规则，在预编译和编译期间对代码进行展开和替换，而后者提供了在运行期间改变代码行为的能力，两种方式的本质都是通过少量的代码生成一些非常相似的代码和逻辑，能够增强编程语言的表达能力并减少开发者的工作量。</p>

<p>无论是宏还是运行时其实都是简化程序中代码的一种手段，归根结底就是一种使用代码生成代码的思想，如果我们能够掌握这种元编程的思想并在编程中熟练的运用就能够很好地解决程序中一些诡异的问题，还能消灭重复的代码，提高我们运用以及掌控编程语言的能力，能够极大地增强编程语言的表达能力，所以元编程确实是一种非常重要并且需要学习的思想。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://en.m.wikipedia.org/wiki/Metaprogramming">Metaprogramming</a></li>
  <li><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/generics/differences-between-cpp-templates-and-csharp-generics">C++ 模板和 C# 泛型之间的区别（C# 编程指南）</a></li>
  <li><a href="https://www.zhihu.com/question/33304378">C++ 模板和 Java 泛型有什么异同？</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Macro_(computer_science)">Macro (computer science)</a></li>
  <li><a href="https://elixir-lang.org/getting-started/meta/macros.html">Macros · Elixir Doc</a></li>
  <li><a href="https://gcc.gnu.org/onlinedocs/cpp/Macros.html">Macros · GCC</a></li>
  <li><a href="http://hbprotoss.github.io/posts/cyu-yan-hong-de-te-shu-yong-fa-he-ji-ge-keng.html">C 语言宏的特殊用法和几个坑</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Hygienic_macro">Hygienic macro</a></li>
  <li><a href="https://elixirschool.com/en/lessons/advanced/metaprogramming/">Metaprogramming · ElixirSchool</a></li>
  <li><a href="https://doc.rust-lang.org/book/first-edition/macros.html">Macros · Rust Doc</a></li>
  <li><a href="https://www.cs.indiana.edu/ftp/techreports/TR206.pdf">Macro-by-Example</a></li>
  <li><a href="https://www.rust-lang.org/en-US/">Rust</a></li>
  <li><a href="https://draveness.me/message">从源代码看 ObjC 中消息的发送</a></li>
  <li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtDynamicResolution.html">Dynamic Method Resolution</a></li>
  <li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW1">Message Forwarding</a></li>
  <li><a href="https://draveness.me/racdelegateproxy">从代理到 RACSignal</a></li>
  <li><a href="https://developer.apple.com/documentation/objectivec/nsobject/1418500-resolveinstancemethod">resolveInstanceMethod(_:)</a></li>
  <li><a href="http://rubylearning.com/satishtalim/ruby_method_missing.html">Ruby Method Missing</a></li>
  <li><a href="https://www.leighhalliday.com/ruby-metaprogramming-method-missing">Ruby Metaprogramming - Method Missing</a></li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>Ruby Web 服务器的并发模型与性能</title>
	  <link>/blogs//ruby-webserver</link>
	  <author></author>
	  <pubDate>2017-11-17T00:00:00+00:00</pubDate>
	  <guid>/blogs//ruby-webserver</guid>
	  <description><![CDATA[
	     <ul>
  <li><a href="https://draveness.me/rack">谈谈 Rack 协议与实现</a></li>
  <li><a href="https://draveness.me/rack-webrick">浅谈 WEBrick 的多线程模型</a></li>
  <li><a href="https://draveness.me/rack-thin">浅谈 Thin 的事件驱动模型</a></li>
  <li><a href="https://draveness.me/rack-unicorn">浅谈 Unicorn 的多进程模型</a></li>
  <li><a href="https://draveness.me/rack-puma">浅谈 Puma 的并发模型与实现</a></li>
  <li><a href="https://draveness.me/ruby-webserver">Ruby Web 服务器的并发模型与性能</a></li>
</ul>

<p>这是整个 Rack 系列文章的最后一篇了，在之前其实也尝试写过很多系列文章，但是到最后都因为各种原因放弃了，最近由于自己对 Ruby 的 webserver 非常感兴趣，所以看了下社区中常见 webserver 的实现原理，包括 WEBrick、Thin、Unicorn 和 Puma，虽然在 Ruby 社区中也有一些其他的 webserver 有着比较优异的性能，但是在这有限的文章中也没有办法全都介绍一遍。</p>

<p><img src="https://img.draveness.me/2017-11-17-webservers.png" alt="webservers" /></p>

<p>在这篇文章中，作者想对 Ruby 社区中不同 webserver 的实现原理和并发模型进行简单的介绍，总结一下前面几篇文章中的内容。</p>

<blockquote>
  <p>文中所有的压力测试都是在内存 16GB、8 CPU、2.6 GHz Intel Core i7 的 macOS 上运行的，如果你想要复现这里的测试可能不会得到完全相同的结果。</p>
</blockquote>

<h2 id="webrick">WEBrick</h2>

<p>WEBrick 是 Ruby 社区中非常古老的 Web 服务器，从 2000 年到现在已经有了将近 20 年的历史了，虽然 WEBrick 有着非常多的问题，但是迄今为止 WEBrick 也是开发环境中最常用的 Ruby 服务器；它使用了最为简单、直接的并发模型，运行一个 WEBrick 服务器只会在后台启动一个进程，默认监听来自 9292 端口的请求。</p>

<p><img src="https://img.draveness.me/2017-11-17-webrick-concurrency-model.png" alt="webrick-concurrency-model" /></p>

<p>当 WEBrick 通过 <code class="highlighter-rouge">.select</code> 方法监听到来自客户端的请求之后，会为每一个请求创建一个单独 <code class="highlighter-rouge">Thread</code> 并在新的线程中处理 HTTP 请求。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">run</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">env</span><span class="o">|</span> <span class="p">[</span><span class="s1">'200'</span><span class="p">,</span> <span class="p">{</span><span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'text/plain'</span><span class="p">},</span> <span class="p">[</span><span class="s1">'get rack\'d'</span><span class="p">]]</span> <span class="p">}</span>
</code></pre></div></div>
<p>如果我们如果创建一个最简单的 Rack 应用，直接返回所有的 HTTP 响应，那么使用下面的命令对 WEBrick 的服务器进行测试会得到如下的结果：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Concurrency Level:      100
Time taken <span class="k">for </span>tests:   22.519 seconds
Complete requests:      10000
Failed requests:        0
Total transferred:      2160000 bytes
HTML transferred:       200000 bytes
Requests per second:    444.07 <span class="o">[</span><span class="c">#/sec] (mean)</span>
Time per request:       225.189 <span class="o">[</span>ms] <span class="o">(</span>mean<span class="o">)</span>
Time per request:       2.252 <span class="o">[</span>ms] <span class="o">(</span>mean, across all concurrent requests<span class="o">)</span>
Transfer rate:          93.67 <span class="o">[</span>Kbytes/sec] received
</code></pre></div></div>

<p>在处理 ApacheBench 发出的 10000 个 HTTP 请求时，WEBrick 对于每个请求平均消耗了 225.189ms，每秒处理了 444.07 个请求；除此之外，在处理请求的过程中 WEBrick 进程的 CPU 占用率很快达到了 100%，通过这个测试我们就可以看出为什么不应该在生产环境中使用 WEBrick 作为 Ruby 的应用服务器，在业务逻辑和代码更加复杂的情况下，WEBrick 的性能想必也不会达到期望。</p>

<h2 id="thin">Thin</h2>

<p>在 2006 和 2007 两年，Ruby 社区中发布了两个至今都非常重要的开源项目，其中一个是 Mongrel，它提供了标准的 HTTP 接口，同时多语言的支持也使得 Mongrel 在当时非常流行，另一个项目就是 Rack 了，它在 Web 应用和 Web 服务器之间建立了一套统一的 <a href="https://www.google.com/search?client=safari&amp;rls=en&amp;q=rack+spec&amp;ie=UTF-8&amp;oe=UTF-8">标准</a>，规定了两者的协作方式，所有的应用只要遵循 Rack 协议就能够随时替换底层的应用服务器。</p>

<p><img src="https://img.draveness.me/2017-11-17-rack-protocol.png" alt="rack-protoco" /></p>

<p>随后，在 2009 年出现的 Thin 就站在了巨人的肩膀上，同时遵循了 Rack 协议并使用了 Mongrel 中的解析器，而它也是 Ruby 社区中第一个使用 Reactor 模型的 Web 服务器。</p>

<p><img src="https://img.draveness.me/2017-11-17-thin-concurrency-model.png" alt="thin-concurrency-model" /></p>

<p>Thin 使用 Reactor 模型处理客户端的 HTTP 请求，每一个请求都会交由 EventMachine，通过内部对事件的分发，最终执行相应的回调，这种事件驱动的 IO 模型与 node.js 非常相似，使用单进程单线程的并发模型却能够快速处理 HTTP 请求；在这里，我们仍然使用 ApacheBench 以及同样的负载对 Thin 的性能进行简单的测试。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Concurrency Level:      100
Time taken <span class="k">for </span>tests:   4.221 seconds
Complete requests:      10000
Failed requests:        0
Total transferred:      880000 bytes
HTML transferred:       100000 bytes
Requests per second:    2368.90 <span class="o">[</span><span class="c">#/sec] (mean)</span>
Time per request:       42.214 <span class="o">[</span>ms] <span class="o">(</span>mean<span class="o">)</span>
Time per request:       0.422 <span class="o">[</span>ms] <span class="o">(</span>mean, across all concurrent requests<span class="o">)</span>
Transfer rate:          203.58 <span class="o">[</span>Kbytes/sec] received
</code></pre></div></div>

<p>对于一个相同的 HTTP 请求，Thin 的吞吐量大约是 WEBrick 的四倍，每秒能够处理 2368.90 个请求，同时处理的速度也大幅降低到了 42.214ms；在压力测试的过程中虽然 CPU 占用率有所上升但是在处理的过程中完全没有超过 90%，可以说 Thin 的性能碾压了 WEBrick，这可能也是开发者都不会在生产环境中使用 WEBrick 的最重要原因。</p>

<p>但是同样作为单进程运行的 Thin，由于没有 master 进程的存在，哪怕当前进程由于各种各样奇怪的原因被操作系统杀掉，我们也不会收到任何的通知，只能手动重启应用服务器。</p>

<h2 id="unicorn">Unicorn</h2>

<p>与 Thin 同年发布的 Unicorn 虽然也是 Mongrel 项目的一个 fork，但是使用了完全不同的并发模型，每Unicorn 内部通过多次 <code class="highlighter-rouge">fork</code> 创建多个 worker 进程，所有的 worker 进程也都由一个 master 进程管理和控制：</p>

<p><img src="https://img.draveness.me/2017-11-17-unicorn-master-workers.png" alt="unicorn-master-workers" /></p>

<p>由于 master 进程的存在，当 worker 进程被意外杀掉后会被 master 进程重启，能够保证持续对外界提供服务，多个进程的 worker 也能够很好地压榨多核 CPU 的性能，尽可能地提高请求的处理速度。</p>

<p><img src="https://img.draveness.me/2017-11-17-unicorn-concurrency-model.png" alt="unicorn-concurrency-model" /></p>

<p>一组由 master 管理的 Unicorn worker 会监听绑定的两个 Socket，所有来自客户端的请求都会通过操作系统内部的负载均衡进行调度，将请求分配到不同的 worker 进程上进行处理。</p>

<p>不过由于 Unicorn 虽然使用了多进程的并发模型，但是每个 worker 进程在处理请求时都是用了阻塞 I/O 的方式，所以如果客户端非常慢就会大大影响 Unicorn 的性能，不过这个问题就可以通过反向代理来 nginx 解决。</p>

<p><img src="https://img.draveness.me/2017-11-17-unicorn-multi-processes.png" alt="unicorn-multi-processes" /></p>

<p>在配置 Unicorn 的 worker 数时，为了最大化的利用 CPU 资源，往往会将进程数设置为 CPU 的数量，同样我们使用 ApacheBench 以及相同的负载测试一个使用 8 核 CPU 的 Unicorn 服务的处理效率：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Concurrency Level:      100
Time taken <span class="k">for </span>tests:   2.401 seconds
Complete requests:      10000
Failed requests:        0
Total transferred:      1110000 bytes
HTML transferred:       100000 bytes
Requests per second:    4164.31 <span class="o">[</span><span class="c">#/sec] (mean)</span>
Time per request:       24.014 <span class="o">[</span>ms] <span class="o">(</span>mean<span class="o">)</span>
Time per request:       0.240 <span class="o">[</span>ms] <span class="o">(</span>mean, across all concurrent requests<span class="o">)</span>
Transfer rate:          451.41 <span class="o">[</span>Kbytes/sec] received
</code></pre></div></div>

<p>经过简单的压力测试，当前的一组 Unicorn 服务每秒能够处理 4000 多个请求，每个请求也只消耗了 24ms 的时间，比起使用单进程的 Thin 确实有着比较多的提升，但是并没有数量级的差距。</p>

<p>除此之外，Unicorn 由于其多进程的实现方式会占用大量的内存，在并行的处理大量请求时你可以看到内存的使用量有比较明显的上升。</p>

<h2 id="puma">Puma</h2>

<p>距离 Ruby 社区的第一个 webserver WEBrick 发布的 11 年之后的 2011 年，Puma 正式发布了，它与 Thin 和 Unicorn 一样都从 Mongrel 中继承了 HTTP 协议的解析器，不仅如此它还基于 Rack 协议重新对底层进行了实现。</p>

<p><img src="https://img.draveness.me/2017-11-17-puma-cluster-mode.png" alt="puma-cluster-mode" /></p>

<p>与 Unicorn 不同的是，Puma 是用了多进程加多线程模型，它可以同时在 fork 出来的多个 worker 中创建多个线程来处理请求；不仅如此 Puma 还实现了用于提高并发速度的 Reactor 模块和线程池能够在提升吞吐量的同时，降低内存的消耗。</p>

<p><img src="https://img.draveness.me/2017-11-17-puma-concurrency-model.png" alt="puma-concurrency-mode" /></p>

<p>但是由于 MRI 的存在，往往都需要使用 JRuby 才能最大化 Puma 服务器的性能，但是即便如此，使用 MRI 的 Puma 的吞吐量也能够轻松达到 Unicorn 的两倍。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Concurrency Level:      100
Time taken <span class="k">for </span>tests:   1.057 seconds
Complete requests:      10000
Failed requests:        0
Total transferred:      750000 bytes
HTML transferred:       100000 bytes
Requests per second:    9458.08 <span class="o">[</span><span class="c">#/sec] (mean)</span>
Time per request:       10.573 <span class="o">[</span>ms] <span class="o">(</span>mean<span class="o">)</span>
Time per request:       0.106 <span class="o">[</span>ms] <span class="o">(</span>mean, across all concurrent requests<span class="o">)</span>
Transfer rate:          692.73 <span class="o">[</span>Kbytes/sec] received
</code></pre></div></div>

<p>在这里我们创建了 8 个 Puma 的 worker，每个 worker 中都包含 16~32 个用于处理用户请求的线程，每秒中处理的请求数接近 10000，处理时间也仅为 10.573ms，多进程、多线程以及 Reactor 模式的协作确实能够非常明显的增加 Web 服务器的工作性能和吞吐量。</p>

<p>在 Puma 的 <a href="http://puma.io">官方网站</a> 中，有一张不同 Web 服务器内存消耗的对比图：</p>

<p><img src="https://img.draveness.me/2017-11-17-memory-usage-comparision.png" alt="memory-usage-comparision" /></p>

<p>我们可以看到，与 Unicorn 相比 Puma 的内存使用量几乎可以忽略不计，它明显解决了多个 worker 占用大量内存的问题；不过使用了多线程模型的 Puma 需要开发者在应用中保证不同的线程不会出现竞争条件的问题，Unicorn 的多进程模型就不需要开发者思考这样的事情。</p>

<h2 id="对比">对比</h2>

<p>上述四种不同的 Web 服务器其实有着比较明显的性能差异，在使用同一个最简单的 Web 应用时，不同的服务器表现出了差异巨大的吞吐量：</p>

<p><img src="https://img.draveness.me/2017-11-17-ruby-webservers.jpeg" alt="ruby-webservers" /></p>

<p>Puma 和 Unicorn 两者之间可能还没有明显的数量级差距，1 倍的吞吐量差距也可能很容易被环境因素抹平了，但是 WEBrick 可以说是绝对无法与其他三者匹敌的。</p>

<p>上述的不同服务器其实有着截然不同的 I/O 并发模型，因为 MRI 中 GIL 的存在我们很难利用多核 CPU 的计算资源，所以大多数多线程模型在 MRI 上的性能可能只比单线程略好，达不到完全碾压的效果，但是 JRuby 或者 Rubinius 的使用确实能够利用多核 CPU 的计算资源，从而增加多线程模型的并发效率。</p>

<p><img src="https://img.draveness.me/2017-11-17-jruby.png" alt="jruby" /></p>

<p>传统的 I/O 模型就是在每次接收到客户端的请求时 fork 出一个新的进程来处理当前的请求或者在服务器启动时就启动多个进程，每一个进程在同一时间只能处理一个请求，所以这种并发模型的吞吐量有限，在今天已经几乎看不到使用 <strong>accept &amp; fork</strong> 这种方式处理请求的服务器了。</p>

<p>目前最为流行的方式还是混合多种 I/O 模型，同时使用多进程和多线程压榨 CPU 计算资源，例如 Phusion Passenger 或者 Puma 都支持在单进程和多进程、单线程和多线程之前来回切换，配置的不同会创建不同的并发模型，可以说是 Web 服务器中最好的选择了。</p>

<p>最后要说的 Thin 其实使用了非常不同的 I/O 模型，也就是事件驱动模型，这种模型在 Ruby 社区其实并没有那么热门，主要是因为 Rails 框架以及 Ruby 社区中的大部分项目并没有按照 Reactor 模型的方式进行设计，默认的文件 I/O 也都是阻塞的，而 Ruby 本身也可以利用多进程和多线程的计算资源，没有必要使用事件驱动的方式最大化并发量。</p>

<p><img src="https://img.draveness.me/2017-11-17-nodejs-logo.jpg" alt="nodejs-logo" /></p>

<p>Node.js 就完全不同了。Javascript 作为一个所有操作都会阻塞主线程的语言，更加需要事件驱动模型让主线程只负责接受 HTTP 请求，其余的脏活累活都交给线程池来做了，结果的返回都通过回调的形式通知主线程，这样才能提高吞吐量。</p>

<h2 id="总结">总结</h2>

<p>在这个系列的文章中，我们先后介绍了 Rack 的实现原理以及 Rack 协议，还有四种 webserver 包括 WEBrick、Thin、Unicorn 和 Puma 的实现，除了这四种应用服务器之外，Ruby 社区中还有其他的应用服务器，例如：Rainbows 和 Phusion Passenger，它们都有各自的实现以及优缺点。</p>

<p>从当前的情况来看，还是更推荐开发者使用 Puma 或者 Phusion Passenger 作为应用的服务器，这样能获得最佳的效果。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://read01.com/zh-hk/zm5B.html#.Wf0oLduB0sk">Ruby Web 服务器：这十五年</a></li>
  <li><a href="https://ruby-china.org/topics/25276">Ruby 服务器对比</a></li>
  <li><a href="https://ruby-china.org/topics/10832">Ruby 的多线程应用服务器介绍</a></li>
  <li><a href="https://stackoverflow.com/questions/4113299/ruby-on-rails-server-options">Ruby on Rails Server options</a></li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>浅谈 Puma 的并发模型与实现</title>
	  <link>/blogs//rack-puma</link>
	  <author></author>
	  <pubDate>2017-11-10T00:00:00+00:00</pubDate>
	  <guid>/blogs//rack-puma</guid>
	  <description><![CDATA[
	     <ul>
  <li><a href="https://draveness.me/rack">谈谈 Rack 协议与实现</a></li>
  <li><a href="https://draveness.me/rack-webrick">浅谈 WEBrick 的多线程模型</a></li>
  <li><a href="https://draveness.me/rack-thin">浅谈 Thin 的事件驱动模型</a></li>
  <li><a href="https://draveness.me/rack-unicorn">浅谈 Unicorn 的多进程模型</a></li>
  <li><a href="https://draveness.me/rack-puma">浅谈 Puma 的并发模型与实现</a></li>
  <li><a href="https://draveness.me/ruby-webserver">Ruby Web 服务器的并发模型与性能</a></li>
</ul>

<p>这篇文章已经是整个 Rack 系列文章的第五篇了，在前面的文章中我们见到了多线程模型、多进程模型以及事件驱动的 I/O 模型，对于几种常见的 webserver 已经很了解了，其实无论是 Ruby 还是其他社区对于 webserver 的实现也就是这么几种方式：多线程、多线程和 Reactor。</p>

<p><img src="https://img.draveness.me/2017-11-10-puma-logo.png" alt="puma-logo" /></p>

<p>在这篇文章中要介绍的 Puma 只是混合了两种 I/O 模型，同时使用多进程和多线程来提高应用的并行能力。</p>

<blockquote>
  <p>文中使用的 Puma 版本是 v3.10.0，如果你使用了不同版本的 Puma，原理上的区别不会太大，只是在一些方法的实现上会有一些细微的不同。</p>
</blockquote>

<h2 id="rack-默认处理器">Rack 默认处理器</h2>

<p>Puma 是目前 Rack 中优先级最高的默认 webserver，如果直接使用 <code class="highlighter-rouge">rackup</code> 命令并且当前机器上安装了 <code class="highlighter-rouge">puma</code>，那么 Rack 会自动选择 Puma 作为当前处理 HTTP 请求的服务器：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">default</span>
  <span class="n">pick</span> <span class="p">[</span><span class="s1">'puma'</span><span class="p">,</span> <span class="s1">'thin'</span><span class="p">,</span> <span class="s1">'webrick'</span><span class="p">]</span>
<span class="k">end</span>

<span class="err">$</span> <span class="n">rackup</span>
<span class="no">Puma</span> <span class="n">starting</span> <span class="k">in</span> <span class="n">single</span> <span class="n">mode</span><span class="o">...</span>
<span class="o">*</span> <span class="no">Version</span> <span class="mf">3.10</span><span class="o">.</span><span class="mi">0</span> <span class="p">(</span><span class="n">ruby</span> <span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span><span class="o">-</span><span class="n">p222</span><span class="p">),</span> <span class="ss">codename: </span><span class="no">Russell</span><span class="err">'</span><span class="n">s</span> <span class="no">Teapot</span>
<span class="o">*</span> <span class="no">Min</span> <span class="ss">threads: </span><span class="mi">0</span><span class="p">,</span> <span class="n">max</span> <span class="ss">threads: </span><span class="mi">16</span>
<span class="o">*</span> <span class="no">Environment</span><span class="p">:</span> <span class="n">development</span>
<span class="o">*</span> <span class="no">Listening</span> <span class="n">on</span> <span class="n">tcp</span><span class="ss">:/</span><span class="o">/</span><span class="n">localhost</span><span class="p">:</span><span class="mi">9292</span>
<span class="no">Use</span> <span class="no">Ctrl</span><span class="o">-</span><span class="no">C</span> <span class="n">to</span> <span class="n">stop</span>
</code></pre></div></div>

<p>通过在 <code class="highlighter-rouge">Rack::Handler</code> 下创建一个新的 <code class="highlighter-rouge">module Puma</code> 再实现类方法 <code class="highlighter-rouge">.run</code>，我们就可以直接将启动的过程转交给 <code class="highlighter-rouge">Puma::Launcher</code> 处理：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Rack</span>
  <span class="k">module</span> <span class="nn">Handler</span>
    <span class="k">module</span> <span class="nn">Puma</span>
      <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">run</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
        <span class="n">conf</span>   <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">config</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">options</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="ss">:Silent</span><span class="p">)</span> <span class="p">?</span> <span class="o">::</span><span class="no">Puma</span><span class="o">::</span><span class="no">Events</span><span class="p">.</span><span class="nf">strings</span> <span class="p">:</span> <span class="o">::</span><span class="no">Puma</span><span class="o">::</span><span class="no">Events</span><span class="p">.</span><span class="nf">stdio</span>
        <span class="n">launcher</span> <span class="o">=</span> <span class="o">::</span><span class="no">Puma</span><span class="o">::</span><span class="no">Launcher</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="ss">:events</span> <span class="o">=&gt;</span> <span class="n">events</span><span class="p">)</span>

        <span class="k">yield</span> <span class="n">launcher</span> <span class="k">if</span> <span class="nb">block_given?</span>
        <span class="k">begin</span>
          <span class="n">launcher</span><span class="p">.</span><span class="nf">run</span>
        <span class="k">rescue</span> <span class="no">Interrupt</span>
          <span class="nb">puts</span> <span class="s2">"* Gracefully stopping, waiting for requests to finish"</span>
          <span class="n">launcher</span><span class="p">.</span><span class="nf">stop</span>
          <span class="nb">puts</span> <span class="s2">"* Goodbye!"</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="启动器-launcher">启动器 Launcher</h2>

<p>Puma 中的启动器确实没有做太多的工作，大部分的代码其实都是在做配置，从 <code class="highlighter-rouge">ENV</code> 和上下文的环境中读取参数，而整个初始化方法中需要注意的地方也只有不同 <code class="highlighter-rouge">@runner</code> 的初始化了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">launcher</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">44</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Launcher</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">launcher_args</span><span class="o">=</span><span class="p">{})</span>
  <span class="vi">@runner</span>        <span class="o">=</span> <span class="kp">nil</span>
  <span class="vi">@events</span>        <span class="o">=</span> <span class="n">launcher_args</span><span class="p">[</span><span class="ss">:events</span><span class="p">]</span> <span class="o">||</span> <span class="no">Events</span><span class="o">::</span><span class="no">DEFAULT</span>
  <span class="vi">@argv</span>          <span class="o">=</span> <span class="n">launcher_args</span><span class="p">[</span><span class="ss">:argv</span><span class="p">]</span> <span class="o">||</span> <span class="p">[]</span>
  <span class="vi">@config</span>        <span class="o">=</span> <span class="n">conf</span>
  <span class="vi">@config</span><span class="p">.</span><span class="nf">load</span>

  <span class="no">Dir</span><span class="p">.</span><span class="nf">chdir</span><span class="p">(</span><span class="vi">@restart_dir</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">clustered?</span>
    <span class="vi">@events</span><span class="p">.</span><span class="nf">formatter</span> <span class="o">=</span> <span class="no">Events</span><span class="o">::</span><span class="no">PidFormatter</span><span class="p">.</span><span class="nf">new</span>
    <span class="vi">@options</span><span class="p">[</span><span class="ss">:logger</span><span class="p">]</span> <span class="o">=</span> <span class="vi">@events</span>

    <span class="vi">@runner</span> <span class="o">=</span> <span class="no">Cluster</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="vi">@events</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="vi">@runner</span> <span class="o">=</span> <span class="no">Single</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="vi">@events</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="vi">@status</span> <span class="o">=</span> <span class="ss">:run</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">#initialize</code> 方法中，<code class="highlighter-rouge">@runner</code> 的初始化是根据当前配置中的 worker 数决定的，如果当前的 <code class="highlighter-rouge">worker &gt; 0</code>，那么就会选择 <code class="highlighter-rouge">Cluster</code> 作为 <code class="highlighter-rouge">@runner</code>，否则就会选择 <code class="highlighter-rouge">Single</code>，在初始化结束之后会执行 <code class="highlighter-rouge">Launcher#run</code> 方法启动当前的 Puma 进程：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">launcher</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">165</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Launcher</span>

<span class="k">def</span> <span class="nf">run</span>
  <span class="n">previous_env</span> <span class="o">=</span> <span class="no">ENV</span><span class="p">.</span><span class="nf">to_h</span>

  <span class="n">setup_signals</span>
  <span class="vi">@runner</span><span class="p">.</span><span class="nf">run</span>

  <span class="k">case</span> <span class="vi">@status</span>
  <span class="k">when</span> <span class="ss">:halt</span>
    <span class="n">log</span> <span class="s2">"* Stopping immediately!"</span>
  <span class="k">when</span> <span class="ss">:run</span><span class="p">,</span> <span class="ss">:stop</span>
    <span class="n">graceful_stop</span>
  <span class="k">when</span> <span class="ss">:restart</span>
    <span class="n">log</span> <span class="s2">"* Restarting..."</span>
    <span class="no">ENV</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="n">previous_env</span><span class="p">)</span>
    <span class="vi">@runner</span><span class="p">.</span><span class="nf">before_restart</span>
    <span class="n">restart!</span>
  <span class="k">when</span> <span class="ss">:exit</span>
    <span class="c1"># nothing</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个简单的 <code class="highlighter-rouge">#run</code> 方法中，Puma 通过 <code class="highlighter-rouge">#setup_singals</code> 设置了一些信号的响应过程，在这之后执行 <code class="highlighter-rouge">Runner#run</code> 启动 Puma 的服务。</p>

<h2 id="启动服务">启动服务</h2>

<p>根据配置文件中不同的配置项，Puma 在启动时有两种不同的选择，一种是当前的 worker 数为 0，这时会通过 <code class="highlighter-rouge">Single</code> 启动单机模式的 Puma 进程，另一种情况是 worker 数大于 0，它使用 <code class="highlighter-rouge">Cluster</code> 的 runner 启动一组 Puma 进程。</p>

<p><img src="https://img.draveness.me/2017-11-10-single-cluster.png" alt="single-cluster" /></p>

<p>在这一节中文章将会简单介绍不同的 runner 是如何启动 Puma 进程的。</p>

<h3 id="单机模式">单机模式</h3>

<p>Puma 单机模式的启动通过 <code class="highlighter-rouge">Single</code> 类来处理，而定义这个类的文件 single.rb 中其实并没有多少代码，我们从中就可以看到单机模式下 Puma 的启动其实并不复杂：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">single</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">40</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Single</span>

<span class="k">def</span> <span class="nf">run</span>
  <span class="n">output_header</span> <span class="s2">"single"</span>

  <span class="k">if</span> <span class="n">daemon?</span>
    <span class="n">log</span> <span class="s2">"* Daemonizing..."</span>
    <span class="no">Process</span><span class="p">.</span><span class="nf">daemon</span><span class="p">(</span><span class="kp">true</span><span class="p">)</span>
    <span class="n">redirect_io</span>
  <span class="k">end</span>

  <span class="n">load_and_bind</span>
  <span class="vi">@launcher</span><span class="p">.</span><span class="nf">write_state</span>
  <span class="vi">@server</span> <span class="o">=</span> <span class="n">server</span> <span class="o">=</span> <span class="n">start_server</span>

  <span class="k">begin</span>
    <span class="n">server</span><span class="p">.</span><span class="nf">run</span><span class="p">.</span><span class="nf">join</span>
  <span class="k">rescue</span> <span class="no">Interrupt</span>
    <span class="c1"># Swallow it</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果我们启动了后台模式，就会通过 Puma 为 Process 模块扩展的方法 <code class="highlighter-rouge">.daemon</code> 在后台启动新的 Puma 进程，启动的过程其实和 Unicorn 中的差不多：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">daemon_ext</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">12</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Process&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">daemon</span><span class="p">(</span><span class="n">nochdir</span><span class="o">=</span><span class="kp">false</span><span class="p">,</span> <span class="n">noclose</span><span class="o">=</span><span class="kp">false</span><span class="p">)</span>
  <span class="nb">exit</span> <span class="k">if</span> <span class="nb">fork</span>
  <span class="no">Process</span><span class="p">.</span><span class="nf">setsid</span>
  <span class="nb">exit</span> <span class="k">if</span> <span class="nb">fork</span>

  <span class="no">Dir</span><span class="p">.</span><span class="nf">chdir</span> <span class="s2">"/"</span> <span class="k">unless</span> <span class="n">nochdir</span>

  <span class="k">if</span> <span class="o">!</span><span class="n">noclose</span>
    <span class="no">STDIN</span><span class="p">.</span><span class="nf">reopen</span> <span class="no">File</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="s2">"/dev/null"</span><span class="p">,</span> <span class="s2">"r"</span><span class="p">)</span>
    <span class="n">null_out</span> <span class="o">=</span> <span class="no">File</span><span class="p">.</span><span class="nf">open</span> <span class="s2">"/dev/null"</span><span class="p">,</span> <span class="s2">"w"</span>
    <span class="no">STDOUT</span><span class="p">.</span><span class="nf">reopen</span> <span class="n">null_out</span>
    <span class="no">STDERR</span><span class="p">.</span><span class="nf">reopen</span> <span class="n">null_out</span>
  <span class="k">end</span>

  <span class="mi">0</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 Puma 中通过两次 <code class="highlighter-rouge">fork</code> 同时将当前进程从终端中分离出来，最终就可以得到一个独立的 Puma 进程，你可以通过下面的图片简单理解这个过程：</p>

<p><img src="https://img.draveness.me/2017-11-10-puma-daemonize.png" alt="puma-daemonize" /></p>

<p>当我们在后台启动了一个 Puma 的 master 进程之后就可以开始启动 Puma 的服务器了，也就是 <code class="highlighter-rouge">Puma::Server</code> 的实例：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">runner</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">151</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Runner</span>

<span class="k">def</span> <span class="nf">start_server</span>
  <span class="n">min_t</span> <span class="o">=</span> <span class="vi">@options</span><span class="p">[</span><span class="ss">:min_threads</span><span class="p">]</span>
  <span class="n">max_t</span> <span class="o">=</span> <span class="vi">@options</span><span class="p">[</span><span class="ss">:max_threads</span><span class="p">]</span>

  <span class="n">server</span> <span class="o">=</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Server</span><span class="p">.</span><span class="nf">new</span> <span class="n">app</span><span class="p">,</span> <span class="vi">@launcher</span><span class="p">.</span><span class="nf">events</span><span class="p">,</span> <span class="vi">@options</span>
  <span class="n">server</span><span class="p">.</span><span class="nf">min_threads</span> <span class="o">=</span> <span class="n">min_t</span>
  <span class="n">server</span><span class="p">.</span><span class="nf">max_threads</span> <span class="o">=</span> <span class="n">max_t</span>
  <span class="n">server</span><span class="p">.</span><span class="nf">inherit_binder</span> <span class="vi">@launcher</span><span class="p">.</span><span class="nf">binder</span>

  <span class="k">if</span> <span class="vi">@options</span><span class="p">[</span><span class="ss">:mode</span><span class="p">]</span> <span class="o">==</span> <span class="ss">:tcp</span>
    <span class="n">server</span><span class="p">.</span><span class="nf">tcp_mode!</span>
  <span class="k">end</span>

  <span class="k">unless</span> <span class="n">development?</span>
    <span class="n">server</span><span class="p">.</span><span class="nf">leak_stack_on_error</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="k">end</span>

  <span class="n">server</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这里有很多不是特别重要的代码，需要注意的是 <code class="highlighter-rouge">Server</code> 初始化的过程以及最大、最小线程数的设置，这些信息都是通过命令行或者配置文件传入的，例如 <code class="highlighter-rouge">puma -t 8:32</code> 表示当前的最小线程数为 8、最大线程数为 32 个，Puma 会根据当前的流量自动调节同一个进程中的线程个数。</p>

<p>服务在启动时会创建一个线程池 <code class="highlighter-rouge">ThreadPool</code> 并传入一个用于处理请求的 block，这个方法的实现其实非常长，这里省略了很多代码；</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">255</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">background</span><span class="o">=</span><span class="kp">true</span><span class="p">)</span>
  <span class="n">queue_requests</span> <span class="o">=</span> <span class="vi">@queue_requests</span>

  <span class="vi">@thread_pool</span> <span class="o">=</span> <span class="no">ThreadPool</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@min_threads</span><span class="p">,</span>
                                <span class="vi">@max_threads</span><span class="p">,</span>
                                <span class="no">IOBuffer</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">client</span><span class="p">,</span> <span class="n">buffer</span><span class="o">|</span>
    <span class="n">process_now</span> <span class="o">=</span> <span class="kp">false</span>

    <span class="k">begin</span>
      <span class="k">if</span> <span class="n">queue_requests</span>
        <span class="n">process_now</span> <span class="o">=</span> <span class="n">client</span><span class="p">.</span><span class="nf">eagerly_finish</span>
      <span class="k">else</span>
        <span class="n">client</span><span class="p">.</span><span class="nf">finish</span>
        <span class="n">process_now</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="k">end</span>
    <span class="k">rescue</span> <span class="no">MiniSSL</span><span class="o">::</span><span class="no">SSLError</span><span class="p">,</span> <span class="no">HttpParserError</span> <span class="o">=&gt;</span> <span class="n">e</span>
      <span class="c1"># ...</span>
    <span class="k">rescue</span> <span class="no">ConnectionError</span>
      <span class="n">client</span><span class="p">.</span><span class="nf">close</span>
    <span class="k">else</span>
      <span class="k">if</span> <span class="n">process_now</span>
        <span class="n">process_client</span> <span class="n">client</span><span class="p">,</span> <span class="n">buffer</span>
      <span class="k">else</span>
        <span class="n">client</span><span class="p">.</span><span class="nf">set_timeout</span> <span class="vi">@first_data_timeout</span>
        <span class="vi">@reactor</span><span class="p">.</span><span class="nf">add</span> <span class="n">client</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">if</span> <span class="n">queue_requests</span>
    <span class="vi">@reactor</span> <span class="o">=</span> <span class="no">Reactor</span><span class="p">.</span><span class="nf">new</span> <span class="nb">self</span><span class="p">,</span> <span class="vi">@thread_pool</span>
    <span class="vi">@reactor</span><span class="p">.</span><span class="nf">run_in_thread</span>
  <span class="k">end</span>

  <span class="vi">@thread</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="n">handle_servers</span> <span class="p">}</span>
  <span class="vi">@thread</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述代码创建了一个新的 <code class="highlighter-rouge">Reactor</code> 对象并在一个新的线程中执行 <code class="highlighter-rouge">#handle_servers</code> 接受客户端的请求，文章会在后面介绍请求的处理。</p>

<h3 id="集群模式">集群模式</h3>

<p>如果在启动 puma 进程时使用 <code class="highlighter-rouge">-w</code> 参数，例如下面的命令：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>puma <span class="nt">-w</span> 3
<span class="o">[</span>20904] Puma starting <span class="k">in </span>cluster mode...
<span class="o">[</span>20904] <span class="k">*</span> Version 3.10.0 <span class="o">(</span>ruby 2.3.3-p222<span class="o">)</span>, codename: Russell<span class="s1">'s Teapot
[20904] * Min threads: 0, max threads: 16
[20904] * Environment: development
[20904] * Process workers: 3
[20904] * Phased restart available
[20904] * Listening on tcp://0.0.0.0:9292
[20904] Use Ctrl-C to stop
[20904] - Worker 2 (pid: 20907) booted, phase: 0
[20904] - Worker 1 (pid: 20906) booted, phase: 0
[20904] - Worker 0 (pid: 20905) booted, phase: 0

$ ps aux | grep puma
draveness        20909   0.0  0.0  4296440    952 s001  S+   10:23AM   0:00.01 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn puma
draveness        20907   0.0  0.1  4358888  12128 s003  S+   10:23AM   0:00.07 puma: cluster worker 2: 20904 [Desktop]
draveness        20906   0.0  0.1  4358888  12148 s003  S+   10:23AM   0:00.07 puma: cluster worker 1: 20904 [Desktop]
draveness        20905   0.0  0.1  4358888  12196 s003  S+   10:23AM   0:00.07 puma: cluster worker 0: 20904 [Desktop]
draveness        20904   0.0  0.2  4346784  25632 s003  S+   10:23AM   0:00.67 puma 3.10.0 (tcp://0.0.0.0:9292) [Desktop]
</span></code></pre></div></div>

<p>上述命令就会启动一个 Puma 的 master 进程和三个 worker 进程，Puma 集群模式就是通过 <code class="highlighter-rouge">Puma::Cluster</code> 类来启动的，而启动集群的方法 <code class="highlighter-rouge">#run</code> 仍然是一个非常长的方法，在这里仍然省去了很多的代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">cluster</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">386</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Cluster</span>

<span class="k">def</span> <span class="nf">run</span>
  <span class="vi">@status</span> <span class="o">=</span> <span class="ss">:run</span>

  <span class="n">output_header</span> <span class="s2">"cluster"</span>
  <span class="n">log</span> <span class="s2">"* Process workers: </span><span class="si">#{</span><span class="vi">@options</span><span class="p">[</span><span class="ss">:workers</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span>

  <span class="n">read</span><span class="p">,</span> <span class="vi">@wakeup</span> <span class="o">=</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Util</span><span class="p">.</span><span class="nf">pipe</span>

  <span class="no">Process</span><span class="p">.</span><span class="nf">daemon</span><span class="p">(</span><span class="kp">true</span><span class="p">)</span>
  <span class="n">spawn_workers</span>

  <span class="k">begin</span>
    <span class="k">while</span> <span class="vi">@status</span> <span class="o">==</span> <span class="ss">:run</span>
      <span class="k">begin</span>
        <span class="n">res</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">select</span><span class="p">([</span><span class="n">read</span><span class="p">],</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="no">WORKER_CHECK_INTERVAL</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">res</span>
          <span class="n">req</span> <span class="o">=</span> <span class="n">read</span><span class="p">.</span><span class="nf">read_nonblock</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
          <span class="n">result</span> <span class="o">=</span> <span class="n">read</span><span class="p">.</span><span class="nf">gets</span>
          <span class="n">pid</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="nf">to_i</span>

          <span class="k">if</span> <span class="n">w</span> <span class="o">=</span> <span class="vi">@workers</span><span class="p">.</span><span class="nf">find</span> <span class="p">{</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">x</span><span class="p">.</span><span class="nf">pid</span> <span class="o">==</span> <span class="n">pid</span> <span class="p">}</span>
            <span class="k">case</span> <span class="n">req</span>
            <span class="k">when</span> <span class="s2">"b"</span>
              <span class="n">w</span><span class="p">.</span><span class="nf">boot!</span>
            <span class="k">when</span> <span class="s2">"t"</span>
              <span class="n">w</span><span class="p">.</span><span class="nf">dead!</span>
            <span class="k">when</span> <span class="s2">"p"</span>
              <span class="n">w</span><span class="p">.</span><span class="nf">ping!</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="nf">sub</span><span class="p">(</span><span class="sr">/^\d+/</span><span class="p">,</span><span class="s1">''</span><span class="p">).</span><span class="nf">chomp</span><span class="p">)</span>
            <span class="k">end</span>
          <span class="k">else</span>
            <span class="n">log</span> <span class="s2">"! Out-of-sync worker list, no </span><span class="si">#{</span><span class="n">pid</span><span class="si">}</span><span class="s2"> worker"</span>
          <span class="k">end</span>
        <span class="k">end</span>

      <span class="k">rescue</span> <span class="no">Interrupt</span>
        <span class="vi">@status</span> <span class="o">=</span> <span class="ss">:stop</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">stop_workers</span> <span class="k">unless</span> <span class="vi">@status</span> <span class="o">==</span> <span class="ss">:halt</span>
  <span class="k">ensure</span>
    <span class="n">read</span><span class="p">.</span><span class="nf">close</span>
    <span class="vi">@wakeup</span><span class="p">.</span><span class="nf">close</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在使用 <code class="highlighter-rouge">#spawn_workers</code> 之后，当前 master 进程就开始通过 Socket 监听所有来自worker 的消息，例如当前的状态以及心跳检查等等。</p>

<p><code class="highlighter-rouge">#spawn_workers</code> 方法会通过 fork 创建当前集群中缺少的 worker 数，在新的进程中执行 <code class="highlighter-rouge">#worker</code> 方法并将 worker 保存在 master 的 <code class="highlighter-rouge">@workers</code> 数组中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">cluster</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">116</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Cluster</span>

<span class="k">def</span> <span class="nf">spawn_workers</span>
  <span class="n">diff</span> <span class="o">=</span> <span class="vi">@options</span><span class="p">[</span><span class="ss">:workers</span><span class="p">]</span> <span class="o">-</span> <span class="vi">@workers</span><span class="p">.</span><span class="nf">size</span>
  <span class="k">return</span> <span class="k">if</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="mi">1</span>

  <span class="n">master</span> <span class="o">=</span> <span class="no">Process</span><span class="p">.</span><span class="nf">pid</span>

  <span class="n">diff</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">next_worker_index</span>
    <span class="n">pid</span> <span class="o">=</span> <span class="nb">fork</span> <span class="p">{</span> <span class="n">worker</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">master</span><span class="p">)</span> <span class="p">}</span>

    <span class="n">debug</span> <span class="s2">"Spawned worker: </span><span class="si">#{</span><span class="n">pid</span><span class="si">}</span><span class="s2">"</span>
    <span class="vi">@workers</span> <span class="o">&lt;&lt;</span> <span class="no">Worker</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="vi">@phase</span><span class="p">,</span> <span class="vi">@options</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 fork 出的新进程中，<code class="highlighter-rouge">#worker</code> 方法与单机模式中一样都创建了新的 <code class="highlighter-rouge">Server</code> 实例，调用 <code class="highlighter-rouge">#run</code> 和 <code class="highlighter-rouge">#join</code> 方法启动服务：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">cluster</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">231</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Cluster</span>

<span class="k">def</span> <span class="nf">worker</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">master</span><span class="p">)</span>
  <span class="n">title</span>  <span class="o">=</span> <span class="s2">"puma: cluster worker </span><span class="si">#{</span><span class="n">index</span><span class="si">}</span><span class="s2">: </span><span class="si">#{</span><span class="n">master</span><span class="si">}</span><span class="s2">"</span>
  <span class="vg">$0</span> <span class="o">=</span> <span class="n">title</span>

  <span class="n">server</span> <span class="o">=</span> <span class="n">start_server</span>
  <span class="n">server</span><span class="p">.</span><span class="nf">run</span><span class="p">.</span><span class="nf">join</span>
<span class="k">end</span>
</code></pre></div></div>

<p>与 Unicorn 完全相同，Puma 使用了一个 master 进程来管理所有的 worker 进程：</p>

<p><img src="https://img.draveness.me/2017-11-10-puma-cluster-mode.png" alt="puma-cluster-mode" /></p>

<p>虽然 Puma 集群中的所有节点也都是由 master 管理的，但是所有的事件和信号会由各个接受信号的进程处理的，只有在特定事件发生时会通知主进程。</p>

<h2 id="处理请求">处理请求</h2>

<p>在 Puma 中所有的请求都是通过 <code class="highlighter-rouge">Server</code> 和 <code class="highlighter-rouge">ThreadPool</code> 协作来响应的，我们在 <code class="highlighter-rouge">#handler_servers</code> 方法中通过 <code class="highlighter-rouge">IO.select</code> 监听一组套接字上的读写事件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">334</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">handle_servers</span>
  <span class="k">begin</span>
    <span class="n">sockets</span> <span class="o">=</span> <span class="vi">@binder</span><span class="p">.</span><span class="nf">ios</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="vi">@thread_pool</span>

    <span class="k">while</span> <span class="vi">@status</span> <span class="o">==</span> <span class="ss">:run</span>
      <span class="k">begin</span>
        <span class="n">ios</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">select</span> <span class="n">sockets</span>
        <span class="n">ios</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">sock</span><span class="o">|</span>
          <span class="k">begin</span>
            <span class="k">if</span> <span class="n">io</span> <span class="o">=</span> <span class="n">sock</span><span class="p">.</span><span class="nf">accept_nonblock</span>
              <span class="n">client</span> <span class="o">=</span> <span class="no">Client</span><span class="p">.</span><span class="nf">new</span> <span class="n">io</span><span class="p">,</span> <span class="vi">@binder</span><span class="p">.</span><span class="nf">env</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
              <span class="n">pool</span> <span class="o">&lt;&lt;</span> <span class="n">client</span>
              <span class="n">pool</span><span class="p">.</span><span class="nf">wait_until_not_full</span>
            <span class="k">end</span>
          <span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">ECONNABORTED</span>
            <span class="n">io</span><span class="p">.</span><span class="nf">close</span> <span class="k">rescue</span> <span class="kp">nil</span>
          <span class="k">end</span>
        <span class="k">rescue</span> <span class="no">Object</span> <span class="o">=&gt;</span> <span class="n">e</span>
          <span class="vi">@events</span><span class="p">.</span><span class="nf">unknown_error</span> <span class="nb">self</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="s2">"Listen loop"</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
      <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当有读写事件发生时会非阻塞的接受 Socket，创建新的 <code class="highlighter-rouge">Client</code> 对象最后加入到线程池中交给线程池来处理接下来的请求。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">thread_pool</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">140</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">ThreadPool</span>

<span class="k">def</span> <span class="nf">&lt;&lt;</span><span class="p">(</span><span class="n">work</span><span class="p">)</span>
  <span class="vi">@mutex</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
    <span class="k">if</span> <span class="vi">@shutdown</span>
      <span class="k">raise</span> <span class="s2">"Unable to add work while shutting down"</span>
    <span class="k">end</span>

    <span class="vi">@todo</span> <span class="o">&lt;&lt;</span> <span class="n">work</span>

    <span class="k">if</span> <span class="vi">@waiting</span> <span class="o">&lt;</span> <span class="vi">@todo</span><span class="p">.</span><span class="nf">size</span> <span class="n">and</span> <span class="vi">@spawned</span> <span class="o">&lt;</span> <span class="vi">@max</span>
      <span class="n">spawn_thread</span>
    <span class="k">end</span>

    <span class="vi">@not_empty</span><span class="p">.</span><span class="nf">signal</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">ThreadPool</code> 覆写了 <code class="highlighter-rouge">#&lt;&lt;</code> 方法，在这个方法中它将 <code class="highlighter-rouge">Client</code> 对象加入到 <code class="highlighter-rouge">@todo</code> 数组中，通过对比几个参数选择是否创建一个新的线程来处理当前队列中的任务。</p>

<p>重新回到 <code class="highlighter-rouge">ThreadPool</code> 的初始化方法 <code class="highlighter-rouge">#initialize</code> 中，线程池在初始化时就会创建最低数量的线程保证当前的 worker 进程中有足够的工作线程能够处理客户端的请求：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">thread_pool</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">21</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">ThreadPool</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="o">*</span><span class="n">extra</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="vi">@mutex</span> <span class="o">=</span> <span class="no">Mutex</span><span class="p">.</span><span class="nf">new</span>

  <span class="vi">@todo</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="vi">@spawned</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="vi">@waiting</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="vi">@min</span> <span class="o">=</span> <span class="no">Integer</span><span class="p">(</span><span class="n">min</span><span class="p">)</span>
  <span class="vi">@max</span> <span class="o">=</span> <span class="no">Integer</span><span class="p">(</span><span class="n">max</span><span class="p">)</span>
  <span class="vi">@block</span> <span class="o">=</span> <span class="n">block</span>
  <span class="vi">@extra</span> <span class="o">=</span> <span class="n">extra</span>

  <span class="vi">@workers</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="vi">@mutex</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
    <span class="vi">@min</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span> <span class="n">spawn_thread</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>每一个线程都是通过 <code class="highlighter-rouge">Thread.new</code> 创建的，我们会在这个线程执行的过程中执行传入的 block：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">thread_pool</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">21</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">ThreadPool</span>

<span class="k">def</span> <span class="nf">spawn_thread</span>
  <span class="vi">@spawned</span> <span class="o">+=</span> <span class="mi">1</span>

  <span class="n">th</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@spawned</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">spawned</span><span class="o">|</span>
    <span class="n">todo</span>  <span class="o">=</span> <span class="vi">@todo</span>
    <span class="n">block</span> <span class="o">=</span> <span class="vi">@block</span>
    <span class="n">mutex</span> <span class="o">=</span> <span class="vi">@mutex</span>

    <span class="n">extra</span> <span class="o">=</span> <span class="vi">@extra</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span><span class="p">.</span><span class="nf">new</span> <span class="p">}</span>

    <span class="k">while</span> <span class="kp">true</span>
      <span class="n">work</span> <span class="o">=</span> <span class="kp">nil</span>

      <span class="n">continue</span> <span class="o">=</span> <span class="kp">true</span>

      <span class="n">mutex</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
        <span class="n">work</span> <span class="o">=</span> <span class="n">todo</span><span class="p">.</span><span class="nf">shift</span>
      <span class="k">end</span>

      <span class="k">begin</span>
        <span class="n">block</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="o">*</span><span class="n">extra</span><span class="p">)</span>
      <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
        <span class="no">STDERR</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"Error reached top of thread-pool: </span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">message</span><span class="si">}</span><span class="s2"> (</span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">class</span><span class="si">}</span><span class="s2">)"</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="n">mutex</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
      <span class="vi">@spawned</span> <span class="o">-=</span> <span class="mi">1</span>
      <span class="vi">@workers</span><span class="p">.</span><span class="nf">delete</span> <span class="n">th</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="vi">@workers</span> <span class="o">&lt;&lt;</span> <span class="n">th</span>
  <span class="n">th</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在每一个工作完成之后，也会在一个互斥锁内部使用 <code class="highlighter-rouge">#delete</code> 方法将当前线程从数组中删除，在这里执行的 block 中将客户端对象 <code class="highlighter-rouge">Client</code> 加入了 <code class="highlighter-rouge">Reactor</code> 中等待之后的处理。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@thread_pool</span> <span class="o">=</span> <span class="no">ThreadPool</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@min_threads</span><span class="p">,</span>
                              <span class="vi">@max_threads</span><span class="p">,</span>
                              <span class="no">IOBuffer</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">client</span><span class="p">,</span> <span class="n">buffer</span><span class="o">|</span>
  <span class="k">begin</span>
    <span class="n">client</span><span class="p">.</span><span class="nf">finish</span>
  <span class="k">rescue</span> <span class="no">MiniSSL</span><span class="o">::</span><span class="no">SSLError</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="c1"># ...</span>
  <span class="k">else</span>
    <span class="n">process_client</span> <span class="n">client</span><span class="p">,</span> <span class="n">buffer</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如过当前任务不需要立即处理，就会向 <code class="highlighter-rouge">Reactor</code> 加入任务等待一段时间，否则就会立即由 <code class="highlighter-rouge">#process_client</code> 方法进行处理，其中调用了 <code class="highlighter-rouge">#handle_request</code> 方法尝试处理当前的网络请求：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">439</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">process_client</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buffer</span><span class="p">)</span>
  <span class="k">begin</span>
    <span class="k">while</span> <span class="kp">true</span>
      <span class="k">case</span> <span class="n">handle_request</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">buffer</span><span class="p">)</span>
      <span class="k">when</span> <span class="kp">false</span>
        <span class="k">return</span>
      <span class="k">when</span> <span class="kp">true</span>
        <span class="k">return</span> <span class="k">unless</span> <span class="vi">@queue_requests</span>
        <span class="n">buffer</span><span class="p">.</span><span class="nf">reset</span>
        <span class="k">unless</span> <span class="n">client</span><span class="p">.</span><span class="nf">reset</span><span class="p">(</span><span class="vi">@status</span> <span class="o">==</span> <span class="ss">:run</span><span class="p">)</span>
          <span class="n">client</span><span class="p">.</span><span class="nf">set_timeout</span> <span class="vi">@persistent_timeout</span>
          <span class="vi">@reactor</span><span class="p">.</span><span class="nf">add</span> <span class="n">client</span>
          <span class="k">return</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="no">StandardError</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="c1"># ...</span>
  <span class="k">ensure</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>用于处理网络请求的方法 <code class="highlighter-rouge">#handle_request</code> 足足有 200 多行，代码中处理非常多的实现细节，在这里实在是不想一行一行代码看过去，也就简单梳理一下这段代码的脉络了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">puma</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">574</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Puma</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">handle_request</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">lines</span><span class="p">)</span>
  <span class="n">env</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="nf">env</span>
  <span class="n">client</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="nf">io</span>

  <span class="c1"># ...</span>

  <span class="k">begin</span>
    <span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">res_body</span> <span class="o">=</span> <span class="vi">@app</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>

    <span class="n">headers</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">k</span><span class="p">,</span> <span class="n">vs</span><span class="o">|</span>
      <span class="c1"># ...</span>
    <span class="k">end</span>

    <span class="n">fast_write</span> <span class="n">client</span><span class="p">,</span> <span class="n">lines</span><span class="p">.</span><span class="nf">to_s</span>
    <span class="n">res_body</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">part</span><span class="o">|</span>
      <span class="n">fast_write</span> <span class="n">client</span><span class="p">,</span> <span class="n">part</span>
      <span class="n">client</span><span class="p">.</span><span class="nf">flush</span>
    <span class="k">end</span>
  <span class="k">ensure</span>
    <span class="n">body</span><span class="p">.</span><span class="nf">close</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>我们在这里直接将这段代码压缩至 20 行左右，你可以看到与其他的 webserver 完全相同，这里也调用了 Rack 应用的 <code class="highlighter-rouge">#call</code> 方法获得了一个三元组，然后通过 <code class="highlighter-rouge">#fast_write</code> 将请求写回客户端的 Socket 结束这个 HTTP 请求。</p>

<h2 id="并发模型">并发模型</h2>

<p>到目前为止，我们已经对 Puma 是如何处理 HTTP 请求的有一个比较清晰的认识了，对于每一个 HTTP 请求都会由操作系统选择不同的进程来处理，这部分的负载均衡完全是由 OS 层来做的，当请求被分配给某一个进程时，当前进程会根据持有的线程数选择是否对请求进行处理，在这时可能会创建新的 <code class="highlighter-rouge">Thread</code> 对象来处理这个请求，也可能会把当前请求暂时扔到 <code class="highlighter-rouge">Reactor</code> 中进行等待。</p>

<p><img src="https://img.draveness.me/2017-11-10-puma-concurrency-model.png" alt="puma-concurrency-model" /></p>

<p><code class="highlighter-rouge">Reactor</code> 主要是为了提高 Puma 服务的性能存在的产物，它能够让当前的 worker 接受所有请求并将它们以队列的形式传入处理器中；如果当前的系统中存在慢客户端，那么也会占用处理请求的资源，不过由于 Puma 是多进程多线程模型的，所以影响没有那么严重，但是我们也经常会通过反向代理来解决慢客户端的问题。</p>

<h2 id="总结">总结</h2>

<p>相比于多进程单线程的 Unicorn，Puma 提供了更灵活的配置功能，每一个进程的线程数都能在一定范围内进行收缩，目前也是绝大多数的 Ruby 项目使用的 webserver，从不同 webserver 的发展我们其实可以看出混合方式的并发模型虽然实现更加复杂，但是确实能够提供更高的性能和容错。</p>

<p>Puma 项目使用了 Rubocop 来规范项目中的代码风格，相比其他的 webserver 来说确实有更好的阅读体验，只是偶尔出现的长方法会让代码在理解时出现一些问题。</p>


	  ]]></description>
	</item>

	<item>
	  <title>浅谈 Unicorn 的多进程模型</title>
	  <link>/blogs//rack-unicorn</link>
	  <author></author>
	  <pubDate>2017-11-08T00:00:00+00:00</pubDate>
	  <guid>/blogs//rack-unicorn</guid>
	  <description><![CDATA[
	     <ul>
  <li><a href="https://draveness.me/rack">谈谈 Rack 协议与实现</a></li>
  <li><a href="https://draveness.me/rack-webrick">浅谈 WEBrick 的多线程模型</a></li>
  <li><a href="https://draveness.me/rack-thin">浅谈 Thin 的事件驱动模型</a></li>
  <li><a href="https://draveness.me/rack-unicorn">浅谈 Unicorn 的多进程模型</a></li>
  <li><a href="https://draveness.me/rack-puma">浅谈 Puma 的并发模型与实现</a></li>
  <li><a href="https://draveness.me/ruby-webserver">Ruby Web 服务器的并发模型与性能</a></li>
</ul>

<p>作为 Ruby 社区中老牌的 webserver，在今天也有很多开发者在生产环境使用 Unicorn 处理客户端的发出去的 HTTP 请求，与 WEBrick 和 Thin 不同，Unicorn 使用了完全不同的模型，提供了多进程模型批量处理来自客户端的请求。</p>

<p><img src="https://img.draveness.me/2017-11-08-unicorn.jpeg" alt="unicorn" /></p>

<p>Unicorn 为 Rails 应用提供并发的方式是使用 <code class="highlighter-rouge">fork</code> 创建多个 worker 线程，监听同一个 Socket 上的输入。</p>

<blockquote>
  <p>本文中使用的是 5.3.1 的 Unicorn，如果你使用了不同版本的 Unicorn，原理上的区别不会太大，只是在一些方法的实现上会有一些细微的不同。</p>
</blockquote>

<h2 id="实现原理">实现原理</h2>

<p>Unicorn 虽然也是一个遵循 Rack 协议的 Ruby webserver，但是因为它本身并没有提供 Rack 处理器，所以没有办法直接通过 <code class="highlighter-rouge">rackup -s Unicorn</code> 来启动 Unicorn 的进程。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">unicorn</span> <span class="o">-</span><span class="n">c</span> <span class="n">unicorn</span><span class="p">.</span><span class="nf">rb</span>
<span class="no">I</span><span class="p">,</span> <span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mo">06</span><span class="no">T08</span><span class="p">:</span><span class="mo">05</span><span class="p">:</span><span class="mo">03</span><span class="o">.</span><span class="mi">082116</span> <span class="c1">#33222]  INFO -- : listening on addr=0.0.0.0:8080 fd=10</span>
<span class="no">I</span><span class="p">,</span> <span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mo">06</span><span class="no">T08</span><span class="p">:</span><span class="mo">05</span><span class="p">:</span><span class="mo">03</span><span class="o">.</span><span class="mi">082290</span> <span class="c1">#33222]  INFO -- : worker=0 spawning...</span>
<span class="no">I</span><span class="p">,</span> <span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mo">06</span><span class="no">T08</span><span class="p">:</span><span class="mo">05</span><span class="p">:</span><span class="mo">03</span><span class="o">.</span><span class="mi">083505</span> <span class="c1">#33222]  INFO -- : worker=1 spawning...</span>
<span class="no">I</span><span class="p">,</span> <span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mo">06</span><span class="no">T08</span><span class="p">:</span><span class="mo">05</span><span class="p">:</span><span class="mo">03</span><span class="o">.</span><span class="mi">083989</span> <span class="c1">#33222]  INFO -- : master process ready</span>
<span class="no">I</span><span class="p">,</span> <span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mo">06</span><span class="no">T08</span><span class="p">:</span><span class="mo">05</span><span class="p">:</span><span class="mo">03</span><span class="o">.</span><span class="mi">084610</span> <span class="c1">#33223]  INFO -- : worker=0 spawned pid=33223</span>
<span class="no">I</span><span class="p">,</span> <span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mo">06</span><span class="no">T08</span><span class="p">:</span><span class="mo">05</span><span class="p">:</span><span class="mo">03</span><span class="o">.</span><span class="mi">085100</span> <span class="c1">#33223]  INFO -- : Refreshing Gem list</span>
<span class="no">I</span><span class="p">,</span> <span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mo">06</span><span class="no">T08</span><span class="p">:</span><span class="mo">05</span><span class="p">:</span><span class="mo">03</span><span class="o">.</span><span class="mi">084902</span> <span class="c1">#33224]  INFO -- : worker=1 spawned pid=33224</span>
<span class="no">I</span><span class="p">,</span> <span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mo">06</span><span class="no">T08</span><span class="p">:</span><span class="mo">05</span><span class="p">:</span><span class="mo">03</span><span class="o">.</span><span class="mi">085457</span> <span class="c1">#33224]  INFO -- : Refreshing Gem list</span>
<span class="no">I</span><span class="p">,</span> <span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mo">06</span><span class="no">T08</span><span class="p">:</span><span class="mo">05</span><span class="p">:</span><span class="mo">03</span><span class="o">.</span><span class="mi">123611</span> <span class="c1">#33224]  INFO -- : worker=1 ready</span>
<span class="no">I</span><span class="p">,</span> <span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mo">06</span><span class="no">T08</span><span class="p">:</span><span class="mo">05</span><span class="p">:</span><span class="mo">03</span><span class="o">.</span><span class="mi">123670</span> <span class="c1">#33223]  INFO -- : worker=0 ready</span>
</code></pre></div></div>

<p>在使用 Unicorn 时，我们需要直接使用 <code class="highlighter-rouge">unicorn</code> 命令来启动一个 Unicorn 服务，在使用时可以通过 <code class="highlighter-rouge">-c</code> 传入一个配置文件，文件中的内容其实都是 Ruby 代码，每一个方法调用都是 Unicorn 的一条配置项：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">cat</span> <span class="n">unicorn</span><span class="p">.</span><span class="nf">rb</span>
<span class="n">worker_processes</span> <span class="mi">2</span>
</code></pre></div></div>

<h3 id="可执行文件">可执行文件</h3>

<p><code class="highlighter-rouge">unicorn</code> 这个命令位于 <code class="highlighter-rouge">bin/unicorn</code> 中，在这个可执行文件中，大部分的代码都是对命令行参数的配置和说明，整个文件可以简化为以下的几行代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rackup_opts</span> <span class="o">=</span> <span class="c1"># ...</span>
<span class="n">app</span> <span class="o">=</span> <span class="no">Unicorn</span><span class="p">.</span><span class="nf">builder</span><span class="p">(</span><span class="no">ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="s1">'config.ru'</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
<span class="no">Unicorn</span><span class="o">::</span><span class="no">Launcher</span><span class="p">.</span><span class="nf">daemonize!</span><span class="p">(</span><span class="n">options</span><span class="p">)</span> <span class="k">if</span> <span class="n">rackup_opts</span><span class="p">[</span><span class="ss">:daemonize</span><span class="p">]</span>
<span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span><span class="p">).</span><span class="nf">start</span><span class="p">.</span><span class="nf">join</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">unicorn</code> 命令会从 Rack 应用的标配 config.ru 文件或者传入的文件中加载代码构建一个新的 Rack 应用；初始化 Rack 应用后会使用 <code class="highlighter-rouge">.daemonize!</code> 方法将 unicorn 进程启动在后台运行；最后会创建并启动一个新的 <code class="highlighter-rouge">HttpServer</code> 的实例。</p>

<h3 id="构建应用">构建应用</h3>

<p>读取 config.ru 文件并解析的过程其实就是直接使用了 Rack 的 <code class="highlighter-rouge">Builder</code> 模块，通过 <code class="highlighter-rouge">eval</code> 运行一段代码得到一个 Rack 应用：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">39</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Unicorn&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">builder</span><span class="p">(</span><span class="n">ru</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>
  <span class="n">raw</span> <span class="o">=</span> <span class="no">File</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">ru</span><span class="p">)</span>
  <span class="n">inner_app</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s2">"Rack::Builder.new {(</span><span class="se">\n</span><span class="si">#{</span><span class="n">raw</span><span class="si">}</span><span class="se">\n</span><span class="s2">)}.to_app"</span><span class="p">,</span> <span class="no">TOPLEVEL_BINDING</span><span class="p">,</span> <span class="n">ru</span><span class="p">)</span>

  <span class="n">middleware</span> <span class="o">=</span> <span class="p">{</span>
    <span class="no">ContentLength</span><span class="p">:</span> <span class="kp">nil</span><span class="p">,</span>
    <span class="no">Chunked</span><span class="p">:</span> <span class="kp">nil</span><span class="p">,</span>
    <span class="no">CommonLogger</span><span class="p">:</span> <span class="p">[</span> <span class="vg">$stderr</span> <span class="p">],</span>
    <span class="no">ShowExceptions</span><span class="p">:</span> <span class="kp">nil</span><span class="p">,</span>
    <span class="no">Lint</span><span class="p">:</span> <span class="kp">nil</span><span class="p">,</span>
    <span class="no">TempfileReaper</span><span class="p">:</span> <span class="kp">nil</span><span class="p">,</span>
  <span class="p">}</span>

  <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="n">middleware</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="p">,</span> <span class="n">args</span><span class="o">|</span>
      <span class="n">use</span><span class="p">(</span><span class="no">Rack</span><span class="p">.</span><span class="nf">const_get</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="k">if</span> <span class="no">Rack</span><span class="p">.</span><span class="nf">const_defined?</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">run</span> <span class="n">inner_app</span>
  <span class="k">end</span><span class="p">.</span><span class="nf">to_app</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在该方法中会执行两次 <code class="highlighter-rouge">Rack::Builder.new</code> 方法，第一次会运行 config.ru 中的代码，第二次会添加一些默认的中间件，最终会返回一个接受 <code class="highlighter-rouge">#call</code> 方法返回三元组的 Rack 应用。</p>

<h3 id="守护进程">守护进程</h3>

<p>在默认情况下，Unicorn 的进程都是以前台进程的形式运行的，但是在生产环境我们往往需要在后台运行 Unicorn 进程，这也就是 <code class="highlighter-rouge">Unicorn::Launcher</code> 所做的工作。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">23</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Unicorn::Launcher&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">daemonize!</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
  <span class="n">cfg</span> <span class="o">=</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">Configurator</span>
  <span class="vg">$stdin</span><span class="p">.</span><span class="nf">reopen</span><span class="p">(</span><span class="s2">"/dev/null"</span><span class="p">)</span>

  <span class="k">unless</span> <span class="no">ENV</span><span class="p">[</span><span class="s1">'UNICORN_FD'</span><span class="p">]</span>
    <span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>
    <span class="n">grandparent</span> <span class="o">=</span> <span class="vg">$$</span>
    <span class="k">if</span> <span class="nb">fork</span>
      <span class="n">wr</span><span class="p">.</span><span class="nf">close</span>
    <span class="k">else</span>
      <span class="n">rd</span><span class="p">.</span><span class="nf">close</span>
      <span class="no">Process</span><span class="p">.</span><span class="nf">setsid</span>
      <span class="nb">exit</span> <span class="k">if</span> <span class="nb">fork</span>
    <span class="k">end</span>

    <span class="k">if</span> <span class="n">grandparent</span> <span class="o">==</span> <span class="vg">$$</span>
      <span class="n">master_pid</span> <span class="o">=</span> <span class="p">(</span><span class="n">rd</span><span class="p">.</span><span class="nf">readpartial</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="k">rescue</span> <span class="kp">nil</span><span class="p">).</span><span class="nf">to_i</span>
      <span class="k">unless</span> <span class="n">master_pid</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="nb">warn</span> <span class="s2">"master failed to start, check stderr log for details"</span>
        <span class="nb">exit!</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="k">end</span>
      <span class="nb">exit</span> <span class="mi">0</span>
    <span class="k">else</span>
      <span class="n">options</span><span class="p">[</span><span class="ss">:ready_pipe</span><span class="p">]</span> <span class="o">=</span> <span class="n">wr</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="n">cfg</span><span class="o">::</span><span class="no">DEFAULTS</span><span class="p">[</span><span class="ss">:stderr_path</span><span class="p">]</span> <span class="o">||=</span> <span class="s2">"/dev/null"</span>
  <span class="n">cfg</span><span class="o">::</span><span class="no">DEFAULTS</span><span class="p">[</span><span class="ss">:stdout_path</span><span class="p">]</span> <span class="o">||=</span> <span class="s2">"/dev/null"</span>
  <span class="n">cfg</span><span class="o">::</span><span class="no">RACKUP</span><span class="p">[</span><span class="ss">:daemonized</span><span class="p">]</span> <span class="o">=</span> <span class="kp">true</span>
<span class="k">end</span>
</code></pre></div></div>

<p>想要真正理解上述代码的工作，我们需要理解广义上的 daemonize 过程，在 Unix-like 的系统中，一个 <a href="https://en.wikipedia.org/wiki/Daemon_(computing)">daemon</a>（守护进程）是运行在后台不直接被用户操作的进程；一个进程想要变成守护进程通常需要做以下的事情：</p>

<ol>
  <li>执行 <code class="highlighter-rouge">fork</code> 和 <code class="highlighter-rouge">exit</code> 来创建一个后台任务；</li>
  <li>从 tty 的控制中分离、创建一个新的 session 并成为新的 session 和进程组的管理者；</li>
  <li>将根目录 <code class="highlighter-rouge">/</code> 设置为当前进程的工作目录；</li>
  <li>将 umask 更新成 <code class="highlighter-rouge">0</code> 以提供自己的权限管理掩码；</li>
  <li>使用日志文件、控制台或者 <code class="highlighter-rouge">/dev/null</code> 设备作为标准输入、输出和错误；</li>
</ol>

<p>在 <code class="highlighter-rouge">.daemonize!</code> 方法中我们总共使用 fork 创建了两个进程，整个过程涉及三个进程的协作，其中 grandparent 是启动 Unicorn 的进程一般指终端，parent 是用来启动 Unicorn 服务的进程，master 就是 Unicorn 服务中的主进程，三个进程有以下的关系：</p>

<p><img src="https://img.draveness.me/2017-11-08-unicorn-daemonize.png" alt="unicorn-daemonize" /></p>

<p>上述的三个进程中，grandparent 表示用于启动 Unicorn 进程的终端，parent 只是一个用于设置进程状态和掩码的中间进程，它在启动 Unicorn 的 master 进程后就会立刻退出。</p>

<p>在这里，我们会分三个部分分别介绍 grandparent、parent 和 master 究竟做了哪些事情；首先，对于 grandparent 进程来说，我们实际上运行了以下的代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">daemonize!</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
  <span class="vg">$stdin</span><span class="p">.</span><span class="nf">reopen</span><span class="p">(</span><span class="s2">"/dev/null"</span><span class="p">)</span>
  <span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>
  <span class="n">wr</span><span class="p">.</span><span class="nf">close</span>

  <span class="c1"># fork</span>

  <span class="n">master_pid</span> <span class="o">=</span> <span class="p">(</span><span class="n">rd</span><span class="p">.</span><span class="nf">readpartial</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="k">rescue</span> <span class="kp">nil</span><span class="p">).</span><span class="nf">to_i</span>
  <span class="k">unless</span> <span class="n">master_pid</span> <span class="o">&gt;</span> <span class="mi">1</span>
    <span class="nb">warn</span> <span class="s2">"master failed to start, check stderr log for details"</span>
    <span class="nb">exit!</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>通过 <code class="highlighter-rouge">IO.pipe</code> 方法创建了一对 Socket 节点，其中一个用于读，另一个用于写，在这里由于当前进程 grantparent 不需要写，所以直接将写的一端 <code class="highlighter-rouge">#close</code>，保留读的一端等待 Unicorn master 进程发送它的 <code class="highlighter-rouge">pid</code>，如果 master 没有成功启动就会报错，这也是 grandparent 进程的主要作用。</p>

<p>对于 parent 进程来说做的事情其实就更简单了，在 <code class="highlighter-rouge">fork</code> 之后会直接将读的一端执行 <code class="highlighter-rouge">#close</code>，这样无论是当前进程 parent 还是 parent fork 出来的进程都无法通过 <code class="highlighter-rouge">rd</code> 读取数据：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">daemonize!</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
  <span class="vg">$stdin</span><span class="p">.</span><span class="nf">reopen</span><span class="p">(</span><span class="s2">"/dev/null"</span><span class="p">)</span>
  <span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>

  <span class="c1"># fork</span>

  <span class="n">rd</span><span class="p">.</span><span class="nf">close</span>
  <span class="no">Process</span><span class="p">.</span><span class="nf">setsid</span>
  <span class="nb">exit</span> <span class="k">if</span> <span class="nb">fork</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 parent 进程中，我们通过 <code class="highlighter-rouge">Process.setsid</code> 将当前的进程设置为新的 session 和进程组的管理者，从 tty 中分离；最后直接执行 <code class="highlighter-rouge">fork</code> 创建一个新的进程 master 并退出 parent 进程，parent 进程的作用其实就是为了启动新 Unicorn master 进程。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">daemonize!</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
  <span class="n">cfg</span> <span class="o">=</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">Configurator</span>
  <span class="vg">$stdin</span><span class="p">.</span><span class="nf">reopen</span><span class="p">(</span><span class="s2">"/dev/null"</span><span class="p">)</span>

  <span class="n">rd</span><span class="p">,</span> <span class="n">wr</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>
  <span class="n">rd</span><span class="p">.</span><span class="nf">close</span>

  <span class="no">Process</span><span class="p">.</span><span class="nf">setsid</span>

  <span class="c1"># fork</span>

  <span class="n">options</span><span class="p">[</span><span class="ss">:ready_pipe</span><span class="p">]</span> <span class="o">=</span> <span class="n">wr</span>
  <span class="n">cfg</span><span class="o">::</span><span class="no">DEFAULTS</span><span class="p">[</span><span class="ss">:stderr_path</span><span class="p">]</span> <span class="o">||=</span> <span class="s2">"/dev/null"</span>
  <span class="n">cfg</span><span class="o">::</span><span class="no">DEFAULTS</span><span class="p">[</span><span class="ss">:stdout_path</span><span class="p">]</span> <span class="o">||=</span> <span class="s2">"/dev/null"</span>
  <span class="n">cfg</span><span class="o">::</span><span class="no">RACKUP</span><span class="p">[</span><span class="ss">:daemonized</span><span class="p">]</span> <span class="o">=</span> <span class="kp">true</span>
<span class="k">end</span>
</code></pre></div></div>

<p>新的进程 Unicorn master 就是一个不关联在任何 tty 的一个后台进程，不过到这里为止也仅仅创建另一个进程，Unicorn 还无法对外提供服务，我们将可读的 Socket <code class="highlighter-rouge">wr</code> 写入 <code class="highlighter-rouge">options</code> 中，在 webserver 成功启动后将通过 <code class="highlighter-rouge">IO.pipe</code> 创建的一对 Socket 将信息回传给 grandparent 进程通知服务启动的结果。</p>

<h3 id="初始化服务">初始化服务</h3>

<p>HTTP 服务在初始化时其实也没有做太多的事情，只是对 Rack 应用进行存储并初始化了一些实例变量：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="o">/</span><span class="n">http_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">69</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="vi">@app</span> <span class="o">=</span> <span class="n">app</span>
  <span class="vi">@request</span> <span class="o">=</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpRequest</span><span class="p">.</span><span class="nf">new</span>
  <span class="vi">@reexec_pid</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="vi">@ready_pipe</span> <span class="o">=</span> <span class="n">options</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="ss">:ready_pipe</span><span class="p">)</span>
  <span class="vi">@init_listeners</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:listeners</span><span class="p">]</span> <span class="p">?</span> <span class="n">options</span><span class="p">[:</span><span class="n">listeners</span><span class="p">].</span><span class="nf">dup</span> <span class="p">:</span> <span class="p">[]</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">config</span> <span class="o">=</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">Configurator</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">listener_opts</span> <span class="o">=</span> <span class="p">{}</span>

  <span class="vi">@self_pipe</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="vi">@workers</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="vi">@sig_queue</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="vi">@pid</span> <span class="o">=</span> <span class="kp">nil</span>

  <span class="n">config</span><span class="p">.</span><span class="nf">commit!</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="ss">:skip</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="ss">:listeners</span><span class="p">,</span> <span class="ss">:pid</span><span class="p">])</span>
  <span class="vi">@orig_app</span> <span class="o">=</span> <span class="n">app</span>
  <span class="vi">@queue_sigs</span> <span class="o">=</span> <span class="p">[</span><span class="ss">:WINCH</span><span class="p">,</span> <span class="ss">:QUIT</span><span class="p">,</span> <span class="ss">:INT</span><span class="p">,</span> <span class="ss">:TERM</span><span class="p">,</span> <span class="ss">:USR1</span><span class="p">,</span> <span class="ss">:USR2</span><span class="p">,</span> <span class="ss">:HUP</span><span class="p">,</span> <span class="ss">:TTIN</span><span class="p">,</span> <span class="ss">:TTOU</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">.daemonize!</code> 方法中存储的 <code class="highlighter-rouge">ready_pipe</code> 在这时被当前的 <code class="highlighter-rouge">HttpServer</code> 对象持有，之后会通过这个管道上传数据。</p>

<h3 id="启动服务">启动服务</h3>

<p><code class="highlighter-rouge">HttpServer</code> 服务的启动一看就是这个 <code class="highlighter-rouge">#start</code> 实例方法控制的，在这个方法中总过做了两件比较重要的事情：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="o">/</span><span class="n">http_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">120</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span>

<span class="k">def</span> <span class="nf">start</span>
  <span class="vi">@queue_sigs</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">sig</span><span class="o">|</span> <span class="nb">trap</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="p">{</span> <span class="vi">@sig_queue</span> <span class="o">&lt;&lt;</span> <span class="n">sig</span><span class="p">;</span> <span class="n">awaken_master</span> <span class="p">}</span> <span class="p">}</span>
  <span class="nb">trap</span><span class="p">(</span><span class="ss">:CHLD</span><span class="p">)</span> <span class="p">{</span> <span class="n">awaken_master</span> <span class="p">}</span>

  <span class="nb">self</span><span class="p">.</span><span class="nf">pid</span> <span class="o">=</span> <span class="n">config</span><span class="p">[</span><span class="ss">:pid</span><span class="p">]</span>

  <span class="n">spawn_missing_workers</span>
  <span class="nb">self</span>
<span class="k">end</span>
</code></pre></div></div>

<p>第一件事情是将构造器中初始化的 <code class="highlighter-rouge">queue_sigs</code> 实例变量中的全部信号，通过 <code class="highlighter-rouge">trap</code> 为信号提供用于响应事件的代码。</p>

<p>第二件事情就是通过 <code class="highlighter-rouge">#spawn_missing_workers</code> 方法 <code class="highlighter-rouge">fork</code> 当前 master 进程创建一系列的 worker 进程：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="o">/</span><span class="n">http_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">531</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span>

<span class="k">def</span> <span class="nf">spawn_missing_workers</span>
  <span class="n">worker_nr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
  <span class="k">until</span> <span class="p">(</span><span class="n">worker_nr</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="vi">@worker_processes</span>
    <span class="n">worker</span> <span class="o">=</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">Worker</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">worker_nr</span><span class="p">)</span>
    <span class="n">before_fork</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">)</span>

    <span class="n">pid</span> <span class="o">=</span> <span class="nb">fork</span>

    <span class="k">unless</span> <span class="n">pid</span>
      <span class="n">after_fork_internal</span>
      <span class="n">worker_loop</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span>
      <span class="nb">exit</span>
    <span class="k">end</span>

    <span class="vi">@workers</span><span class="p">[</span><span class="n">pid</span><span class="p">]</span> <span class="o">=</span> <span class="n">worker</span>
    <span class="n">worker</span><span class="p">.</span><span class="nf">atfork_parent</span>
  <span class="k">end</span>
<span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="vi">@logger</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">rescue</span> <span class="kp">nil</span>
  <span class="nb">exit!</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这种调用了 <code class="highlighter-rouge">fork</code> 的方法中，我们还是将其一分为二来看，在这里就是 master 和 worker 进程，对于 master 进程来说：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="o">/</span><span class="n">http_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">531</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span>

<span class="k">def</span> <span class="nf">spawn_missing_workers</span>
  <span class="n">worker_nr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
  <span class="k">until</span> <span class="p">(</span><span class="n">worker_nr</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="vi">@worker_processes</span>
    <span class="n">worker</span> <span class="o">=</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">Worker</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">worker_nr</span><span class="p">)</span>
    <span class="n">before_fork</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">)</span>

    <span class="n">pid</span> <span class="o">=</span> <span class="nb">fork</span>
    
    <span class="c1"># ...</span>

    <span class="vi">@workers</span><span class="p">[</span><span class="n">pid</span><span class="p">]</span> <span class="o">=</span> <span class="n">worker</span>
  <span class="k">end</span>
<span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="vi">@logger</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">rescue</span> <span class="kp">nil</span>
  <span class="nb">exit!</span>
<span class="k">end</span>
</code></pre></div></div>

<p>通过一个 until 循环，master 进程能够创建 <code class="highlighter-rouge">worker_processes</code> 个 worker 进程，在每个循环中，上述方法都会创建一个 <code class="highlighter-rouge">Unicorn::Worker</code> 对象并在 <code class="highlighter-rouge">fork</code> 之后，将子进程的 <code class="highlighter-rouge">pid</code> 和 <code class="highlighter-rouge">worker</code> 以键值对的形式存到 <code class="highlighter-rouge">workers</code> 这个实例变量中。</p>

<p><code class="highlighter-rouge">before_fork</code> 中存储的 block 是我们非常熟悉的，其实就是向服务器的日志中追加内容：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">DEFAULTS</span> <span class="o">=</span> <span class="p">{</span>
  <span class="c1"># ...</span>
  <span class="ss">:after_fork</span> <span class="o">=&gt;</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">server</span><span class="p">,</span> <span class="n">worker</span><span class="o">|</span>
    <span class="n">server</span><span class="p">.</span><span class="nf">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s2">"worker=</span><span class="si">#{</span><span class="n">worker</span><span class="p">.</span><span class="nf">nr</span><span class="si">}</span><span class="s2"> spawned pid=</span><span class="si">#{</span><span class="vg">$$</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
  <span class="p">},</span>
  <span class="ss">:before_fork</span> <span class="o">=&gt;</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">server</span><span class="p">,</span> <span class="n">worker</span><span class="o">|</span>
    <span class="n">server</span><span class="p">.</span><span class="nf">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s2">"worker=</span><span class="si">#{</span><span class="n">worker</span><span class="p">.</span><span class="nf">nr</span><span class="si">}</span><span class="s2"> spawning..."</span><span class="p">)</span>
  <span class="p">},</span>
  <span class="ss">:before_exec</span> <span class="o">=&gt;</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">server</span><span class="o">|</span>
    <span class="n">server</span><span class="p">.</span><span class="nf">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s2">"forked child re-executing..."</span><span class="p">)</span>
  <span class="p">},</span>
  <span class="ss">:after_worker_exit</span> <span class="o">=&gt;</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">server</span><span class="p">,</span> <span class="n">worker</span><span class="p">,</span> <span class="n">status</span><span class="o">|</span>
    <span class="n">m</span> <span class="o">=</span> <span class="s2">"reaped </span><span class="si">#{</span><span class="n">status</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2"> worker=</span><span class="si">#{</span><span class="n">worker</span><span class="p">.</span><span class="nf">nr</span> <span class="k">rescue</span> <span class="s1">'unknown'</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">if</span> <span class="n">status</span><span class="p">.</span><span class="nf">success?</span>
      <span class="n">server</span><span class="p">.</span><span class="nf">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="n">server</span><span class="p">.</span><span class="nf">logger</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="p">},</span>
  <span class="ss">:after_worker_ready</span> <span class="o">=&gt;</span> <span class="nb">lambda</span> <span class="p">{</span> <span class="o">|</span><span class="n">server</span><span class="p">,</span> <span class="n">worker</span><span class="o">|</span>
    <span class="n">server</span><span class="p">.</span><span class="nf">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s2">"worker=</span><span class="si">#{</span><span class="n">worker</span><span class="p">.</span><span class="nf">nr</span><span class="si">}</span><span class="s2"> ready"</span><span class="p">)</span>
  <span class="p">},</span>
  <span class="c1"># ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>所有日志相关的输出大都在 <code class="highlighter-rouge">Unicorn::Configurator</code> 类中作为常量定义起来，并在初始化时作为缺省值赋值到 <code class="highlighter-rouge">HttpServer</code> 相应的实例变量上。而对于真正处理 HTTP 请求的 worker 进程来说，就会进入更加复杂的逻辑了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">spawn_missing_workers</span>
  <span class="n">worker_nr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
  <span class="k">until</span> <span class="p">(</span><span class="n">worker_nr</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="vi">@worker_processes</span>
    <span class="n">worker</span> <span class="o">=</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">Worker</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">worker_nr</span><span class="p">)</span>
    <span class="n">before_fork</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">)</span>

    <span class="c1"># fork</span>

    <span class="n">after_fork_internal</span>
    <span class="n">worker_loop</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span>
    <span class="nb">exit</span>
  <span class="k">end</span>
<span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="vi">@logger</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">rescue</span> <span class="kp">nil</span>
  <span class="nb">exit!</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这里调用了两个实例方法，其中一个是 <code class="highlighter-rouge">#after_fork_internal</code>，另一个是 <code class="highlighter-rouge">#worker_loop</code> 方法，前者用于处理一些 <code class="highlighter-rouge">fork</code> 之后收尾的逻辑，比如关闭仅在 master 进程中使用的 <code class="highlighter-rouge">self_pipe</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">after_fork_internal</span>
  <span class="vi">@self_pipe</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:close</span><span class="p">).</span><span class="nf">clear</span>
  <span class="vi">@ready_pipe</span><span class="p">.</span><span class="nf">close</span> <span class="k">if</span> <span class="vi">@ready_pipe</span>
  <span class="no">Unicorn</span><span class="o">::</span><span class="no">Configurator</span><span class="o">::</span><span class="no">RACKUP</span><span class="p">.</span><span class="nf">clear</span>
  <span class="vi">@ready_pipe</span> <span class="o">=</span> <span class="vi">@init_listeners</span> <span class="o">=</span> <span class="vi">@before_exec</span> <span class="o">=</span> <span class="vi">@before_fork</span> <span class="o">=</span> <span class="kp">nil</span>
<span class="k">end</span>
</code></pre></div></div>

<p>而后者就是 worker 持续监听 Socket 输入并处理请求的循环了。</p>

<h3 id="循环">循环</h3>

<p>当我们开始运行 worker 中的循环时，就开始监听 Socket 上的事件，整个过程还是比较直观的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="o">/</span><span class="n">http_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">681</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span>

<span class="k">def</span> <span class="nf">worker_loop</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span>
  <span class="n">ppid</span> <span class="o">=</span> <span class="vi">@master_pid</span>
  <span class="n">readers</span> <span class="o">=</span> <span class="n">init_worker_process</span><span class="p">(</span><span class="n">worker</span><span class="p">)</span>
  <span class="n">ready</span> <span class="o">=</span> <span class="n">readers</span><span class="p">.</span><span class="nf">dup</span>
  <span class="vi">@after_worker_ready</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">worker</span><span class="p">)</span>

  <span class="k">begin</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">ready</span><span class="p">.</span><span class="nf">dup</span>
    <span class="k">while</span> <span class="n">sock</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">.</span><span class="nf">shift</span>
      <span class="k">if</span> <span class="n">client</span> <span class="o">=</span> <span class="n">sock</span><span class="p">.</span><span class="nf">kgio_tryaccept</span>
        <span class="n">process_client</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">unless</span> <span class="n">nr</span> <span class="o">==</span> <span class="mi">0</span>
      <span class="n">tmp</span> <span class="o">=</span> <span class="n">ready</span><span class="p">.</span><span class="nf">dup</span>
      <span class="k">redo</span>
    <span class="k">end</span>

    <span class="n">ppid</span> <span class="o">==</span> <span class="no">Process</span><span class="p">.</span><span class="nf">ppid</span> <span class="n">or</span> <span class="k">return</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="n">readers</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="vi">@timeout</span><span class="p">)</span> <span class="n">and</span> <span class="n">ready</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="c1"># ...</span>
  <span class="k">end</span> <span class="k">while</span> <span class="n">readers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果当前 Socket 上有等待处理的 HTTP 请求，就会执行 <code class="highlighter-rouge">#process_client</code> 方法队请求进行处理，在这里调用了 Rack 应用的 <code class="highlighter-rouge">#call</code> 方法得到了三元组：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="o">/</span><span class="n">http_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">605</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span>

<span class="k">def</span> <span class="nf">process_client</span><span class="p">(</span><span class="n">client</span><span class="p">)</span>
  <span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">body</span> <span class="o">=</span> <span class="vi">@app</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">env</span> <span class="o">=</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">client</span><span class="p">))</span>

  <span class="k">begin</span>
    <span class="k">return</span> <span class="k">if</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">hijacked?</span>

    <span class="vi">@request</span><span class="p">.</span><span class="nf">headers?</span> <span class="n">or</span> <span class="n">headers</span> <span class="o">=</span> <span class="kp">nil</span>
    <span class="n">http_response_write</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span>
                        <span class="vi">@request</span><span class="p">.</span><span class="nf">response_start_sent</span><span class="p">)</span>
  <span class="k">ensure</span>
    <span class="n">body</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:close</span><span class="p">)</span> <span class="n">and</span> <span class="n">body</span><span class="p">.</span><span class="nf">close</span>
  <span class="k">end</span>

  <span class="k">unless</span> <span class="n">client</span><span class="p">.</span><span class="nf">closed?</span>
    <span class="n">client</span><span class="p">.</span><span class="nf">shutdown</span>
    <span class="n">client</span><span class="p">.</span><span class="nf">close</span>
  <span class="k">end</span>
<span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="n">handle_error</span><span class="p">(</span><span class="n">client</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>请求的解析是通过 <code class="highlighter-rouge">Request#read</code> 处理的，而向 Socket 写 HTTP 响应是通过 <code class="highlighter-rouge">#http_response_write</code> 方法来完成的，在这里有关 HTTP 请求的解析和响应的处理都属于一些不重要的实现细节，在这里也就不展开介绍了；当我们已经响应了用户的请求就可以将当前 Socket 直接关掉，断掉这个 TCP 连接了。</p>

<h2 id="调度">调度</h2>

<p>我们在上面已经通过多次 <code class="highlighter-rouge">fork</code> 启动了用于管理 Unicorn worker 进程的 master 以及多个 worker 进程，由于 Unicorn webserver 涉及了多个进程，所以需要进程之间进行调度。</p>

<p>在 Unix 中，进程的调度往往都是通过信号来进行的，<code class="highlighter-rouge">HttpServer#join</code> 就在 Unicorn 的 master 进程上监听外界发送的各种信号，不过在监听信号之前，要通过 <code class="highlighter-rouge">ready_pipe</code> 通知 grandparent 进程当前 master 进程已经启动完毕：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="o">/</span><span class="n">http_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">267</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span>

<span class="k">def</span> <span class="nf">join</span>
  <span class="n">respawn</span> <span class="o">=</span> <span class="kp">true</span>
  <span class="n">last_check</span> <span class="o">=</span> <span class="n">time_now</span>

  <span class="n">proc_name</span> <span class="s1">'master'</span>
  <span class="n">logger</span><span class="p">.</span><span class="nf">info</span> <span class="s2">"master process ready"</span> <span class="c1"># test_exec.rb relies on this message</span>
  <span class="k">if</span> <span class="vi">@ready_pipe</span>
    <span class="k">begin</span>
      <span class="vi">@ready_pipe</span><span class="p">.</span><span class="nf">syswrite</span><span class="p">(</span><span class="vg">$$</span><span class="p">.</span><span class="nf">to_s</span><span class="p">)</span>
    <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
      <span class="n">logger</span><span class="p">.</span><span class="nf">warn</span><span class="p">(</span><span class="s2">"grandparent died too soon?: </span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">message</span><span class="si">}</span><span class="s2"> (</span><span class="si">#{</span><span class="n">e</span><span class="p">.</span><span class="nf">class</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="vi">@ready_pipe</span> <span class="o">=</span> <span class="vi">@ready_pipe</span><span class="p">.</span><span class="nf">close</span> <span class="k">rescue</span> <span class="kp">nil</span>
  <span class="k">end</span>

  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当 grandparent 进程，也就是执行 Unicorn 命令的进程接收到命令退出之后，就可以继续做其他的操作了，而 master 进程会进入一个 while 循环持续监听外界发送的信号：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">join</span>
  <span class="c1"># ...</span>

  <span class="k">begin</span>
    <span class="n">reap_all_workers</span>
    <span class="k">case</span> <span class="vi">@sig_queue</span><span class="p">.</span><span class="nf">shift</span>
    <span class="c1"># ...</span>
    <span class="k">when</span> <span class="ss">:WINCH</span>
      <span class="n">respawn</span> <span class="o">=</span> <span class="kp">false</span>
      <span class="n">soft_kill_each_worker</span><span class="p">(</span><span class="ss">:QUIT</span><span class="p">)</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">worker_processes</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">when</span> <span class="ss">:TTIN</span>
      <span class="n">respawn</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">worker_processes</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">when</span> <span class="ss">:TTOU</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">worker_processes</span> <span class="o">-=</span> <span class="mi">1</span> <span class="k">if</span> <span class="nb">self</span><span class="p">.</span><span class="nf">worker_processes</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="k">when</span> <span class="c1"># ...</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="no">Unicorn</span><span class="p">.</span><span class="nf">log_error</span><span class="p">(</span><span class="vi">@logger</span><span class="p">,</span> <span class="s2">"master loop error"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
  <span class="k">end</span> <span class="k">while</span> <span class="kp">true</span>

  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这一部分的几个信号都会改变当前 Unicorn worker 的进程数，无论是 <code class="highlighter-rouge">TTIN</code>、<code class="highlighter-rouge">TTOU</code> 还是 <code class="highlighter-rouge">WINCH</code> 信号最终都修改了 <code class="highlighter-rouge">worker_processes</code> 变量，其中 <code class="highlighter-rouge">#soft_kill_each_worker</code> 方法向所有的 Unicorn worker 进程发送了 <code class="highlighter-rouge">QUIT</code> 信号。</p>

<p>除了一些用于改变当前 worker 数量的信号，Unicorn 的 master 进程还监听了一些用于终止 master 进程或者更新配置文件的信号。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">join</span>
  <span class="c1"># ...</span>

  <span class="k">begin</span>
    <span class="n">reap_all_workers</span>
    <span class="k">case</span> <span class="vi">@sig_queue</span><span class="p">.</span><span class="nf">shift</span>
    <span class="c1"># ...</span>
    <span class="k">when</span> <span class="ss">:QUIT</span>
      <span class="k">break</span>
    <span class="k">when</span> <span class="ss">:TERM</span><span class="p">,</span> <span class="ss">:INT</span>
      <span class="n">stop</span><span class="p">(</span><span class="kp">false</span><span class="p">)</span>
      <span class="k">break</span>
    <span class="k">when</span> <span class="ss">:HUP</span>
      <span class="n">respawn</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="k">if</span> <span class="n">config</span><span class="p">.</span><span class="nf">config_file</span>
        <span class="n">load_config!</span>
      <span class="k">else</span> <span class="c1"># exec binary and exit if there's no config file</span>
        <span class="n">reexec</span>
      <span class="k">end</span>
    <span class="k">when</span> <span class="c1"># ...</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="no">Unicorn</span><span class="p">.</span><span class="nf">log_error</span><span class="p">(</span><span class="vi">@logger</span><span class="p">,</span> <span class="s2">"master loop error"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
  <span class="k">end</span> <span class="k">while</span> <span class="kp">true</span>

  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>无论是 <code class="highlighter-rouge">QUIT</code> 信号还是 <code class="highlighter-rouge">TERM</code>、<code class="highlighter-rouge">INT</code> 最终都执行了 <code class="highlighter-rouge">#stop</code> 方法，选择使用不同的信号干掉当前 master 管理的 worker 进程：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="o">/</span><span class="n">http_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">339</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span>

<span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="n">graceful</span> <span class="o">=</span> <span class="kp">true</span><span class="p">)</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">listeners</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">limit</span> <span class="o">=</span> <span class="n">time_now</span> <span class="o">+</span> <span class="n">timeout</span>
  <span class="k">until</span> <span class="vi">@workers</span><span class="p">.</span><span class="nf">empty?</span> <span class="o">||</span> <span class="n">time_now</span> <span class="o">&gt;</span> <span class="n">limit</span>
    <span class="k">if</span> <span class="n">graceful</span>
      <span class="n">soft_kill_each_worker</span><span class="p">(</span><span class="ss">:QUIT</span><span class="p">)</span>
    <span class="k">else</span>
      <span class="n">kill_each_worker</span><span class="p">(</span><span class="ss">:TERM</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="nb">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="n">reap_all_workers</span>
  <span class="k">end</span>
  <span class="n">kill_each_worker</span><span class="p">(</span><span class="ss">:KILL</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法其实非常容易理解，它会根据传入的参数选择强制终止或者正常停止所有的 worker 进程，这样整个 Unicorn 服务才真正停止并不再为外界提供服务了。</p>

<p>当我们向 master 发送 <code class="highlighter-rouge">TTIN</code> 或者 <code class="highlighter-rouge">TTOU</code> 信号时只是改变了实例变量 <code class="highlighter-rouge">worker_process</code> 的值，还并没有 <code class="highlighter-rouge">fork</code> 出新的进程，这些操作都是在 <code class="highlighter-rouge">nil</code> 条件中完成的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">join</span>
  <span class="c1"># ...</span>

  <span class="k">begin</span>
    <span class="n">reap_all_workers</span>
    <span class="k">case</span> <span class="vi">@sig_queue</span><span class="p">.</span><span class="nf">shift</span>
    <span class="k">when</span> <span class="kp">nil</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">last_check</span> <span class="o">+</span> <span class="vi">@timeout</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">last_check</span> <span class="o">=</span> <span class="n">time_now</span><span class="p">)</span>
        <span class="n">sleep_time</span> <span class="o">=</span> <span class="n">murder_lazy_workers</span>
      <span class="k">else</span>
        <span class="n">sleep_time</span> <span class="o">=</span> <span class="vi">@timeout</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="k">end</span>
      <span class="n">maintain_worker_count</span> <span class="k">if</span> <span class="n">respawn</span>
      <span class="n">master_sleep</span><span class="p">(</span><span class="n">sleep_time</span><span class="p">)</span>
    <span class="k">when</span> <span class="c1"># ...</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
    <span class="no">Unicorn</span><span class="p">.</span><span class="nf">log_error</span><span class="p">(</span><span class="vi">@logger</span><span class="p">,</span> <span class="s2">"master loop error"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
  <span class="k">end</span> <span class="k">while</span> <span class="kp">true</span>

  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当 <code class="highlighter-rouge">@sig_queue.shift</code> 返回 <code class="highlighter-rouge">nil</code> 时也就代表当前没有需要处理的信号，如果需要创建新的进程或者停掉进程就会通过 <code class="highlighter-rouge">#maintain_worker_count</code> 方法，之后 master 进程会陷入睡眠直到被再次唤醒。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="o">/</span><span class="n">http_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">561</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span>

<span class="k">def</span> <span class="nf">maintain_worker_count</span>
  <span class="p">(</span><span class="n">off</span> <span class="o">=</span> <span class="vi">@workers</span><span class="p">.</span><span class="nf">size</span> <span class="o">-</span> <span class="n">worker_processes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="n">and</span> <span class="k">return</span>
  <span class="n">off</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="n">and</span> <span class="k">return</span> <span class="n">spawn_missing_workers</span>
  <span class="vi">@workers</span><span class="p">.</span><span class="nf">each_value</span> <span class="p">{</span> <span class="o">|</span><span class="n">w</span><span class="o">|</span> <span class="n">w</span><span class="p">.</span><span class="nf">nr</span> <span class="o">&gt;=</span> <span class="n">worker_processes</span> <span class="n">and</span> <span class="n">w</span><span class="p">.</span><span class="nf">soft_kill</span><span class="p">(</span><span class="ss">:QUIT</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>通过创建缺失的进程并关闭多余的进程，我们能够实时的保证整个 Unicorn 服务中的进程数与期望的配置完全相同。</p>

<p>在 Unicorn 的服务中，不仅 master 进程能够接收到来自用户或者其他进程的各种信号，worker 进程也能通过以下的方式将接受到的信号交给 master 处理： </p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="o">/</span><span class="n">http_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">120</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span>

<span class="k">def</span> <span class="nf">start</span>
  <span class="c1"># ...</span>
  <span class="vi">@queue_sigs</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">sig</span><span class="o">|</span> <span class="nb">trap</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="p">{</span> <span class="vi">@sig_queue</span> <span class="o">&lt;&lt;</span> <span class="n">sig</span><span class="p">;</span> <span class="n">awaken_master</span> <span class="p">}</span> <span class="p">}</span>
  <span class="nb">trap</span><span class="p">(</span><span class="ss">:CHLD</span><span class="p">)</span> <span class="p">{</span> <span class="n">awaken_master</span> <span class="p">}</span>
<span class="k">end</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">unicorn</span><span class="o">/</span><span class="n">http_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">391</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Unicorn</span><span class="o">::</span><span class="no">HttpServer</span>

<span class="k">def</span> <span class="nf">awaken_master</span>
  <span class="k">return</span> <span class="k">if</span> <span class="vg">$$</span> <span class="o">!=</span> <span class="vi">@master_pid</span>
  <span class="vi">@self_pipe</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">kgio_trywrite</span><span class="p">(</span><span class="s1">'.'</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>所以即使向 worker 进程发送 <code class="highlighter-rouge">TTIN</code> 或者 <code class="highlighter-rouge">TTOU</code> 等信号也能够改变整个 Unicorn 服务中 worker 进程的个数。</p>

<h2 id="多进程模型">多进程模型</h2>

<p>总的来说，Unicorn 作为 Web 服务使用了多进程的模型，通过一个 master 进程来管理多个 worker 进程，其中 master 进程不负责处理客户端的 HTTP 请求，多个 worker 进程监听同一组 Socket：</p>

<p><img src="https://img.draveness.me/2017-11-08-unicorn-io-model.png" alt="unicorn-io-mode" /></p>

<p>一组 worker 进程在监听 Socket 时，如果发现当前的 Socket 有等待处理的请求时就会在当前的进程中直接通过 <code class="highlighter-rouge">#process_client</code> 方法处理，整个过程会阻塞当前的进程，而多进程阻塞 I/O 的方式没有办法接受慢客户端造成的性能损失，只能通过反向代理 nginx 才可以解决这个问题。</p>

<p><img src="https://img.draveness.me/2017-11-08-unicorn-multi-processes.png" alt="unicorn-multi-processes" /></p>

<p>在 Unicorn 中，worker 之间的负载均衡是由操作系统解决的，所有的 worker 是通过 <code class="highlighter-rouge">.select</code> 方法等待共享 Socket 上的请求，一旦出现可用的 worker，就可以立即进行处理，避开了其他负载均衡算法没有考虑到请求处理时间的问题。</p>

<h2 id="总结">总结</h2>

<p>Unicorn 的源代码其实是作者读过的可读性最差的 Ruby 代码了，很多 Ruby 代码的风格写得跟 C 差不多，看起来也比较头疼，可能是需要处理很多边界条件以及信号，涉及较多底层的进程问题；虽然代码风格上看起来确实让人头疼，不过实现还是值得一看的，重要的代码大都包含在 unicorn.rb 和 http_server.rb 两个文件中，阅读时也不需要改变太多的上下文。</p>

<p>相比于 WEBrick 的单进程多线程的 I/O 模型，Unicorn 的多进程模型有很多优势，一是能够充分利用多核 CPU 的性能，其次能够通过 master 来管理并监控 Unicorn 中包含的一组 worker 并提供了零宕机部署的功能，除此之外，多进程的 I/O 模型还不在乎当前的应用是否是线程安全的，所以不会出现线程竞争等问题，不过 Unicorn 由于 <code class="highlighter-rouge">fork</code> 了大量的 worker 进程，如果长时间的在 Unicorn 上运行内存泄露的应用会非常耗费内存资源，可以考虑使用 <a href="https://github.com/kzk/unicorn-worker-killer">unicorn-worker-killer</a> 来自动重启。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://www.digitalocean.com/community/tutorials/how-to-optimize-unicorn-workers-in-a-ruby-on-rails-app">How To Optimize Unicorn Workers in a Ruby on Rails App</a></li>
  <li><a href="https://read01.com/zh-hk/zm5B.html#.Wf0oLduB0sk">Ruby Web 服务器：这十五年</a></li>
  <li><a href="https://github.com/kzk/unicorn-worker-killer">unicorn-worker-killer</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Daemon_(computing)">Daemon (computing)</a></li>
  <li><a href="http://jiangpeng.info/blogs/2014/03/10/nginx-unicorn.html">Nginx 与 Unicorn</a></li>
  <li><a href="https://github.com/blog/517-unicorn">Unicorn!</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>浅谈 Thin 的事件驱动模型</title>
	  <link>/blogs//rack-thin</link>
	  <author></author>
	  <pubDate>2017-11-04T00:00:00+00:00</pubDate>
	  <guid>/blogs//rack-thin</guid>
	  <description><![CDATA[
	     <ul>
  <li><a href="https://draveness.me/rack">谈谈 Rack 协议与实现</a></li>
  <li><a href="https://draveness.me/rack-webrick">浅谈 WEBrick 的多线程模型</a></li>
  <li><a href="https://draveness.me/rack-thin">浅谈 Thin 的事件驱动模型</a></li>
  <li><a href="https://draveness.me/rack-unicorn">浅谈 Unicorn 的多进程模型</a></li>
  <li><a href="https://draveness.me/rack-puma">浅谈 Puma 的并发模型与实现</a></li>
  <li><a href="https://draveness.me/ruby-webserver">Ruby Web 服务器的并发模型与性能</a></li>
</ul>

<p>在上一篇文章中我们已经介绍了 WEBrick 的实现，它的 handler 是写在 Rack 工程中的，而在这篇文章介绍的 webserver <a href="https://github.com/macournoyer/thin">thin</a> 的 Rack 处理器也是写在 Rack 中的；与 WEBrick 相同，Thin 的实现也非常简单，官方对它的介绍是：</p>

<blockquote>
  <p>A very fast &amp; simple Ruby web server.</p>
</blockquote>

<p>它将 <a href="https://zedshaw.com/archive/ragel-state-charts/">Mongrel</a>、<a href="https://github.com/eventmachine/eventmachine">EventMachine</a> 和 <a href="http://rack.github.io">Rack</a> 三者进行组合，在其中起到胶水的作用，所以在理解 Thin 的实现的过程中我们也需要分析 EventMachine 到底是如何工作的。</p>

<h2 id="thin-的实现">Thin 的实现</h2>

<p>在这一节中我们将从源代码来分析介绍 Thin 的实现原理，因为部分代码仍然是在 Rack 工程中实现的，所以我们要从 Rack 工程的代码开始理解 Thin 的实现。</p>

<h3 id="从-rack-开始">从 Rack 开始</h3>

<p>Thin 的处理器 <code class="highlighter-rouge">Rack::Handler::Thin</code> 与其他遵循 Rack 协议的 webserver 一样都实现了 <code class="highlighter-rouge">.run</code> 方法，接受 Rack 应用和 <code class="highlighter-rouge">options</code> 作为输入：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Rack</span>
  <span class="k">module</span> <span class="nn">Handler</span>
    <span class="k">class</span> <span class="nc">Thin</span>
      <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">run</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{})</span>
        <span class="n">environment</span>  <span class="o">=</span> <span class="no">ENV</span><span class="p">[</span><span class="s1">'RACK_ENV'</span><span class="p">]</span> <span class="o">||</span> <span class="s1">'development'</span>
        <span class="n">default_host</span> <span class="o">=</span> <span class="n">environment</span> <span class="o">==</span> <span class="s1">'development'</span> <span class="p">?</span> <span class="s1">'localhost'</span> <span class="p">:</span> <span class="s1">'0.0.0.0'</span>

        <span class="n">host</span> <span class="o">=</span> <span class="n">options</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="ss">:Host</span><span class="p">)</span> <span class="o">||</span> <span class="n">default_host</span>
        <span class="n">port</span> <span class="o">=</span> <span class="n">options</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="ss">:Port</span><span class="p">)</span> <span class="o">||</span> <span class="mi">8080</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">app</span><span class="p">,</span> <span class="n">options</span><span class="p">]</span>
        <span class="n">args</span><span class="p">.</span><span class="nf">pop</span> <span class="k">if</span> <span class="o">::</span><span class="no">Thin</span><span class="o">::</span><span class="no">VERSION</span><span class="o">::</span><span class="no">MAJOR</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">::</span><span class="no">Thin</span><span class="o">::</span><span class="no">VERSION</span><span class="o">::</span><span class="no">MINOR</span> <span class="o">&lt;</span> <span class="mi">8</span>
        <span class="n">server</span> <span class="o">=</span> <span class="o">::</span><span class="no">Thin</span><span class="o">::</span><span class="no">Server</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">server</span> <span class="k">if</span> <span class="nb">block_given?</span>
        <span class="n">server</span><span class="p">.</span><span class="nf">start</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法仍然会从 <code class="highlighter-rouge">options</code> 中取出 ip 地址和端口号，然后初始化一个 <code class="highlighter-rouge">Thin::Server</code> 的实例后，执行 <code class="highlighter-rouge">#start</code> 方法在 8080 端口上监听来自用户的请求。</p>

<h3 id="初始化服务">初始化服务</h3>

<p>Thin 服务的初始化由以下的代码来处理，首先会处理在 <code class="highlighter-rouge">Rack::Handler::Thin.run</code> 中传入的几个参数 <code class="highlighter-rouge">host</code>、<code class="highlighter-rouge">port</code>、<code class="highlighter-rouge">app</code> 和 <code class="highlighter-rouge">options</code>，将 Rack 应用存储在临时变量中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">100</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="no">DEFAULT_HOST</span><span class="p">,</span> <span class="no">DEFAULT_PORT</span><span class="p">,</span> <span class="p">{}</span>

  <span class="n">args</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">arg</span><span class="o">|</span>
    <span class="k">case</span> <span class="n">arg</span>
    <span class="k">when</span> <span class="mi">0</span><span class="p">.</span><span class="nf">class</span><span class="p">,</span> <span class="sr">/^\d+$/</span> <span class="k">then</span> <span class="n">port</span>    <span class="o">=</span> <span class="n">arg</span><span class="p">.</span><span class="nf">to_i</span>
    <span class="k">when</span> <span class="no">String</span>           <span class="k">then</span> <span class="n">host</span>    <span class="o">=</span> <span class="n">arg</span>
    <span class="k">when</span> <span class="no">Hash</span>             <span class="k">then</span> <span class="n">options</span> <span class="o">=</span> <span class="n">arg</span>
    <span class="k">else</span>
      <span class="vi">@app</span> <span class="o">=</span> <span class="n">arg</span> <span class="k">if</span> <span class="n">arg</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:call</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="vi">@backend</span> <span class="o">=</span> <span class="n">select_backend</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
  <span class="vi">@backend</span><span class="p">.</span><span class="nf">server</span> <span class="o">=</span> <span class="nb">self</span>
  <span class="vi">@backend</span><span class="p">.</span><span class="nf">maximum_connections</span>            <span class="o">=</span> <span class="no">DEFAULT_MAXIMUM_CONNECTIONS</span>
  <span class="vi">@backend</span><span class="p">.</span><span class="nf">maximum_persistent_connections</span> <span class="o">=</span> <span class="no">DEFAULT_MAXIMUM_PERSISTENT_CONNECTIONS</span>
  <span class="vi">@backend</span><span class="p">.</span><span class="nf">timeout</span>                        <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:timeout</span><span class="p">]</span> <span class="o">||</span> <span class="no">DEFAULT_TIMEOUT</span>

  <span class="vi">@app</span> <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">).</span><span class="nf">to_app</span> <span class="k">if</span> <span class="n">block</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在初始化服务的过程中，总共只做了三件事情，处理参数、选择并配置 <code class="highlighter-rouge">backend</code>，创建新的应用：</p>

<p><img src="https://img.draveness.me/2017-11-04-thin-initialize-server.png" alt="thin-initialize-serve" /></p>

<p>处理参数的过程自然不用多说，只是这里判断的方式并不是按照顺序处理的，而是按照参数的类型；在初始化器的最后，如果向初始化器传入了 block，那么就会使用 <code class="highlighter-rouge">Rack::Builder</code> 和 block 中的代码初始化一个新的 Rack 应用。</p>

<h3 id="选择后端">选择后端</h3>

<p>在选择后端时 Thin 使用了 <code class="highlighter-rouge">#select_backend</code> 方法，这里使用 <code class="highlighter-rouge">case</code> 语句替代多个 <code class="highlighter-rouge">if</code>、<code class="highlighter-rouge">else</code>，也是一个我们可以使用的小技巧：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">261</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">select_backend</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
  <span class="k">case</span>
  <span class="k">when</span> <span class="n">options</span><span class="p">.</span><span class="nf">has_key?</span><span class="p">(</span><span class="ss">:backend</span><span class="p">)</span>
    <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">":backend must be a class"</span> <span class="k">unless</span> <span class="n">options</span><span class="p">[</span><span class="ss">:backend</span><span class="p">].</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Class</span><span class="p">)</span>
    <span class="n">options</span><span class="p">[</span><span class="ss">:backend</span><span class="p">].</span><span class="nf">new</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
  <span class="k">when</span> <span class="n">options</span><span class="p">.</span><span class="nf">has_key?</span><span class="p">(</span><span class="ss">:swiftiply</span><span class="p">)</span>
    <span class="no">Backends</span><span class="o">::</span><span class="no">SwiftiplyClient</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
  <span class="k">when</span> <span class="n">host</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="s1">'/'</span><span class="p">)</span>
    <span class="no">Backends</span><span class="o">::</span><span class="no">UnixServer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="no">Backends</span><span class="o">::</span><span class="no">TcpServer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在大多数时候，我们只会选择 <code class="highlighter-rouge">UnixServer</code> 和 <code class="highlighter-rouge">TcpServer</code> 两种后端中的一个，而后者又是两者中使用更为频繁的后端：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">backends</span><span class="o">/</span><span class="n">tcp_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">8</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Backends</span><span class="o">::</span><span class="no">TcpServer</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
  <span class="vi">@host</span> <span class="o">=</span> <span class="n">host</span>
  <span class="vi">@port</span> <span class="o">=</span> <span class="n">port</span>
  <span class="k">super</span><span class="p">()</span>
<span class="k">end</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">backends</span><span class="o">/</span><span class="n">base</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">47</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Backends</span><span class="o">::</span><span class="no">Base</span>

<span class="k">def</span> <span class="nf">initialize</span>
  <span class="vi">@connections</span>                    <span class="o">=</span> <span class="p">{}</span>
  <span class="vi">@timeout</span>                        <span class="o">=</span> <span class="no">Server</span><span class="o">::</span><span class="no">DEFAULT_TIMEOUT</span>
  <span class="vi">@persistent_connection_count</span>    <span class="o">=</span> <span class="mi">0</span>
  <span class="vi">@maximum_connections</span>            <span class="o">=</span> <span class="no">Server</span><span class="o">::</span><span class="no">DEFAULT_MAXIMUM_CONNECTIONS</span>
  <span class="vi">@maximum_persistent_connections</span> <span class="o">=</span> <span class="no">Server</span><span class="o">::</span><span class="no">DEFAULT_MAXIMUM_PERSISTENT_CONNECTIONS</span>
  <span class="vi">@no_epoll</span>                       <span class="o">=</span> <span class="kp">false</span>
  <span class="vi">@ssl</span>                            <span class="o">=</span> <span class="kp">nil</span>
  <span class="vi">@threaded</span>                       <span class="o">=</span> <span class="kp">nil</span>
  <span class="vi">@started_reactor</span>                <span class="o">=</span> <span class="kp">false</span>
<span class="k">end</span>
</code></pre></div></div>

<p>初始化的过程中只是对属性设置默认值，比如 <code class="highlighter-rouge">host</code>、<code class="highlighter-rouge">port</code> 以及超时时间等等，并没有太多值得注意的代码。</p>

<h3 id="启动服务">启动服务</h3>

<p>在启动服务时会直接调用 <code class="highlighter-rouge">TcpServer#start</code> 方法并在其中传入一个用于处理信号的 block：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">152</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">start</span>
  <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s1">'app required'</span> <span class="k">unless</span> <span class="vi">@app</span>
  
  <span class="n">log_info</span>  <span class="s2">"Thin web server (v</span><span class="si">#{</span><span class="no">VERSION</span><span class="o">::</span><span class="no">STRING</span><span class="si">}</span><span class="s2"> codename </span><span class="si">#{</span><span class="no">VERSION</span><span class="o">::</span><span class="no">CODENAME</span><span class="si">}</span><span class="s2">)"</span>
  <span class="n">log_debug</span> <span class="s2">"Debugging ON"</span>
  <span class="n">trace</span>     <span class="s2">"Tracing ON"</span>
  
  <span class="n">log_info</span> <span class="s2">"Maximum connections set to </span><span class="si">#{</span><span class="vi">@backend</span><span class="p">.</span><span class="nf">maximum_connections</span><span class="si">}</span><span class="s2">"</span>
  <span class="n">log_info</span> <span class="s2">"Listening on </span><span class="si">#{</span><span class="vi">@backend</span><span class="si">}</span><span class="s2">, CTRL+C to stop"</span>

  <span class="vi">@backend</span><span class="p">.</span><span class="nf">start</span> <span class="p">{</span> <span class="n">setup_signals</span> <span class="k">if</span> <span class="vi">@setup_signals</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>虽然这里的 <code class="highlighter-rouge">backend</code> 其实已经被选择成了 <code class="highlighter-rouge">TcpServer</code>，但是该子类并没有覆写 <code class="highlighter-rouge">#start</code> 方法，这里执行的方法其实是从父类继承的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">backends</span><span class="o">/</span><span class="n">base</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">60</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Backends</span><span class="o">::</span><span class="no">Base</span>

<span class="k">def</span> <span class="nf">start</span>
  <span class="vi">@stopping</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="n">starter</span>   <span class="o">=</span> <span class="nb">proc</span> <span class="k">do</span>
    <span class="n">connect</span>
    <span class="k">yield</span> <span class="k">if</span> <span class="nb">block_given?</span>
    <span class="vi">@running</span> <span class="o">=</span> <span class="kp">true</span>
  <span class="k">end</span>
  
  <span class="c1"># Allow for early run up of eventmachine.</span>
  <span class="k">if</span> <span class="no">EventMachine</span><span class="p">.</span><span class="nf">reactor_running?</span>
    <span class="n">starter</span><span class="p">.</span><span class="nf">call</span>
  <span class="k">else</span>
    <span class="vi">@started_reactor</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="no">EventMachine</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="n">starter</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法在构建一个 <code class="highlighter-rouge">starter</code> block 之后，将该 block 传入 <code class="highlighter-rouge">EventMachine.run</code> 方法，随后执行的 <code class="highlighter-rouge">#connect</code> 会启动一个 <code class="highlighter-rouge">EventMachine</code> 的服务器用于处理用户的网络请求：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">backends</span><span class="o">/</span><span class="n">tcp_server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">15</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Backends</span><span class="o">::</span><span class="no">TcpServer</span>

<span class="k">def</span> <span class="nf">connect</span>
  <span class="vi">@signature</span> <span class="o">=</span> <span class="no">EventMachine</span><span class="p">.</span><span class="nf">start_server</span><span class="p">(</span><span class="vi">@host</span><span class="p">,</span> <span class="vi">@port</span><span class="p">,</span> <span class="no">Connection</span><span class="p">,</span> <span class="o">&amp;</span><span class="nb">method</span><span class="p">(</span><span class="ss">:initialize_connection</span><span class="p">))</span>
  <span class="n">binary_name</span> <span class="o">=</span> <span class="no">EventMachine</span><span class="p">.</span><span class="nf">get_sockname</span><span class="p">(</span> <span class="vi">@signature</span> <span class="p">)</span>
  <span class="n">port_name</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">unpack_sockaddr_in</span><span class="p">(</span> <span class="n">binary_name</span> <span class="p">)</span>
  <span class="vi">@port</span> <span class="o">=</span> <span class="n">port_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="vi">@host</span> <span class="o">=</span> <span class="n">port_name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="vi">@signature</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 EventMachine 的文档中，<code class="highlighter-rouge">.start_server</code> 方法被描述成一个在指定的地址和端口上初始化 TCP 服务的方法，正如这里所展示的，它经常在 <code class="highlighter-rouge">.run</code> 方法的 block 中执行；该方法的参数 <code class="highlighter-rouge">Connection</code> 作为处理 TCP 请求的类，会实现不同的方法接受各种各样的回调，传入的 <code class="highlighter-rouge">initialize_connection</code> block 会在有请求需要处理时对 <code class="highlighter-rouge">Connection</code> 对象进行初始化：</p>

<blockquote>
  <p><code class="highlighter-rouge">Connection</code> 对象继承自 <code class="highlighter-rouge">EventMachine::Connection</code>，是 EventMachine 与外界的接口，在 EventMachine 中的大部分事件都会调用 <code class="highlighter-rouge">Connection</code> 的一个实例方法来传递数据和参数。</p>
</blockquote>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">backends</span><span class="o">/</span><span class="n">base</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">145</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Backends</span><span class="o">::</span><span class="no">Base</span>

<span class="k">def</span> <span class="nf">initialize_connection</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">backend</span>                 <span class="o">=</span> <span class="nb">self</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">app</span>                     <span class="o">=</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">app</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">comm_inactivity_timeout</span> <span class="o">=</span> <span class="vi">@timeout</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">threaded</span>                <span class="o">=</span> <span class="vi">@threaded</span>
  <span class="n">connection</span><span class="p">.</span><span class="nf">start_tls</span><span class="p">(</span><span class="vi">@ssl_options</span><span class="p">)</span> <span class="k">if</span> <span class="vi">@ssl</span>

  <span class="k">if</span> <span class="vi">@persistent_connection_count</span> <span class="o">&lt;</span> <span class="vi">@maximum_persistent_connections</span>
    <span class="n">connection</span><span class="p">.</span><span class="nf">can_persist!</span>
    <span class="vi">@persistent_connection_count</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">end</span>
  <span class="vi">@connections</span><span class="p">[</span><span class="n">connection</span><span class="p">.</span><span class="nf">__id__</span><span class="p">]</span> <span class="o">=</span> <span class="n">connection</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="处理请求的连接">处理请求的连接</h3>

<p><code class="highlighter-rouge">Connection</code> 类中有很多的方法 <code class="highlighter-rouge">#post_init</code>、<code class="highlighter-rouge">#receive_data</code> 方法等等都是由 EventMachine 在接收到请求时调用的，当 Thin 的服务接收到来自客户端的数据时就会调用 <code class="highlighter-rouge">#receive_data</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">connection</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">36</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Connection</span>

<span class="k">def</span> <span class="nf">receive_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
  <span class="vi">@idle</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="n">trace</span> <span class="n">data</span>
  <span class="n">process</span> <span class="k">if</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="k">rescue</span> <span class="no">InvalidRequest</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="n">log_error</span><span class="p">(</span><span class="s2">"Invalid request"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
  <span class="n">post_process</span> <span class="no">Response</span><span class="o">::</span><span class="no">BAD_REQUEST</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这里我们看到了与 WEBrick 在处理来自客户端的原始数据时使用的方法 <code class="highlighter-rouge">#parse</code>，它会解析客户端请求的原始数据并执行 <code class="highlighter-rouge">#process</code> 来处理 HTTP 请求：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">connection</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">47</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Connection</span>

<span class="k">def</span> <span class="nf">process</span>
  <span class="k">if</span> <span class="n">threaded?</span>
    <span class="vi">@request</span><span class="p">.</span><span class="nf">threaded</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="no">EventMachine</span><span class="p">.</span><span class="nf">defer</span> <span class="p">{</span> <span class="n">post_process</span><span class="p">(</span><span class="n">pre_process</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">else</span>
    <span class="vi">@request</span><span class="p">.</span><span class="nf">threaded</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="n">post_process</span><span class="p">(</span><span class="n">pre_process</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果当前的连接允许并行处理多个用户的请求，那么就会在 <code class="highlighter-rouge">EventMachine.defer</code> 的 block 中执行两个方法 <code class="highlighter-rouge">#pre_process</code> 和 <code class="highlighter-rouge">#post_process</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">connection</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">63</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Connection</span>

<span class="k">def</span> <span class="nf">pre_process</span>
  <span class="vi">@request</span><span class="p">.</span><span class="nf">remote_address</span> <span class="o">=</span> <span class="n">remote_address</span>
  <span class="vi">@request</span><span class="p">.</span><span class="nf">async_callback</span> <span class="o">=</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:post_process</span><span class="p">)</span>

  <span class="n">response</span> <span class="o">=</span> <span class="no">AsyncResponse</span>
  <span class="kp">catch</span><span class="p">(</span><span class="ss">:async</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">response</span> <span class="o">=</span> <span class="vi">@app</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="vi">@request</span><span class="p">.</span><span class="nf">env</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">response</span>
<span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="n">unexpected_error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
  <span class="n">can_persist?</span> <span class="o">&amp;&amp;</span> <span class="vi">@request</span><span class="p">.</span><span class="nf">persistent?</span> <span class="p">?</span> <span class="no">Response</span><span class="o">::</span><span class="no">PERSISTENT_ERROR</span> <span class="p">:</span> <span class="no">Response</span><span class="o">::</span><span class="no">ERROR</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">#pre_process</code> 中没有做太多的事情，只是调用了 Rack 应用的 <code class="highlighter-rouge">#call</code> 方法，得到一个三元组 <code class="highlighter-rouge">response</code>，在这之后将这个数组传入 <code class="highlighter-rouge">#post_process</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">thin</span><span class="o">/</span><span class="n">connection</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">95</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Thin</span><span class="o">::</span><span class="no">Connection</span>

<span class="k">def</span> <span class="nf">post_process</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
  <span class="k">return</span> <span class="k">unless</span> <span class="n">result</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="nf">to_a</span>
  <span class="k">return</span> <span class="k">if</span> <span class="n">result</span><span class="p">.</span><span class="nf">first</span> <span class="o">==</span> <span class="no">AsyncResponse</span><span class="p">.</span><span class="nf">first</span>

  <span class="vi">@response</span><span class="p">.</span><span class="nf">status</span><span class="p">,</span> <span class="vi">@response</span><span class="p">.</span><span class="nf">headers</span><span class="p">,</span> <span class="vi">@response</span><span class="p">.</span><span class="nf">body</span> <span class="o">=</span> <span class="o">*</span><span class="n">result</span>
  <span class="vi">@response</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">chunk</span><span class="o">|</span>
    <span class="n">send_data</span> <span class="n">chunk</span>
  <span class="k">end</span>
<span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="n">unexpected_error</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
  <span class="n">close_connection</span>
<span class="k">ensure</span>
  <span class="k">if</span> <span class="vi">@response</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:callback</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="vi">@response</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:errback</span><span class="p">)</span>
    <span class="vi">@response</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">callback</span> <span class="p">{</span> <span class="n">terminate_request</span> <span class="p">}</span>
    <span class="vi">@response</span><span class="p">.</span><span class="nf">body</span><span class="p">.</span><span class="nf">errback</span>  <span class="p">{</span> <span class="n">terminate_request</span> <span class="p">}</span>
  <span class="k">else</span>
    <span class="n">terminate_request</span> <span class="k">unless</span> <span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">result</span><span class="p">.</span><span class="nf">first</span> <span class="o">==</span> <span class="no">AsyncResponse</span><span class="p">.</span><span class="nf">first</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">#post_response</code> 方法将传入的数组赋值给 <code class="highlighter-rouge">response</code> 的 <code class="highlighter-rouge">status</code>、<code class="highlighter-rouge">headers</code> 和 <code class="highlighter-rouge">body</code> 这三部分，在这之后通过 <code class="highlighter-rouge">#send_data</code> 方法将 HTTP 响应以块的形式写回 Socket；写回结束后可能会调用对应的 <code class="highlighter-rouge">callback</code> 并关闭持有的 <code class="highlighter-rouge">request</code> 和 <code class="highlighter-rouge">response</code> 两个实例变量。</p>

<blockquote>
  <p>上述方法中调用的 <code class="highlighter-rouge">#send_data</code> 继承自 <code class="highlighter-rouge">EventMachine::Connection</code> 类。</p>
</blockquote>

<h3 id="小结">小结</h3>

<p>到此为止，我们对于 Thin 是如何处理来自用户的 HTTP 请求的就比较清楚了，我们可以看到 Thin 本身并没有做一些类似解析 HTTP 数据包以及发送数据的问题，它使用了来自 Rack 和 EventMachine 两个开源框架中很多已有的代码逻辑，确实只做了一些胶水的事情。</p>

<p>对于 Rack 是如何工作的我们在前面的文章 <a href="https://draveness.me/rack">谈谈 Rack 协议与实现</a> 中已经介绍过了；虽然我们看到了很多与 EventMachine 相关的代码，但是到这里我们仍然对 EventMachine 不是太了解。</p>

<h2 id="eventmachine-和-reactor-模式">EventMachine 和 Reactor 模式</h2>

<p>为了更好地理解 Thin 的工作原理，在这里我们会介绍一个 EventMachine 和 Reactor 模式。</p>

<p>EventMachine 其实是一个使用 Ruby 实现的事件驱动的并行框架，它使用 Reactor 模式提供了事件驱动的 IO 模型，如果你对 Node.js 有所了解的话，那么你一定对事件驱动这个词并不陌生，EventMachine 的出现主要是为了解决两个核心问题：</p>

<ul>
  <li>为生产环境提供更高的可伸缩性、更好的性能和稳定性；</li>
  <li>为上层提供了一些能够减少高性能的网络编程复杂性的 API；</li>
</ul>

<p>其实 EventMachine 的主要作用就是将所有同步的 IO 都变成异步的，调度都通过事件来进行，这样用于监听用户请求的进程不会被其他代码阻塞，能够同时为更多的客户端提供服务；在这一节中，我们需要了解一下在 Thin 中使用的 EventMachine 中几个常用方法的实现。</p>

<h3 id="启动事件循环">启动事件循环</h3>

<p>EventMachine 其实就是一个事件循环（Event Loop），当我们想使用 EventMachine 来处理某些任务时就一定需要调用 <code class="highlighter-rouge">.run</code> 方法启动这个事件循环来接受外界触发的各种事件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">eventmachine</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">149</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:EventMachine&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">run</span> <span class="n">blk</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span> <span class="n">tail</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span>
  <span class="c1"># ...</span>
  <span class="k">begin</span>
    <span class="vi">@reactor_pid</span> <span class="o">=</span> <span class="no">Process</span><span class="p">.</span><span class="nf">pid</span>
    <span class="vi">@reactor_running</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="n">initialize_event_machine</span>
    <span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">blk</span> <span class="o">||</span> <span class="n">block</span><span class="p">)</span> <span class="n">and</span> <span class="n">add_timer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">if</span> <span class="vi">@next_tick_queue</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="vi">@next_tick_queue</span><span class="p">.</span><span class="nf">empty?</span>
      <span class="n">add_timer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">signal_loopbreak</span> <span class="p">}</span>
    <span class="k">end</span>
    <span class="vi">@reactor_thread</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span>

    <span class="n">run_machine</span>
  <span class="k">ensure</span>
    <span class="k">until</span> <span class="vi">@tails</span><span class="p">.</span><span class="nf">empty?</span>
      <span class="vi">@tails</span><span class="p">.</span><span class="nf">pop</span><span class="p">.</span><span class="nf">call</span>
    <span class="k">end</span>

    <span class="n">release_machine</span>
    <span class="n">cleanup_machine</span>
    <span class="vi">@reactor_running</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="vi">@reactor_thread</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这里我们会使用 <code class="highlighter-rouge">.initialize_event_machine</code> 初始化当前的事件循环，其实也就是一个全局的 <code class="highlighter-rouge">Reactor</code> 的单例，最终会执行 <code class="highlighter-rouge">Reactor#initialize_for_run</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">522</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">EventMachine</span><span class="o">::</span><span class="no">Reactor</span>

<span class="k">def</span> <span class="nf">initialize_for_run</span>
  <span class="vi">@running</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="vi">@stop_scheduled</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="vi">@selectables</span> <span class="o">||=</span> <span class="p">{};</span> <span class="vi">@selectables</span><span class="p">.</span><span class="nf">clear</span>
  <span class="vi">@timers</span> <span class="o">=</span> <span class="no">SortedSet</span><span class="p">.</span><span class="nf">new</span> <span class="c1"># []</span>
  <span class="n">set_timer_quantum</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
  <span class="vi">@current_loop_time</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span>
  <span class="vi">@next_heartbeat</span> <span class="o">=</span> <span class="vi">@current_loop_time</span> <span class="o">+</span> <span class="no">HeartbeatInterval</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在启动事件循环的过程中，它还会将传入的 block 与一个 <code class="highlighter-rouge">interval</code> 为 0 的键组成键值对存到 <code class="highlighter-rouge">@timers</code> 字典中，所有加入的键值对都会在大约 <code class="highlighter-rouge">interval</code> 的时间过后执行一次 block。</p>

<p>随后执行的 <code class="highlighter-rouge">#run_machine</code> 在最后也会执行 <code class="highlighter-rouge">Reactor</code> 的 <code class="highlighter-rouge">#run</code> 方法，该方法中包含一个 loop 语句，也就是我们一直说的事件循环：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">540</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">EventMachine</span><span class="o">::</span><span class="no">Reactor</span>

<span class="k">def</span> <span class="nf">run</span>
  <span class="k">raise</span> <span class="no">Error</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span> <span class="s2">"already running"</span> <span class="p">)</span> <span class="k">if</span> <span class="vi">@running</span>
  <span class="vi">@running</span> <span class="o">=</span> <span class="kp">true</span>

  <span class="k">begin</span>
    <span class="n">open_loopbreaker</span>

    <span class="kp">loop</span> <span class="p">{</span>
      <span class="vi">@current_loop_time</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span>

      <span class="k">break</span> <span class="k">if</span> <span class="vi">@stop_scheduled</span>
      <span class="n">run_timers</span>
      <span class="k">break</span> <span class="k">if</span> <span class="vi">@stop_scheduled</span>
      <span class="n">crank_selectables</span>
      <span class="k">break</span> <span class="k">if</span> <span class="vi">@stop_scheduled</span>
      <span class="n">run_heartbeats</span>
    <span class="p">}</span>
  <span class="k">ensure</span>
    <span class="n">close_loopbreaker</span>
    <span class="vi">@selectables</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span><span class="o">|</span><span class="n">k</span><span class="p">,</span> <span class="n">io</span><span class="o">|</span> <span class="n">io</span><span class="p">.</span><span class="nf">close</span><span class="p">}</span>
    <span class="vi">@selectables</span><span class="p">.</span><span class="nf">clear</span>

    <span class="vi">@running</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在启动事件循环之间会在 <code class="highlighter-rouge">#open_loopbreaker</code> 中创建一个 <code class="highlighter-rouge">LoopbreakReader</code> 的实例绑定在 <code class="highlighter-rouge">127.0.0.1</code> 和随机的端口号组成的地址上，然后开始运行事件循环。</p>

<p><img src="https://img.draveness.me/2017-11-04-reactor-eventloop.png" alt="reactor-eventloop" /></p>

<p>在事件循环中，Reactor 总共需要执行三部分的任务，分别是执行定时器、处理 Socket 上的事件以及运行心跳方法。</p>

<p>无论是运行定时器还是执行心跳方法其实都非常简单，只要与当前时间进行比较，如果到了触发的时间就调用正确的方法或者回调，最后的 <code class="highlighter-rouge">#crank_selectables</code> 方法就是用于处理 Socket 上读写事件的方法了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">540</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">EventMachine</span><span class="o">::</span><span class="no">Reactor</span>

<span class="k">def</span> <span class="nf">crank_selectables</span>
  <span class="n">readers</span> <span class="o">=</span> <span class="vi">@selectables</span><span class="p">.</span><span class="nf">values</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">io</span><span class="o">|</span> <span class="n">io</span><span class="p">.</span><span class="nf">select_for_reading?</span> <span class="p">}</span>
  <span class="n">writers</span> <span class="o">=</span> <span class="vi">@selectables</span><span class="p">.</span><span class="nf">values</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">io</span><span class="o">|</span> <span class="n">io</span><span class="p">.</span><span class="nf">select_for_writing?</span> <span class="p">}</span>

  <span class="n">s</span> <span class="o">=</span> <span class="nb">select</span><span class="p">(</span><span class="n">readers</span><span class="p">,</span> <span class="n">writers</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="vi">@timer_quantum</span><span class="p">)</span>

  <span class="n">s</span> <span class="n">and</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">and</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">w</span><span class="o">|</span> <span class="n">w</span><span class="p">.</span><span class="nf">eventable_write</span> <span class="p">}</span>
  <span class="n">s</span> <span class="n">and</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">and</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">r</span><span class="o">|</span> <span class="n">r</span><span class="p">.</span><span class="nf">eventable_read</span> <span class="p">}</span>

  <span class="vi">@selectables</span><span class="p">.</span><span class="nf">delete_if</span> <span class="p">{</span><span class="o">|</span><span class="n">k</span><span class="p">,</span><span class="n">io</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">io</span><span class="p">.</span><span class="nf">close_scheduled?</span>
      <span class="n">io</span><span class="p">.</span><span class="nf">close</span>
      <span class="k">begin</span>
        <span class="no">EventMachine</span><span class="o">::</span><span class="n">event_callback</span> <span class="n">io</span><span class="p">.</span><span class="nf">uuid</span><span class="p">,</span> <span class="no">ConnectionUnbound</span><span class="p">,</span> <span class="kp">nil</span>
      <span class="k">rescue</span> <span class="no">ConnectionNotBound</span><span class="p">;</span> <span class="k">end</span>
      <span class="kp">true</span>
    <span class="k">end</span>
  <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法会在 Socket 变成可读或者可写时执行 <code class="highlighter-rouge">#eventable_write</code> 或 <code class="highlighter-rouge">#eventable_read</code> 执行事件的回调，我们暂时放下这两个方法，先来了解一下 EventMachine 是如何启动服务的。</p>

<h3 id="启动服务-1">启动服务</h3>

<p>在启动服务的过程中，最重要的目的就是创建一个 Socket 并绑定在指定的 ip 和端口上，在实现这个目的的过程中，我们使用了以下的几个方法，首先是 <code class="highlighter-rouge">EventMachine.start_server</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">eventmachine</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">516</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:EventMachine&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">start_server</span> <span class="n">server</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span>
  <span class="n">port</span> <span class="o">=</span> <span class="no">Integer</span><span class="p">(</span><span class="n">port</span><span class="p">)</span>
  <span class="n">klass</span> <span class="o">=</span> <span class="n">klass_from_handler</span><span class="p">(</span><span class="no">Connection</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

  <span class="n">s</span> <span class="o">=</span> <span class="k">if</span> <span class="n">port</span>
        <span class="n">start_tcp_server</span> <span class="n">server</span><span class="p">,</span> <span class="n">port</span>
      <span class="k">else</span>
        <span class="n">start_unix_server</span> <span class="n">server</span>
      <span class="k">end</span>
  <span class="vi">@acceptors</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">klass</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">block</span><span class="p">]</span>
  <span class="n">s</span>
<span class="k">end</span>
</code></pre></div></div>

<p>该方法其实使我们在使用 EventMachine 时常见的接口，只要我们想要启动一个新的 TCP 或者 UNIX 服务器，就可以上述方法，在这里会根据端口号是否存在，选择执行 <code class="highlighter-rouge">.start_tcp_server</code> 或者 <code class="highlighter-rouge">.start_unix_server</code> 创建一个新的 Socket 并存储在 <code class="highlighter-rouge">@acceptors</code> 中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">184</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:EventMachine&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">start_tcp_server</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span>
  <span class="p">(</span><span class="n">s</span> <span class="o">=</span> <span class="no">EvmaTCPServer</span><span class="p">.</span><span class="nf">start_server</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span> <span class="n">or</span> <span class="k">raise</span> <span class="s2">"no acceptor"</span>
  <span class="n">s</span><span class="p">.</span><span class="nf">uuid</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">EventMachine.start_tcp_server</code> 在这里也只做了个『转发』方法的作用的，直接调用 <code class="highlighter-rouge">EvmaTCPServer.start_server</code> 创建一个新的 Socket 对象并绑定到传入的 <code class="highlighter-rouge">&lt;host, port&gt;</code> 上：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">1108</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:EventMachine::EvmaTCPServer&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">start_server</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span>
  <span class="n">sd</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span> <span class="no">Socket</span><span class="o">::</span><span class="no">AF_LOCAL</span><span class="p">,</span> <span class="no">Socket</span><span class="o">::</span><span class="no">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span>
  <span class="n">sd</span><span class="p">.</span><span class="nf">setsockopt</span><span class="p">(</span> <span class="no">Socket</span><span class="o">::</span><span class="no">SOL_SOCKET</span><span class="p">,</span> <span class="no">Socket</span><span class="o">::</span><span class="no">SO_REUSEADDR</span><span class="p">,</span> <span class="kp">true</span> <span class="p">)</span>
  <span class="n">sd</span><span class="p">.</span><span class="nf">bind</span><span class="p">(</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">pack_sockaddr_in</span><span class="p">(</span> <span class="n">port</span><span class="p">,</span> <span class="n">host</span> <span class="p">))</span>
  <span class="n">sd</span><span class="p">.</span><span class="nf">listen</span><span class="p">(</span> <span class="mi">50</span> <span class="p">)</span> <span class="c1"># 5 is what you see in all the books. Ain't enough.</span>
  <span class="no">EvmaTCPServer</span><span class="p">.</span><span class="nf">new</span> <span class="n">sd</span>
<span class="k">end</span>
</code></pre></div></div>

<p>方法的最后会创建一个新的 <code class="highlighter-rouge">EvmaTCPServer</code> 实例的过程中，我们需要通过 <code class="highlighter-rouge">#fcntl</code> 将 Socket 变成非阻塞式的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">687</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">EventMachine</span><span class="o">::</span><span class="no">Selectable</span>

<span class="k">def</span> <span class="nf">initialize</span> <span class="n">io</span>
  <span class="vi">@io</span> <span class="o">=</span> <span class="n">io</span>
  <span class="vi">@uuid</span> <span class="o">=</span> <span class="no">UuidGenerator</span><span class="p">.</span><span class="nf">generate</span>
  <span class="vi">@is_server</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="vi">@last_activity</span> <span class="o">=</span> <span class="no">Reactor</span><span class="p">.</span><span class="nf">instance</span><span class="p">.</span><span class="nf">current_loop_time</span>

  <span class="n">m</span> <span class="o">=</span> <span class="vi">@io</span><span class="p">.</span><span class="nf">fcntl</span><span class="p">(</span><span class="no">Fcntl</span><span class="o">::</span><span class="no">F_GETFL</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="vi">@io</span><span class="p">.</span><span class="nf">fcntl</span><span class="p">(</span><span class="no">Fcntl</span><span class="o">::</span><span class="no">F_SETFL</span><span class="p">,</span> <span class="no">Fcntl</span><span class="o">::</span><span class="no">O_NONBLOCK</span> <span class="o">|</span> <span class="n">m</span><span class="p">)</span>

  <span class="vi">@close_scheduled</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="vi">@close_requested</span> <span class="o">=</span> <span class="kp">false</span>

  <span class="n">se</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span> <span class="vi">@io</span><span class="p">.</span><span class="nf">instance_eval</span> <span class="p">{</span> <span class="vi">@my_selectable</span> <span class="o">=</span> <span class="n">se</span> <span class="p">}</span>
  <span class="no">Reactor</span><span class="p">.</span><span class="nf">instance</span><span class="p">.</span><span class="nf">add_selectable</span> <span class="vi">@io</span>
<span class="k">end</span>
</code></pre></div></div>

<p>不只是 <code class="highlighter-rouge">EvmaTCPServer</code>，所有的 <code class="highlighter-rouge">Selectable</code> 子类在初始化的最后都会将新的 Socket 以 <code class="highlighter-rouge">uuid</code> 为键存储到 <code class="highlighter-rouge">Reactor</code> 单例对象的 <code class="highlighter-rouge">@selectables</code> 字典中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">532</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">EventMachine</span><span class="o">::</span><span class="no">Reactor</span>

<span class="k">def</span> <span class="nf">add_selectable</span> <span class="n">io</span>
  <span class="vi">@selectables</span><span class="p">[</span><span class="n">io</span><span class="p">.</span><span class="nf">uuid</span><span class="p">]</span> <span class="o">=</span> <span class="n">io</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在整个事件循环的大循环中，这里存入的所有 Socket 都会被 <code class="highlighter-rouge">#select</code> 方法监听，在响应的事件发生时交给合适的回调处理，作者在 <a href="https://draveness.me/redis-eventloop">Redis 中的事件循环</a> 一文中也介绍过非常相似的处理过程。</p>

<p><img src="https://img.draveness.me/2017-11-04-eventmachine-select.png" alt="eventmachine-select" /></p>

<p>所有的 Socket 都会存储在一个 <code class="highlighter-rouge">@selectables</code> 的哈希中并由 <code class="highlighter-rouge">#select</code> 方法监听所有的读写事件，一旦相应的事件触发就会通过 <code class="highlighter-rouge">eventable_read</code> 或者 <code class="highlighter-rouge">eventable_write</code> 方法来响应该事件。</p>

<h3 id="处理读写事件">处理读写事件</h3>

<p>所有的读写事件都是通过 <code class="highlighter-rouge">Selectable</code> 和它的子类来处理的，在 EventMachine 中，总共有以下的几种子类：</p>

<p><img src="https://img.draveness.me/2017-11-04-selectable-and-subclasses.png" alt="selectable-and-subclasses" /></p>

<p>所有处理服务端读写事件的都是 <code class="highlighter-rouge">Selectable</code> 的子类，也就是 <code class="highlighter-rouge">EvmaTCPServer</code> 和 <code class="highlighter-rouge">EvmaUNIXServer</code>，而所有处理客户端读写事件的都是 <code class="highlighter-rouge">StreamObject</code> 的子类 <code class="highlighter-rouge">EvmaTCPServer</code> 和 <code class="highlighter-rouge">EvmaUNIXClient</code>。</p>

<p>当我们初始化的绑定在 <code class="highlighter-rouge">&lt;host, port&gt;</code> 上的 Socket 对象监听到了来自用户的 TCP 请求时，当前的 Socket 就会变得可读，事件循环中的 <code class="highlighter-rouge">#select</code> 方法就会调用 <code class="highlighter-rouge">EvmaTCPClient#eventable_read</code> 通知由一个请求需要处理：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">1130</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">EventMachine</span><span class="o">::</span><span class="no">EvmaTCPServer</span>

<span class="k">def</span> <span class="nf">eventable_read</span>
  <span class="k">begin</span>
    <span class="mi">10</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span>
      <span class="n">descriptor</span><span class="p">,</span> <span class="n">peername</span> <span class="o">=</span> <span class="n">io</span><span class="p">.</span><span class="nf">accept_nonblock</span>
      <span class="n">sd</span> <span class="o">=</span> <span class="no">EvmaTCPClient</span><span class="p">.</span><span class="nf">new</span> <span class="n">descriptor</span>
      <span class="n">sd</span><span class="p">.</span><span class="nf">is_server</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="no">EventMachine</span><span class="o">::</span><span class="n">event_callback</span> <span class="n">uuid</span><span class="p">,</span> <span class="no">ConnectionAccepted</span><span class="p">,</span> <span class="n">sd</span><span class="p">.</span><span class="nf">uuid</span>
    <span class="p">}</span>
  <span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">EWOULDBLOCK</span><span class="p">,</span> <span class="no">Errno</span><span class="o">::</span><span class="no">EAGAIN</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这里会尝试多次 <code class="highlighter-rouge">#accept_non_block</code> 当前的 Socket 并会创建一个 TCP 的客户端对象 <code class="highlighter-rouge">EvmaTCPClient</code>，同时通过 <code class="highlighter-rouge">.event_callback</code> 方法发送 <code class="highlighter-rouge">ConnectionAccepted</code> 消息。</p>

<p><code class="highlighter-rouge">EventMachine::event_callback</code> 就像是一个用于处理所有事件的中心方法，所有的回调都要通过这个中继器进行调度，在实现上就是一个庞大的 <code class="highlighter-rouge">if</code>、<code class="highlighter-rouge">else</code> 语句，里面处理了 EventMachine 中可能出现的 10 种状态和操作：</p>

<p><img src="https://img.draveness.me/2017-11-04-event-callback.png" alt="event-callback" /></p>

<p>大多数事件在触发时，都会从 <code class="highlighter-rouge">@conns</code> 中取出相应的 <code class="highlighter-rouge">Connection</code> 对象，最后执行合适的方法来处理，而这里触发的 <code class="highlighter-rouge">ConnectionAccepted</code> 事件是通过以下的代码来处理的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">eventmachine</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">1462</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:EventMachine&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">event_callback</span> <span class="n">conn_binding</span><span class="p">,</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">data</span>
  <span class="k">if</span> <span class="n">opcode</span> <span class="o">==</span> <span class="c1"># ...</span>
    <span class="c1"># ...</span>
  <span class="k">elsif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="no">ConnectionAccepted</span>
    <span class="n">accep</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">blk</span> <span class="o">=</span> <span class="vi">@acceptors</span><span class="p">[</span><span class="n">conn_binding</span><span class="p">]</span>
    <span class="k">raise</span> <span class="no">NoHandlerForAcceptedConnection</span> <span class="k">unless</span> <span class="n">accep</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">accep</span><span class="p">.</span><span class="nf">new</span> <span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span>
    <span class="vi">@conns</span><span class="p">[</span><span class="n">data</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
    <span class="n">blk</span> <span class="n">and</span> <span class="n">blk</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="n">c</span>
  <span class="k">else</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述的 <code class="highlighter-rouge">accep</code> 变量就是我们在 Thin 调用 <code class="highlighter-rouge">.start_server</code> 时传入的 <code class="highlighter-rouge">Connection</code> 类，在这里我们初始化了一个新的实例，同时以 Socket 的 <code class="highlighter-rouge">uuid</code> 作为键存到 <code class="highlighter-rouge">@conns</code> 中。</p>

<p>在这之后 <code class="highlighter-rouge">#select</code> 方法就会监听更多 Socket 上的事件了，当这个 “accept” 后创建的 Socket 接收到数据时，就会触发下面的 <code class="highlighter-rouge">#eventable_read</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">1130</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">EventMachine</span><span class="o">::</span><span class="no">StreamObject</span>

<span class="k">def</span> <span class="nf">eventable_read</span>
  <span class="vi">@last_activity</span> <span class="o">=</span> <span class="no">Reactor</span><span class="p">.</span><span class="nf">instance</span><span class="p">.</span><span class="nf">current_loop_time</span>
  <span class="k">begin</span>
    <span class="k">if</span> <span class="n">io</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:read_nonblock</span><span class="p">)</span>
      <span class="mi">10</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">io</span><span class="p">.</span><span class="nf">read_nonblock</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
        <span class="no">EventMachine</span><span class="o">::</span><span class="n">event_callback</span> <span class="n">uuid</span><span class="p">,</span> <span class="no">ConnectionData</span><span class="p">,</span> <span class="n">data</span>
      <span class="p">}</span>
    <span class="k">else</span>
      <span class="n">data</span> <span class="o">=</span> <span class="n">io</span><span class="p">.</span><span class="nf">sysread</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
      <span class="no">EventMachine</span><span class="o">::</span><span class="n">event_callback</span> <span class="n">uuid</span><span class="p">,</span> <span class="no">ConnectionData</span><span class="p">,</span> <span class="n">data</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">EAGAIN</span><span class="p">,</span> <span class="no">Errno</span><span class="o">::</span><span class="no">EWOULDBLOCK</span><span class="p">,</span> <span class="no">SSLConnectionWaitReadable</span>
  <span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">ECONNRESET</span><span class="p">,</span> <span class="no">Errno</span><span class="o">::</span><span class="no">ECONNREFUSED</span><span class="p">,</span> <span class="no">EOFError</span><span class="p">,</span> <span class="no">Errno</span><span class="o">::</span><span class="no">EPIPE</span><span class="p">,</span> <span class="no">OpenSSL</span><span class="o">::</span><span class="no">SSL</span><span class="o">::</span><span class="no">SSLError</span>
    <span class="vi">@close_scheduled</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="no">EventMachine</span><span class="o">::</span><span class="n">event_callback</span> <span class="n">uuid</span><span class="p">,</span> <span class="no">ConnectionUnbound</span><span class="p">,</span> <span class="kp">nil</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>方法会从 Socket 中读取数据并通过 <code class="highlighter-rouge">.event_callback</code> 发送 <code class="highlighter-rouge">ConnectionData</code> 事件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">eventmachine</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">1462</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:EventMachine&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">event_callback</span> <span class="n">conn_binding</span><span class="p">,</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">data</span>
  <span class="k">if</span> <span class="n">opcode</span> <span class="o">==</span> <span class="c1"># ...</span>
    <span class="c1"># ...</span>
  <span class="k">elsif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="no">ConnectionData</span>
    <span class="n">c</span> <span class="o">=</span> <span class="vi">@conns</span><span class="p">[</span><span class="n">conn_binding</span><span class="p">]</span> <span class="n">or</span> <span class="k">raise</span> <span class="no">ConnectionNotBound</span><span class="p">,</span> <span class="s2">"received data </span><span class="si">#{</span><span class="n">data</span><span class="si">}</span><span class="s2"> for unknown signature: </span><span class="si">#{</span><span class="n">conn_binding</span><span class="si">}</span><span class="s2">"</span>
    <span class="n">c</span><span class="p">.</span><span class="nf">receive_data</span> <span class="n">data</span>
  <span class="k">else</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>从上述方法对 <code class="highlighter-rouge">ConnectionData</code> 事件的处理就可以看到通过传入 Socket 的 <code class="highlighter-rouge">uuid</code> 和数据，就可以找到上面初始化的 <code class="highlighter-rouge">Connection</code> 对象，<code class="highlighter-rouge">#receive_data</code> 方法就能够将数据传递到上层，让用户在自定义的 <code class="highlighter-rouge">Connection</code> 中实现自己的处理逻辑，这也就是 Thin 需要覆写 <code class="highlighter-rouge">#receive_data</code> 方法来接受数据的原因了。</p>

<p>当 Thin 以及 Rack 应用已经接收到了来自用户的请求、完成处理并返回之后经过一系列复杂的调用栈就会执行 <code class="highlighter-rouge">Connection#send_data</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">connection</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">324</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">EventMachine</span><span class="o">::</span><span class="no">Connection</span>

<span class="k">def</span> <span class="nf">send_data</span> <span class="n">data</span>
  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">to_s</span>
  <span class="n">size</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">bytesize</span> <span class="k">if</span> <span class="n">data</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:bytesize</span><span class="p">)</span>
  <span class="n">size</span> <span class="o">||=</span> <span class="n">data</span><span class="p">.</span><span class="nf">size</span>
  <span class="no">EventMachine</span><span class="o">::</span><span class="n">send_data</span> <span class="vi">@signature</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">size</span>
<span class="k">end</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">172</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:EventMachine&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">send_data</span> <span class="n">target</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">datalength</span>
  <span class="n">selectable</span> <span class="o">=</span> <span class="no">Reactor</span><span class="p">.</span><span class="nf">instance</span><span class="p">.</span><span class="nf">get_selectable</span><span class="p">(</span> <span class="n">target</span> <span class="p">)</span> <span class="n">or</span> <span class="k">raise</span> <span class="s2">"unknown send_data target"</span>
  <span class="n">selectable</span><span class="p">.</span><span class="nf">send_data</span> <span class="n">data</span>
<span class="k">end</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">851</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">EventMachine</span><span class="o">::</span><span class="no">StreamObject</span>

<span class="k">def</span> <span class="nf">send_data</span> <span class="n">data</span>
  <span class="k">unless</span> <span class="vi">@close_scheduled</span> <span class="n">or</span> <span class="vi">@close_requested</span> <span class="n">or</span> <span class="o">!</span><span class="n">data</span> <span class="n">or</span> <span class="n">data</span><span class="p">.</span><span class="nf">length</span> <span class="o">&lt;=</span> <span class="mi">0</span>
    <span class="vi">@outbound_q</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">.</span><span class="nf">to_s</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>经过一系列同名方法的调用，在调用栈末尾的 <code class="highlighter-rouge">StreamObject#send_data</code> 中，将所有需要写入的数据全部加入 <code class="highlighter-rouge">@outbound_q</code> 中，这其实就是一个待写入数据的队列。</p>

<p>当 Socket 变得可写之后，就会由 <code class="highlighter-rouge">#select</code> 方法触发 <code class="highlighter-rouge">#eventable_write</code> 将 <code class="highlighter-rouge">@outbound_q</code> 队列中的数据通过 <code class="highlighter-rouge">#write_nonblock</code> 或者 <code class="highlighter-rouge">syswrite</code> 写入 Socket，也就是将请求返回给客户端。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">823</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">EventMachine</span><span class="o">::</span><span class="no">StreamObject</span>

<span class="k">def</span> <span class="nf">eventable_write</span>
  <span class="vi">@last_activity</span> <span class="o">=</span> <span class="no">Reactor</span><span class="p">.</span><span class="nf">instance</span><span class="p">.</span><span class="nf">current_loop_time</span>
  <span class="k">while</span> <span class="n">data</span> <span class="o">=</span> <span class="vi">@outbound_q</span><span class="p">.</span><span class="nf">shift</span> <span class="k">do</span>
    <span class="k">begin</span>
      <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">to_s</span>
      <span class="n">w</span> <span class="o">=</span> <span class="k">if</span> <span class="n">io</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:write_nonblock</span><span class="p">)</span>
            <span class="n">io</span><span class="p">.</span><span class="nf">write_nonblock</span> <span class="n">data</span>
          <span class="k">else</span>
            <span class="n">io</span><span class="p">.</span><span class="nf">syswrite</span> <span class="n">data</span>
          <span class="k">end</span>

      <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">.</span><span class="nf">length</span>
        <span class="vi">@outbound_q</span><span class="p">.</span><span class="nf">unshift</span> <span class="n">data</span><span class="p">[</span><span class="n">w</span><span class="o">..-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">break</span>
      <span class="k">end</span>
    <span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">EAGAIN</span><span class="p">,</span> <span class="no">SSLConnectionWaitReadable</span><span class="p">,</span> <span class="no">SSLConnectionWaitWritable</span>
      <span class="vi">@outbound_q</span><span class="p">.</span><span class="nf">unshift</span> <span class="n">data</span>
      <span class="k">break</span>
    <span class="k">rescue</span> <span class="no">EOFError</span><span class="p">,</span> <span class="no">Errno</span><span class="o">::</span><span class="no">ECONNRESET</span><span class="p">,</span> <span class="no">Errno</span><span class="o">::</span><span class="no">ECONNREFUSED</span><span class="p">,</span> <span class="no">Errno</span><span class="o">::</span><span class="no">EPIPE</span><span class="p">,</span> <span class="no">OpenSSL</span><span class="o">::</span><span class="no">SSL</span><span class="o">::</span><span class="no">SSLError</span>
      <span class="vi">@close_scheduled</span> <span class="o">=</span> <span class="kp">true</span>
      <span class="vi">@outbound_q</span><span class="p">.</span><span class="nf">clear</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="关闭-socket">关闭 Socket</h3>

<p>当数据写入时发生了 <code class="highlighter-rouge">EOFError</code> 或者其他错误时就会将 <code class="highlighter-rouge">close_scheduled</code> 标记为 <code class="highlighter-rouge">true</code>，在随后的事件循环中会关闭 Socket 并发送 <code class="highlighter-rouge">ConnectionUnbound</code> 事件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">em</span><span class="o">/</span><span class="n">pure_ruby</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">540</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">EventMachine</span><span class="o">::</span><span class="no">Reactor</span>

<span class="k">def</span> <span class="nf">crank_selectables</span>
  <span class="c1"># ...</span>

  <span class="vi">@selectables</span><span class="p">.</span><span class="nf">delete_if</span> <span class="p">{</span><span class="o">|</span><span class="n">k</span><span class="p">,</span><span class="n">io</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">io</span><span class="p">.</span><span class="nf">close_scheduled?</span>
      <span class="n">io</span><span class="p">.</span><span class="nf">close</span>
      <span class="k">begin</span>
        <span class="no">EventMachine</span><span class="o">::</span><span class="n">event_callback</span> <span class="n">io</span><span class="p">.</span><span class="nf">uuid</span><span class="p">,</span> <span class="no">ConnectionUnbound</span><span class="p">,</span> <span class="kp">nil</span>
      <span class="k">rescue</span> <span class="no">ConnectionNotBound</span><span class="p">;</span> <span class="k">end</span>
      <span class="kp">true</span>
    <span class="k">end</span>
  <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">.event_callback</code> 在处理 <code class="highlighter-rouge">ConnectionUnbound</code> 事件时会在 <code class="highlighter-rouge">@conns</code> 中将结束的 <code class="highlighter-rouge">Connection</code> 剔除：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">event_callback</span> <span class="n">conn_binding</span><span class="p">,</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">data</span>
  <span class="k">if</span> <span class="n">opcode</span> <span class="o">==</span> <span class="no">ConnectionUnbound</span>
    <span class="k">if</span> <span class="n">c</span> <span class="o">=</span> <span class="vi">@conns</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span> <span class="n">conn_binding</span> <span class="p">)</span>
      <span class="n">c</span><span class="p">.</span><span class="nf">unbind</span>
      <span class="n">io</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="nf">instance_variable_get</span><span class="p">(</span><span class="ss">:@io</span><span class="p">)</span>
      <span class="k">begin</span>
        <span class="n">io</span><span class="p">.</span><span class="nf">close</span>
      <span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">EBADF</span><span class="p">,</span> <span class="no">IOError</span>
      <span class="k">end</span>
    <span class="k">elsif</span> <span class="n">c</span> <span class="o">=</span> <span class="vi">@acceptors</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span> <span class="n">conn_binding</span> <span class="p">)</span>
    <span class="k">else</span>
      <span class="k">raise</span> <span class="no">ConnectionNotBound</span><span class="p">,</span> <span class="s2">"received ConnectionUnbound for an unknown signature: </span><span class="si">#{</span><span class="n">conn_binding</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>
  <span class="k">elsif</span> <span class="n">opcode</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="c1">#...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这之后会调用 <code class="highlighter-rouge">Connection</code> 的 <code class="highlighter-rouge">#unbind</code> 方法，再次执行 <code class="highlighter-rouge">#close</code> 确保 Socket 连接已经断掉了。</p>

<h3 id="小结-1">小结</h3>

<p>EventMachine 在处理用户的请求时，会通过一个事件循环和一个中心化的事件处理中心 <code class="highlighter-rouge">.event_callback</code> 来响应所有的事件，你可以看到在使用 EventMachine 时所有的响应都是异步的，尤其是对 Socket 的读写，所有外部的输入在 EventMachine 看来都是一个事件，它们会被 EventMachine 选择合适的处理器进行转发。</p>

<h2 id="io-模型">I/O 模型</h2>

<p>Thin 本身其实没有实现任何的 I/O 模型，它通过对 EventMachine 进行封装，使用了其事件驱动的特点，为上层提供了处理并发 I/O 的 Reactor 模型，在不同的阶段有着不同的工作流程，在启动 Thin 的服务时，Thin 会直接通过 <code class="highlighter-rouge">.start_server</code> 创建一个 Socket 监听一个 <code class="highlighter-rouge">&lt;host, port&gt;</code> 组成的元组：</p>

<p><img src="https://img.draveness.me/2017-11-04-thin-start-server.png" alt="thin-start-server" /></p>

<p>当服务启动之后，就可以接受来自客户端的 HTTP 请求了，处理 HTTP 请求总共需要三个模块的合作，分别是 EventMachine、Thin 以及 Rack 应用：</p>

<p><img src="https://img.draveness.me/2017-11-04-thin-handle-request.png" alt="thin-handle-request" /></p>

<p>在上图中省略了 Rack 的处理部分，不过对于其他部分的展示还是比较详细的，EventMachine 负责对 TCP Socket 进行监听，在发生事件时通过 <code class="highlighter-rouge">.event_callback</code> 进行处理，将消息转发给位于 Thin 中的 <code class="highlighter-rouge">Connection</code>，该类以及模块负责处理 HTTP 协议相关的内容，将整个请求包装成一个 <code class="highlighter-rouge">env</code> 对象，调用 <code class="highlighter-rouge">#call</code> 方法。</p>

<p>在这时就开始了返回响应的逻辑了，<code class="highlighter-rouge">#call</code> 方法会返回一个三元组，经过 Thin 中的 <code class="highlighter-rouge">#send_data</code> 最终将数据写入 <code class="highlighter-rouge">outbound_q</code> 队列中等待处理：</p>

<p><img src="https://img.draveness.me/2017-11-04-thin-send-response.png" alt="thin-send-response" /></p>

<p>EventMachine 会通过一个事件循环，使用 <code class="highlighter-rouge">#select</code> 监听当前 Socket 的可读写状态，并在合适的时候触发 <code class="highlighter-rouge">#eventable_write</code> 从 <code class="highlighter-rouge">outbound_q</code> 队列中读取数据写入 Socket，在写入结束后 Socket 就会被关闭，整个请求的响应也就结束了。</p>

<p><img src="https://img.draveness.me/2017-11-04-thin-io-model.png" alt="thin-io-model" /></p>

<p>Thin 使用了 EventMachine 作为底层处理 TCP 协议的框架，提供了事件驱动的 I/O 模型，也就是我们理解的 Reactor 模型，对于每一个 HTTP 请求都会创建一个对应的 <code class="highlighter-rouge">Connection</code> 对象，所有的事件都由 EventMachine 来派发，最大程度做到了 I/O 的读写都是异步的，不会阻塞当前的线程，这也是 Thin 以及 Node.js 能够并发处理大量请求的原因。</p>

<h2 id="总结">总结</h2>

<p>Thin 作为一个 Ruby 社区中简单的 webserver，其实本身没有做太多的事情，只是使用了 EventMachine 提供的事件驱动的 I/O 模型，为上层提供了更加易用的 API，相比于其他同步处理请求的 webserver，Reactor 模式的优点就是 Thin 的优点，主程序只负责监听事件和分发事件，一旦涉及到 I/O 的工作都尽量使用回调的方式处理，当回调完成后再发送通知，这种方式能够减少进程的等待时间，时刻都在处理用户的请求和事件。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://zedshaw.com/archive/ragel-state-charts/">Ragel State Charts</a></li>
  <li><a href="http://www.colm.net/open-source/ragel/">Ragel State Machine Compiler</a></li>
  <li><a href="https://www.igvita.com/2008/05/27/ruby-eventmachine-the-speed-demon/">Ruby EventMachine - The Speed Demon</a></li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>浅谈 WEBrick 的多线程模型</title>
	  <link>/blogs//rack-webrick</link>
	  <author></author>
	  <pubDate>2017-11-01T00:00:00+00:00</pubDate>
	  <guid>/blogs//rack-webrick</guid>
	  <description><![CDATA[
	     <ul>
  <li><a href="https://draveness.me/rack">谈谈 Rack 协议与实现</a></li>
  <li><a href="https://draveness.me/rack-webrick">浅谈 WEBrick 的多线程模型</a></li>
  <li><a href="https://draveness.me/rack-thin">浅谈 Thin 的事件驱动模型</a></li>
  <li><a href="https://draveness.me/rack-unicorn">浅谈 Unicorn 的多进程模型</a></li>
  <li><a href="https://draveness.me/rack-puma">浅谈 Puma 的并发模型与实现</a></li>
  <li><a href="https://draveness.me/ruby-webserver">Ruby Web 服务器的并发模型与性能</a></li>
</ul>

<p>这篇文章会介绍在开发环境中最常用的应用容器 WEBrick 的实现原理，除了通过源代码分析之外，我们也会介绍它的 IO 模型以及一些特点。</p>

<p>在 GitHub 上，WEBrick 从 2003 年的六月份就开始开发了，有着十几年历史的 WEBrick 的实现非常简单，总共只有 4000 多行的代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">loc_counter</span> <span class="o">.</span>
<span class="mi">40</span> <span class="n">files</span> <span class="n">processed</span>
<span class="no">Total</span>     <span class="mi">6918</span> <span class="n">lines</span>
<span class="no">Empty</span>     <span class="mi">990</span> <span class="n">lines</span>
<span class="no">Comments</span>  <span class="mi">1927</span> <span class="n">lines</span>
<span class="no">Code</span>      <span class="mi">4001</span> <span class="n">lines</span>
</code></pre></div></div>

<h2 id="webrick-的实现">WEBrick 的实现</h2>

<p>由于 WEBrick 是 Rack 中内置的处理器，所以与 Unicorn 和 Puma 这种第三方开发的 webserver 不同，WEBrick 的处理器是在 Rack 中实现的，而 WEBrick 的运行也都是从这个处理器的开始的。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Rack</span>
  <span class="k">module</span> <span class="nn">Handler</span>
    <span class="k">class</span> <span class="nc">WEBrick</span> <span class="o">&lt;</span> <span class="o">::</span><span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServlet</span><span class="o">::</span><span class="no">AbstractServlet</span>
      <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">run</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{})</span>
        <span class="n">environment</span>  <span class="o">=</span> <span class="no">ENV</span><span class="p">[</span><span class="s1">'RACK_ENV'</span><span class="p">]</span> <span class="o">||</span> <span class="s1">'development'</span>
        <span class="n">default_host</span> <span class="o">=</span> <span class="n">environment</span> <span class="o">==</span> <span class="s1">'development'</span> <span class="p">?</span> <span class="s1">'localhost'</span> <span class="p">:</span> <span class="kp">nil</span>

        <span class="n">options</span><span class="p">[</span><span class="ss">:BindAddress</span><span class="p">]</span> <span class="o">=</span> <span class="n">options</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="ss">:Host</span><span class="p">)</span> <span class="o">||</span> <span class="n">default_host</span>
        <span class="n">options</span><span class="p">[</span><span class="ss">:Port</span><span class="p">]</span> <span class="o">||=</span> <span class="mi">8080</span>
        <span class="vi">@server</span> <span class="o">=</span> <span class="o">::</span><span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
        <span class="vi">@server</span><span class="p">.</span><span class="nf">mount</span> <span class="s2">"/"</span><span class="p">,</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Handler</span><span class="o">::</span><span class="no">WEBrick</span><span class="p">,</span> <span class="n">app</span>
        <span class="k">yield</span> <span class="vi">@server</span>  <span class="k">if</span> <span class="nb">block_given?</span>
        <span class="vi">@server</span><span class="p">.</span><span class="nf">start</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>我们在上一篇文章 <a href="https://draveness.me/rack">谈谈 Rack 协议与实现</a> 中介绍 Rack 的实现原理时，最终调用了上述方法，从这里开始大部分的实现都与 WEBrick 有关了。</p>

<p>在这里，你可以看到方法会先处理传入的参数比如：地址、端口号等等，在这之后会使用 WEBrick 提供的 <code class="highlighter-rouge">HTTPServer</code> 来处理 HTTP 请求，调用 <code class="highlighter-rouge">mount</code> 在根路由上挂载应用和处理器 <code class="highlighter-rouge">Rack::Handler::WEBrick</code> 接受请求，最后执行 <code class="highlighter-rouge">#start</code> 方法启动服务器。</p>

<h3 id="初始化服务器">初始化服务器</h3>

<p><code class="highlighter-rouge">HTTPServer</code> 的初始化分为两个阶段，一部分是 <code class="highlighter-rouge">HTTPServer</code> 的初始化，另一部分调用父类的 <code class="highlighter-rouge">initialize</code> 方法，在自己构造器中，会配置当前服务器能够处理的 HTTP 版本并初始化新的 <code class="highlighter-rouge">MountTable</code> 实例：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">webrick</span><span class="o">/</span><span class="n">httpserver</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">46</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:WEBrick::HTTPServer&gt;</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="p">{},</span> <span class="n">default</span><span class="o">=</span><span class="no">Config</span><span class="o">::</span><span class="no">HTTP</span><span class="p">)</span>
  <span class="k">super</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
  <span class="vi">@http_version</span> <span class="o">=</span> <span class="no">HTTPVersion</span><span class="o">::</span><span class="n">convert</span><span class="p">(</span><span class="vi">@config</span><span class="p">[</span><span class="ss">:HTTPVersion</span><span class="p">])</span>

  <span class="vi">@mount_tab</span> <span class="o">=</span> <span class="no">MountTable</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">if</span> <span class="vi">@config</span><span class="p">[</span><span class="ss">:DocumentRoot</span><span class="p">]</span>
    <span class="n">mount</span><span class="p">(</span><span class="s2">"/"</span><span class="p">,</span> <span class="no">HTTPServlet</span><span class="o">::</span><span class="no">FileHandler</span><span class="p">,</span> <span class="vi">@config</span><span class="p">[</span><span class="ss">:DocumentRoot</span><span class="p">],</span>
          <span class="vi">@config</span><span class="p">[</span><span class="ss">:DocumentRootOptions</span><span class="p">])</span>
  <span class="k">end</span>

  <span class="k">unless</span> <span class="vi">@config</span><span class="p">[</span><span class="ss">:AccessLog</span><span class="p">]</span>
    <span class="vi">@config</span><span class="p">[</span><span class="ss">:AccessLog</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
      <span class="p">[</span> <span class="vg">$stderr</span><span class="p">,</span> <span class="no">AccessLog</span><span class="o">::</span><span class="no">COMMON_LOG_FORMAT</span> <span class="p">],</span>
      <span class="p">[</span> <span class="vg">$stderr</span><span class="p">,</span> <span class="no">AccessLog</span><span class="o">::</span><span class="no">REFERER_LOG_FORMAT</span> <span class="p">]</span>
    <span class="p">]</span>
  <span class="k">end</span>

  <span class="vi">@virtual_hosts</span> <span class="o">=</span> <span class="no">Array</span><span class="p">.</span><span class="nf">new</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在父类 <code class="highlighter-rouge">GenericServer</code> 中初始化了用于监听端口号的 Socket 连接：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">webrick</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">185</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:WEBrick::GenericServer&gt;</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="p">{},</span> <span class="n">default</span><span class="o">=</span><span class="no">Config</span><span class="o">::</span><span class="no">General</span><span class="p">)</span>
  <span class="vi">@config</span> <span class="o">=</span> <span class="n">default</span><span class="p">.</span><span class="nf">dup</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
  <span class="vi">@status</span> <span class="o">=</span> <span class="ss">:Stop</span>

  <span class="vi">@listeners</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">listen</span><span class="p">(</span><span class="vi">@config</span><span class="p">[</span><span class="ss">:BindAddress</span><span class="p">],</span> <span class="vi">@config</span><span class="p">[</span><span class="ss">:Port</span><span class="p">])</span>
  <span class="k">if</span> <span class="vi">@config</span><span class="p">[</span><span class="ss">:Port</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="vi">@config</span><span class="p">[</span><span class="ss">:Port</span><span class="p">]</span> <span class="o">=</span> <span class="vi">@listeners</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">addr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>每一个服务器都会在初始化的时候创建一系列的 <code class="highlighter-rouge">listener</code> 用于监听地址和端口号组成的元组，其内部调用了 <code class="highlighter-rouge">Utils</code> 模块中定义的方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">webrick</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">127</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:WEBrick::GenericServer&gt;</span>

<span class="k">def</span> <span class="nf">listen</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
  <span class="vi">@listeners</span> <span class="o">+=</span> <span class="no">Utils</span><span class="o">::</span><span class="n">create_listeners</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
<span class="k">end</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">webrick</span><span class="o">/</span><span class="n">utils</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">61</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:WEBrick::Utils&gt;</span>

<span class="k">def</span> <span class="nf">create_listeners</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
  <span class="n">sockets</span> <span class="o">=</span> <span class="no">Socket</span><span class="p">.</span><span class="nf">tcp_server_sockets</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span>
  <span class="n">sockets</span> <span class="o">=</span> <span class="n">sockets</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span><span class="o">|</span><span class="n">s</span><span class="o">|</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">autoclose</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="n">ts</span> <span class="o">=</span> <span class="no">TCPServer</span><span class="p">.</span><span class="nf">for_fd</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="nf">fileno</span><span class="p">)</span>
    <span class="n">s</span><span class="p">.</span><span class="nf">close</span>
    <span class="n">ts</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">sockets</span>
<span class="k">end</span>
<span class="kp">module_function</span> <span class="ss">:create_listeners</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">.create_listeners</code> 方法中调用了 <code class="highlighter-rouge">.tcp_server_sockets</code> 方法由于初始化一组 <code class="highlighter-rouge">Socket</code> 对象，最后得到一个数组的 <code class="highlighter-rouge">TCPServer</code> 实例。</p>

<h3 id="挂载应用">挂载应用</h3>

<p>在使用 <code class="highlighter-rouge">WEBrick</code> 启动服务的时候，第二步就是将处理器和 Rack 应用挂载到根路由下：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="vi">@server</span><span class="p">.</span><span class="nf">mount</span> <span class="s2">"/"</span><span class="p">,</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Handler</span><span class="o">::</span><span class="no">WEBrick</span><span class="p">,</span> <span class="n">app</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">#mount</code> 方法其实是一个比较简单的方法，因为我们在构造器中已经初始化了 <code class="highlighter-rouge">MountTable</code> 对象，所以这一步只是将传入的多个参数放到这个表中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">webrick</span><span class="o">/</span><span class="n">httpserver</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">155</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServer</span>

<span class="k">def</span> <span class="nf">mount</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">servlet</span><span class="p">,</span> <span class="o">*</span><span class="n">options</span><span class="p">)</span>
  <span class="vi">@mount_tab</span><span class="p">[</span><span class="n">dir</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="n">servlet</span><span class="p">,</span> <span class="n">options</span> <span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">MountTable</code> 是一个包含从路由到 Rack 处理器一个 App 的映射表：</p>

<p><img src="https://img.draveness.me/2017-11-01-mounttable-and-applications.png" alt="mounttable-and-applications" /></p>

<p>当执行了 <code class="highlighter-rouge">MountTable</code> 的 <code class="highlighter-rouge">#compile</code> 方法时，上述的对象就会将表中的所有键按照加入的顺序逆序拼接成一个如下的正则表达式用来匹配传入的路由：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">^</span><span class="p">(</span><span class="sr">/|/</span><span class="n">admin</span><span class="o">|</span><span class="sr">/user)(?=/</span><span class="o">|</span><span class="err">$</span><span class="p">)</span>
</code></pre></div></div>

<p>上述正则表达式在使用时如果匹配到了指定的路由就会返回 <code class="highlighter-rouge">$&amp;</code> 和 <code class="highlighter-rouge">$'</code> 两个部分，前者表示整个匹配的文本，后者表示匹配文本后面的字符串。</p>

<h3 id="启动服务器">启动服务器</h3>

<p>在 <code class="highlighter-rouge">Rack::Handler::WEBrick</code> 中的 <code class="highlighter-rouge">.run</code> 方法先初始化了服务器，将处理器和应用挂载到了根路由上，在最后执行 <code class="highlighter-rouge">#start</code> 方法启动服务器：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">webrick</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">152</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">WEBrick</span><span class="o">::</span><span class="no">GenericServer</span>

<span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">raise</span> <span class="no">ServerError</span><span class="p">,</span> <span class="s2">"already started."</span> <span class="k">if</span> <span class="vi">@status</span> <span class="o">!=</span> <span class="ss">:Stop</span>

  <span class="vi">@status</span> <span class="o">=</span> <span class="ss">:Running</span>
  <span class="k">begin</span>
    <span class="k">while</span> <span class="vi">@status</span> <span class="o">==</span> <span class="ss">:Running</span>
      <span class="k">begin</span>
        <span class="k">if</span> <span class="n">svrs</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">select</span><span class="p">([</span><span class="o">*</span><span class="vi">@listeners</span><span class="p">],</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">)</span>
          <span class="n">svrs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">each</span><span class="p">{</span> <span class="o">|</span><span class="n">svr</span><span class="o">|</span>
            <span class="n">sock</span> <span class="o">=</span> <span class="n">accept_client</span><span class="p">(</span><span class="n">svr</span><span class="p">)</span>
            <span class="n">start_thread</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
          <span class="p">}</span>
        <span class="k">end</span>
      <span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">EBADF</span><span class="p">,</span> <span class="no">Errno</span><span class="o">::</span><span class="no">ENOTSOCK</span><span class="p">,</span> <span class="no">IOError</span><span class="p">,</span> <span class="no">StandardError</span> <span class="o">=&gt;</span> <span class="n">ex</span>
      <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">ex</span>
        <span class="k">raise</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">ensure</span>
    <span class="n">cleanup_listener</span>
    <span class="vi">@status</span> <span class="o">=</span> <span class="ss">:Stop</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>由于原方法的实现比较复杂不容易阅读，在这里对方法进行了简化，省略了向 logger 中输出内容、处理服务的关闭以及执行回调等功能。</p>

<p>我们可以理解为上述方法通过 <code class="highlighter-rouge">.select</code> 方法对一组 Socket 进行监听，当有消息需要处理时就依次执行 <code class="highlighter-rouge">#accept_client</code> 和 <code class="highlighter-rouge">#start_thread</code> 两个方法处理来自客户端的请求：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">webrick</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">254</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">WEBrick</span><span class="o">::</span><span class="no">GenericServer</span>

<span class="k">def</span> <span class="nf">accept_client</span><span class="p">(</span><span class="n">svr</span><span class="p">)</span>
  <span class="n">sock</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="k">begin</span>
    <span class="n">sock</span> <span class="o">=</span> <span class="n">svr</span><span class="p">.</span><span class="nf">accept</span>
    <span class="n">sock</span><span class="p">.</span><span class="nf">sync</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="no">Utils</span><span class="o">::</span><span class="n">set_non_blocking</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
  <span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">ECONNRESET</span><span class="p">,</span> <span class="no">Errno</span><span class="o">::</span><span class="no">ECONNABORTED</span><span class="p">,</span>
         <span class="no">Errno</span><span class="o">::</span><span class="no">EPROTO</span><span class="p">,</span> <span class="no">Errno</span><span class="o">::</span><span class="no">EINVAL</span>
  <span class="k">rescue</span> <span class="no">StandardError</span> <span class="o">=&gt;</span> <span class="n">ex</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">"</span><span class="si">#{</span><span class="n">ex</span><span class="p">.</span><span class="nf">class</span><span class="si">}</span><span class="s2">: </span><span class="si">#{</span><span class="n">ex</span><span class="p">.</span><span class="nf">message</span><span class="si">}</span><span class="se">\n\t</span><span class="si">#{</span><span class="n">ex</span><span class="p">.</span><span class="nf">backtrace</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">"</span>
    <span class="vi">@logger</span><span class="p">.</span><span class="nf">error</span> <span class="n">msg</span>
  <span class="k">end</span>
  <span class="k">return</span> <span class="n">sock</span>
<span class="k">end</span>
</code></pre></div></div>

<p>WEBrick 在 <code class="highlighter-rouge">#accept_client</code> 方法中执行了 <code class="highlighter-rouge">#accept</code> 方法来得到一个 TCP 客户端 Socket，同时会通过 <code class="highlighter-rouge">set_non_blocking</code> 将该 Socket 变成非阻塞的，最后在方法末尾返回创建的 Socket。</p>

<p>在 <code class="highlighter-rouge">#start_thread</code> 方法中会<strong>开启一个新的线程</strong>，并在新的线程中执行 <code class="highlighter-rouge">#run</code> 方法来处理请求：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">webrick</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">278</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">WEBrick</span><span class="o">::</span><span class="no">GenericServer</span>

<span class="k">def</span> <span class="nf">start_thread</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="no">Thread</span><span class="p">.</span><span class="nf">start</span> <span class="p">{</span>
    <span class="k">begin</span>
      <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">[</span><span class="ss">:WEBrickSocket</span><span class="p">]</span> <span class="o">=</span> <span class="n">sock</span>
      <span class="n">run</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
    <span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">ENOTCONN</span><span class="p">,</span> <span class="no">ServerError</span><span class="p">,</span> <span class="no">Exception</span>
    <span class="k">ensure</span>
      <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">[</span><span class="ss">:WEBrickSocket</span><span class="p">]</span> <span class="o">=</span> <span class="kp">nil</span>
      <span class="n">sock</span><span class="p">.</span><span class="nf">close</span>
    <span class="k">end</span>
  <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="处理请求">处理请求</h3>

<p>所有的请求都不会由 <code class="highlighter-rouge">GenericServer</code> 这个通用的服务器来处理，它只处理通用的逻辑，对于 HTTP 请求的处理都是在 <code class="highlighter-rouge">HTTPServer#run</code> 中完成的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">webrick</span><span class="o">/</span><span class="n">httpserver</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">69</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServer</span>

<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
  <span class="k">while</span> <span class="kp">true</span>
    <span class="n">res</span> <span class="o">=</span> <span class="no">HTTPResponse</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@config</span><span class="p">)</span>
    <span class="n">req</span> <span class="o">=</span> <span class="no">HTTPRequest</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@config</span><span class="p">)</span>
    <span class="n">server</span> <span class="o">=</span> <span class="nb">self</span>
    <span class="k">begin</span>
      <span class="n">timeout</span> <span class="o">=</span> <span class="vi">@config</span><span class="p">[</span><span class="ss">:RequestTimeout</span><span class="p">]</span>
      <span class="k">while</span> <span class="n">timeout</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">break</span> <span class="k">if</span> <span class="n">sock</span><span class="p">.</span><span class="nf">to_io</span><span class="p">.</span><span class="nf">wait_readable</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="k">break</span> <span class="k">if</span> <span class="vi">@status</span> <span class="o">!=</span> <span class="ss">:Running</span>
        <span class="n">timeout</span> <span class="o">-=</span> <span class="mf">0.5</span>
      <span class="k">end</span>
      <span class="k">raise</span> <span class="no">HTTPStatus</span><span class="o">::</span><span class="no">EOFError</span> <span class="k">if</span> <span class="n">timeout</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="vi">@status</span> <span class="o">!=</span> <span class="ss">:Running</span>
      <span class="k">raise</span> <span class="no">HTTPStatus</span><span class="o">::</span><span class="no">EOFError</span> <span class="k">if</span> <span class="n">sock</span><span class="p">.</span><span class="nf">eof?</span>
      <span class="n">req</span><span class="p">.</span><span class="nf">parse</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
      <span class="n">res</span><span class="p">.</span><span class="nf">request_method</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="nf">request_method</span>
      <span class="n">res</span><span class="p">.</span><span class="nf">request_uri</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="nf">request_uri</span>
      <span class="n">res</span><span class="p">.</span><span class="nf">request_http_version</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="nf">http_version</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">service</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
    <span class="k">rescue</span> <span class="no">HTTPStatus</span><span class="o">::</span><span class="no">EOFError</span><span class="p">,</span> <span class="no">HTTPStatus</span><span class="o">::</span><span class="no">RequestTimeout</span><span class="p">,</span> <span class="no">HTTPStatus</span><span class="o">::</span><span class="no">Error</span> <span class="o">=&gt;</span> <span class="n">ex</span>
      <span class="n">res</span><span class="p">.</span><span class="nf">set_error</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
    <span class="k">rescue</span> <span class="no">HTTPStatus</span><span class="o">::</span><span class="no">Status</span> <span class="o">=&gt;</span> <span class="n">ex</span>
      <span class="n">res</span><span class="p">.</span><span class="nf">status</span> <span class="o">=</span> <span class="n">ex</span><span class="p">.</span><span class="nf">code</span>
    <span class="k">rescue</span> <span class="no">StandardError</span> <span class="o">=&gt;</span> <span class="n">ex</span>
      <span class="n">res</span><span class="p">.</span><span class="nf">set_error</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span>
    <span class="k">ensure</span>
      <span class="n">res</span><span class="p">.</span><span class="nf">send_response</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span> <span class="k">if</span> <span class="n">req</span><span class="p">.</span><span class="nf">request_line</span>
    <span class="k">end</span>
    <span class="k">break</span> <span class="k">if</span> <span class="vi">@http_version</span> <span class="o">&lt;</span> <span class="s2">"1.1"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>对 HTTP 协议了解的读者应该能从上面的代码中看到很多与 HTTP 协议相关的东西，比如 HTTP 的版本号、方法、URL 等等，上述方法总共做了三件事情，等待监听的 Socket 变得可读，执行 <code class="highlighter-rouge">#parse</code> 方法解析 Socket 上的数据，通过 <code class="highlighter-rouge">#service</code> 方法完成处理请求的响应，首先是对 Socket 上的数据进行解析：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">webrick</span><span class="o">/</span><span class="n">httprequest</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">192</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPRequest</span>

<span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">socket</span><span class="o">=</span><span class="kp">nil</span><span class="p">)</span>
  <span class="vi">@socket</span> <span class="o">=</span> <span class="n">socket</span>
  <span class="k">begin</span>
    <span class="vi">@peeraddr</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:peeraddr</span><span class="p">)</span> <span class="p">?</span> <span class="n">socket</span><span class="p">.</span><span class="nf">peeraddr</span> <span class="p">:</span> <span class="p">[]</span>
    <span class="vi">@addr</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:addr</span><span class="p">)</span> <span class="p">?</span> <span class="n">socket</span><span class="p">.</span><span class="nf">addr</span> <span class="p">:</span> <span class="p">[]</span>
  <span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">ENOTCONN</span>
    <span class="k">raise</span> <span class="no">HTTPStatus</span><span class="o">::</span><span class="no">EOFError</span>
  <span class="k">end</span>

  <span class="n">read_request_line</span><span class="p">(</span><span class="n">socket</span><span class="p">)</span>
  <span class="k">if</span> <span class="vi">@http_version</span><span class="p">.</span><span class="nf">major</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
  <span class="k">return</span> <span class="k">if</span> <span class="vi">@request_method</span> <span class="o">==</span> <span class="s2">"CONNECT"</span>
  <span class="k">return</span> <span class="k">if</span> <span class="vi">@unparsed_uri</span> <span class="o">==</span> <span class="s2">"*"</span>

  <span class="k">begin</span>
    <span class="n">setup_forwarded_info</span>
    <span class="vi">@request_uri</span> <span class="o">=</span> <span class="n">parse_uri</span><span class="p">(</span><span class="vi">@unparsed_uri</span><span class="p">)</span>
    <span class="vi">@path</span> <span class="o">=</span> <span class="no">HTTPUtils</span><span class="o">::</span><span class="n">unescape</span><span class="p">(</span><span class="vi">@request_uri</span><span class="p">.</span><span class="nf">path</span><span class="p">)</span>
    <span class="vi">@path</span> <span class="o">=</span> <span class="no">HTTPUtils</span><span class="o">::</span><span class="n">normalize_path</span><span class="p">(</span><span class="vi">@path</span><span class="p">)</span>
    <span class="vi">@host</span> <span class="o">=</span> <span class="vi">@request_uri</span><span class="p">.</span><span class="nf">host</span>
    <span class="vi">@port</span> <span class="o">=</span> <span class="vi">@request_uri</span><span class="p">.</span><span class="nf">port</span>
    <span class="vi">@query_string</span> <span class="o">=</span> <span class="vi">@request_uri</span><span class="p">.</span><span class="nf">query</span>
    <span class="vi">@script_name</span> <span class="o">=</span> <span class="s2">""</span>
    <span class="vi">@path_info</span> <span class="o">=</span> <span class="vi">@path</span><span class="p">.</span><span class="nf">dup</span>
  <span class="k">rescue</span>
    <span class="k">raise</span> <span class="no">HTTPStatus</span><span class="o">::</span><span class="no">BadRequest</span><span class="p">,</span> <span class="s2">"bad URI `</span><span class="si">#{</span><span class="vi">@unparsed_uri</span><span class="si">}</span><span class="s2">'."</span>
  <span class="k">end</span>

  <span class="k">if</span> <span class="sr">/close/io</span> <span class="o">=~</span> <span class="nb">self</span><span class="p">[</span><span class="s2">"connection"</span><span class="p">]</span>
    <span class="c1"># deal with keep alive</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>由于 HTTP 协议本身就比较复杂，请求中包含的信息也非常多，所以在这里用于<strong>解析</strong> HTTP 请求的代码也很多，想要了解 WEBrick 是如何解析 HTTP 请求的可以看 httprequest.rb 文件中的代码，在处理了 HTTP 请求之后，就开始执行 <code class="highlighter-rouge">#service</code> 响应该 HTTP 请求了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">webrick</span><span class="o">/</span><span class="n">httpserver</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">125</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServer</span>

<span class="k">def</span> <span class="nf">service</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
  <span class="n">servlet</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">script_name</span><span class="p">,</span> <span class="n">path_info</span> <span class="o">=</span> <span class="n">search_servlet</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="nf">path</span><span class="p">)</span>
  <span class="k">raise</span> <span class="no">HTTPStatus</span><span class="o">::</span><span class="no">NotFound</span><span class="p">,</span> <span class="s2">"`</span><span class="si">#{</span><span class="n">req</span><span class="p">.</span><span class="nf">path</span><span class="si">}</span><span class="s2">' not found."</span> <span class="k">unless</span> <span class="n">servlet</span>
  <span class="n">req</span><span class="p">.</span><span class="nf">script_name</span> <span class="o">=</span> <span class="n">script_name</span>
  <span class="n">req</span><span class="p">.</span><span class="nf">path_info</span> <span class="o">=</span> <span class="n">path_info</span>
  <span class="n">si</span> <span class="o">=</span> <span class="n">servlet</span><span class="p">.</span><span class="nf">get_instance</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="o">*</span><span class="n">options</span><span class="p">)</span>
  <span class="n">si</span><span class="p">.</span><span class="nf">service</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这里我们会从上面提到的 <code class="highlighter-rouge">MountTable</code> 中找出在之前注册的处理器 handler 和 Rack 应用：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">webrick</span><span class="o">/</span><span class="n">httpserver</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">182</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServer</span>

<span class="k">def</span> <span class="nf">search_servlet</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
  <span class="n">script_name</span><span class="p">,</span> <span class="n">path_info</span> <span class="o">=</span> <span class="vi">@mount_tab</span><span class="p">.</span><span class="nf">scan</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
  <span class="n">servlet</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="vi">@mount_tab</span><span class="p">[</span><span class="n">script_name</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">servlet</span>
    <span class="p">[</span> <span class="n">servlet</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">script_name</span><span class="p">,</span> <span class="n">path_info</span> <span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>得到了处理器 handler 之后，通过 <code class="highlighter-rouge">.get_instance</code> 方法创建一个新的实例，这个方法在大多数情况下等同于初始化方法 <code class="highlighter-rouge">.new</code>，随后调用了该处理器 <code class="highlighter-rouge">Rack::WEBrick::Handler</code> 的 <code class="highlighter-rouge">#service</code> 方法，该方法是在 rack 工程中定义的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">rack</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">handler</span><span class="o">/</span><span class="n">webrick</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">57</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Handler</span><span class="o">::</span><span class="no">WEBrick</span>

<span class="k">def</span> <span class="nf">service</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>
  <span class="n">res</span><span class="p">.</span><span class="nf">rack</span> <span class="o">=</span> <span class="kp">true</span>
  <span class="n">env</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="nf">meta_vars</span>
  <span class="n">env</span><span class="p">.</span><span class="nf">delete_if</span> <span class="p">{</span> <span class="o">|</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">|</span> <span class="n">v</span><span class="p">.</span><span class="nf">nil?</span> <span class="p">}</span>

  <span class="n">env</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span>
    <span class="c1"># ...</span>
    <span class="no">RACK_URL_SCHEME</span>   <span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"yes"</span><span class="p">,</span> <span class="s2">"on"</span><span class="p">,</span> <span class="s2">"1"</span><span class="p">].</span><span class="nf">include?</span><span class="p">(</span><span class="n">env</span><span class="p">[</span><span class="no">HTTPS</span><span class="p">])</span> <span class="p">?</span> <span class="s2">"https"</span> <span class="p">:</span> <span class="s2">"http"</span><span class="p">,</span>
    <span class="c1"># ...</span>
  <span class="p">)</span>
  
  <span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">body</span> <span class="o">=</span> <span class="vi">@app</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
  <span class="k">begin</span>
    <span class="n">res</span><span class="p">.</span><span class="nf">status</span> <span class="o">=</span> <span class="n">status</span><span class="p">.</span><span class="nf">to_i</span>
    <span class="n">headers</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">k</span><span class="p">,</span> <span class="n">vs</span><span class="o">|</span>
      <span class="c1"># ...</span>
    <span class="p">}</span>

    <span class="n">body</span><span class="p">.</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">part</span><span class="o">|</span>
      <span class="n">res</span><span class="p">.</span><span class="nf">body</span> <span class="o">&lt;&lt;</span> <span class="n">part</span>
    <span class="p">}</span>
  <span class="k">ensure</span>
    <span class="n">body</span><span class="p">.</span><span class="nf">close</span>  <span class="k">if</span> <span class="n">body</span><span class="p">.</span><span class="nf">respond_to?</span> <span class="ss">:close</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>由于上述方法也涉及了非常多 HTTP 协议的实现细节所以很多过程都被省略了，在上述方法中，我们先构建了应用的输入 <code class="highlighter-rouge">env</code> 哈希变量，然后通过执行 <code class="highlighter-rouge">#call</code> 方法将控制权交给 Rack 应用，最后获得一个由 <code class="highlighter-rouge">status</code>、<code class="highlighter-rouge">headers</code> 和 <code class="highlighter-rouge">body</code> 组成的三元组；在接下来的代码中，分别对这三者进行处理，为这次请求『填充』一个完成的 HTTP 请求。</p>

<p>到这里，最后由 <code class="highlighter-rouge">WEBrick::HTTPServer#run</code> 方法中的 <code class="highlighter-rouge">ensure</code> block 来结束整个 HTTP 请求的处理：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">webrick</span><span class="o">/</span><span class="n">httpserver</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">69</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServer</span>

<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span>
  <span class="k">while</span> <span class="kp">true</span>
    <span class="n">res</span> <span class="o">=</span> <span class="no">HTTPResponse</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@config</span><span class="p">)</span>
    <span class="n">req</span> <span class="o">=</span> <span class="no">HTTPRequest</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@config</span><span class="p">)</span>
    <span class="n">server</span> <span class="o">=</span> <span class="nb">self</span>
    <span class="k">begin</span>
      <span class="c1"># ...</span>
    <span class="k">ensure</span>
      <span class="n">res</span><span class="p">.</span><span class="nf">send_response</span><span class="p">(</span><span class="n">sock</span><span class="p">)</span> <span class="k">if</span> <span class="n">req</span><span class="p">.</span><span class="nf">request_line</span>
    <span class="k">end</span>
    <span class="k">break</span> <span class="k">if</span> <span class="vi">@http_version</span> <span class="o">&lt;</span> <span class="s2">"1.1"</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">#send_reponse</code> 方法中，分别执行了 <code class="highlighter-rouge">#send_header</code> 和 <code class="highlighter-rouge">#send_body</code> 方法向当前的 Socket 中发送 HTTP 响应中的数据：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">webrick</span><span class="o">/</span><span class="n">httpresponse</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">205</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPResponse</span>

<span class="k">def</span> <span class="nf">send_response</span><span class="p">(</span><span class="n">socket</span><span class="p">)</span>
  <span class="k">begin</span>
    <span class="n">setup_header</span><span class="p">()</span>
    <span class="n">send_header</span><span class="p">(</span><span class="n">socket</span><span class="p">)</span>
    <span class="n">send_body</span><span class="p">(</span><span class="n">socket</span><span class="p">)</span>
  <span class="k">rescue</span> <span class="no">Errno</span><span class="o">::</span><span class="no">EPIPE</span><span class="p">,</span> <span class="no">Errno</span><span class="o">::</span><span class="no">ECONNRESET</span><span class="p">,</span> <span class="no">Errno</span><span class="o">::</span><span class="no">ENOTCONN</span> <span class="o">=&gt;</span> <span class="n">ex</span>
    <span class="vi">@logger</span><span class="p">.</span><span class="nf">debug</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
    <span class="vi">@keep_alive</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">ex</span>
    <span class="vi">@logger</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
    <span class="vi">@keep_alive</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>所有向 Socket 中写入数据的工作最终都会由 <code class="highlighter-rouge">#_write_data</code> 这个方法来处理，将数据全部写入 Socket 中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">webrick</span><span class="o">/</span><span class="n">httpresponse</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">464</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPResponse</span>

<span class="k">def</span> <span class="nf">_write_data</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
  <span class="n">socket</span> <span class="o">&lt;&lt;</span> <span class="n">data</span>
<span class="k">end</span>
</code></pre></div></div>

<p>从解析 HTTP 请求、调用 Rack 应用、创建 Response 到最后向 Socket 中写回数据，WEBrick 处理 HTTP 请求的部分就结束了。</p>

<h2 id="io-模型">I/O 模型</h2>

<p>通过对 WEBrick 源代码的阅读，我们其实已经能够了解整个 webserver 的工作原理，当我们启动一个 WEBrick 服务时只会启动一个进程，该进程会在指定的 ip 和端口上使用 <code class="highlighter-rouge">.select</code> 监听来自用户的所有 HTTP 请求：</p>

<p><img src="https://img.draveness.me/2017-11-01-webrick-io-model.png" alt="webrick-io-mode" /></p>

<p>当 <code class="highlighter-rouge">.select</code> 接收到来自用户的请求时，会为每一个请求创建一个新的 <code class="highlighter-rouge">Thread</code> 并在新的线程中对 HTTP 请求进行处理。</p>

<p>由于 WEBrick 在运行时只会启动一个进程，并没有其他的守护进程，所以它不够健壮，不能在发生问题时重启持续对外界提供服务，再加上 WEBrick 确实历史比较久远，代码的风格也不是特别的优雅，还有普遍知道的内存泄漏以及 HTTP 解析的问题，所以在生产环境中很少被使用。</p>

<p>虽然 WEBrick 有一些性能问题，但是作为 Ruby 自带的默认 webserver，在开发阶段使用 WEBrick 提供服务还是没有什么问题的。</p>

<h2 id="总结">总结</h2>

<p>WEBrick 是 Ruby 社区中老牌的 webserver，虽然至今也仍然被广泛了解和使用，但是在生产环境中开发者往往会使用更加稳定的 Unicorn 和 Puma 代替它，我们选择在这个系列的文章中介绍它很大原因就是 WEBrick 的源代码与实现足够简单，我们很快就能了解一个 webserver 到底具备那些功能，在接下来的文章中我们就可以分析更加复杂的 webserver、了解更复杂的 IO 模型与实现了。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://stackoverflow.com/questions/4113299/ruby-on-rails-server-options">Ruby on Rails Server options</a></li>
</ul>


	  ]]></description>
	</item>

	<item>
	  <title>谈谈 Rack 的协议与实现</title>
	  <link>/blogs//rack</link>
	  <author></author>
	  <pubDate>2017-10-29T00:00:00+00:00</pubDate>
	  <guid>/blogs//rack</guid>
	  <description><![CDATA[
	     <ul>
  <li><a href="https://draveness.me/rack">谈谈 Rack 协议与实现</a></li>
  <li><a href="https://draveness.me/rack-webrick">浅谈 WEBrick 的多线程模型</a></li>
  <li><a href="https://draveness.me/rack-thin">浅谈 Thin 的事件驱动模型</a></li>
  <li><a href="https://draveness.me/rack-unicorn">浅谈 Unicorn 的多进程模型</a></li>
  <li><a href="https://draveness.me/rack-puma">浅谈 Puma 的并发模型与实现</a></li>
  <li><a href="https://draveness.me/ruby-webserver">Ruby Web 服务器的并发模型与性能</a></li>
</ul>

<p>作为 Rails 开发者，基本上每天都与 Rails 的各种 API 以及数据库打交道，Rails 的世界虽然非常简洁，不过其内部的实现还是很复杂的，很多刚刚接触 Rails 的开发者可能都不知道 Rails 其实就是一个 <a href="https://github.com/rack/rack">Rack</a> 应用，在这一系列的文章中，我们会分别介绍 Rack 以及一些常见的遵循 Rack 协议的 webserver 的实现原理。</p>

<p><img src="https://img.draveness.me/2017-10-29-rack-logo.png" alt="rack-logo" /></p>

<p>不只是 Rails，几乎所有的 Ruby 的 Web 框架都是一个 Rack 的应用，除了 Web 框架之外，Rack 也支持相当多的 Web 服务器，可以说 Ruby 世界几乎一切与 Web 相关的服务都与 Rack 有关。</p>

<p><img src="https://img.draveness.me/2017-10-29-rack-and-web-servers-frameworks.png" alt="rack-and-web-servers-frameworks" /></p>

<p>所以如果想要了解 Rails 或者其他 Web 服务底层的实现，那么一定需要了解 Rack 是如何成为应用容器（webserver）和应用框架之间的桥梁的，本文中介绍的是 2.0.3 版本的 rack。</p>

<h2 id="rack-协议">Rack 协议</h2>

<p>在 Rack 的协议中，将 Rack 应用描述成一个可以响应 <code class="highlighter-rouge">call</code> 方法的 Ruby 对象，它仅接受来自外界的一个参数，也就是环境，然后返回一个只包含三个值的数组，按照顺序分别是状态码、HTTP Headers 以及响应请求的正文。</p>

<blockquote>
  <p>A Rack application is a Ruby object (not a class) that responds to call. It takes exactly one argument, the environment and returns an Array of exactly three values: The status, the headers, and the body.</p>
</blockquote>

<p><img src="https://img.draveness.me/2017-10-29-rack-protocol.png" alt="rack-protoco" /></p>

<p>Rack 在 webserver 和应用框架之间提供了一套最小的 API 接口，如果 webserver 都遵循 Rack 提供的这套规则，那么所有的框架都能通过协议任意地改变底层使用 webserver；所有的 webserver 只需要在 <code class="highlighter-rouge">Rack::Handler</code> 的模块中创建一个实现了 <code class="highlighter-rouge">.run</code> 方法的类就可以了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Rack</span>
  <span class="k">module</span> <span class="nn">Handler</span>
    <span class="k">class</span> <span class="nc">WEBrick</span> <span class="o">&lt;</span> <span class="o">::</span><span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServlet</span><span class="o">::</span><span class="no">AbstractServlet</span>
      <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">run</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{})</span>
        <span class="c1"># ..</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这个类方法接受两个参数，分别是一个 Rack 应用对象和一个包含各种参数的 <code class="highlighter-rouge">options</code> 字典，其中可能包括自定义的 ip 地址和端口号以及各种配置，根据 Rack 协议，所有应用对象在接受到一个 <code class="highlighter-rouge">#call</code> 方法并且传入 <code class="highlighter-rouge">env</code> 时，都会返回一个三元组：</p>

<p><img src="https://img.draveness.me/2017-10-29-rack-app.png" alt="rack-app" /></p>

<p>最后的 <code class="highlighter-rouge">body</code> 响应体其实是一个由多个响应内容组成的数组，Rack 使用的 webserver 会将 <code class="highlighter-rouge">body</code> 中几个部分的连接到一起最后拼接成一个 HTTP 响应后返回。</p>

<h2 id="rack-的使用">Rack 的使用</h2>

<p>我们在大致了解 Rack 协议之后，其实可以从一段非常简单的代码入手来了解 Rack 是如何启动 webserver 来处理来自用户的请求的，我们可以在任意目录下创建如下所示的 config.ru 文件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># config.ru</span>

<span class="n">run</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">env</span><span class="o">|</span> <span class="p">[</span><span class="s1">'200'</span><span class="p">,</span> <span class="p">{</span><span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'text/html'</span><span class="p">},</span> <span class="p">[</span><span class="s1">'get rack\'d'</span><span class="p">]]</span> <span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>因为 <code class="highlighter-rouge">Proc</code> 对象也能够响应 <code class="highlighter-rouge">#call</code> 方法，所以上述的 Proc 对象也可以看做是一个 Rack 应用。</p>
</blockquote>

<p>接下来，我们在同一目录使用 <code class="highlighter-rouge">rackup</code> 命令在命令行中启动一个 webserver 进程：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>rackup config.ru
<span class="o">[</span>2017-10-26 22:59:26] INFO  WEBrick 1.3.1
<span class="o">[</span>2017-10-26 22:59:26] INFO  ruby 2.3.3 <span class="o">(</span>2016-11-21<span class="o">)</span> <span class="o">[</span>x86_64-darwin16]
<span class="o">[</span>2017-10-26 22:59:26] INFO  WEBrick::HTTPServer#start: <span class="nv">pid</span><span class="o">=</span>83546 <span class="nv">port</span><span class="o">=</span>9292
</code></pre></div></div>

<p>从命令的输出我们可以看到，使用 rackup 运行了一个 WEBrick 的进程，监听了 9292 端口，如果我们使用 curl 来访问对应的请求，就可以得到在 config.ru 文件中出现的 <code class="highlighter-rouge">'get rack\'d'</code> 文本：</p>

<blockquote>
  <p>在这篇文章中，作者都会使用开源的工具 <a href="https://github.com/jakubroztocil/httpie">httpie</a> 代替 curl 在命令行中发出 HTTP 请求，相比 curl 而言 httpie 能够提供与 HTTP 响应有关的更多信息。</p>
</blockquote>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">http</span> <span class="n">http</span><span class="ss">:/</span><span class="o">/</span><span class="n">localhost</span><span class="p">:</span><span class="mi">9292</span>
<span class="no">HTTP</span><span class="o">/</span><span class="mf">1.1</span> <span class="mi">200</span> <span class="no">OK</span>
<span class="no">Connection</span><span class="p">:</span> <span class="no">Keep</span><span class="o">-</span><span class="no">Alive</span>
<span class="no">Content</span><span class="o">-</span><span class="no">Type</span><span class="p">:</span> <span class="n">text</span><span class="o">/</span><span class="n">html</span>
<span class="no">Date</span><span class="p">:</span> <span class="no">Thu</span><span class="p">,</span> <span class="mi">26</span> <span class="no">Oct</span> <span class="mi">2017</span> <span class="mi">15</span><span class="p">:</span><span class="mo">07</span><span class="p">:</span><span class="mi">47</span> <span class="no">GMT</span>
<span class="no">Server</span><span class="p">:</span> <span class="no">WEBrick</span><span class="o">/</span><span class="mf">1.3</span><span class="o">.</span><span class="mi">1</span> <span class="p">(</span><span class="no">Ruby</span><span class="o">/</span><span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span><span class="o">/</span><span class="mi">2016</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">21</span><span class="p">)</span>
<span class="no">Transfer</span><span class="o">-</span><span class="no">Encoding</span><span class="p">:</span> <span class="n">chunked</span>

<span class="n">get</span> <span class="n">rack</span><span class="err">'</span><span class="n">d</span>
</code></pre></div></div>

<p>从上述请求返回的 HTTP 响应头中的信息，我们可以看到 WEBrick 确实按照 config.ru 文件中的代码对当前的 HTTP 请求进行了处理。</p>

<h3 id="中间件">中间件</h3>

<p>Rack 协议和中间件是 Rack 能达到今天地位不可或缺的两个功能或者说特性，Rack 协议规定了 webserver 和 Rack 应用之间应该如何通信，而 Rack 中间件能够在上层改变 HTTP 的响应或者请求，在不改变应用的基础上为 Rack 应用增加新的功能。</p>

<p>Rack 的中间件是一个实现了两个方法 <code class="highlighter-rouge">.initialize</code> 和 <code class="highlighter-rouge">#call</code> 的类，初始化方法会接受两个参数，分别是 <code class="highlighter-rouge">app</code> 和 <code class="highlighter-rouge">options</code> 字典，而 <code class="highlighter-rouge">#call</code> 方法接受一个参数也就是 HTTP 请求的环境参数 <code class="highlighter-rouge">env</code>，在这里我们创建了一个新的 Rack 中间件 <code class="highlighter-rouge">StatusLogger</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">StatusLogger</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{})</span>
    <span class="vi">@app</span> <span class="o">=</span> <span class="n">app</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">body</span> <span class="o">=</span> <span class="vi">@app</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="n">status</span>
    <span class="p">[</span><span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">body</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在所有的 <code class="highlighter-rouge">#call</code> 方法中都<strong>应该</strong>调用 <code class="highlighter-rouge">app.call</code> 让应用对 HTTP 请求进行处理并在方法结束时将所有的参数按照顺序返回。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">use</span> <span class="no">StatusLogger</span>
<span class="n">run</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">env</span><span class="o">|</span> <span class="p">[</span><span class="s1">'200'</span><span class="p">,</span> <span class="p">{</span><span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'text/html'</span><span class="p">},</span> <span class="p">[</span><span class="s1">'get rack\'d'</span><span class="p">]]</span> <span class="p">}</span>
</code></pre></div></div>

<p>如果需要使用某一个 Rack 中间件只需要在当前文件中使用 <code class="highlighter-rouge">use</code> 方法，在每次接收到来自用户的 HTTP 请求时都会打印出当前响应的状态码。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">rackup</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">19</span><span class="p">:</span><span class="mi">46</span><span class="p">:</span><span class="mi">40</span><span class="p">]</span> <span class="no">INFO</span>  <span class="no">WEBrick</span> <span class="mf">1.3</span><span class="o">.</span><span class="mi">1</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">19</span><span class="p">:</span><span class="mi">46</span><span class="p">:</span><span class="mi">40</span><span class="p">]</span> <span class="no">INFO</span>  <span class="n">ruby</span> <span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span> <span class="p">(</span><span class="mi">2016</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">21</span><span class="p">)</span> <span class="p">[</span><span class="n">x86_64</span><span class="o">-</span><span class="n">darwin16</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">19</span><span class="p">:</span><span class="mi">46</span><span class="p">:</span><span class="mi">40</span><span class="p">]</span> <span class="no">INFO</span>  <span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServer</span><span class="c1">#start: pid=5274 port=9292</span>
<span class="mi">200</span>
<span class="mf">127.0</span><span class="o">.</span><span class="mf">0.1</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">27</span><span class="o">/</span><span class="no">Oct</span><span class="o">/</span><span class="mi">2017</span><span class="p">:</span><span class="mi">19</span><span class="p">:</span><span class="mi">46</span><span class="p">:</span><span class="mi">53</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s2">"GET / HTTP/1.1"</span> <span class="mi">200</span> <span class="o">-</span> <span class="mf">0.0004</span>
</code></pre></div></div>

<p>除了直接通过 <code class="highlighter-rouge">use</code> 方法直接传入 <code class="highlighter-rouge">StatusLogger</code> 中间件之外，我们也可以在 <code class="highlighter-rouge">use</code> 中传入配置参数，所有的配置都会通过 <code class="highlighter-rouge">options</code> 最终初始化一个中间件的实例，比如，我们有以下的中间件 <code class="highlighter-rouge">BodyTransformer</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BodyTransformer</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{})</span>
    <span class="vi">@app</span> <span class="o">=</span> <span class="n">app</span>
    <span class="vi">@count</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:count</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">body</span> <span class="o">=</span> <span class="vi">@app</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="n">body</span> <span class="o">=</span> <span class="n">body</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">str</span><span class="o">|</span> <span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="o">...</span><span class="vi">@count</span><span class="p">].</span><span class="nf">upcase</span> <span class="o">+</span> <span class="n">str</span><span class="p">[</span><span class="vi">@count</span><span class="o">..-</span><span class="mi">1</span><span class="p">]</span> <span class="p">}</span>
    <span class="p">[</span><span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">body</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述中间件会在每次调用时都将 Rack 应用返回的 <code class="highlighter-rouge">body</code> 中前 <code class="highlighter-rouge">count</code> 个字符变成大写的，我们可以在 config.ru 中添加一个新的中间件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">use</span> <span class="no">StatusLogger</span>
<span class="n">use</span> <span class="no">BodyTransformer</span><span class="p">,</span> <span class="ss">count: </span><span class="mi">3</span>
<span class="n">run</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">env</span><span class="o">|</span> <span class="p">[</span><span class="s1">'200'</span><span class="p">,</span> <span class="p">{</span><span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'text/html'</span><span class="p">},</span> <span class="p">[</span><span class="s1">'get rack\'d'</span><span class="p">]]</span> <span class="p">}</span>
</code></pre></div></div>

<p>当我们再次使用 http 命令请求相同的 URL 时，就会获得不同的结果，同时由于我们保留了 <code class="highlighter-rouge">StatusLogger</code>，所以在 console 中也会打印出当前响应的状态码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># session 1</span>
<span class="err">$</span> <span class="n">rackup</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">21</span><span class="p">:</span><span class="mo">04</span><span class="p">:</span><span class="mo">05</span><span class="p">]</span> <span class="no">INFO</span>  <span class="no">WEBrick</span> <span class="mf">1.3</span><span class="o">.</span><span class="mi">1</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">21</span><span class="p">:</span><span class="mo">04</span><span class="p">:</span><span class="mo">05</span><span class="p">]</span> <span class="no">INFO</span>  <span class="n">ruby</span> <span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span> <span class="p">(</span><span class="mi">2016</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">21</span><span class="p">)</span> <span class="p">[</span><span class="n">x86_64</span><span class="o">-</span><span class="n">darwin16</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">21</span><span class="p">:</span><span class="mo">04</span><span class="p">:</span><span class="mo">05</span><span class="p">]</span> <span class="no">INFO</span>  <span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServer</span><span class="c1">#start: pid=7524 port=9292</span>
<span class="mi">200</span>
<span class="mf">127.0</span><span class="o">.</span><span class="mf">0.1</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">27</span><span class="o">/</span><span class="no">Oct</span><span class="o">/</span><span class="mi">2017</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span><span class="mo">04</span><span class="p">:</span><span class="mi">19</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s2">"GET / HTTP/1.1"</span> <span class="mi">200</span> <span class="o">-</span> <span class="mf">0.0005</span>

<span class="c1"># session 2</span>
<span class="err">$</span> <span class="n">http</span> <span class="n">http</span><span class="ss">:/</span><span class="o">/</span><span class="n">localhost</span><span class="p">:</span><span class="mi">9292</span>
<span class="no">HTTP</span><span class="o">/</span><span class="mf">1.1</span> <span class="mi">200</span> <span class="no">OK</span>
<span class="no">Connection</span><span class="p">:</span> <span class="no">Keep</span><span class="o">-</span><span class="no">Alive</span>
<span class="no">Content</span><span class="o">-</span><span class="no">Type</span><span class="p">:</span> <span class="n">text</span><span class="o">/</span><span class="n">html</span>
<span class="no">Date</span><span class="p">:</span> <span class="no">Fri</span><span class="p">,</span> <span class="mi">27</span> <span class="no">Oct</span> <span class="mi">2017</span> <span class="mi">13</span><span class="p">:</span><span class="mo">04</span><span class="p">:</span><span class="mi">19</span> <span class="no">GMT</span>
<span class="no">Server</span><span class="p">:</span> <span class="no">WEBrick</span><span class="o">/</span><span class="mf">1.3</span><span class="o">.</span><span class="mi">1</span> <span class="p">(</span><span class="no">Ruby</span><span class="o">/</span><span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span><span class="o">/</span><span class="mi">2016</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">21</span><span class="p">)</span>
<span class="no">Transfer</span><span class="o">-</span><span class="no">Encoding</span><span class="p">:</span> <span class="n">chunked</span>

<span class="no">GET</span> <span class="n">rack</span><span class="err">'</span><span class="n">d</span>
</code></pre></div></div>

<p>Rack 的中间件的使用其实非常简单，我们只需要定义符合要求的类，然后在合适的方法中返回合适的结果就可以了，在接下来的部分我们将介绍 Rack 以及中间件的实现原理。</p>

<h2 id="rack-的实现原理">Rack 的实现原理</h2>

<p>到这里，我们已经对 Rack 的使用有一些基本的了解了，包括如何使用 <code class="highlighter-rouge">rackup</code> 命令启动一个 webserver，也包括 Rack 的中间件如何使用，接下来我们就准备开始对 Rack 是如何实现上述功能进行分析了。</p>

<h3 id="rackup-命令">rackup 命令</h3>

<p>那么 <code class="highlighter-rouge">rackup</code> 到底是如何工作的呢，首先我们通过 <code class="highlighter-rouge">which</code> 命令来查找当前 <code class="highlighter-rouge">rackup</code> 的执行路径并打印出该文件的全部内容：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">which</span> <span class="n">rackup</span>
<span class="sr">/Users/</span><span class="n">draveness</span><span class="o">/</span><span class="p">.</span><span class="nf">rvm</span><span class="o">/</span><span class="n">gems</span><span class="o">/</span><span class="n">ruby</span><span class="o">-</span><span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">rackup</span>

<span class="err">$</span> <span class="n">cat</span> <span class="sr">/Users/</span><span class="n">draveness</span><span class="o">/</span><span class="p">.</span><span class="nf">rvm</span><span class="o">/</span><span class="n">gems</span><span class="o">/</span><span class="n">ruby</span><span class="o">-</span><span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">rackup</span>
<span class="c1">#!/usr/bin/env ruby_executable_hooks</span>
<span class="c1">#</span>
<span class="c1"># This file was generated by RubyGems.</span>
<span class="c1">#</span>
<span class="c1"># The application 'rack' is installed as part of a gem, and</span>
<span class="c1"># this file is here to facilitate running it.</span>
<span class="c1">#</span>

<span class="nb">require</span> <span class="s1">'rubygems'</span>

<span class="n">version</span> <span class="o">=</span> <span class="s2">"&gt;= 0.a"</span>

<span class="k">if</span> <span class="no">ARGV</span><span class="p">.</span><span class="nf">first</span>
  <span class="n">str</span> <span class="o">=</span> <span class="no">ARGV</span><span class="p">.</span><span class="nf">first</span>
  <span class="n">str</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="nf">dup</span><span class="p">.</span><span class="nf">force_encoding</span><span class="p">(</span><span class="s2">"BINARY"</span><span class="p">)</span> <span class="k">if</span> <span class="n">str</span><span class="p">.</span><span class="nf">respond_to?</span> <span class="ss">:force_encoding</span>
  <span class="k">if</span> <span class="n">str</span> <span class="o">=~</span> <span class="sr">/\A_(.*)_\z/</span> <span class="n">and</span> <span class="no">Gem</span><span class="o">::</span><span class="no">Version</span><span class="p">.</span><span class="nf">correct?</span><span class="p">(</span><span class="vg">$1</span><span class="p">)</span> <span class="k">then</span>
    <span class="n">version</span> <span class="o">=</span> <span class="vg">$1</span>
    <span class="no">ARGV</span><span class="p">.</span><span class="nf">shift</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="nb">load</span> <span class="no">Gem</span><span class="p">.</span><span class="nf">activate_bin_path</span><span class="p">(</span><span class="s1">'rack'</span><span class="p">,</span> <span class="s1">'rackup'</span><span class="p">,</span> <span class="n">version</span><span class="p">)</span>
</code></pre></div></div>

<p>从上述文件中的注释中可以看到当前文件是由 RubyGems 自动生成的，在文件的最后由一个 <code class="highlighter-rouge">load</code> 方法加载了某一个文件中的代码，我们可以在 pry 中尝试运行一下这个命令。</p>

<p>首先，通过 <code class="highlighter-rouge">gem list</code> 命令得到当前机器中所有 rack 的版本，然后进入 pry 执行 <code class="highlighter-rouge">.activate_bin_path</code> 命令：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">gem</span> <span class="n">list</span> <span class="s2">"^rack$"</span>

<span class="o">***</span> <span class="no">LOCAL</span> <span class="no">GEMS</span> <span class="o">***</span>

<span class="n">rack</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">.</span><span class="mi">3</span><span class="p">,</span> <span class="mf">2.0</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.6</span><span class="o">.</span><span class="mi">8</span><span class="p">,</span> <span class="mf">1.2</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>

<span class="err">$</span> <span class="n">pry</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">Gem</span><span class="p">.</span><span class="nf">activate_bin_path</span><span class="p">(</span><span class="s1">'rack'</span><span class="p">,</span> <span class="s1">'rackup'</span><span class="p">,</span> <span class="s1">'2.0.3'</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="s2">"/Users/draveness/.rvm/gems/ruby-2.3.3/gems/rack-2.0.3/bin/rackup"</span>

<span class="err">$</span> <span class="n">cat</span> <span class="sr">/Users/</span><span class="n">draveness</span><span class="o">/</span><span class="p">.</span><span class="nf">rvm</span><span class="o">/</span><span class="n">gems</span><span class="o">/</span><span class="n">ruby</span><span class="o">-</span><span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span><span class="o">/</span><span class="n">gems</span><span class="o">/</span><span class="n">rack</span><span class="o">-</span><span class="mf">2.0</span><span class="o">.</span><span class="mi">3</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">rackup</span>
<span class="c1">#!/usr/bin/env ruby</span>

<span class="nb">require</span> <span class="s2">"rack"</span>
<span class="no">Rack</span><span class="o">::</span><span class="no">Server</span><span class="p">.</span><span class="nf">start</span>
</code></pre></div></div>

<blockquote>
  <p><code class="highlighter-rouge">rackup</code> 命令定义在 rack 工程的 bin/rackup 文件中，在通过 rubygems 安装后会生成另一个加载该文件的可执行文建。</p>
</blockquote>

<p>在最后打印了该文件的内容，到这里我们就应该知道 <code class="highlighter-rouge">.activate_bin_path</code> 方法会查找对应 gem 当前生效的版本，并返回文件的路径；在这个可执行文件中，上述代码只是简单的 <code class="highlighter-rouge">require</code> 了一下 rack 方法，之后运行 <code class="highlighter-rouge">.start</code> 启动了一个 <code class="highlighter-rouge">Rack::Server</code>。</p>

<h3 id="server-的启动">Server 的启动</h3>

<p>从这里开始，我们就已经从 rackup 命令的执行进入了 rack 的源代码，可以直接使用 pry 找到 <code class="highlighter-rouge">.start</code> 方法所在的文件，从方法中可以看到当前类方法初始化了一个新的实例后，在新的对象上执行了 <code class="highlighter-rouge">#start</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">pry</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="nb">require</span> <span class="s1">'rack'</span>
<span class="o">=&gt;</span> <span class="kp">true</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span><span class="p">.</span><span class="nf">start</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">147</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Rack::Server&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">start</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="n">new</span><span class="p">(</span><span class="n">options</span><span class="p">).</span><span class="nf">start</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="初始化和配置">初始化和配置</h3>

<p>在 <code class="highlighter-rouge">Rack::Server</code> 启动的过程中初始化了一个新的对象，初始化的过程中其实也包含了整个服务器的配置过程：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">185</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Rack::Server&gt;</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="vi">@ignore_options</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">if</span> <span class="n">options</span>
    <span class="vi">@use_default_options</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="vi">@options</span> <span class="o">=</span> <span class="n">options</span>
    <span class="vi">@app</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:app</span><span class="p">]</span> <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="ss">:app</span><span class="p">]</span>
  <span class="k">else</span>
    <span class="n">argv</span> <span class="o">=</span> <span class="n">defined?</span><span class="p">(</span><span class="no">SPEC_ARGV</span><span class="p">)</span> <span class="p">?</span> <span class="no">SPEC_ARGV</span> <span class="p">:</span> <span class="no">ARGV</span>
    <span class="vi">@use_default_options</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="vi">@options</span> <span class="o">=</span> <span class="n">parse_options</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个 <code class="highlighter-rouge">Server</code> 对象的初始化器中，虽然可以通过 <code class="highlighter-rouge">options</code> 从外界传入参数，但是当前类中仍然存在这个 <code class="highlighter-rouge">#options</code> 和 <code class="highlighter-rouge">#default_options</code> 两个实例方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">199</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">options</span>
  <span class="n">merged_options</span> <span class="o">=</span> <span class="vi">@use_default_options</span> <span class="p">?</span> <span class="n">default_options</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="vi">@options</span><span class="p">)</span> <span class="p">:</span> <span class="vi">@options</span>
  <span class="n">merged_options</span><span class="p">.</span><span class="nf">reject</span> <span class="p">{</span> <span class="o">|</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">|</span> <span class="vi">@ignore_options</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">204</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">default_options</span>
  <span class="n">environment</span>  <span class="o">=</span> <span class="no">ENV</span><span class="p">[</span><span class="s1">'RACK_ENV'</span><span class="p">]</span> <span class="o">||</span> <span class="s1">'development'</span>
  <span class="n">default_host</span> <span class="o">=</span> <span class="n">environment</span> <span class="o">==</span> <span class="s1">'development'</span> <span class="p">?</span> <span class="s1">'localhost'</span> <span class="p">:</span> <span class="s1">'0.0.0.0'</span>
  <span class="p">{</span>
    <span class="ss">:environment</span> <span class="o">=&gt;</span> <span class="n">environment</span><span class="p">,</span>
    <span class="ss">:pid</span>         <span class="o">=&gt;</span> <span class="kp">nil</span><span class="p">,</span>
    <span class="ss">:Port</span>        <span class="o">=&gt;</span> <span class="mi">9292</span><span class="p">,</span>
    <span class="ss">:Host</span>        <span class="o">=&gt;</span> <span class="n">default_host</span><span class="p">,</span>
    <span class="ss">:AccessLog</span>   <span class="o">=&gt;</span> <span class="p">[],</span>
    <span class="ss">:config</span>      <span class="o">=&gt;</span> <span class="s2">"config.ru"</span>
  <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述两个方法中处理了一些对象本身定义的一些参数，比如默认的端口号 9292 以及默认的 config 文件，config 文件也就是 <code class="highlighter-rouge">rackup</code> 命令接受的一个文件参数，文件中的内容就是用来配置一个 Rack 服务器的代码，在默认情况下为 config.ru，也就是如果文件名是 config.ru，我们不需要向 <code class="highlighter-rouge">rackup</code> 命令传任何参数，它会自动找当前目录的该文件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">rackup</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">09</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mi">34</span><span class="p">]</span> <span class="no">INFO</span>  <span class="no">WEBrick</span> <span class="mf">1.3</span><span class="o">.</span><span class="mi">1</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">09</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mi">34</span><span class="p">]</span> <span class="no">INFO</span>  <span class="n">ruby</span> <span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span> <span class="p">(</span><span class="mi">2016</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">21</span><span class="p">)</span> <span class="p">[</span><span class="n">x86_64</span><span class="o">-</span><span class="n">darwin16</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">09</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mi">34</span><span class="p">]</span> <span class="no">INFO</span>  <span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServer</span><span class="c1">#start: pid=96302 port=9292</span>
</code></pre></div></div>

<p>访问相同的 URL 能得到完全一致的结果，在这里就不再次展示了，有兴趣的读者可以亲自尝试一下。</p>

<h3 id="包装应用">『包装』应用</h3>

<p>当我们执行了 <code class="highlighter-rouge">.initialize</code> 方法初始化了一个新的实例之后，接下来就会进入 <code class="highlighter-rouge">#start</code> 实例方法尝试启动一个 webserver 处理 config.ru 中定义的应用了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">258</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">start</span> <span class="o">&amp;</span><span class="n">blk</span>
  <span class="c1"># ...</span>

  <span class="n">wrapped_app</span>
  <span class="c1"># ..</span>

  <span class="n">server</span><span class="p">.</span><span class="nf">run</span> <span class="n">wrapped_app</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blk</span>
<span class="k">end</span>
</code></pre></div></div>

<p>我们已经从上述方法中删除了很多对于本文来说不重要的代码实现，所以上述方法中最重要的部分就是 <code class="highlighter-rouge">#wrapped_app</code> 方法，以及另一个 <code class="highlighter-rouge">#server</code> 方法，首先来看 <code class="highlighter-rouge">#wrapped_app</code> 方法的实现。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">353</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">wrapped_app</span>
  <span class="vi">@wrapped_app</span> <span class="o">||=</span> <span class="n">build_app</span> <span class="n">app</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法有两部分组成，分别是 <code class="highlighter-rouge">#app</code> 和 <code class="highlighter-rouge">#build_app</code> 两个实例方法，其中 <code class="highlighter-rouge">#app</code> 方法的调用栈比较复杂：</p>

<p><img src="https://img.draveness.me/2017-10-29-server-app-call-stack.png" alt="server-app-call-stack" /></p>

<p>整个方法在最终会执行 <code class="highlighter-rouge">Builder.new_from_string</code> 通过 Ruby 中元编程中经常使用的 <code class="highlighter-rouge">eval</code> 方法，将输入文件中的全部内容与两端字符串拼接起来，并直接执行这段代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">builder</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">48</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">new_from_string</span><span class="p">(</span><span class="n">builder_script</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="s2">"(rackup)"</span><span class="p">)</span>
  <span class="nb">eval</span> <span class="s2">"Rack::Builder.new {</span><span class="se">\n</span><span class="s2">"</span> <span class="o">+</span> <span class="n">builder_script</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">}.to_app"</span><span class="p">,</span>
    <span class="no">TOPLEVEL_BINDING</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="mi">0</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">eval</code> 方法中执行代码的作用其实就是如下所示的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span>
  <span class="n">use</span> <span class="no">StatusLogger</span>
  <span class="n">use</span> <span class="no">BodyTransformer</span><span class="p">,</span> <span class="ss">count: </span><span class="mi">3</span>
  <span class="n">run</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">env</span><span class="o">|</span> <span class="p">[</span><span class="s1">'200'</span><span class="p">,</span> <span class="p">{</span><span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'text/html'</span><span class="p">},</span> <span class="p">[</span><span class="s1">'get rack\'d'</span><span class="p">]]</span> <span class="p">}</span>
<span class="p">}.</span><span class="nf">to_app</span>
</code></pre></div></div>

<p>我们先暂时不管这段代码是如何执行的，我们只需要知道上述代码存储了所有的中间件以及 Proc 对象，最后通过 <code class="highlighter-rouge">#to_app</code> 方法返回一个 Rack 应用。</p>

<p>在这之后会使用 <code class="highlighter-rouge">#build_app</code> 方法将所有的中间件都包括在 Rack 应用周围，因为所有的中间件也都是一个响应 <code class="highlighter-rouge">#call</code> 方法，返回三元组的对象，其实也就是一个遵循协议的 App，唯一的区别就是中间件中会调用初始化时传入的 Rack App：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">343</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">build_app</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
  <span class="n">middleware</span><span class="p">[</span><span class="n">options</span><span class="p">[</span><span class="ss">:environment</span><span class="p">]].</span><span class="nf">reverse_each</span> <span class="k">do</span> <span class="o">|</span><span class="n">middleware</span><span class="o">|</span>
    <span class="n">middleware</span> <span class="o">=</span> <span class="n">middleware</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="k">if</span> <span class="n">middleware</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:call</span><span class="p">)</span>
    <span class="k">next</span> <span class="k">unless</span> <span class="n">middleware</span>
    <span class="n">klass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">middleware</span>
    <span class="n">app</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">app</span>
<span class="k">end</span>
</code></pre></div></div>

<p>经过上述方法，我们在一个 Rack 应用周围一层一层包装上了所有的中间件，最后调用的中间件在整个调用栈中的最外层，当包装后的应用接受来自外界的请求时，会按照如下的方式进行调用：</p>

<p><img src="https://img.draveness.me/2017-10-29-wrapped-app.png" alt="wrapped-app" /></p>

<p>所有的请求都会先经过中间件，每一个中间件都会在 <code class="highlighter-rouge">#call</code> 方法内部调用另一个中间件或者应用，在接收到应用的返回之后会分别对响应进行处理最后由最先定义的中间件返回。</p>

<h3 id="中间件的实现">中间件的实现</h3>

<p>在 Rack 中，中间件是由两部分的代码共同处理的，分别是 <code class="highlighter-rouge">Rack::Builder</code> 和 <code class="highlighter-rouge">Rack::Server</code> 两个类，前者包含所有的能够在 config.ru 文件中使用的 DSL 方法，当我们使用 <code class="highlighter-rouge">eval</code> 执行 config.ru 文件中的代码时，会先初始化一个 <code class="highlighter-rouge">Builder</code> 的实例，然后执行 <code class="highlighter-rouge">instance_eval</code> 运行代码块中的所有内容：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">builder</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">53</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">default_app</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="vi">@use</span><span class="p">,</span> <span class="vi">@map</span><span class="p">,</span> <span class="vi">@run</span><span class="p">,</span> <span class="vi">@warmup</span> <span class="o">=</span> <span class="p">[],</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">default_app</span><span class="p">,</span> <span class="kp">nil</span>
  <span class="nb">instance_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="k">if</span> <span class="nb">block_given?</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这时，config.ru 文件中的代码就会在当前实例的环境下执行，文件中的 <code class="highlighter-rouge">#use</code> 和 <code class="highlighter-rouge">#run</code> 方法在调用时就会执行 <code class="highlighter-rouge">Builder</code> 的实例方法，我们可以先看一下 <code class="highlighter-rouge">#use</code> 方法是如何实现的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">builder</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">81</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span>

<span class="k">def</span> <span class="nf">use</span><span class="p">(</span><span class="n">middleware</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="vi">@use</span> <span class="o">&lt;&lt;</span> <span class="nb">proc</span> <span class="p">{</span> <span class="o">|</span><span class="n">app</span><span class="o">|</span> <span class="n">middleware</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法会将传入的参数组合成一个接受 <code class="highlighter-rouge">app</code> 作为入参的 <code class="highlighter-rouge">Proc</code> 对象，然后加入到 <code class="highlighter-rouge">@use</code> 数组中存储起来，在这里并没有发生任何其他的事情，另一个 <code class="highlighter-rouge">#run</code> 方法的实现其实就更简单了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">builder</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">103</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span>

<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
  <span class="vi">@run</span> <span class="o">=</span> <span class="n">app</span>
<span class="k">end</span>
</code></pre></div></div>

<p>它只是将传入的 <code class="highlighter-rouge">app</code> 对象存储到持有的 <code class="highlighter-rouge">@run</code> 实例变量中，如果我们想要获取当前的 <code class="highlighter-rouge">Builder</code> 生成的应用，只需要通过 <code class="highlighter-rouge">#to_app</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">builder</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">144</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span>

<span class="k">def</span> <span class="nf">to_app</span>
  <span class="nb">fail</span> <span class="s2">"missing run or map statement"</span> <span class="k">unless</span> <span class="vi">@run</span>
  <span class="vi">@use</span><span class="p">.</span><span class="nf">reverse</span><span class="p">.</span><span class="nf">inject</span><span class="p">(</span><span class="vi">@run</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span><span class="n">e</span><span class="o">|</span> <span class="n">e</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法将所有传入 <code class="highlighter-rouge">#use</code> 和 <code class="highlighter-rouge">#run</code> 命令的应用和中间件进行了组合，通过 <code class="highlighter-rouge">#inject</code> 方法达到了如下所示的效果：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># config.ru</span>
<span class="n">use</span> <span class="no">MiddleWare1</span>
<span class="n">use</span> <span class="no">MiddleWare2</span>
<span class="n">run</span> <span class="no">RackApp</span>

<span class="c1"># equals to</span>
<span class="no">MiddleWare1</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">MiddleWare2</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">RackApp</span><span class="p">)))</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Builder</code> 类其实简单来看就做了这件事情，将一种非常难以阅读的代码，变成比较清晰可读的 DSL，最终返回了一个中间件（也可以说是应用）对象，虽然在 <code class="highlighter-rouge">Builder</code> 中也包含其他的 DSL 语法元素，但是在这里都没有介绍。</p>

<p>上一小节提到的 <code class="highlighter-rouge">#build_app</code> 方法其实也只是根据当前的环境选择合适的中间件继续包裹到这个链式的调用中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">343</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">build_app</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
  <span class="n">middleware</span><span class="p">[</span><span class="n">options</span><span class="p">[</span><span class="ss">:environment</span><span class="p">]].</span><span class="nf">reverse_each</span> <span class="k">do</span> <span class="o">|</span><span class="n">middleware</span><span class="o">|</span>
    <span class="n">middleware</span> <span class="o">=</span> <span class="n">middleware</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="k">if</span> <span class="n">middleware</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:call</span><span class="p">)</span>
    <span class="k">next</span> <span class="k">unless</span> <span class="n">middleware</span>
    <span class="n">klass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">middleware</span>
    <span class="n">app</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">app</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这里的 <code class="highlighter-rouge">#middleware</code> 方法可以被子类覆写，如果不覆写该方法会根据环境的不同选择不同的中间件数组包裹当前的应用：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">229</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Rack::Server&gt;</span>

<span class="k">def</span> <span class="nf">default_middleware_by_environment</span>
  <span class="n">m</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span><span class="o">|</span><span class="n">h</span><span class="p">,</span><span class="n">k</span><span class="o">|</span> <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]}</span>
  <span class="n">m</span><span class="p">[</span><span class="s2">"deployment"</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">ContentLength</span><span class="p">],</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">Chunked</span><span class="p">],</span>
    <span class="n">logging_middleware</span><span class="p">,</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">TempfileReaper</span><span class="p">]</span>
  <span class="p">]</span>
  <span class="n">m</span><span class="p">[</span><span class="s2">"development"</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">ContentLength</span><span class="p">],</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">Chunked</span><span class="p">],</span>
    <span class="n">logging_middleware</span><span class="p">,</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">ShowExceptions</span><span class="p">],</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">Lint</span><span class="p">],</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">TempfileReaper</span><span class="p">]</span>
  <span class="p">]</span>
  <span class="n">m</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">.default_middleware_by_environment</code> 中就包含了不同环境下应该使用的中间件，<code class="highlighter-rouge">#build_app</code> 会视情况选择中间件加载。</p>

<h3 id="webserver-的选择">webserver 的选择</h3>

<p>在 <code class="highlighter-rouge">Server#start</code> 方法中，我们已经通过 <code class="highlighter-rouge">#wrapped_app</code> 方法将应用和中间件打包到了一起，然后分别执行 <code class="highlighter-rouge">#server</code> 和 <code class="highlighter-rouge">Server#run</code> 方法选择并运行 webserver，先来看 webserver 是如何选择的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">300</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">server</span>
  <span class="vi">@_server</span> <span class="o">||=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Handler</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="ss">:server</span><span class="p">])</span>
  <span class="k">unless</span> <span class="vi">@_server</span>
    <span class="vi">@_server</span> <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Handler</span><span class="p">.</span><span class="nf">default</span>
  <span class="k">end</span>
  <span class="vi">@_server</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果我们在运行 <code class="highlighter-rouge">rackup</code> 命令时传入了 <code class="highlighter-rouge">server</code> 选项，例如 <code class="highlighter-rouge">rackup -s WEBrick</code>，就会直接使用传入的 webserver，否则就会使用默认的 Rack 处理器：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">handler</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">46</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Rack::Handler&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">default</span>
  <span class="c1"># Guess.</span>
  <span class="k">if</span> <span class="no">ENV</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="s2">"PHP_FCGI_CHILDREN"</span><span class="p">)</span>
    <span class="no">Rack</span><span class="o">::</span><span class="no">Handler</span><span class="o">::</span><span class="no">FastCGI</span>
  <span class="k">elsif</span> <span class="no">ENV</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="no">REQUEST_METHOD</span><span class="p">)</span>
    <span class="no">Rack</span><span class="o">::</span><span class="no">Handler</span><span class="o">::</span><span class="no">CGI</span>
  <span class="k">elsif</span> <span class="no">ENV</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="s2">"RACK_HANDLER"</span><span class="p">)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="no">ENV</span><span class="p">[</span><span class="s2">"RACK_HANDLER"</span><span class="p">])</span>
  <span class="k">else</span>
    <span class="n">pick</span> <span class="p">[</span><span class="s1">'puma'</span><span class="p">,</span> <span class="s1">'thin'</span><span class="p">,</span> <span class="s1">'webrick'</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个方法中，调用 <code class="highlighter-rouge">.pick</code> 其实最终也会落到 <code class="highlighter-rouge">.get</code> 方法上，在 <code class="highlighter-rouge">.pick</code> 中我们通过遍历传入的数组<strong>尝试</strong>对其进行加载：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">handler</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">34</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Rack::Handler&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">pick</span><span class="p">(</span><span class="n">server_names</span><span class="p">)</span>
  <span class="n">server_names</span> <span class="o">=</span> <span class="no">Array</span><span class="p">(</span><span class="n">server_names</span><span class="p">)</span>
  <span class="n">server_names</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">server_name</span><span class="o">|</span>
    <span class="k">begin</span>
      <span class="k">return</span> <span class="n">get</span><span class="p">(</span><span class="n">server_name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">)</span>
    <span class="k">rescue</span> <span class="no">LoadError</span><span class="p">,</span> <span class="no">NameError</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">raise</span> <span class="no">LoadError</span><span class="p">,</span> <span class="s2">"Couldn't find handler for: </span><span class="si">#{</span><span class="n">server_names</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">', '</span><span class="p">)</span><span class="si">}</span><span class="s2">."</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">.get</code> 方法是用于加载 webserver 对应处理器的方法，方法中会通过一定的命名规范从对应的文件目录下加载相应的常量：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">handler</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">11</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Rack::Handler&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">get</span><span class="p">(</span><span class="n">server</span><span class="p">)</span>
  <span class="k">return</span> <span class="k">unless</span> <span class="n">server</span>
  <span class="n">server</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="nf">to_s</span>

  <span class="k">unless</span> <span class="vi">@handlers</span><span class="p">.</span><span class="nf">include?</span> <span class="n">server</span>
    <span class="n">load_error</span> <span class="o">=</span> <span class="n">try_require</span><span class="p">(</span><span class="s1">'rack/handler'</span><span class="p">,</span> <span class="n">server</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">if</span> <span class="n">klass</span> <span class="o">=</span> <span class="vi">@handlers</span><span class="p">[</span><span class="n">server</span><span class="p">]</span>
    <span class="n">klass</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s2">"::"</span><span class="p">).</span><span class="nf">inject</span><span class="p">(</span><span class="no">Object</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">o</span><span class="p">,</span> <span class="n">x</span><span class="o">|</span> <span class="n">o</span><span class="p">.</span><span class="nf">const_get</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">else</span>
    <span class="nb">const_get</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span>
  <span class="k">end</span>

<span class="k">rescue</span> <span class="no">NameError</span> <span class="o">=&gt;</span> <span class="n">name_error</span>
  <span class="k">raise</span> <span class="n">load_error</span> <span class="o">||</span> <span class="n">name_error</span>
<span class="k">end</span>
</code></pre></div></div>

<p>一部分常量是预先定义在 handler.rb 文件中的，另一部分是由各个 webserver 的开发者自己定义或者遵循一定的命名规范加载的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">register</span> <span class="s1">'cgi'</span><span class="p">,</span> <span class="s1">'Rack::Handler::CGI'</span>
<span class="n">register</span> <span class="s1">'fastcgi'</span><span class="p">,</span> <span class="s1">'Rack::Handler::FastCGI'</span>
<span class="n">register</span> <span class="s1">'webrick'</span><span class="p">,</span> <span class="s1">'Rack::Handler::WEBrick'</span>
<span class="n">register</span> <span class="s1">'lsws'</span><span class="p">,</span> <span class="s1">'Rack::Handler::LSWS'</span>
<span class="n">register</span> <span class="s1">'scgi'</span><span class="p">,</span> <span class="s1">'Rack::Handler::SCGI'</span>
<span class="n">register</span> <span class="s1">'thin'</span><span class="p">,</span> <span class="s1">'Rack::Handler::Thin'</span>
</code></pre></div></div>

<p>在默认的情况下，如果不在启动服务时指定服务器就会按照 puma、thin 和 webrick 的顺序依次尝试加载响应的处理器。</p>

<h3 id="webserver-的启动">webserver 的启动</h3>

<p>当 Rack 已经使用中间件对应用进行包装并且选择了对应的 webserver 之后，我们就可以将处理好的应用作为参数传入 <code class="highlighter-rouge">WEBrick.run</code> 方法了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Rack</span>
  <span class="k">module</span> <span class="nn">Handler</span>
    <span class="k">class</span> <span class="nc">WEBrick</span> <span class="o">&lt;</span> <span class="o">::</span><span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServlet</span><span class="o">::</span><span class="no">AbstractServlet</span>
      <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">run</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{})</span>
        <span class="n">environment</span>  <span class="o">=</span> <span class="no">ENV</span><span class="p">[</span><span class="s1">'RACK_ENV'</span><span class="p">]</span> <span class="o">||</span> <span class="s1">'development'</span>
        <span class="n">default_host</span> <span class="o">=</span> <span class="n">environment</span> <span class="o">==</span> <span class="s1">'development'</span> <span class="p">?</span> <span class="s1">'localhost'</span> <span class="p">:</span> <span class="kp">nil</span>

        <span class="n">options</span><span class="p">[</span><span class="ss">:BindAddress</span><span class="p">]</span> <span class="o">=</span> <span class="n">options</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="ss">:Host</span><span class="p">)</span> <span class="o">||</span> <span class="n">default_host</span>
        <span class="n">options</span><span class="p">[</span><span class="ss">:Port</span><span class="p">]</span> <span class="o">||=</span> <span class="mi">8080</span>
        <span class="vi">@server</span> <span class="o">=</span> <span class="o">::</span><span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
        <span class="vi">@server</span><span class="p">.</span><span class="nf">mount</span> <span class="s2">"/"</span><span class="p">,</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Handler</span><span class="o">::</span><span class="no">WEBrick</span><span class="p">,</span> <span class="n">app</span>
        <span class="k">yield</span> <span class="vi">@server</span>  <span class="k">if</span> <span class="nb">block_given?</span>
        <span class="vi">@server</span><span class="p">.</span><span class="nf">start</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>所有遵循 Rack 协议的 webserver 都会实现上述 <code class="highlighter-rouge">.run</code> 方法接受 <code class="highlighter-rouge">app</code>、<code class="highlighter-rouge">options</code> 和一个 block 作为参数运行一个进程来处理所有的来自用户的 HTTP 请求，在这里就是每个 webserver 自己需要解决的了，它其实并不属于 Rack 负责的部门，但是 Rack 实现了一些常见 webserver 的 handler，比如 CGI、Thin 和 WEBrick 等等，这些 handler 的实现原理都不会包含在这篇文章中。</p>

<h2 id="rails-和-rack">Rails 和 Rack</h2>

<p>在了解了 Rack 的实现之后，其实我们可以发现 Rails 应用就是一堆 Rake 中间件和一个 Rack 应用的集合，在任意的工程中我们执行 <code class="highlighter-rouge">rake middleware</code> 的命令都可以得到以下的输出：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">rake</span> <span class="n">middleware</span>
<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Sendfile</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">Static</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">Executor</span>
<span class="n">use</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Cache</span><span class="o">::</span><span class="no">Strategy</span><span class="o">::</span><span class="no">LocalCache</span><span class="o">::</span><span class="no">Middleware</span>
<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Runtime</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">RequestId</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">RemoteIp</span>
<span class="n">use</span> <span class="no">Rails</span><span class="o">::</span><span class="no">Rack</span><span class="o">::</span><span class="no">Logger</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">ShowExceptions</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">DebugExceptions</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">Reloader</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">Callbacks</span>
<span class="n">use</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span><span class="o">::</span><span class="no">CheckPending</span>
<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Head</span>
<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">ConditionalGet</span>
<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">ETag</span>
<span class="n">run</span> <span class="no">ApplicationName</span><span class="o">::</span><span class="no">Application</span><span class="p">.</span><span class="nf">routes</span>
</code></pre></div></div>

<p>在这里包含了很多使用 <code class="highlighter-rouge">use</code> 加载的 Rack 中间件，当然在最后也包含一个 Rack 应用，也就是 <code class="highlighter-rouge">ApplicationName::Application.routes</code>，这个对象其实是一个 <code class="highlighter-rouge">RouteSet</code> 实例，也就是说在 Rails 中所有的请求在经过中间件之后都会先有一个路由表来处理，路由会根据一定的规则将请求交给其他控制器处理：</p>

<p><img src="https://img.draveness.me/2017-10-29-rails-application.png" alt="rails-application" /></p>

<p>除此之外，<code class="highlighter-rouge">rake middleware</code> 命令的输出也告诉我们 Rack 其实为我们提供了很多非常方便的中间件比如 <code class="highlighter-rouge">Rack::Sendfile</code> 等可以减少我们在开发一个 webserver 时需要处理的事情。</p>

<h2 id="总结">总结</h2>

<p>Rack 协议可以说占领了整个 Ruby 服务端的市场，无论是常见的服务器还是框架都遵循 Rack 协议进行了设计，而正因为 Rack 以及 Rack 协议的存在我们在使用 Rails 或者 Sinatra 开发 Web 应用时才可以对底层使用的 webserver 进行无缝的替换，在接下来的文章中会逐一介绍不同的 webserver 是如何对 HTTP 请求进行处理以及它们拥有怎样的 I/O 模型。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://github.com/rack/rack">Rack · A modular Ruby webserver interface</a></li>
  <li><a href="http://rack.github.io">Rack: a Ruby Webserver Interface</a></li>
  <li><a href="http://rubydoc.info/github/rack/rack/master/file/SPEC">Rack interface specification</a></li>
  <li><a href="http://guides.rubyonrails.org/rails_on_rack.html">Rails on Rack</a></li>
  <li><a href="http://railscasts.com/episodes/151-rack-middleware">Rack Middleware</a></li>
  <li><a href="http://chneukirchen.org/blog/archive/2007/02/introducing-rack.html">Introducing Rack</a></li>
  <li><a href="https://stackoverflow.com/questions/4113299/ruby-on-rails-server-options">Ruby on Rails Server options</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>全面理解 ActiveRecord</title>
	  <link>/blogs//activerecord</link>
	  <author></author>
	  <pubDate>2017-10-21T00:00:00+00:00</pubDate>
	  <guid>/blogs//activerecord</guid>
	  <description><![CDATA[
	     <p>最近事情并不是特别多，看了一些数据库相关的书籍，最后想到自己并不了解每天都在用的 ActiveRecord，对于它是如何创建模型、建立关系、执行 SQL 查询以及完成数据库迁移的，作者一直都有着自己的猜测，但是真正到源代码中去寻找答案一直都是没有做过的。</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-architecture.png" alt="activerecord-architecture" /></p>

<p>我们可以将 ActiveRecord 理解为一个不同 SQL 数据库的 Wrapper，同时为上层提供一种简洁、优雅的 API 或者说 DSL，能够极大得减轻开发者的负担并提升工作效率。</p>

<p>文章分四个部分介绍了 ActiveRecord 中的重要内容，模型的创建过程、Scope 和查询的实现、模型关系的实现以及最后的 Migrations 任务的实现和执行过程，各个模块之间没有太多的关联，由于文章内容比较多，如果读者只对某一部分的内容感兴趣，可以只挑选一部分进行阅读。</p>

<h2 id="模型的创建过程">模型的创建过程</h2>

<p>在这篇文章中，我们会先分析阅读 ActiveRecord 是如何创建模型并将数据插入到数据库中的，由于 ActiveRecord 的源码变更非常迅速，这里使用的 ActiveRecord 版本是 v5.1.4，如果希望重现文中对方法的追踪过程可以 checkout 到 v5.1.4 的标签上并使用如下所示的命令安装指定版本的 ActiveRecord：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gem install activerecord <span class="nt">-v</span> <span class="s1">'5.1.4'</span>
</code></pre></div></div>

<h3 id="引入-activerecord">引入 ActiveRecord</h3>

<p>在正式开始使用 <a href="https://github.com/pry/pry">pry</a> 对方法进行追踪之前，我们需要现在 pry 中 <code class="highlighter-rouge">require</code> 对应的 gem，并且创建一个用于追踪的模型类：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="nb">require</span> <span class="s1">'active_record'</span>
<span class="o">=&gt;</span> <span class="kp">true</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">;</span> <span class="k">end</span>
<span class="o">=&gt;</span> <span class="kp">nil</span>
</code></pre></div></div>

<p>这个步骤非常的简单，这里也不多说什么了，只是创建了一个继承自 <code class="highlighter-rouge">ActiveRecord::Base</code> 的类 <code class="highlighter-rouge">Post</code>，虽然我们并没有在数据库中创建对应的表结构，不过目前来说已经够用了。</p>

<h3 id="从-postcreate-开始">从 Post.create 开始</h3>

<p>使用过 ActiveRecord 的人都知道，当我们使用 <code class="highlighter-rouge">Post.create</code> 方法的时候就会在数据库中创建一条数据记录，所以在这里我们就将该方法作为入口一探究竟：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="no">Post</span><span class="p">.</span><span class="nf">create</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">persistence</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">29</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Persistence</span><span class="o">::</span><span class="no">ClassMethods</span>

<span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="n">attributes</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">attributes</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Array</span><span class="p">)</span>
    <span class="n">attributes</span><span class="p">.</span><span class="nf">collect</span> <span class="p">{</span> <span class="o">|</span><span class="kp">attr</span><span class="o">|</span> <span class="n">create</span><span class="p">(</span><span class="kp">attr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">else</span>
    <span class="n">object</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">attributes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">object</span><span class="p">.</span><span class="nf">save</span>
    <span class="n">object</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<blockquote>
  <p><code class="highlighter-rouge">$</code> 是 pry 为我们提供的用于查看方法源代码的工具，这篇文章中会省略 <code class="highlighter-rouge">$</code> 方法的一部分输出，还可能会对方法做一些简化减少理解方法实现时的干扰。</p>
</blockquote>

<p>通过 pry 的输出，我们可以在 ActiveRecord 的 <code class="highlighter-rouge">lib/active_record/persistence.rb</code> 文件中找到 <code class="highlighter-rouge">ActiveRecord::Base.create</code> 方法的实现，如果传入的参数是一个 <code class="highlighter-rouge">Hash</code>，该方法会先后执行 <code class="highlighter-rouge">ActiveRecord::Base.new</code> 和 <code class="highlighter-rouge">ActiveRecord::Base#save!</code> 创建一个新的对象并保存。</p>

<h4 id="使用-pry-追踪-save">使用 pry 追踪 #save!</h4>

<p><code class="highlighter-rouge">ActiveRecord::Base.new</code> 在大多数情况下都会调用父类的 <code class="highlighter-rouge">#initialize</code> 方法初始化实例，所以没有什么好说的，而 <code class="highlighter-rouge">ActiveRecord::Base#save!</code> 方法就做了很多事情：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="c1">#save!</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">suppressor</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">45</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Suppressor</span>

<span class="k">def</span> <span class="nf">save!</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="c1"># :nodoc:</span>
  <span class="no">SuppressorRegistry</span><span class="p">.</span><span class="nf">suppressed</span><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">name</span><span class="p">]</span> <span class="p">?</span> <span class="kp">true</span> <span class="p">:</span> <span class="k">super</span>
<span class="k">end</span>
</code></pre></div></div>

<p>首先是使用 <code class="highlighter-rouge">SuppressorRegistry</code> 来判断是否需要对当前的存取请求进行抑制，然后执行 <code class="highlighter-rouge">super</code> 方法，由于从上述代码中没有办法知道这里的 <code class="highlighter-rouge">super</code> 到底是什么，所以我们就需要通过 <code class="highlighter-rouge">.ancestors</code> 方法看看 <code class="highlighter-rouge">ActiveRecord::Base</code> 到底有哪些父类了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">ancestors</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">,</span>
 <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Suppressor</span><span class="p">,</span>
 <span class="o">...</span>
 <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Persistence</span><span class="p">,</span>
 <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Core</span><span class="p">,</span>
 <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">ToJsonWithActiveSupportEncoder</span><span class="p">,</span>
 <span class="no">Object</span><span class="p">,</span>
 <span class="o">...</span>
 <span class="no">Kernel</span><span class="p">,</span>
 <span class="no">BasicObject</span><span class="p">]</span>

<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">ancestors</span><span class="p">.</span><span class="nf">count</span>
<span class="o">=&gt;</span> <span class="mi">65</span>
</code></pre></div></div>

<p>使用 <code class="highlighter-rouge">.ancestors</code> 方法，你就可以看到整个方法调用链上包含 64 个父类，在这时简单的使用 pry 就已经不能帮助我们理解方法的调用过程了，因为 pry 没法查看当前的方法在父类中是否存在，我们需要从工程中分析哪些类的 <code class="highlighter-rouge">#save!</code> 方法在整个过程中被执行了并根据上述列表排出它们执行的顺序；经过分析，我们得到如下的结果：</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-base-save.png" alt="activerecord-base-save" /></p>

<p>从 <code class="highlighter-rouge">ActiveRecord::Suppressor</code> 到 <code class="highlighter-rouge">ActiveRecord::Persistence</code> 一共有五个 module 实现了 <code class="highlighter-rouge">#save!</code> 方法，上面我们已经知道了 <code class="highlighter-rouge">ActiveRecord::Suppressor#save!</code> 模块提供了对保存的抑制功能，接下来将依次看后四个方法都在保存模型的过程中做了什么。</p>

<h4 id="事务的执行">事务的执行</h4>

<p>从名字就可以看出 <code class="highlighter-rouge">ActiveRecord::Transactions</code> 主要是为数据库事务提供支持，并在数据库事务的不同阶段执行不同的回调，这个 module 中的 <code class="highlighter-rouge">#save!</code> 方法仅在 <code class="highlighter-rouge">#with_transaction_returning_status</code> 的 block 中执行了 <code class="highlighter-rouge">super</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">ActiveRecord</span>
  <span class="k">module</span> <span class="nn">Transactions</span>
    <span class="k">def</span> <span class="nf">save!</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="c1">#:nodoc:</span>
      <span class="n">with_transaction_returning_status</span> <span class="p">{</span> <span class="k">super</span> <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">#with_transaction_returning_status</code> 方法会运行外部传入的 block 通过 <code class="highlighter-rouge">super</code> 执行父类的 <code class="highlighter-rouge">#save!</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">with_transaction_returning_status</span>
  <span class="n">status</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
    <span class="n">add_to_transaction</span>
    <span class="k">begin</span>
      <span class="n">status</span> <span class="o">=</span> <span class="k">yield</span>
    <span class="k">rescue</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Rollback</span>
      <span class="n">clear_transaction_record_state</span>
      <span class="n">status</span> <span class="o">=</span> <span class="kp">nil</span>
    <span class="k">end</span>

    <span class="k">raise</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Rollback</span> <span class="k">unless</span> <span class="n">status</span>
  <span class="k">end</span>
  <span class="n">status</span>
<span class="k">ensure</span>
  <span class="k">if</span> <span class="vi">@transaction_state</span> <span class="o">&amp;&amp;</span> <span class="vi">@transaction_state</span><span class="p">.</span><span class="nf">committed?</span>
    <span class="n">clear_transaction_record_state</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>通过上述方法，我们将所有的 SQL 请求都包装在了一个 <code class="highlighter-rouge">.transaction</code> 中，开启一个新的数据库事务并在其中执行请求，在这里统一处理一些跟事务回滚以及异常相关的逻辑，同时 <code class="highlighter-rouge">ActiveRecord::Transactions</code> 又能为当前的模型添加一些回调的支持：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">ActiveRecord</span>
  <span class="k">module</span> <span class="nn">Transactions</span>
    <span class="n">included</span> <span class="k">do</span>
      <span class="n">define_callbacks</span> <span class="ss">:commit</span><span class="p">,</span> <span class="ss">:rollback</span><span class="p">,</span>
                       <span class="ss">:before_commit</span><span class="p">,</span>
                       <span class="ss">:before_commit_without_transaction_enrollment</span><span class="p">,</span>
                       <span class="ss">:commit_without_transaction_enrollment</span><span class="p">,</span>
                       <span class="ss">:rollback_without_transaction_enrollment</span><span class="p">,</span>
                       <span class="ss">scope: </span><span class="p">[</span><span class="ss">:kind</span><span class="p">,</span> <span class="ss">:name</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>开发者就能够在模型中根据需要注册回调用来监听各种数据库事务相关的事件，绝大多数的事务最终都会在 <code class="highlighter-rouge">ActiveRecord::ConnectionAdapters::Transaction#within_new_transaction</code> 方法中执行：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">within_new_transaction</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="vi">@connection</span><span class="p">.</span><span class="nf">lock</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
    <span class="k">begin</span>
      <span class="n">transaction</span> <span class="o">=</span> <span class="n">begin_transaction</span> <span class="n">options</span>
      <span class="k">yield</span>
    <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">error</span>
      <span class="k">if</span> <span class="n">transaction</span>
        <span class="n">rollback_transaction</span>
        <span class="n">after_failure_actions</span><span class="p">(</span><span class="n">transaction</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
      <span class="k">end</span>
      <span class="k">raise</span>
    <span class="k">ensure</span>
      <span class="k">unless</span> <span class="n">error</span>
        <span class="k">if</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">status</span> <span class="o">==</span> <span class="s2">"aborting"</span>
          <span class="n">rollback_transaction</span> <span class="k">if</span> <span class="n">transaction</span>
        <span class="k">else</span>
          <span class="k">begin</span>
            <span class="n">commit_transaction</span>
          <span class="k">rescue</span> <span class="no">Exception</span>
            <span class="n">rollback_transaction</span><span class="p">(</span><span class="n">transaction</span><span class="p">)</span> <span class="k">unless</span> <span class="n">transaction</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">completed?</span>
            <span class="k">raise</span>
          <span class="k">end</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法虽然看起来非常复杂，但是方法的逻辑还是还是非常清晰的，如果事务没有抛出任何的异常，就可以将上述代码简化成以下的几行代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">within_new_transaction</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="vi">@connection</span><span class="p">.</span><span class="nf">lock</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
      <span class="n">begin_transaction</span> <span class="n">options</span>
      <span class="k">yield</span>
      <span class="n">commit_transaction</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>我们可以看到，经过一系列的方法调用最后会在数据库中执行 <code class="highlighter-rouge">BEGIN</code>、SQL 语句和 <code class="highlighter-rouge">COMMIT</code> 来完成数据的持久化。</p>

<h4 id="追踪属性的重置">追踪属性的重置</h4>

<p>当 <code class="highlighter-rouge">ActiveRecord::Transactions#save!</code> 通过 <code class="highlighter-rouge">super</code> 将方法抛给上层之后，就由 <code class="highlighter-rouge">ActiveRecord::AttributesMethod::Dirty</code> 来处理了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">save!</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
  <span class="k">super</span><span class="p">.</span><span class="nf">tap</span> <span class="k">do</span>
    <span class="n">changes_applied</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果 <code class="highlighter-rouge">#save!</code> 最终执行成功，在这个阶段会将所有模型改变的标记全部清除，对包括 <code class="highlighter-rouge">@changed_attributes</code>、<code class="highlighter-rouge">@mutation_tracker</code> 在内的实例变量全部重置，为追踪下一次模型的修改做准备。</p>

<h4 id="字段的验证">字段的验证</h4>

<p>沿着整个继承链往下走，下一个被执行的模块就是 <code class="highlighter-rouge">ActiveRecord::Validations</code> 了，正如这么模块名字所暗示的，我们在这里会对模型中的字段进行验证：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">save!</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="n">perform_validations</span><span class="p">(</span><span class="n">options</span><span class="p">)</span> <span class="p">?</span> <span class="k">super</span> <span class="p">:</span> <span class="n">raise_validation_error</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述代码使用 <code class="highlighter-rouge">#perform_validations</code> 方法验证模型中的全部字段，以此来保证所有的字段都符合我们的预期：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">perform_validations</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="n">options</span><span class="p">[</span><span class="ss">:validate</span><span class="p">]</span> <span class="o">==</span> <span class="kp">false</span> <span class="o">||</span> <span class="n">valid?</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="ss">:context</span><span class="p">])</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个方法中我们可以看到如果在调用 <code class="highlighter-rouge">save!</code> 方法时，传入了 <code class="highlighter-rouge">validate: false</code> 所有的验证就都会被跳过，我们通过 <code class="highlighter-rouge">#valid?</code> 来判断当前的模型是否合法，而这个方法的执行过程其实也包含两个过程：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">ActiveRecord</span>
  <span class="k">module</span> <span class="nn">Validations</span>
    <span class="k">def</span> <span class="nf">valid?</span><span class="p">(</span><span class="n">context</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
      <span class="n">context</span> <span class="o">||=</span> <span class="n">default_validation_context</span>
      <span class="n">output</span> <span class="o">=</span> <span class="k">super</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
      <span class="n">errors</span><span class="p">.</span><span class="nf">empty?</span> <span class="o">&amp;&amp;</span> <span class="n">output</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">ActiveModel</span>
  <span class="k">module</span> <span class="nn">Validations</span>
    <span class="k">def</span> <span class="nf">valid?</span><span class="p">(</span><span class="n">context</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
      <span class="n">current_context</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="nf">validation_context</span> <span class="o">=</span> <span class="n">validation_context</span><span class="p">,</span> <span class="n">context</span>
      <span class="n">errors</span><span class="p">.</span><span class="nf">clear</span>
      <span class="n">run_validations!</span>
    <span class="k">ensure</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">validation_context</span> <span class="o">=</span> <span class="n">current_context</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>由于 <code class="highlighter-rouge">ActiveModel::Validations</code> 是 <code class="highlighter-rouge">ActiveRecord::Validations</code> 的『父类』，所以在 <code class="highlighter-rouge">ActiveRecord::Validations</code> 执行 <code class="highlighter-rouge">#valid?</code> 方法时，最终会执行父类 <code class="highlighter-rouge">#run_validations</code> 运行全部的验证回调。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">ActiveModel</span>
  <span class="k">module</span> <span class="nn">Validations</span>
    <span class="k">def</span> <span class="nf">run_validations!</span>
      <span class="n">_run_validate_callbacks</span>
      <span class="n">errors</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>通过上述方法的实现，我们可以发现验证是否成功其实并不是通过我们在 <code class="highlighter-rouge">validate</code> 中传入一个返回 <code class="highlighter-rouge">true/false</code> 的方法决定的，而是要向当前模型的 <code class="highlighter-rouge">errors</code> 中添加更多的错误：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Invoice</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">validate</span> <span class="ss">:active_customer</span>
 
  <span class="k">def</span> <span class="nf">active_customer</span>
    <span class="n">errors</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="ss">:customer_id</span><span class="p">,</span> <span class="s2">"is not active"</span><span class="p">)</span> <span class="k">unless</span> <span class="n">customer</span><span class="p">.</span><span class="nf">active?</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个过程中执行的另一个方法 <code class="highlighter-rouge">#_run_validate_callbacks</code> 其实是通过 <code class="highlighter-rouge">ActiveSupport::Callbacks</code> 提供的 <code class="highlighter-rouge">#define_callbacks</code> 方法动态生成的，所以我们没有办法在工程中搜索到：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">define_callbacks</span><span class="p">(</span><span class="o">*</span><span class="n">names</span><span class="p">)</span>
  <span class="n">options</span> <span class="o">=</span> <span class="n">names</span><span class="p">.</span><span class="nf">extract_options!</span>

  <span class="n">names</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
    <span class="nb">name</span> <span class="o">=</span> <span class="nb">name</span><span class="p">.</span><span class="nf">to_sym</span>
    <span class="n">set_callbacks</span> <span class="nb">name</span><span class="p">,</span> <span class="no">CallbackChain</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="nb">module_eval</span> <span class="o">&lt;&lt;-</span><span class="no">RUBY</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
      def _run_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">_callbacks(&amp;block)
        run_callbacks </span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="sh">, &amp;block
      end

      def self._</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">_callbacks
        get_callbacks(</span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="sh">)
      end

      def self._</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">_callbacks=(value)
        set_callbacks(</span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="sh">, value)
      end

      def _</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">_callbacks
        __callbacks[</span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="sh">]
      end
</span><span class="no">    RUBY</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这篇文章中，我们只需要知道该 <code class="highlighter-rouge">#save!</code> 在合适的时机运行了正确的回调就可以了，在后面的文章（可能）中会详细介绍整个 callbacks 的具体执行流程。</p>

<h4 id="数据的持久化">数据的持久化</h4>

<p><code class="highlighter-rouge">#save!</code> 的调用栈最顶端就是 <code class="highlighter-rouge">ActiveRecord::Persistence#save!</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">save!</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">create_or_update</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="o">||</span> <span class="k">raise</span><span class="p">(</span><span class="no">RecordNotSaved</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"Failed to save the record"</span><span class="p">,</span> <span class="nb">self</span><span class="p">))</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">create_or_update</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">_raise_readonly_record_error</span> <span class="k">if</span> <span class="n">readonly?</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">new_record?</span> <span class="p">?</span> <span class="n">_create_record</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="p">:</span> <span class="n">_update_record</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">!=</span> <span class="kp">false</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个方法中，我们执行了 <code class="highlighter-rouge">#create_or_update</code> 以及 <code class="highlighter-rouge">#_create_record</code> 两个方法来创建模型：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_create_record</span><span class="p">(</span><span class="n">attribute_names</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">attribute_names</span><span class="p">)</span>
  <span class="n">attributes_values</span> <span class="o">=</span> <span class="n">arel_attributes_with_values_for_create</span><span class="p">(</span><span class="n">attribute_names</span><span class="p">)</span>
  <span class="n">new_id</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">insert</span> <span class="n">attributes_values</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">id</span> <span class="o">||=</span> <span class="n">new_id</span> <span class="k">if</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">primary_key</span>
  <span class="vi">@new_record</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="k">yield</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="k">if</span> <span class="nb">block_given?</span>
  <span class="nb">id</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个私有方法中开始执行数据的插入操作了，首先是通过 <code class="highlighter-rouge">ActiveRecord::AttributeMethods#arel_attributes_with_values_for_create</code> 方法获取一个用于插入数据的字典，其中包括了数据库中的表字段和对应的待插入值。</p>

<p><img src="https://img.draveness.me/2017-10-21-database-statement-insert.png" alt="database-statement-insert" /></p>

<p>而下面的 <code class="highlighter-rouge">.insert</code> 方法就会将这个字典转换成 SQL 语句，经过上图所示的调用栈最终到不同的数据库中执行语句并返回最新的主键。</p>

<h3 id="小结">小结</h3>

<p>从整个模型的创建过程中，我们可以看到 ActiveRecord 对于不同功能的组织非常优雅，每一个方法都非常简短并且易于阅读，通过对应的方法名和模块名我们就能够明确的知道这个东西是干什么的，对于同一个方法的不同执行逻辑也分散了不同的模块中，最终使用 module 加上 include 的方式组织起来，如果要对某个方法添加一些新的逻辑也可以通过增加更多的 module 达到目的。</p>

<p>通过对源代码的阅读，我们可以看到对于 ActiveRecord 来说，<code class="highlighter-rouge">#create</code> 和 <code class="highlighter-rouge">#save!</code> 方法的执行路径其实是差不多的，只是在细节上有一些不同之处。</p>

<p><img src="https://img.draveness.me/2017-10-21-actual-callstack-for-activerecord-base-save.png" alt="actual-callstack-for-activerecord-base-save" /></p>

<p>虽然模型或者说数据行的创建过程最终会从子类一路执行到父类的 <code class="highlighter-rouge">#save!</code> 方法，但是逻辑的<strong>处理顺序</strong>并不是按照从子类到父类执行的，我们可以通过上图了解不同模块的真正执行过程。</p>

<h2 id="scope-和查询的实现">Scope 和查询的实现</h2>

<p>除了模型的插入、创建和迁移模块，ActiveRecord 中还有另一个非常重要的模块，也就是 Scope 和查询；为什么同时介绍这两个看起来毫不相干的内容呢？这是因为 Scope 和查询是完全分不开的一个整体，在 ActiveRecord 的实现中，两者有着非常紧密的联系。</p>

<h3 id="activerecordrelation">ActiveRecord::Relation</h3>

<p>对 ActiveRecord 稍有了解的人都知道，在使用 ActiveRecord 进行查询时，所有的查询方法其实都会返回一个 <code class="highlighter-rouge">#{Model}::ActiveRecord_Relation</code> 类的对象，比如 <code class="highlighter-rouge">User.all</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">class</span>
<span class="o">=&gt;</span> <span class="no">User</span><span class="o">::</span><span class="no">ActiveRecord_Relation</span>
</code></pre></div></div>

<p>在这里使用 pry 来可以帮助我们快速理解整个过程到底都发生了什么事情：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">scoping</span><span class="o">/</span><span class="n">named</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">24</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Scoping</span><span class="o">::</span><span class="no">Named</span><span class="o">::</span><span class="no">ClassMethods</span>

<span class="k">def</span> <span class="nf">all</span>
  <span class="k">if</span> <span class="n">current_scope</span>
    <span class="n">current_scope</span><span class="p">.</span><span class="nf">clone</span>
  <span class="k">else</span>
    <span class="n">default_scoped</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">#all</code> 方法中的注释中也写着它会返回一个 <code class="highlighter-rouge">ActiveRecord::Relation</code> 对象，它其实可以理解为 ActiveRecord 查询体系中的单位元，它的调用并不改变当前查询；而如果我们使用 pry 去看其他的方法例如 <code class="highlighter-rouge">User.where</code> 的时候：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="no">User</span><span class="p">.</span><span class="nf">where</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">querying</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">10</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Querying</span>

<span class="n">delegate</span> <span class="ss">:select</span><span class="p">,</span> <span class="ss">:group</span><span class="p">,</span> <span class="ss">:order</span><span class="p">,</span> <span class="ss">:except</span><span class="p">,</span> <span class="ss">:reorder</span><span class="p">,</span> <span class="ss">:limit</span><span class="p">,</span> <span class="ss">:offset</span><span class="p">,</span> <span class="ss">:joins</span><span class="p">,</span> <span class="ss">:left_joins</span><span class="p">,</span> <span class="ss">:left_outer_joins</span><span class="p">,</span> <span class="ss">:or</span><span class="p">,</span>
         <span class="ss">:where</span><span class="p">,</span> <span class="ss">:rewhere</span><span class="p">,</span> <span class="ss">:preload</span><span class="p">,</span> <span class="ss">:eager_load</span><span class="p">,</span> <span class="ss">:includes</span><span class="p">,</span> <span class="ss">:from</span><span class="p">,</span> <span class="ss">:lock</span><span class="p">,</span> <span class="ss">:readonly</span><span class="p">,</span> <span class="ss">:extending</span><span class="p">,</span>
         <span class="ss">:having</span><span class="p">,</span> <span class="ss">:create_with</span><span class="p">,</span> <span class="ss">:distinct</span><span class="p">,</span> <span class="ss">:references</span><span class="p">,</span> <span class="ss">:none</span><span class="p">,</span> <span class="ss">:unscope</span><span class="p">,</span> <span class="ss">:merge</span><span class="p">,</span> <span class="ss">to: :all</span>
</code></pre></div></div>

<p>从这里我们可以看出，真正实现为 <code class="highlighter-rouge">User</code> 类方法的只有 <code class="highlighter-rouge">.all</code>，其他的方法都会代理给 <code class="highlighter-rouge">all</code> 方法，在 <code class="highlighter-rouge">.all</code> 方法返回的对象上执行：</p>

<p><img src="https://img.draveness.me/2017-10-21-active-record-relation-delegation.png" alt="active-record-relation-delegation" /></p>

<p>所有直接在类上调用的方法都会先执行 <code class="highlighter-rouge">#all</code>，也就是说下面的几种写法是完全相同的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">User</span>    <span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">name: </span><span class="s1">'draven'</span><span class="p">)</span>
<span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">name: </span><span class="s1">'draven'</span><span class="p">)</span>
<span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">name: </span><span class="s1">'draven'</span><span class="p">).</span><span class="nf">all</span>
</code></pre></div></div>

<p>当我们了解了 <code class="highlighter-rouge">.where == .all + #where</code> 就可以再一次使用 pry 来查找真正被 ActiveRecord 实现的 <code class="highlighter-rouge">#where</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">where</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">relation</span><span class="o">/</span><span class="n">query_methods</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">599</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">QueryMethods</span>

<span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="n">opts</span> <span class="o">=</span> <span class="ss">:chain</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">)</span>
  <span class="k">if</span> <span class="ss">:chain</span> <span class="o">==</span> <span class="n">opts</span>
    <span class="no">WhereChain</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">spawn</span><span class="p">)</span>
  <span class="k">elsif</span> <span class="n">opts</span><span class="p">.</span><span class="nf">blank?</span>
    <span class="nb">self</span>
  <span class="k">else</span>
    <span class="n">spawn</span><span class="p">.</span><span class="nf">where!</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在分析查询的过程中，我们会选择几个常见的方法作为入口，尽可能得覆盖较多的查询相关的代码，增加我们对 ActiveRecord 的理解和认识。</p>

<h3 id="从-userall-开始">从 User.all 开始</h3>

<p>再来看一下上面看到的 <code class="highlighter-rouge">ActiveRecord::Relation.all</code> 方法，无论是 <code class="highlighter-rouge">#current_scope</code> 还是 <code class="highlighter-rouge">#default_scoped</code> 其实返回的都是当前的 <code class="highlighter-rouge">ActiveRecord</code> 对象：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">all</span>
  <span class="k">if</span> <span class="n">current_scope</span>
    <span class="n">current_scope</span><span class="p">.</span><span class="nf">clone</span>
  <span class="k">else</span>
    <span class="n">default_scoped</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="current_scope-和-default_scope">current_scope 和 default_scope</h4>

<p>如果当前没有 <code class="highlighter-rouge">#current_scope</code> 那么，就会调用 <code class="highlighter-rouge">#default_scoped</code> 返回响应的结果，否则就会 clone 当前对象并返回，可以简单举一个例子证明这里的猜测：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">current_scope</span>
<span class="o">=&gt;</span> <span class="kp">nil</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">current_scope</span>
  <span class="no">User</span> <span class="no">Load</span> <span class="p">(</span><span class="mf">0.1</span><span class="n">ms</span><span class="p">)</span>  <span class="no">SELECT</span> <span class="s2">"users"</span><span class="p">.</span><span class="nf">*</span> <span class="no">FROM</span> <span class="s2">"users"</span>
<span class="o">=&gt;</span> <span class="p">[]</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">current_scope</span><span class="p">.</span><span class="nf">class</span>
<span class="o">=&gt;</span> <span class="no">User</span><span class="o">::</span><span class="no">ActiveRecord_Relation</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">.current_scope</code> 是存储在位于线程变量的 <code class="highlighter-rouge">ScopeRegistry</code> 中，它其实就是当前的查询语句的上下文，存储着这一次链式调用造成的全部副作用：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">current_scope</span><span class="p">(</span><span class="n">skip_inherited_scope</span> <span class="o">=</span> <span class="kp">false</span><span class="p">)</span>
  <span class="no">ScopeRegistry</span><span class="p">.</span><span class="nf">value_for</span><span class="p">(</span><span class="ss">:current_scope</span><span class="p">,</span> <span class="nb">self</span><span class="p">,</span> <span class="n">skip_inherited_scope</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>而 <code class="highlighter-rouge">.default_scoped</code> 就是在当前查询链刚开始时执行的第一个方法，因为在执行第一个查询方法之前 <code class="highlighter-rouge">.current_scope</code> 一定为空：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">default_scoped</span><span class="p">(</span><span class="n">scope</span> <span class="o">=</span> <span class="n">relation</span><span class="p">)</span>
  <span class="n">build_default_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span> <span class="o">||</span> <span class="n">scope</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">build_default_scope</span><span class="p">(</span><span class="n">base_rel</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="k">return</span> <span class="k">if</span> <span class="n">abstract_class?</span>

  <span class="k">if</span> <span class="n">default_scopes</span><span class="p">.</span><span class="nf">any?</span>
    <span class="n">base_rel</span> <span class="o">||=</span> <span class="n">relation</span>
    <span class="n">evaluate_default_scope</span> <span class="k">do</span>
      <span class="n">default_scopes</span><span class="p">.</span><span class="nf">inject</span><span class="p">(</span><span class="n">base_rel</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">default_scope</span><span class="p">,</span> <span class="n">scope</span><span class="o">|</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:to_proc</span><span class="p">)</span> <span class="p">?</span> <span class="n">scope</span> <span class="p">:</span> <span class="n">scope</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="ss">:call</span><span class="p">)</span>
        <span class="n">default_scope</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">base_rel</span><span class="p">.</span><span class="nf">instance_exec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scope</span><span class="p">))</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当我们在 Rails 的模型层中使用 <code class="highlighter-rouge">.default_scope</code> 定义一些默认的上下文时，所有的 block 都换被转换成 <code class="highlighter-rouge">Proc</code> 对象最终添加到 <code class="highlighter-rouge">default_scopes</code> 数组中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">default_scope</span><span class="p">(</span><span class="n">scope</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span> <span class="c1"># :doc:</span>
  <span class="n">scope</span> <span class="o">=</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="k">if</span> <span class="nb">block_given?</span>
  <span class="c1"># ...</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">default_scopes</span> <span class="o">+=</span> <span class="p">[</span><span class="n">scope</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上面提到的 <code class="highlighter-rouge">.build_default_scope</code> 方法其实只是在 <code class="highlighter-rouge">default_scopes</code> 数组不为空时，将当前的 <code class="highlighter-rouge">Relation</code> 对象和数组中的全部 scope 一一 <code class="highlighter-rouge">#merge</code> 并返回一个新的 <code class="highlighter-rouge">Relation</code> 对象。</p>

<h4 id="activerecordrelation-对象">ActiveRecord::Relation 对象</h4>

<p><code class="highlighter-rouge">.default_scoped</code> 方法的参数 <code class="highlighter-rouge">scope</code> 其实就有一个默认值 <code class="highlighter-rouge">#relation</code>，这个默认值其实就是一个 <code class="highlighter-rouge">Relation</code> 类的实例：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">relation</span>
  <span class="n">relation</span> <span class="o">=</span> <span class="no">Relation</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">arel_table</span><span class="p">,</span> <span class="n">predicate_builder</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">finder_needs_type_condition?</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ignore_default_scope?</span>
    <span class="n">relation</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">type_condition</span><span class="p">).</span><span class="nf">create_with</span><span class="p">(</span><span class="n">inheritance_column</span><span class="p">.</span><span class="nf">to_s</span> <span class="o">=&gt;</span> <span class="n">sti_name</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="n">relation</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Relation.create</code> 对象的创建过程其实比较复杂，我们只需要知道经过 ActiveRecord 一系列的疯狂操作，最终会将几个参数传入 <code class="highlighter-rouge">.new</code> 方法初始化一个 <code class="highlighter-rouge">ActiveRecord::Relation</code> 实例：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Relation</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">predicate_builder</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="vi">@klass</span>  <span class="o">=</span> <span class="n">klass</span>
    <span class="vi">@table</span>  <span class="o">=</span> <span class="n">table</span>
    <span class="vi">@values</span> <span class="o">=</span> <span class="n">values</span>
    <span class="vi">@offsets</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="vi">@loaded</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="vi">@predicate_builder</span> <span class="o">=</span> <span class="n">predicate_builder</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当执行的是 <code class="highlighter-rouge">#all</code>、<code class="highlighter-rouge">.all</code> 或者绝大多数查询方法时，都会直接将这个初始化的对象返回来接受随后的链式调用。</p>

<h3 id="where-方法">where 方法</h3>

<p>相比于 <code class="highlighter-rouge">#all</code>、<code class="highlighter-rouge">#where</code> 查询的实现就复杂多了，不像 <code class="highlighter-rouge">#all</code> 会返回一个默认的 <code class="highlighter-rouge">Relation</code> 对象，<code class="highlighter-rouge">#where</code> 由 <code class="highlighter-rouge">WhereClause</code> 以及 <code class="highlighter-rouge">WhereClauseFactory</code> 等类共同处理；在 <code class="highlighter-rouge">#where</code> 的最正常的执行路径中，它会执行 <code class="highlighter-rouge">#where!</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="n">opts</span> <span class="o">=</span> <span class="ss">:chain</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">)</span>
  <span class="k">if</span> <span class="ss">:chain</span> <span class="o">==</span> <span class="n">opts</span>
    <span class="no">WhereChain</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">spawn</span><span class="p">)</span>
  <span class="k">elsif</span> <span class="n">opts</span><span class="p">.</span><span class="nf">blank?</span>
    <span class="nb">self</span>
  <span class="k">else</span>
    <span class="n">spawn</span><span class="p">.</span><span class="nf">where!</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">where!</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">)</span>
  <span class="n">opts</span> <span class="o">=</span> <span class="n">sanitize_forbidden_attributes</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
  <span class="n">references!</span><span class="p">(</span><span class="no">PredicateBuilder</span><span class="p">.</span><span class="nf">references</span><span class="p">(</span><span class="n">opts</span><span class="p">))</span> <span class="k">if</span> <span class="no">Hash</span> <span class="o">===</span> <span class="n">opts</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">where_clause</span> <span class="o">+=</span> <span class="n">where_clause_factory</span><span class="p">.</span><span class="nf">build</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span>
  <span class="nb">self</span>
<span class="k">end</span>
</code></pre></div></div>

<blockquote>
  <p><code class="highlighter-rouge">#spawn</code> 其实就是对当前的 <code class="highlighter-rouge">Relation</code> 对象进行 <code class="highlighter-rouge">#clone</code>。</p>
</blockquote>

<p>查询方法 <code class="highlighter-rouge">#where!</code> 中的四行代码只有一行代码是我们需要关注的，该方法调用 <code class="highlighter-rouge">WhereClauseFactory#build</code> 生成一条 where 查询并存储到当前对象的 <code class="highlighter-rouge">where_clause</code> 中，在这个过程中并不会生成 SQL，而是会生成一个 <code class="highlighter-rouge">WhereClause</code> 对象，其中存储着 SQL 节点树：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">name: </span><span class="s1">'draven'</span><span class="p">).</span><span class="nf">where_clause</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;ActiveRecord::Relation::WhereClause:0x007fe5a10bf2c8</span>
 <span class="vi">@binds</span><span class="o">=</span>
  <span class="p">[</span><span class="c1">#&lt;ActiveRecord::Relation::QueryAttribute:0x007fe5a10bf4f8</span>
    <span class="vi">@name</span><span class="o">=</span><span class="s2">"name"</span><span class="p">,</span>
    <span class="vi">@original_attribute</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span>
    <span class="vi">@type</span><span class="o">=</span><span class="c1">#&lt;ActiveModel::Type::String:0x007fe59d33f2e0 @limit=nil, @precision=nil, @scale=nil&gt;,</span>
    <span class="vi">@value_before_type_cast</span><span class="o">=</span><span class="s2">"draven"</span><span class="o">&gt;</span><span class="p">],</span>
 <span class="vi">@predicates</span><span class="o">=</span>
  <span class="p">[</span><span class="c1">#&lt;Arel::Nodes::Equality:0x007fe5a10bf368</span>
    <span class="vi">@left</span><span class="o">=</span>
     <span class="c1">#&lt;struct Arel::Attributes::Attribute</span>
      <span class="n">relation</span><span class="o">=</span>
       <span class="c1">#&lt;Arel::Table:0x007fe59cc87830</span>
        <span class="vi">@name</span><span class="o">=</span><span class="s2">"users"</span><span class="p">,</span>
        <span class="vi">@table_alias</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span>
        <span class="vi">@type_caster</span><span class="o">=</span>
         <span class="c1">#&lt;ActiveRecord::TypeCaster::Map:0x007fe59cc87bf0</span>
          <span class="vi">@types</span><span class="o">=</span>
           <span class="no">User</span><span class="p">(</span><span class="ss">id: </span><span class="n">integer</span><span class="p">,</span> <span class="ss">avatar: </span><span class="n">string</span><span class="p">,</span> <span class="ss">nickname: </span><span class="n">string</span><span class="p">,</span> <span class="ss">wechat: </span><span class="n">string</span><span class="p">,</span> <span class="ss">name: </span><span class="n">string</span><span class="p">,</span> <span class="ss">gender: </span><span class="n">integer</span><span class="p">,</span> <span class="ss">school: </span><span class="n">string</span><span class="p">,</span> <span class="ss">grade: </span><span class="n">string</span><span class="p">,</span> <span class="ss">major: </span><span class="n">string</span><span class="p">,</span> <span class="ss">completed: </span><span class="n">boolean</span><span class="p">,</span> <span class="ss">created_at: </span><span class="n">datetime</span><span class="p">,</span> <span class="ss">updated_at: </span><span class="n">datetime</span><span class="p">,</span> <span class="ss">mobile: </span><span class="n">string</span><span class="p">,</span> <span class="ss">admin: </span><span class="n">boolean</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">,</span>
      <span class="nb">name</span><span class="o">=</span><span class="s2">"name"</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="vi">@right</span><span class="o">=</span><span class="c1">#&lt;Arel::Nodes::BindParam:0x007fe5a10bf520&gt;&gt;]&gt;</span>
</code></pre></div></div>

<blockquote>
  <p><a href="https://github.com/rails/arel">Arel</a> 是一个 Ruby 的 SQL 抽象语法树的管理器，ActiveRecord 查询的过程都是惰性的，在真正进入数据库查询之前，查询条件都是以语法树的形式存储的。</p>
</blockquote>

<p>在这里不像展开介绍 SQL 语法树的生成过程，因为过程比较复杂，详细分析也没有太大的意义。</p>

<h3 id="order-方法">order 方法</h3>

<p>除了 <code class="highlighter-rouge">#where</code> 方法之外，在这里还想简单介绍一下另外一个常用的方法 <code class="highlighter-rouge">#order</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">check_if_method_has_arguments!</span><span class="p">(</span><span class="ss">:order</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
  <span class="n">spawn</span><span class="p">.</span><span class="nf">order!</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">order!</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">preprocess_order_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">order_values</span> <span class="o">+=</span> <span class="n">args</span>
  <span class="nb">self</span>
<span class="k">end</span>
</code></pre></div></div>

<p>该方法的调用栈与 <code class="highlighter-rouge">#where</code> 非常相似，在调用栈中都会执行另一个带有 <code class="highlighter-rouge">!</code> 的方法，也都会向自己持有的某个『属性』追加一些参数，参数的处理也有点复杂，在这里简单看一看就好：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">preprocess_order_args</span><span class="p">(</span><span class="n">order_args</span><span class="p">)</span>
  <span class="n">order_args</span><span class="p">.</span><span class="nf">map!</span> <span class="k">do</span> <span class="o">|</span><span class="n">arg</span><span class="o">|</span>
    <span class="n">klass</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="ss">:sanitize_sql_for_order</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">order_args</span><span class="p">.</span><span class="nf">flatten!</span>
  <span class="n">validate_order_args</span><span class="p">(</span><span class="n">order_args</span><span class="p">)</span>

  <span class="n">references</span> <span class="o">=</span> <span class="n">order_args</span><span class="p">.</span><span class="nf">grep</span><span class="p">(</span><span class="no">String</span><span class="p">)</span>
  <span class="n">references</span><span class="p">.</span><span class="nf">map!</span> <span class="p">{</span> <span class="o">|</span><span class="n">arg</span><span class="o">|</span> <span class="n">arg</span> <span class="o">=~</span> <span class="sr">/^([a-zA-Z]\w*)\.(\w+)/</span> <span class="o">&amp;&amp;</span> <span class="vg">$1</span> <span class="p">}.</span><span class="nf">compact!</span>
  <span class="n">references!</span><span class="p">(</span><span class="n">references</span><span class="p">)</span> <span class="k">if</span> <span class="n">references</span><span class="p">.</span><span class="nf">any?</span>

  <span class="c1"># if a symbol is given we prepend the quoted table name</span>
  <span class="n">order_args</span><span class="p">.</span><span class="nf">map!</span> <span class="k">do</span> <span class="o">|</span><span class="n">arg</span><span class="o">|</span>
    <span class="k">case</span> <span class="n">arg</span>
    <span class="k">when</span> <span class="no">Symbol</span>
      <span class="n">arel_attribute</span><span class="p">(</span><span class="n">arg</span><span class="p">).</span><span class="nf">asc</span>
    <span class="k">when</span> <span class="no">Hash</span>
      <span class="n">arg</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">field</span><span class="p">,</span> <span class="n">dir</span><span class="o">|</span>
        <span class="k">case</span> <span class="n">field</span>
        <span class="k">when</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">SqlLiteral</span>
          <span class="n">field</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">dir</span><span class="p">.</span><span class="nf">downcase</span><span class="p">)</span>
        <span class="k">else</span>
          <span class="n">arel_attribute</span><span class="p">(</span><span class="n">field</span><span class="p">).</span><span class="nf">send</span><span class="p">(</span><span class="n">dir</span><span class="p">.</span><span class="nf">downcase</span><span class="p">)</span>
        <span class="k">end</span>
      <span class="p">}</span>
    <span class="k">else</span>
      <span class="n">arg</span>
    <span class="k">end</span>
  <span class="k">end</span><span class="p">.</span><span class="nf">flatten!</span>
<span class="k">end</span>
</code></pre></div></div>

<p>同样的，<code class="highlighter-rouge">#order</code> 方法的使用也会向 <code class="highlighter-rouge">order_values</code> 数组中添加对应的语法元素：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">name: :desc</span><span class="p">).</span><span class="nf">order_values</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="c1">#&lt;Arel::Nodes::Descending:0x007fe59ce4f190</span>
  <span class="vi">@expr</span><span class="o">=</span>
   <span class="c1">#&lt;struct Arel::Attributes::Attribute</span>
    <span class="n">relation</span><span class="o">=</span>
     <span class="c1">#&lt;Arel::Table:0x007fe59cc87830</span>
      <span class="vi">@name</span><span class="o">=</span><span class="s2">"users"</span><span class="p">,</span>
      <span class="vi">@table_alias</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span>
      <span class="vi">@type_caster</span><span class="o">=</span>
       <span class="c1">#&lt;ActiveRecord::TypeCaster::Map:0x007fe59cc87bf0</span>
        <span class="vi">@types</span><span class="o">=</span>
         <span class="no">User</span><span class="p">(</span><span class="ss">id: </span><span class="n">integer</span><span class="p">,</span> <span class="ss">avatar: </span><span class="n">string</span><span class="p">,</span> <span class="ss">nickname: </span><span class="n">string</span><span class="p">,</span> <span class="ss">wechat: </span><span class="n">string</span><span class="p">,</span> <span class="ss">name: </span><span class="n">string</span><span class="p">,</span> <span class="ss">gender: </span><span class="n">integer</span><span class="p">,</span> <span class="ss">school: </span><span class="n">string</span><span class="p">,</span> <span class="ss">grade: </span><span class="n">string</span><span class="p">,</span> <span class="ss">major: </span><span class="n">string</span><span class="p">,</span> <span class="ss">completed: </span><span class="n">boolean</span><span class="p">,</span> <span class="ss">created_at: </span><span class="n">datetime</span><span class="p">,</span> <span class="ss">updated_at: </span><span class="n">datetime</span><span class="p">,</span> <span class="ss">mobile: </span><span class="n">string</span><span class="p">,</span> <span class="ss">admin: </span><span class="n">boolean</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="nb">name</span><span class="o">=</span><span class="ss">:name</span><span class="o">&gt;&gt;</span><span class="p">]</span>
</code></pre></div></div>

<p>在这个方法的返回值中，我们也能看到与 Arel 相关的各种节点，可以大致理解上述语法树的作用。</p>

<h3 id="语法树的存储">语法树的存储</h3>

<p>无论是 <code class="highlighter-rouge">#where</code> 还是 <code class="highlighter-rouge">#order</code> 方法，它们其实都会向当前的 <code class="highlighter-rouge">Relation</code> 对象中追加相应的语法树节点，而除了上述的两个方法之外 <code class="highlighter-rouge">#from</code>、<code class="highlighter-rouge">#distinct</code>、<code class="highlighter-rouge">#lock</code>、<code class="highlighter-rouge">#limit</code> 等等，几乎所有的查询方法都会改变 <code class="highlighter-rouge">Relation</code> 中的某个值，然而所有的值其实都是通过 <code class="highlighter-rouge">@values</code> 这个实例变量存储的：</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-relation-value-methods.png" alt="activerecord-relation-value-methods" /></p>

<p><code class="highlighter-rouge">@values</code> 中存储的值分为三类，<code class="highlighter-rouge">SINGLE_VALUE</code>、<code class="highlighter-rouge">MULTI_VALUE</code> 和 <code class="highlighter-rouge">CLAUSE</code>，这三类属性会按照下面的规则存储在 <code class="highlighter-rouge">@values</code> 中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Relation</span><span class="o">::</span><span class="no">VALUE_METHODS</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
  <span class="n">method_name</span> <span class="o">=</span> <span class="p">\</span>
    <span class="k">case</span> <span class="nb">name</span>
    <span class="k">when</span> <span class="o">*</span><span class="no">Relation</span><span class="o">::</span><span class="no">MULTI_VALUE_METHODS</span> <span class="k">then</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">_values"</span>
    <span class="k">when</span> <span class="o">*</span><span class="no">Relation</span><span class="o">::</span><span class="no">SINGLE_VALUE_METHODS</span> <span class="k">then</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">_value"</span>
    <span class="k">when</span> <span class="o">*</span><span class="no">Relation</span><span class="o">::</span><span class="no">CLAUSE_METHODS</span> <span class="k">then</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">_clause"</span>
    <span class="k">end</span>
  <span class="nb">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
    def </span><span class="si">#{</span><span class="n">method_name</span><span class="si">}</span><span class="sh">                   # def includes_values
      get_value(</span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="sh">)         #   get_value(:includes)
    end                                  # end

    def </span><span class="si">#{</span><span class="n">method_name</span><span class="si">}</span><span class="sh">=(value)           # def includes_values=(value)
      set_value(</span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="sh">, value)  #   set_value(:includes, value)
    end                                  # end
</span><span class="no">  CODE</span>
<span class="k">end</span>
</code></pre></div></div>

<p>各种不同的值在最后都会按照一定的命名规则，存储在这个 <code class="highlighter-rouge">@values</code> 字典中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="vi">@values</span><span class="p">[</span><span class="nb">name</span><span class="p">]</span> <span class="o">||</span> <span class="n">default_value_for</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
  <span class="n">assert_mutability!</span>
  <span class="vi">@values</span><span class="p">[</span><span class="nb">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果我们直接在一个查询链中访问 <code class="highlighter-rouge">#values</code> 方法可以获得其中存储的所有查询条件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">name: </span><span class="s1">'draven'</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="ss">name: :desc</span><span class="p">).</span><span class="nf">values</span>
<span class="o">=&gt;</span> <span class="p">{</span><span class="ss">:references</span><span class="o">=&gt;</span><span class="p">[],</span>
 <span class="ss">:where</span><span class="o">=&gt;</span>
  <span class="c1">#&lt;ActiveRecord::Relation::WhereClause:0x007fe59d14d860&gt;,</span>
 <span class="ss">:order</span><span class="o">=&gt;</span>
  <span class="p">[</span><span class="c1">#&lt;Arel::Nodes::Descending:0x007fe59d14cd98&gt;]}</span>
</code></pre></div></div>

<p>很多 ActiveRecord 的使用者其实在使用的过程中都感觉在各种链式方法调用时没有改变任何事情，所有的方法都可以任意组合进行链式调用，其实每一个方法的调用都会对 <code class="highlighter-rouge">@values</code> 中存储的信息进行了修改，只是 ActiveRecord 很好地将它隐藏了幕后，让我们没有感知到它的存在。</p>

<h3 id="scope-方法">scope 方法</h3>

<p>相比于 <code class="highlighter-rouge">.default_scope</code> 这个类方法只是改变了当前模型中的 <code class="highlighter-rouge">default_scopes</code> 数组，另一个方法 <code class="highlighter-rouge">.scope</code> 会为当前类定义一个新的类方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">scoping</span><span class="o">/</span><span class="n">named</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">155</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Scoping</span><span class="o">::</span><span class="no">Named</span><span class="o">::</span><span class="no">ClassMethods</span>

<span class="k">def</span> <span class="nf">scope</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">extension</span> <span class="o">=</span> <span class="no">Module</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="k">if</span> <span class="n">block</span>

  <span class="k">if</span> <span class="n">body</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:to_proc</span><span class="p">)</span>
    <span class="n">singleton_class</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="ss">:define_method</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span> <span class="k">do</span> <span class="o">|*</span><span class="n">args</span><span class="o">|</span>
      <span class="n">scope</span> <span class="o">=</span> <span class="n">all</span><span class="p">.</span><span class="nf">scoping</span> <span class="p">{</span> <span class="n">instance_exec</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">body</span><span class="p">)</span> <span class="p">}</span>
      <span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span><span class="p">.</span><span class="nf">extending</span><span class="p">(</span><span class="n">extension</span><span class="p">)</span> <span class="k">if</span> <span class="n">extension</span>
      <span class="n">scope</span> <span class="o">||</span> <span class="n">all</span>
    <span class="k">end</span>
  <span class="k">else</span>
    <span class="n">singleton_class</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="ss">:define_method</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span> <span class="k">do</span> <span class="o">|*</span><span class="n">args</span><span class="o">|</span>
      <span class="n">scope</span> <span class="o">=</span> <span class="n">all</span><span class="p">.</span><span class="nf">scoping</span> <span class="p">{</span> <span class="n">body</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="p">}</span>
      <span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span><span class="p">.</span><span class="nf">extending</span><span class="p">(</span><span class="n">extension</span><span class="p">)</span> <span class="k">if</span> <span class="n">extension</span>
      <span class="n">scope</span> <span class="o">||</span> <span class="n">all</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法会直接在当前类的单类上通过 <code class="highlighter-rouge">define_methods</code> 为当前类定义类方法，定义的方法会在上面提到的 <code class="highlighter-rouge">.all</code> 的返回结果上执行 <code class="highlighter-rouge">#scoping</code>，存储当前执行的上下文，执行传入的 block，再恢复 <code class="highlighter-rouge">current_scope</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">scoping</span>
  <span class="n">previous</span><span class="p">,</span> <span class="n">klass</span><span class="p">.</span><span class="nf">current_scope</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">current_scope</span><span class="p">(</span><span class="kp">true</span><span class="p">),</span> <span class="nb">self</span>
  <span class="k">yield</span>
<span class="k">ensure</span>
  <span class="n">klass</span><span class="p">.</span><span class="nf">current_scope</span> <span class="o">=</span> <span class="n">previous</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这里其实有一个可能很多人从来没用过的特性，就是在 <code class="highlighter-rouge">.scope</code> 方法中传入一个 block：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span>
  <span class="n">scope</span> <span class="ss">:male</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="ss">gender: :male</span> <span class="p">}</span> <span class="k">do</span>
    <span class="k">def</span> <span class="nf">twenty</span>
      <span class="n">where</span> <span class="ss">age: </span><span class="mi">20</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">male</span><span class="p">.</span><span class="nf">twenty</span>
<span class="c1">#=&gt; &lt;#User:0x007f98f3d61c38&gt;</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">twenty</span>
<span class="c1">#=&gt; NoMethodError: undefined method `twenty' for #&lt;Class:0x007f98f5c7b2b8&gt;</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">female</span><span class="p">.</span><span class="nf">twenty</span>
<span class="c1">#=&gt; NoMethodError: undefined method `twenty' for #&lt;User::ActiveRecord_Relation:0x007f98f5d950e0&gt;</span>
</code></pre></div></div>

<p>这个传入的 block 只会在当前 <code class="highlighter-rouge">Relation</code> 对象的单类上添加方法，如果我们想定义一些不想在其他作用域使用的方法就可以使用这种方式：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">extending</span><span class="p">(</span><span class="o">*</span><span class="n">modules</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">modules</span><span class="p">.</span><span class="nf">any?</span> <span class="o">||</span> <span class="n">block</span>
    <span class="n">spawn</span><span class="p">.</span><span class="nf">extending!</span><span class="p">(</span><span class="o">*</span><span class="n">modules</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="nb">self</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">extending!</span><span class="p">(</span><span class="o">*</span><span class="n">modules</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">modules</span> <span class="o">&lt;&lt;</span> <span class="no">Module</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="k">if</span> <span class="n">block</span>
  <span class="n">modules</span><span class="p">.</span><span class="nf">flatten!</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">extending_values</span> <span class="o">+=</span> <span class="n">modules</span>
  <span class="kp">extend</span><span class="p">(</span><span class="o">*</span><span class="n">extending_values</span><span class="p">)</span> <span class="k">if</span> <span class="n">extending_values</span><span class="p">.</span><span class="nf">any?</span>
  <span class="nb">self</span>
<span class="k">end</span>
</code></pre></div></div>

<p>而 <code class="highlighter-rouge">extending</code> 方法的实现确实与我们预期的一样，创建了新的 <code class="highlighter-rouge">Module</code> 对象之后，直接使用 <code class="highlighter-rouge">#extend</code> 将其中的方法挂载当前对象的单类上。</p>

<h3 id="小结-1">小结</h3>

<p>到这里为止，我们对 ActiveRecord 中查询的分析就已经比较全面了，从最终要的 <code class="highlighter-rouge">Relation</code> 对象，到常见的 <code class="highlighter-rouge">#all</code>、<code class="highlighter-rouge">#where</code> 和 <code class="highlighter-rouge">#order</code> 方法，到 ActiveRecord 对语法树的存储，如何与 Arel 进行协作，在最后我们也介绍了 <code class="highlighter-rouge">.scope</code> 方法的工作原理，对于其它方法或者功能的实现其实也都大同小异，在这里就不展开细谈了。</p>

<h2 id="模型的关系">模型的关系</h2>

<p>作为一个关系型数据库的 ORM，ActiveRecord 一定要提供对模型之间关系的支持，它为模型之间的关系建立提供了四个类方法 <code class="highlighter-rouge">has_many</code>、<code class="highlighter-rouge">has_one</code>、<code class="highlighter-rouge">belongs_to</code> 和 <code class="highlighter-rouge">has_and_belongs_to_many</code>，在文章的这一部分，我们会从上面几个方法中选择一部分介绍 ActiveRecord 是如何建立模型之间的关系的。</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-associations.png" alt="activerecord-associations" /></p>

<h3 id="association-和继承链">Association 和继承链</h3>

<p>首先来看 <code class="highlighter-rouge">.has_many</code> 方法是如何实现的，我们可以通过 pry 直接找到该方法的源代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="no">User</span><span class="p">.</span><span class="nf">has_many</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">associations</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">1401</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Associations</span><span class="o">::</span><span class="no">ClassMethods</span>

<span class="k">def</span> <span class="nf">has_many</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">scope</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{},</span> <span class="o">&amp;</span><span class="n">extension</span><span class="p">)</span>
  <span class="n">reflection</span> <span class="o">=</span> <span class="no">Builder</span><span class="o">::</span><span class="no">HasMany</span><span class="p">.</span><span class="nf">build</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extension</span><span class="p">)</span>
  <span class="no">Reflection</span><span class="p">.</span><span class="nf">add_reflection</span> <span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">reflection</span>
<span class="k">end</span>
</code></pre></div></div>

<p>整个 <code class="highlighter-rouge">.has_many</code> 方法的实现也只有两行代码，总共涉及两个类 <code class="highlighter-rouge">Builder::HasMany</code> 和 <code class="highlighter-rouge">Reflection</code>，其中前者用于创建新的 <code class="highlighter-rouge">HasMany</code> 关系，后者负责将关系添加到当前类中。</p>

<p><code class="highlighter-rouge">HasMany</code> 类的实现其实非常简单，但是它从父类和整个继承链中继承了很多方法：</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-hasmany-ancestors.png" alt="activerecord-hasmany-ancestors" /></p>

<p>我们暂时先忘记 <code class="highlighter-rouge">.has_many</code> 方法的实现，先来看一下这里涉及的两个非常重要的类都是如何工作的，首先是 <code class="highlighter-rouge">Association</code> 以及它的子类；在 ActiveRecord 的实现中，我们其实能够找到四种关系的 Builder，它们有着非常清晰简单的继承关系：</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-ancestor-builders.png" alt="activerecord-ancestor-builders" /></p>

<p>在这里定义的 <code class="highlighter-rouge">.build</code> 方法其实实现也很清晰，它通过调用当前抽象类 <code class="highlighter-rouge">Association</code> 或者子类的响应方法完成一些建立关系必要的工作：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">build</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">extension</span> <span class="o">=</span> <span class="n">define_extensions</span> <span class="n">model</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span>
  <span class="n">reflection</span> <span class="o">=</span> <span class="n">create_reflection</span> <span class="n">model</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">extension</span>
  <span class="n">define_accessors</span> <span class="n">model</span><span class="p">,</span> <span class="n">reflection</span>
  <span class="n">define_callbacks</span> <span class="n">model</span><span class="p">,</span> <span class="n">reflection</span>
  <span class="n">define_validations</span> <span class="n">model</span><span class="p">,</span> <span class="n">reflection</span>
  <span class="n">reflection</span>
<span class="k">end</span>
</code></pre></div></div>

<p>其中包括创建用于操作、查询和管理当前关系扩展 Module 的 <code class="highlighter-rouge">.define_extensions</code> 方法，同时也会使用 <code class="highlighter-rouge">.create_reflection</code> 创建一个用于检查 ActiveRecord 类的关系的 <code class="highlighter-rouge">Reflection</code> 对象，我们会在下一节中展开介绍，在创建了 <code class="highlighter-rouge">Reflection</code> 后，我们会根据传入的模型和 <code class="highlighter-rouge">Reflection</code> 对象为当前的类，例如 <code class="highlighter-rouge">User</code> 定义属性存取方法、回调以及验证:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_accessors</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">reflection</span><span class="p">)</span>
  <span class="n">mixin</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="nf">generated_association_methods</span>
  <span class="nb">name</span> <span class="o">=</span> <span class="n">reflection</span><span class="p">.</span><span class="nf">name</span>
  <span class="n">define_readers</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
  <span class="n">define_writers</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_readers</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
  <span class="n">mixin</span><span class="p">.</span><span class="nf">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
    def </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">(*args)
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).reader(*args)
    end
</span><span class="no">  CODE</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_writers</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
  <span class="n">mixin</span><span class="p">.</span><span class="nf">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
    def </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">=(value)
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).writer(value)
    end
</span><span class="no">  CODE</span>
<span class="k">end</span>
</code></pre></div></div>

<p>存取方法还是通过 Ruby 的元编程能力定义的，在这里通过 <code class="highlighter-rouge">.class_eval</code> 方法非常轻松地就能在当前的模型中定义方法，关于回调和验证的定义在这里就不在展开介绍了。</p>

<h3 id="reflection-和继承链">Reflection 和继承链</h3>

<p><code class="highlighter-rouge">Reflection</code> 启用了检查 ActiveRecord 类和对象的关系和聚合的功能，它能够在 Builder 中使用为 ActiveRecord 中的类创建对应属性和方法。</p>

<p>与 <code class="highlighter-rouge">Association</code> 一样，ActiveRecord 中的不同关系也有不同的 <code class="highlighter-rouge">Reflection</code>，根据不同的关系和不同的配置，ActiveRecord 中建立了一套 Reflection 的继承体系与数据库中的不同关系一一对应：</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-reflections.png" alt="activerecord-reflections" /></p>

<p>当我们在上面使用 <code class="highlighter-rouge">.has_many</code> 方法时，会通过 <code class="highlighter-rouge">.create_reflection</code> 创建一个 <code class="highlighter-rouge">HasManyReflection</code> 对象：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">create_reflection</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">extension</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">scope</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Hash</span><span class="p">)</span>
    <span class="n">options</span> <span class="o">=</span> <span class="n">scope</span>
    <span class="n">scope</span>   <span class="o">=</span> <span class="kp">nil</span>
  <span class="k">end</span>

  <span class="n">validate_options</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
  <span class="n">scope</span> <span class="o">=</span> <span class="n">build_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="n">extension</span><span class="p">)</span>
  <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Reflection</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="n">macro</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Reflection#create</code> 方法是一个工厂方法，它会根据传入的 <code class="highlighter-rouge">macro</code> 和 <code class="highlighter-rouge">options</code> 中的值选择合适的类实例化：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">create</span><span class="p">(</span><span class="n">macro</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">ar</span><span class="p">)</span>
  <span class="n">klass</span> <span class="o">=</span> <span class="p">\</span>
    <span class="k">case</span> <span class="n">macro</span>
    <span class="k">when</span> <span class="ss">:composed_of</span>
      <span class="no">AggregateReflection</span>
    <span class="k">when</span> <span class="ss">:has_many</span>
      <span class="no">HasManyReflection</span>
    <span class="k">when</span> <span class="ss">:has_one</span>
      <span class="no">HasOneReflection</span>
    <span class="k">when</span> <span class="ss">:belongs_to</span>
      <span class="no">BelongsToReflection</span>
    <span class="k">else</span>
      <span class="k">raise</span> <span class="s2">"Unsupported Macro: </span><span class="si">#{</span><span class="n">macro</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>

  <span class="n">reflection</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">ar</span><span class="p">)</span>
  <span class="n">options</span><span class="p">[</span><span class="ss">:through</span><span class="p">]</span> <span class="p">?</span> <span class="no">ThroughReflection</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">reflection</span><span class="p">)</span> <span class="p">:</span> <span class="n">reflection</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这个创建的 <code class="highlighter-rouge">Reflection</code> 在很多时候都有非常重要的作用，在创建存储方法、回调和验证时，都需要将这个对象作为参数传入提供一定的支持，起到了数据源和提供 Helper 方法的作用。</p>

<p>在整个定义方法、属性以及回调的工作完成之后，会将当前的对象以 <code class="highlighter-rouge">name</code> 作为键存储到自己持有的一个 <code class="highlighter-rouge">_reflections</code> 字典中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class_attribute :_reflections, instance_writer: false</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">add_reflection</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">reflection</span><span class="p">)</span>
  <span class="n">ar</span><span class="p">.</span><span class="nf">clear_reflections_cache</span>
  <span class="n">ar</span><span class="p">.</span><span class="nf">_reflections</span> <span class="o">=</span> <span class="n">ar</span><span class="p">.</span><span class="nf">_reflections</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span> <span class="o">=&gt;</span> <span class="n">reflection</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这个字典中存储着所有在当前类中使用 <code class="highlighter-rouge">has_many</code>、<code class="highlighter-rouge">has_one</code>、<code class="highlighter-rouge">belongs_to</code> 等方法定义的关系对应的映射。</p>

<h3 id="一对多关系">一对多关系</h3>

<p>一对多关系的这一节会分别介绍两个极其重要的方法 <code class="highlighter-rouge">.has_many</code> 和 <code class="highlighter-rouge">.belongs_to</code> 的实现；在这里，会先通过 <code class="highlighter-rouge">.has_many</code> 关系了解它是如何通过覆写父类方法定制自己的特性的，之后会通过 <code class="highlighter-rouge">.belongs_to</code> 研究 getter/setter 方法的调用栈。</p>

<p><img src="https://img.draveness.me/2017-10-21-one-to-many-association.png" alt="one-to-many-association" /></p>

<p>一对多关系在数据库的模型之间非常常见，而这两个方法在 ActiveRecord 也经常成对出现。</p>

<h4 id="has_many">has_many</h4>

<p>当我们对构建关系模块的两大支柱都已经有所了解之后，再来看这几个常用的方法就没有太多的难度了，首先来看一下一对多关系中的『多』是怎么实现的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">has_many</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">scope</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{},</span> <span class="o">&amp;</span><span class="n">extension</span><span class="p">)</span>
  <span class="n">reflection</span> <span class="o">=</span> <span class="no">Builder</span><span class="o">::</span><span class="no">HasMany</span><span class="p">.</span><span class="nf">build</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extension</span><span class="p">)</span>
  <span class="no">Reflection</span><span class="p">.</span><span class="nf">add_reflection</span> <span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">reflection</span>
<span class="k">end</span>
</code></pre></div></div>

<p>由于已经对 <code class="highlighter-rouge">Reflection.add_reflection</code> 方法的实现有所了解，所以这里直接看 <code class="highlighter-rouge">.has_many</code> 调用的 <code class="highlighter-rouge">Builder::HasMany.build</code> 方法的实现就可以知道这个类方法究竟做了什么，：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">build</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">extension</span> <span class="o">=</span> <span class="n">define_extensions</span> <span class="n">model</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span>
  <span class="n">reflection</span> <span class="o">=</span> <span class="n">create_reflection</span> <span class="n">model</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">extension</span>
  <span class="n">define_accessors</span> <span class="n">model</span><span class="p">,</span> <span class="n">reflection</span>
  <span class="n">define_callbacks</span> <span class="n">model</span><span class="p">,</span> <span class="n">reflection</span>
  <span class="n">define_validations</span> <span class="n">model</span><span class="p">,</span> <span class="n">reflection</span>
  <span class="n">reflection</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这里执行的 <code class="highlighter-rouge">.build</code> 方法与抽象类中的方法实现完全相同，子类并没有覆盖父类实现的方法，我们来找一下 <code class="highlighter-rouge">.define_accessors</code>、<code class="highlighter-rouge">.define_callbacks</code> 和 <code class="highlighter-rouge">.define_validations</code> 三个方法在 has_many 关系中都做了什么。</p>

<p><code class="highlighter-rouge">HasMany</code> 作为 has_many 关系的 Builder 类，其本身并没有实现太多的方法，只是对一些关系选项有一些自己独有的声明：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">ActiveRecord::Associations::Builder</span>
  <span class="k">class</span> <span class="nc">HasMany</span> <span class="o">&lt;</span> <span class="no">CollectionAssociation</span>
    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">macro</span>
      <span class="ss">:has_many</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">valid_options</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
      <span class="k">super</span> <span class="o">+</span> <span class="p">[</span><span class="ss">:primary_key</span><span class="p">,</span> <span class="ss">:dependent</span><span class="p">,</span> <span class="ss">:as</span><span class="p">,</span> <span class="ss">:through</span><span class="p">,</span> <span class="ss">:source</span><span class="p">,</span> <span class="ss">:source_type</span><span class="p">,</span> <span class="ss">:inverse_of</span><span class="p">,</span> <span class="ss">:counter_cache</span><span class="p">,</span> <span class="ss">:join_table</span><span class="p">,</span> <span class="ss">:foreign_type</span><span class="p">,</span> <span class="ss">:index_errors</span><span class="p">]</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">valid_dependent_options</span>
      <span class="p">[</span><span class="ss">:destroy</span><span class="p">,</span> <span class="ss">:delete_all</span><span class="p">,</span> <span class="ss">:nullify</span><span class="p">,</span> <span class="ss">:restrict_with_error</span><span class="p">,</span> <span class="ss">:restrict_with_exception</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>由于本身 has_many 关系中的读写方法都是对集合的操作，所以首先覆写了 <code class="highlighter-rouge">.define_writers</code> 和 <code class="highlighter-rouge">.define_readers</code> 两个方法生成了另外一组操作 id 的 getter/setter 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_readers</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
  <span class="k">super</span>

  <span class="n">mixin</span><span class="p">.</span><span class="nf">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
    def </span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">singularize</span><span class="si">}</span><span class="sh">_ids
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).ids_reader
    end
</span><span class="no">  CODE</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_writers</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
  <span class="k">super</span>

  <span class="n">mixin</span><span class="p">.</span><span class="nf">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
    def </span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">singularize</span><span class="si">}</span><span class="sh">_ids=(ids)
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).ids_writer(ids)
    end
</span><span class="no">  CODE</span>
<span class="k">end</span>
</code></pre></div></div>

<p>has_many 关系在 <code class="highlighter-rouge">CollectionAssociation</code> 和 <code class="highlighter-rouge">HasManyAssociation</code> 中实现的几个方法 <code class="highlighter-rouge">#reader</code>、<code class="highlighter-rouge">#writer</code>、<code class="highlighter-rouge">#ids_reader</code> 和 <code class="highlighter-rouge">#ids_writer</code> 其实还是比较复杂的，在这里就跳过不谈了。</p>

<p>而 <code class="highlighter-rouge">.define_callbacks</code> 和 <code class="highlighter-rouge">.define_extensions</code> 其实都大同小异，在作者看来没有什么值得讲的，has_many 中最重要的部分还是读写方法的实现过程，不过由于篇幅所限这里就不多说了。</p>

<h4 id="belongs_to">belongs_to</h4>

<p>在一对多关系中，经常与 has_many 对应的关系 belongs_to 其实实现和调用栈也几乎完全相同：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">belongs_to</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">scope</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="n">reflection</span> <span class="o">=</span> <span class="no">Builder</span><span class="o">::</span><span class="no">BelongsTo</span><span class="p">.</span><span class="nf">build</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
  <span class="no">Reflection</span><span class="p">.</span><span class="nf">add_reflection</span> <span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">reflection</span>
<span class="k">end</span>
</code></pre></div></div>

<p>但是与 has_many 比较大的不同是 <code class="highlighter-rouge">Builder::BelongsTo</code> 通过继承的父类定义了很多用于创建新关系的方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_accessors</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">reflection</span><span class="p">)</span>
  <span class="k">super</span>
  <span class="n">mixin</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="nf">generated_association_methods</span>
  <span class="nb">name</span> <span class="o">=</span> <span class="n">reflection</span><span class="p">.</span><span class="nf">name</span>
  <span class="n">define_constructors</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span> <span class="k">if</span> <span class="n">reflection</span><span class="p">.</span><span class="nf">constructable?</span>
  <span class="n">mixin</span><span class="p">.</span><span class="nf">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
    def reload_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).force_reload_reader
    end
</span><span class="no">  CODE</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_constructors</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
  <span class="n">mixin</span><span class="p">.</span><span class="nf">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
    def build_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">(*args, &amp;block)
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).build(*args, &amp;block)
    end
    def create_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">(*args, &amp;block)
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).create(*args, &amp;block)
    end
    def create_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">!(*args, &amp;block)
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).create!(*args, &amp;block)
    end
</span><span class="no">  CODE</span>
<span class="k">end</span>
</code></pre></div></div>

<p>其他的部分虽然实现上也与 has_many 有着非常大的不同，但是原理基本上完全一致，不过在这里我们可以来看一下 belongs_to 关系创建的两个方法 <code class="highlighter-rouge">association</code> 和 <code class="highlighter-rouge">association=</code> 究竟是如何对数据库进行操作的。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Topic</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:subtopics</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Subtopic</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:topic</span>
<span class="k">end</span>
</code></pre></div></div>

<p>假设我们有着如上所示的两个模型，它们之间是一对多关系，我们以这对模型为例先来看一下 <code class="highlighter-rouge">association</code> 这个读方法的调用栈。</p>

<p><img src="https://img.draveness.me/2017-10-21-callstack-for-belongs-to-association-getter.png" alt="callstack-for-belongs-to-association-gette" /></p>

<p>通过我们对源代码和调用栈的阅读，我们可以发现其实如下的所有方法调用在大多数情况下是完全等价的，假设我们已经持有了一个 <code class="highlighter-rouge">Subtopic</code> 对象：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">subtopic</span> <span class="o">=</span> <span class="no">Subtopic</span><span class="p">.</span><span class="nf">first</span> <span class="c1">#=&gt; #&lt;Subtopic:0x007ff513f67768&gt;</span>

<span class="n">subtopic</span><span class="p">.</span><span class="nf">topic</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">reader</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">target</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">load_target</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">send</span><span class="p">(</span><span class="ss">:find_target</span><span class="p">)</span>
</code></pre></div></div>

<p>上述的五种方式都可以获得当前 <code class="highlighter-rouge">Subtopic</code> 对象的 belongs_to 关系对应的 <code class="highlighter-rouge">Topic</code> 数据行，而最后一个方法 <code class="highlighter-rouge">#find_target</code> 其实也就是真正创建、绑定到最后执行查询 SQL 的方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">find_target</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">associations</span><span class="o">/</span><span class="n">singular_association</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">38</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Associations</span><span class="o">::</span><span class="no">SingularAssociation</span>

<span class="k">def</span> <span class="nf">find_target</span>
  <span class="k">return</span> <span class="n">scope</span><span class="p">.</span><span class="nf">take</span> <span class="k">if</span> <span class="n">skip_statement_cache?</span>

  <span class="n">conn</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">connection</span>
  <span class="n">sc</span> <span class="o">=</span> <span class="n">reflection</span><span class="p">.</span><span class="nf">association_scope_cache</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">owner</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">StatementCache</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">params</span><span class="o">|</span>
      <span class="n">as</span> <span class="o">=</span> <span class="no">AssociationScope</span><span class="p">.</span><span class="nf">create</span> <span class="p">{</span> <span class="n">params</span><span class="p">.</span><span class="nf">bind</span> <span class="p">}</span>
      <span class="n">target_scope</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">as</span><span class="p">.</span><span class="nf">scope</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">conn</span><span class="p">)).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="k">end</span>

  <span class="n">binds</span> <span class="o">=</span> <span class="no">AssociationScope</span><span class="p">.</span><span class="nf">get_bind_values</span><span class="p">(</span><span class="n">owner</span><span class="p">,</span> <span class="n">reflection</span><span class="p">.</span><span class="nf">chain</span><span class="p">)</span>
  <span class="n">sc</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">binds</span><span class="p">,</span> <span class="n">klass</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">record</span><span class="o">|</span>
    <span class="n">set_inverse_instance</span> <span class="n">record</span>
  <span class="k">end</span><span class="p">.</span><span class="nf">first</span>
<span class="k">rescue</span> <span class="o">::</span><span class="no">RangeError</span>
  <span class="kp">nil</span>
<span class="k">end</span>
</code></pre></div></div>

<p>我们已经对 <code class="highlighter-rouge">association</code> 方法的实现有了非常清楚的认知了，下面再来过一下 <code class="highlighter-rouge">association=</code> 方法的实现，首先还是来看一下 setter 方法的调用栈：</p>

<p><img src="https://img.draveness.me/2017-10-21-callstack-for-belongs-to-association-setter.png" alt="callstack-for-belongs-to-association-sette" /></p>

<p>相比于 getter 的调用栈，setter 方法的调用栈都复杂了很多，在研究 setter 方法实现的过程中我们一定要记住这个方法并不会改变数据库中对应的数据行，只会改变当前对应的某个属性，经过对调用栈和源代码的分析，我们可以有以下的结论：假设现在有一个 <code class="highlighter-rouge">Subtopic</code> 对象和一个新的 <code class="highlighter-rouge">Topic</code> 实例，那么下面的一系列操作其实是完全相同的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">subtopic</span> <span class="o">=</span> <span class="no">Subtopic</span><span class="p">.</span><span class="nf">first</span> <span class="c1">#=&gt; #&lt;Subtopic:0x007ff513f67768&gt;</span>
<span class="n">new_topic</span> <span class="o">=</span> <span class="no">Topic</span><span class="p">.</span><span class="nf">first</span>   <span class="c1">#=&gt; #&lt;Topic:0x007ff514b24cb8&gt;</span>

<span class="n">subtopic</span><span class="p">.</span><span class="nf">topic</span> <span class="o">=</span> <span class="n">new_topic</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">topic_id</span> <span class="o">=</span> <span class="n">new_topic</span><span class="p">.</span><span class="nf">id</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">writer</span><span class="p">(</span><span class="n">new_topic</span><span class="p">)</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">replace</span><span class="p">(</span><span class="n">new_topic</span><span class="p">)</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">replace_keys</span><span class="p">(</span><span class="n">new_topic</span><span class="p">)</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">owner</span><span class="p">[</span><span class="ss">:topic_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_topic</span><span class="p">.</span><span class="nf">id</span>
<span class="n">subtopic</span><span class="p">[</span><span class="ss">:topic_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_topic</span><span class="p">.</span><span class="nf">id</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">write_attribute</span><span class="p">(</span><span class="ss">:topic_id</span><span class="p">,</span> <span class="n">new_topic</span><span class="p">.</span><span class="nf">id</span><span class="p">)</span>
</code></pre></div></div>

<p>虽然这些方法最后返回的结果可能有所不同，但是它们最终都会将 <code class="highlighter-rouge">subtopic</code> 对象的 <code class="highlighter-rouge">topic_id</code> 属性更新成 <code class="highlighter-rouge">topic.id</code>，上面的方法中有简单的，也有复杂的，不过都能达到相同的目的；我相信如果读者亲手创建上述的关系并使用 pry 查看源代码一定会对 getter 和 setter 的执行过程有着非常清楚的认识。</p>

<h3 id="多对多关系-habtm">多对多关系 habtm</h3>

<p>无论是 has_many 还是 belongs_to 其实都是一个 ORM 原生需要支持的关系，但是 habtm(has_and_belongs_to_many) 却是 ActiveRecord 为我们提供的一个非常方便的语法糖，哪怕是并没有 <code class="highlighter-rouge">.has_and_belongs_to_many</code> 这个方法，我们也能通过 <code class="highlighter-rouge">.has_many</code> 实现多对多关系，得到与前者完全等价的效果，只是实现的过程稍微麻烦一些。</p>

<p>在这一小节中，我们想要了解 habtm 这个语法糖是如何工作的，它是如何将现有的关系组成更复杂的 habtm 的多对多关系的；想要了解它的工作原理，我们自然要分析它的源代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">has_and_belongs_to_many</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">scope</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extension</span><span class="p">)</span>
  <span class="n">builder</span> <span class="o">=</span> <span class="no">Builder</span><span class="o">::</span><span class="no">HasAndBelongsToMany</span><span class="p">.</span><span class="nf">new</span> <span class="nb">name</span><span class="p">,</span> <span class="nb">self</span><span class="p">,</span> <span class="n">options</span>
  <span class="n">join_model</span> <span class="o">=</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Deprecation</span><span class="p">.</span><span class="nf">silence</span> <span class="p">{</span> <span class="n">builder</span><span class="p">.</span><span class="nf">through_model</span> <span class="p">}</span>
  <span class="nb">const_set</span> <span class="n">join_model</span><span class="p">.</span><span class="nf">name</span><span class="p">,</span> <span class="n">join_model</span>
  <span class="n">private_constant</span> <span class="n">join_model</span><span class="p">.</span><span class="nf">name</span>

  <span class="n">habtm_reflection</span> <span class="o">=</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Reflection</span><span class="o">::</span><span class="no">HasAndBelongsToManyReflection</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="nb">self</span><span class="p">)</span>
  <span class="n">middle_reflection</span> <span class="o">=</span> <span class="n">builder</span><span class="p">.</span><span class="nf">middle_reflection</span> <span class="n">join_model</span>
  <span class="no">Builder</span><span class="o">::</span><span class="no">HasMany</span><span class="p">.</span><span class="nf">define_callbacks</span> <span class="nb">self</span><span class="p">,</span> <span class="n">middle_reflection</span>
  <span class="no">Reflection</span><span class="p">.</span><span class="nf">add_reflection</span> <span class="nb">self</span><span class="p">,</span> <span class="n">middle_reflection</span><span class="p">.</span><span class="nf">name</span><span class="p">,</span> <span class="n">middle_reflection</span>
  <span class="n">middle_reflection</span><span class="p">.</span><span class="nf">parent_reflection</span> <span class="o">=</span> <span class="n">habtm_reflection</span>

  <span class="c1"># ...</span>

  <span class="n">hm_options</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="n">hm_options</span><span class="p">[</span><span class="ss">:through</span><span class="p">]</span> <span class="o">=</span> <span class="n">middle_reflection</span><span class="p">.</span><span class="nf">name</span>
  <span class="n">hm_options</span><span class="p">[</span><span class="ss">:source</span><span class="p">]</span> <span class="o">=</span> <span class="n">join_model</span><span class="p">.</span><span class="nf">right_reflection</span><span class="p">.</span><span class="nf">name</span>

  <span class="c1"># ...</span>

  <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Deprecation</span><span class="p">.</span><span class="nf">silence</span> <span class="p">{</span> <span class="n">has_many</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">hm_options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extension</span> <span class="p">}</span>
  <span class="n">_reflections</span><span class="p">[</span><span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">].</span><span class="nf">parent_reflection</span> <span class="o">=</span> <span class="n">habtm_reflection</span>
<span class="k">end</span>
</code></pre></div></div>

<blockquote>
  <p>在这里，我们对该方法的源代码重新进行组织和排序，方法的作用与 v5.1.4 中的完全相同。</p>
</blockquote>

<p>上述方法在最开始先创建了一个 <code class="highlighter-rouge">HasAndBelongsToMany</code> 的 Builder 实例，然后在 block 中执行了这个 Builder 的 <code class="highlighter-rouge">#through_model</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">through_model</span>
  <span class="n">habtm</span> <span class="o">=</span> <span class="no">JoinTableResolver</span><span class="p">.</span><span class="nf">build</span> <span class="n">lhs_model</span><span class="p">,</span> <span class="n">association_name</span><span class="p">,</span> <span class="n">options</span>

  <span class="n">join_model</span> <span class="o">=</span> <span class="no">Class</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span><span class="p">;</span>
      <span class="nb">attr_accessor</span> <span class="ss">:left_model</span>
      <span class="nb">attr_accessor</span> <span class="ss">:name</span>
      <span class="nb">attr_accessor</span> <span class="ss">:table_name_resolver</span>
      <span class="nb">attr_accessor</span> <span class="ss">:left_reflection</span>
      <span class="nb">attr_accessor</span> <span class="ss">:right_reflection</span>
    <span class="k">end</span>

    <span class="c1"># ...</span>
  <span class="p">}</span>

  <span class="n">join_model</span><span class="p">.</span><span class="nf">name</span>                <span class="o">=</span> <span class="s2">"HABTM_</span><span class="si">#{</span><span class="n">association_name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">camelize</span><span class="si">}</span><span class="s2">"</span>
  <span class="n">join_model</span><span class="p">.</span><span class="nf">table_name_resolver</span> <span class="o">=</span> <span class="n">habtm</span>
  <span class="n">join_model</span><span class="p">.</span><span class="nf">left_model</span>          <span class="o">=</span> <span class="n">lhs_model</span>
  <span class="n">join_model</span><span class="p">.</span><span class="nf">add_left_association</span> <span class="ss">:left_side</span><span class="p">,</span> <span class="ss">anonymous_class: </span><span class="n">lhs_model</span>
  <span class="n">join_model</span><span class="p">.</span><span class="nf">add_right_association</span> <span class="n">association_name</span><span class="p">,</span> <span class="n">belongs_to_options</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
  <span class="n">join_model</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">#through_model</code> 方法会返回一个新的继承自 <code class="highlighter-rouge">ActiveRecord::Base</code> 的类，我们通过一下的例子来说明一下这里究竟做了什么，假设在我们的工程中定义了如下的两个类：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:tags</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Tag</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:posts</span>
<span class="k">end</span>
</code></pre></div></div>

<p>它们每个类都通过 <code class="highlighter-rouge">.has_and_belongs_to_many</code> 创建了一个 <code class="highlighter-rouge">join_model</code> 类，这两个类都是在当前类的命名空间下的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Post</span><span class="o">::</span><span class="no">HABTM_Posts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">;</span> <span class="k">end</span>
<span class="k">class</span> <span class="nc">Tags</span><span class="o">::</span><span class="no">HABTM_Posts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">;</span> <span class="k">end</span>
</code></pre></div></div>

<p>除了在当前类的命名空间下定义两个新的类之外，<code class="highlighter-rouge">#through_model</code> 方法还通过 <code class="highlighter-rouge">#add_left_association</code> 和 <code class="highlighter-rouge">#add_right_association</code> 为创建的私有类添加了两个 <code class="highlighter-rouge">.belongs_to</code> 方法的调用：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">join_model</span> <span class="o">=</span> <span class="no">Class</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1"># ...</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">add_left_association</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="n">belongs_to</span> <span class="nb">name</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">left_reflection</span> <span class="o">=</span> <span class="n">_reflect_on_association</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">add_right_association</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="n">rhs_name</span> <span class="o">=</span> <span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">singularize</span><span class="p">.</span><span class="nf">to_sym</span>
    <span class="n">belongs_to</span> <span class="n">rhs_name</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">right_reflection</span> <span class="o">=</span> <span class="n">_reflect_on_association</span><span class="p">(</span><span class="n">rhs_name</span><span class="p">)</span>
  <span class="k">end</span>
<span class="p">}</span>
</code></pre></div></div>

<p>所以在这里，每一个 HABTM 类中都通过 <code class="highlighter-rouge">.belongs_to</code> 增加了两个对数据库表中对应列的映射：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Post</span><span class="o">::</span><span class="no">HABTM_Posts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:post_id</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span>
  <span class="n">belongs_to</span> <span class="ss">:tag_id</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Tags</span><span class="o">::</span><span class="no">HABTM_Posts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:tag_id</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span>
  <span class="n">belongs_to</span> <span class="ss">:post_id</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span>
<span class="k">end</span>
</code></pre></div></div>

<p>看到这里，你可能会认为既然有两个模型，那么应该会有两张表分别对应这两个模型，但是实际情况却不是这样。</p>

<p><img src="https://img.draveness.me/2017-10-21-habtm-association-table-name.png" alt="habtm-association-table-name" /></p>

<p>ActiveRecord 通过覆写这两个类的 <code class="highlighter-rouge">.table_name</code> 方法，使用一个 <code class="highlighter-rouge">JoinTableResolver</code> 来解决不同的模型拥有相同的数据库表的问题：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Migration</span>
  <span class="k">module</span> <span class="nn">JoinTable</span>
    <span class="k">def</span> <span class="nf">join_table_name</span><span class="p">(</span><span class="n">table_1</span><span class="p">,</span> <span class="n">table_2</span><span class="p">)</span>
      <span class="no">ModelSchema</span><span class="p">.</span><span class="nf">derive_join_table_name</span><span class="p">(</span><span class="n">table_1</span><span class="p">,</span> <span class="n">table_2</span><span class="p">).</span><span class="nf">to_sym</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">ModelSchema</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">derive_join_table_name</span><span class="p">(</span><span class="n">first_table</span><span class="p">,</span> <span class="n">second_table</span><span class="p">)</span> 
    <span class="p">[</span><span class="n">first_table</span><span class="p">.</span><span class="nf">to_s</span><span class="p">,</span> <span class="n">second_table</span><span class="p">.</span><span class="nf">to_s</span><span class="p">].</span><span class="nf">sort</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s2">"</span><span class="se">\0</span><span class="s2">"</span><span class="p">).</span><span class="nf">gsub</span><span class="p">(</span><span class="sr">/^(.*_)(.+)\0\1(.+)/</span><span class="p">,</span> <span class="s1">'\1\2_\3'</span><span class="p">).</span><span class="nf">tr</span><span class="p">(</span><span class="s2">"</span><span class="se">\0</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"_"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在默认的 <code class="highlighter-rouge">join_table</code> 规则中，两张表会按照字母顺序排序，最后通过 <code class="highlighter-rouge">_</code> 连接到一起，但是如果两张表有着完全相同的前缀，比如 music_artists 和 music_records 两张表，它们连接的结果就是 music_artists_records，公共的前缀会被删除，这种情况经常发生在包含命名空间的模型中，例如：<code class="highlighter-rouge">Music::Artist</code>。</p>

<p>当我们已经通过多对多关系的 Builder 创建了一个中间模型之后，就会建立两个 <code class="highlighter-rouge">Reflection</code> 对象：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">habtm_reflection</span> <span class="o">=</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Reflection</span><span class="o">::</span><span class="no">HasAndBelongsToManyReflection</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="nb">self</span><span class="p">)</span>
<span class="n">middle_reflection</span> <span class="o">=</span> <span class="n">builder</span><span class="p">.</span><span class="nf">middle_reflection</span> <span class="n">join_model</span>
<span class="no">Builder</span><span class="o">::</span><span class="no">HasMany</span><span class="p">.</span><span class="nf">define_callbacks</span> <span class="nb">self</span><span class="p">,</span> <span class="n">middle_reflection</span>
<span class="no">Reflection</span><span class="p">.</span><span class="nf">add_reflection</span> <span class="nb">self</span><span class="p">,</span> <span class="n">middle_reflection</span><span class="p">.</span><span class="nf">name</span><span class="p">,</span> <span class="n">middle_reflection</span>
<span class="n">middle_reflection</span><span class="p">.</span><span class="nf">parent_reflection</span> <span class="o">=</span> <span class="n">habtm_reflection</span>
</code></pre></div></div>

<p>其中一个对象是 <code class="highlighter-rouge">HasAndBelongsToManyReflection</code> 实例，表示当前的多对多关系，另一个对象是 <code class="highlighter-rouge">#middle_reflection</code> 方法返回的 <code class="highlighter-rouge">HasMany</code>，表示当前的类与 <code class="highlighter-rouge">join_model</code> 之间有一个一对多关系，这个关系是隐式的，不过我们可以通过下面的代码来『理解』它：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># has_and_belongs_to_many :posts</span>
  <span class="c1"># =</span>
  <span class="n">has_many</span> <span class="ss">:posts_tag</span>
  <span class="c1"># + </span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述的代码构成了整个多对多关系的一部分，而另一部分由下面的代码来处理，当模型持有了一个跟中间模型相关的一对多关系之后，就会创建另一个以中间模型为桥梁 has_many 关系：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hm_options</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">hm_options</span><span class="p">[</span><span class="ss">:through</span><span class="p">]</span> <span class="o">=</span> <span class="n">middle_reflection</span><span class="p">.</span><span class="nf">name</span>
<span class="n">hm_options</span><span class="p">[</span><span class="ss">:source</span><span class="p">]</span> <span class="o">=</span> <span class="n">join_model</span><span class="p">.</span><span class="nf">right_reflection</span><span class="p">.</span><span class="nf">name</span>

<span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Deprecation</span><span class="p">.</span><span class="nf">silence</span> <span class="p">{</span> <span class="n">has_many</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">hm_options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extension</span> <span class="p">}</span>
</code></pre></div></div>

<p>这里还是使用 <code class="highlighter-rouge">Post</code> 和 <code class="highlighter-rouge">Tag</code> 这两个模型之间的关系举例子，通过上述代码，我们会在两个类中分别建立如下的关系：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># has_many :posts_tag</span>
  <span class="n">has_many</span> <span class="ss">:tags</span><span class="p">,</span> <span class="ss">through: :posts_tag</span><span class="p">,</span> <span class="ss">source: :tag</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Tag</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># has_many :tags_post</span>
  <span class="n">has_many</span> <span class="ss">:post</span><span class="p">,</span> <span class="ss">through: :tags_post</span><span class="p">,</span> <span class="ss">source: :post</span>
<span class="k">end</span>
</code></pre></div></div>

<p>通过两个隐式的 has_many 关系，两个显示的 has_many 就能够通过 <code class="highlighter-rouge">through</code> 和 <code class="highlighter-rouge">source</code> 间接找到自己对应的多个数据行，而从开发者的角度来看，整个工程中只使用了一行代码 <code class="highlighter-rouge">has_and_belongs_to_many :models</code>，其他的工作完全都是隐式的。</p>

<p><img src="https://img.draveness.me/2017-10-21-many-to-many-associations.png" alt="many-to-many-associations" /></p>

<p>由于关系型数据库其实并没有物理上的多对多关系，只有在逻辑上才能实现多对多，所以对于每一个模型来说，它实现的都是一对多关系；只有从整体来看，通过 <code class="highlighter-rouge">PostsTags</code> 第三张表的引入，我们实现的才是从 <code class="highlighter-rouge">Post</code> 到 <code class="highlighter-rouge">Tag</code> 之间的多对多关系。</p>

<h3 id="小结-2">小结</h3>

<p>ActiveRecord 对关系的支持其实非常全面，从最常见的一对一、一对多关系，再到多对多关系，都有着非常优雅、简洁的实现，虽然这一小节中没能全面的介绍所有关系的实现，但是对整个模块中重要类和整体架构的介绍已经非常具体了；不得不感叹 ActiveRecord 对多对多关系方法 <code class="highlighter-rouge">has_and_belongs_to_many</code> 的实现非常整洁，我们在分析其实现时也非常顺畅。</p>

<h2 id="migrations-任务和执行过程">Migrations 任务和执行过程</h2>

<p>Migrations（迁移）是 ActiveRecord 提供的一种用于更改数据库 Schema 的方式，它提供了可以直接操作数据库的 DSL，这样我们就不需要自己去手写所有的 SQL 来更新数据库中的表结构了。</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-migrations.png" alt="activerecord-migrations" /></p>

<p>每一个 Migration 都具有一个唯一的时间戳，每次进行迁移时都会在现有的数据库中执行当前 Migration 文件的 DSL 更新数据库 Schema 得到新的数据库版本。而想要理解 Migrations 是如何工作的，就需要知道 <code class="highlighter-rouge">#create_table</code>、<code class="highlighter-rouge">#add_column</code> 等 DSL 是怎么实现的。</p>

<h3 id="migration51">Migration[5.1]</h3>

<p>我在使用 ActiveRecord 提供的数据库迁移的时候一直都特别好奇 <code class="highlighter-rouge">Migration[5.1]</code> 后面跟着的这个 <code class="highlighter-rouge">[5.1]</code> 是个什么工作原理，看了源代码之后我才知道：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Migration</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">[]</span><span class="p">(</span><span class="n">version</span><span class="p">)</span>
    <span class="no">Compatibility</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">version</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">.[]</code> 是 <code class="highlighter-rouge">ActiveRecord::Migration</code> 的类方法，它通过执行 <code class="highlighter-rouge">Compatibility.find</code> 来判断当前的代码中使用的数据库迁移版本是否与 gem 中的版本兼容：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Current</span> <span class="o">&lt;</span> <span class="no">Migration</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">compatibility.rb</code> 在兼容性方面做了很多事情，保证 ActiveRecord 中的迁移都是可以向前兼容的，在这里也就不准备介绍太多了。</p>

<h3 id="从-rake-dbmigrate-开始">从 rake db:migrate 开始</h3>

<p>作者在阅读迁移部分的源代码时最开始以 <code class="highlighter-rouge">Migration</code> 类作为入口，结果发现这并不是一个好的选择，最终也没能找到定义 DSL 的位置，所以重新选择了 <code class="highlighter-rouge">rake db:migrate</code> 作为入口分析迁移的实现；通过对工程目录的分析，很快就能发现 ActiveRecord 中所有的 rake 命令都位于 <code class="highlighter-rouge">lib/railties/database.rake</code> 文件中，在文件中也能找到 <code class="highlighter-rouge">db:migrate</code> 对应的 rake 任务：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">db_namespace</span> <span class="o">=</span> <span class="n">namespace</span> <span class="ss">:db</span> <span class="k">do</span>
  <span class="n">desc</span> <span class="s2">"Migrate the database (options: VERSION=x, VERBOSE=false, SCOPE=blog)."</span>
  <span class="n">task</span> <span class="ss">migrate: </span><span class="p">[</span><span class="ss">:environment</span><span class="p">,</span> <span class="ss">:load_config</span><span class="p">]</span> <span class="k">do</span>
    <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Tasks</span><span class="o">::</span><span class="no">DatabaseTasks</span><span class="p">.</span><span class="nf">migrate</span>
    <span class="n">db_namespace</span><span class="p">[</span><span class="s2">"_dump"</span><span class="p">].</span><span class="nf">invoke</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述代码中的 <code class="highlighter-rouge">DatabaseTasks</code> 类就包含在 <code class="highlighter-rouge">lib/active_record/tasks</code> 目录中的 <code class="highlighter-rouge">database_tasks.rb</code> 文件里：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">tasks</span><span class="o">/</span>
<span class="err">├──</span> <span class="n">database_tasks</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">├──</span> <span class="n">mysql_database_tasks</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">├──</span> <span class="n">postgresql_database_tasks</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">└──</span> <span class="n">sqlite_database_tasks</span><span class="p">.</span><span class="nf">rb</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">#migrate</code> 方法就是 <code class="highlighter-rouge">DatabaseTasks</code> 的一个实例方法，同时 ActiveRecord 通过 <code class="highlighter-rouge">extend self</code> 将 <code class="highlighter-rouge">#migrate</code> 方法添加到了当前类的单类上，成为了当前类的类方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Tasks</span>
  <span class="k">module</span> <span class="nn">DatabaseTasks</span>
    <span class="kp">extend</span> <span class="nb">self</span>
    
    <span class="k">def</span> <span class="nf">migrate</span>
      <span class="k">raise</span> <span class="s2">"Empty VERSION provided"</span> <span class="k">if</span> <span class="no">ENV</span><span class="p">[</span><span class="s2">"VERSION"</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="no">ENV</span><span class="p">[</span><span class="s2">"VERSION"</span><span class="p">].</span><span class="nf">empty?</span>

      <span class="n">version</span> <span class="o">=</span> <span class="no">ENV</span><span class="p">[</span><span class="s2">"VERSION"</span><span class="p">]</span> <span class="p">?</span> <span class="no">ENV</span><span class="p">[</span><span class="s2">"VERSION"</span><span class="p">].</span><span class="nf">to_i</span> <span class="p">:</span> <span class="kp">nil</span>
      <span class="n">scope</span> <span class="o">=</span> <span class="no">ENV</span><span class="p">[</span><span class="s2">"SCOPE"</span><span class="p">]</span>
      <span class="no">Migrator</span><span class="p">.</span><span class="nf">migrate</span><span class="p">(</span><span class="n">migrations_paths</span><span class="p">,</span> <span class="n">version</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">migration</span><span class="o">|</span>
        <span class="n">scope</span><span class="p">.</span><span class="nf">blank?</span> <span class="o">||</span> <span class="n">scope</span> <span class="o">==</span> <span class="n">migration</span><span class="p">.</span><span class="nf">scope</span>
      <span class="k">end</span>
      <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">clear_cache!</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="迁移器migrator">『迁移器』Migrator</h4>

<p>迁移任务中主要使用了 <code class="highlighter-rouge">Migrator.migrate</code> 方法，通过传入迁移文件的路径和期望的迁移版本对数据库进行迁移：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Migrator</span><span class="c1">#:nodoc:</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">migrate</span><span class="p">(</span><span class="n">migrations_paths</span><span class="p">,</span> <span class="n">target_version</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
      <span class="k">case</span>
      <span class="k">when</span> <span class="n">target_version</span><span class="p">.</span><span class="nf">nil?</span>
        <span class="n">up</span><span class="p">(</span><span class="n">migrations_paths</span><span class="p">,</span> <span class="n">target_version</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
      <span class="k">when</span> <span class="n">current_version</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">target_version</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">[]</span>
      <span class="k">when</span> <span class="n">current_version</span> <span class="o">&gt;</span> <span class="n">target_version</span>
        <span class="n">down</span><span class="p">(</span><span class="n">migrations_paths</span><span class="p">,</span> <span class="n">target_version</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
      <span class="k">else</span>
        <span class="n">up</span><span class="p">(</span><span class="n">migrations_paths</span><span class="p">,</span> <span class="n">target_version</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在默认情况下，显然我们是不会传入目标的数据库版本的，也就是 <code class="highlighter-rouge">target_version.nil? == true</code>，这时会执行 <code class="highlighter-rouge">.up</code> 方法，对数据库向『上』迁移：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">up</span><span class="p">(</span><span class="n">migrations_paths</span><span class="p">,</span> <span class="n">target_version</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="n">migrations</span> <span class="o">=</span> <span class="n">migrations</span><span class="p">(</span><span class="n">migrations_paths</span><span class="p">)</span>
  <span class="n">migrations</span><span class="p">.</span><span class="nf">select!</span> <span class="p">{</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="k">yield</span> <span class="n">m</span> <span class="p">}</span> <span class="k">if</span> <span class="nb">block_given?</span>

  <span class="n">new</span><span class="p">(</span><span class="ss">:up</span><span class="p">,</span> <span class="n">migrations</span><span class="p">,</span> <span class="n">target_version</span><span class="p">).</span><span class="nf">migrate</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="方法调用栈">方法调用栈</h4>

<p>通过 <code class="highlighter-rouge">.new</code> 方法 ActiveRecord 初始化了一个新的 <code class="highlighter-rouge">Migrator</code> 实例，然后执行了 <code class="highlighter-rouge">Migrator#migrate</code>，在整个迁移执行的过程中，我们有以下的方法调用栈：</p>

<p><img src="https://img.draveness.me/2017-10-21-rake-db-migrate.png" alt="rake-db-migrate" /></p>

<p>在整个迁移过程的调用栈中，我们会关注以下的四个部分，首先是 <code class="highlighter-rouge">Migrator#migrate_without_lock</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">migrate_without_lock</span>
  <span class="k">if</span> <span class="n">invalid_target?</span>
    <span class="k">raise</span> <span class="no">UnknownMigrationVersionError</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@target_version</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">runnable</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">migration</span><span class="o">|</span>
    <span class="n">execute_migration_in_transaction</span><span class="p">(</span><span class="n">migration</span><span class="p">,</span> <span class="vi">@direction</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">record_environment</span>
  <span class="n">result</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这个方法其实并没有那么重要，但是这里调用了 <code class="highlighter-rouge">Migrator#runnable</code> 方法，这个无参的方法返回了所有需要运行的 <code class="highlighter-rouge">Migration</code> 文件，<code class="highlighter-rouge">Migrator#runnable</code> 是如何选择需要迁移的文件是作者比较想要了解的，也是作者认为比较重要的地方：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">runnable</span>
  <span class="n">runnable</span> <span class="o">=</span> <span class="n">migrations</span><span class="p">[</span><span class="n">start</span><span class="o">..</span><span class="n">finish</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">up?</span>
    <span class="n">runnable</span><span class="p">.</span><span class="nf">reject</span> <span class="p">{</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">ran?</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">else</span>
    <span class="n">runnable</span><span class="p">.</span><span class="nf">pop</span> <span class="k">if</span> <span class="n">target</span>
    <span class="n">runnable</span><span class="p">.</span><span class="nf">find_all</span> <span class="p">{</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">ran?</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">ran?</span><span class="p">(</span><span class="n">migration</span><span class="p">)</span>
  <span class="n">migrated</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="n">migration</span><span class="p">.</span><span class="nf">version</span><span class="p">.</span><span class="nf">to_i</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>通过对这个方法的阅读的分析，我们可以看到，如果迁移模式是 <code class="highlighter-rouge">:up</code>，那么就会选择所有未迁移的文件，也就是说在这时<strong>迁移文件的选择与创建的顺序是无关的</strong>。</p>

<h4 id="迁移的执行">迁移的执行</h4>

<p>当我们通过 <code class="highlighter-rouge">#runnable</code> 获得了整个待运行的迁移文件数组之后，就可以遍历所有的文件一次执行 <code class="highlighter-rouge">Migrator#execute_migrate_in_transaction</code> 方法了，在调用栈的最后会执行 <code class="highlighter-rouge">Migration#exec_migration</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">exec_migration</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span>
  <span class="vi">@connection</span> <span class="o">=</span> <span class="n">conn</span>
  <span class="k">if</span> <span class="nb">respond_to?</span><span class="p">(</span><span class="ss">:change</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="ss">:down</span>
      <span class="n">revert</span> <span class="p">{</span> <span class="n">change</span> <span class="p">}</span>
    <span class="k">else</span>
      <span class="n">change</span>
    <span class="k">end</span>
  <span class="k">else</span>
    <span class="nb">send</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">ensure</span>
  <span class="vi">@connection</span> <span class="o">=</span> <span class="kp">nil</span>
<span class="k">end</span>
</code></pre></div></div>

<p>到这里就能与我们平时在 <code class="highlighter-rouge">Migration</code> 中实现的 <code class="highlighter-rouge">#change</code>、<code class="highlighter-rouge">#up</code> 和 <code class="highlighter-rouge">#down</code> 连到一起，逻辑也走通了；上述代码的逻辑还是很清晰的，如果当前的 <code class="highlighter-rouge">Migratoin</code> 实现了 <code class="highlighter-rouge">#change</code> 方法就会根据 <code class="highlighter-rouge">direction</code> 选择执行 <code class="highlighter-rouge">#change</code> 还是 <code class="highlighter-rouge">#revert + #change</code>，否则就会按照迁移的方向执行对应的方法。</p>

<h3 id="migrations-的-dsl">Migrations 的 DSL</h3>

<p>在数据迁移的模块执行的 Migration 文件中包含的都是 ActiveRecord 提供的 DSL 语法，这部分语法包含两部分，一部分是 Schema 相关的 DSL <code class="highlighter-rouge">schema_statements.rb</code>，其中包括表格的创建和删除以及一些用于辅助 Schema 创建的 <code class="highlighter-rouge">#column_exists?</code> 等方法，另一部分是表定义相关的 DSL <code class="highlighter-rouge">schema_definitions.rb</code>，其中包括处理表结构的 <code class="highlighter-rouge">TableDefinition</code> 类和抽象代表一张数据库中表的 <code class="highlighter-rouge">Table</code> 类。</p>

<h4 id="抽象适配器">抽象适配器</h4>

<p>在整个 <code class="highlighter-rouge">connection_adapters</code> 的子模块中，绝大多数模块在三大 SQL 数据库，MySQL、PostgreSQL 和 sqlite3 中都有着各自的实现：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">connection_adapters</span>
<span class="err">├──</span> <span class="n">abstract</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">connection_pool</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">database_limits</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">database_statements</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">query_cache</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">quoting</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">savepoints</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_creation</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_definitions</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_dumper</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_statements</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">└──</span> <span class="n">transaction</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">├──</span> <span class="n">mysql</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">column</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">database_statements</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">explain_pretty_printer</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">quoting</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_creation</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_definitions</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_dumper</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_statements</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">└──</span> <span class="n">type_metadata</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">├──</span> <span class="n">postgresql</span>
<span class="err">│  </span> <span class="err">└──</span> <span class="o">...</span>
<span class="err">├──</span> <span class="n">sqlite3</span>
<span class="err">│  </span> <span class="err">└──</span> <span class="o">...</span>
<span class="err">├──</span> <span class="n">abstract_adapter</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">├──</span> <span class="o">...</span>
<span class="err">└──</span> <span class="n">sqlite3_adapter</span><span class="p">.</span><span class="nf">rb</span>
</code></pre></div></div>

<p>不过这三个数据库的所有子模块都继承自 <code class="highlighter-rouge">AbstractAdapter</code> 下面对应的子模块，以获得一些三者共用的能力，包括数据库、Schema 的声明与管理等功能。</p>

<p><img src="https://img.draveness.me/2017-10-21-abstract-adapter-and-much-more.png" alt="abstract-adapter-and-much-more" /></p>

<p>通过 <code class="highlighter-rouge">AbstractAdapter</code> 抽离出的公用功能，我们可以通过新的适配器随时适配其他的 SQL 数据库。</p>

<h4 id="schema-dsl">Schema DSL</h4>

<p>数据库的 Schema DSL 部分就包含我们经常使用的 <code class="highlighter-rouge">#create_table</code>、<code class="highlighter-rouge">#rename_table</code> 以及 <code class="highlighter-rouge">#add_column</code> 这些需要表名才能执行的方法，在这里以最常见的 <code class="highlighter-rouge">#create_table</code> 为例，简单分析一下这部分代码的实现：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">create_table</span><span class="p">(</span><span class="n">table_name</span><span class="p">,</span> <span class="ss">comment: </span><span class="kp">nil</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
  <span class="n">td</span> <span class="o">=</span> <span class="n">create_table_definition</span> <span class="n">table_name</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="ss">:temporary</span><span class="p">],</span> <span class="n">options</span><span class="p">[</span><span class="ss">:options</span><span class="p">],</span> <span class="n">options</span><span class="p">[</span><span class="ss">:as</span><span class="p">],</span> <span class="ss">comment: </span><span class="n">comment</span>

  <span class="k">yield</span> <span class="n">td</span> <span class="k">if</span> <span class="nb">block_given?</span>

  <span class="n">execute</span> <span class="n">schema_creation</span><span class="p">.</span><span class="nf">accept</span> <span class="n">td</span>
<span class="k">end</span>
</code></pre></div></div>

<p>首先，在创建表时先通过 <code class="highlighter-rouge">#create_table_definition</code> 方法创建一个新的 <code class="highlighter-rouge">TableDefinition</code> 实例，然后将这个实例作为参数传入 block：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">create_table</span> <span class="ss">:users</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 block 对这个 <code class="highlighter-rouge">TableDefinition</code> 对象一顿操作后，会通过 <code class="highlighter-rouge">SchemaCreation#accept</code> 方法获得一个用于在数据库中，能够创建表的 SQL 语句：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">accept</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
  <span class="n">m</span> <span class="o">=</span> <span class="vi">@cache</span><span class="p">[</span><span class="n">o</span><span class="p">.</span><span class="nf">class</span><span class="p">]</span> <span class="o">||=</span> <span class="s2">"visit_</span><span class="si">#{</span><span class="n">o</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">name</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">'::'</span><span class="p">).</span><span class="nf">last</span><span class="si">}</span><span class="s2">"</span>
  <span class="nb">send</span> <span class="n">m</span><span class="p">,</span> <span class="n">o</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">visit_TableDefinition</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
  <span class="n">create_sql</span> <span class="o">=</span> <span class="s2">"CREATE</span><span class="si">#{</span><span class="s1">' TEMPORARY'</span> <span class="k">if</span> <span class="n">o</span><span class="p">.</span><span class="nf">temporary</span><span class="si">}</span><span class="s2"> TABLE </span><span class="si">#{</span><span class="n">quote_table_name</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="nf">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> "</span>

  <span class="n">statements</span> <span class="o">=</span> <span class="n">o</span><span class="p">.</span><span class="nf">columns</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="n">accept</span> <span class="n">c</span> <span class="p">}</span>
  <span class="n">statements</span> <span class="o">&lt;&lt;</span> <span class="n">accept</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="nf">primary_keys</span><span class="p">)</span> <span class="k">if</span> <span class="n">o</span><span class="p">.</span><span class="nf">primary_keys</span>

  <span class="n">create_sql</span> <span class="o">&lt;&lt;</span> <span class="s2">"(</span><span class="si">#{</span><span class="n">statements</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">', '</span><span class="p">)</span><span class="si">}</span><span class="s2">)"</span> <span class="k">if</span> <span class="n">statements</span><span class="p">.</span><span class="nf">present?</span>
  <span class="n">add_table_options!</span><span class="p">(</span><span class="n">create_sql</span><span class="p">,</span> <span class="n">table_options</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
  <span class="n">create_sql</span> <span class="o">&lt;&lt;</span> <span class="s2">" AS </span><span class="si">#{</span><span class="vi">@conn</span><span class="p">.</span><span class="nf">to_sql</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="nf">as</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span> <span class="k">if</span> <span class="n">o</span><span class="p">.</span><span class="nf">as</span>
  <span class="n">create_sql</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">SchemaCreation</code> 类就是一个接受各种各样的 <code class="highlighter-rouge">TableDefinition</code>、<code class="highlighter-rouge">PrimaryKeyDefinition</code> 对象返回 SQL 的一个工具，可以将 <code class="highlighter-rouge">SchemaCreation</code> 理解为一个表结构的解释器；最后的 <code class="highlighter-rouge">#execute</code> 会在数据库中执行 SQL 改变数据库中的表结构。</p>

<p>在 <code class="highlighter-rouge">SchemaStatements</code> 中定义的其它方法的实现也都是大同小异，比如 <code class="highlighter-rouge">#drop_table</code> 其实都是删除数据库中的某张表：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">drop_table</span><span class="p">(</span><span class="n">table_name</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="n">execute</span> <span class="s2">"DROP TABLE</span><span class="si">#{</span><span class="s1">' IF EXISTS'</span> <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="ss">:if_exists</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">quote_table_name</span><span class="p">(</span><span class="n">table_name</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="表定义-dsl">表定义 DSL</h4>

<p><code class="highlighter-rouge">SchemaStatements</code> 中定义的方法，参数大都包含 <code class="highlighter-rouge">table_name</code>，而另一个类 <code class="highlighter-rouge">TableDefinitions</code> 就包含了直接对表操作的 DSL：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">create_table</span> <span class="ss">:foo</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">t</span><span class="p">.</span><span class="nf">class</span>  <span class="c1"># =&gt; "ActiveRecord::ConnectionAdapters::TableDefinition"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当我们在 <code class="highlighter-rouge">#create_table</code> 中使用例如 <code class="highlighter-rouge">#string</code>、<code class="highlighter-rouge">#integer</code> 等方法时，所有的方法都会通过元编程的魔法最终执行 <code class="highlighter-rouge">TableDefinition#column</code> 改变表的定义：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">ColumnMethods</span>
  <span class="p">[</span>
    <span class="ss">:bigint</span><span class="p">,</span>
    <span class="c1"># ...</span>
    <span class="ss">:integer</span><span class="p">,</span>
    <span class="ss">:string</span><span class="p">,</span>
    <span class="ss">:text</span><span class="p">,</span>
    <span class="ss">:time</span><span class="p">,</span>
    <span class="ss">:timestamp</span><span class="p">,</span>
    <span class="ss">:virtual</span><span class="p">,</span>
  <span class="p">].</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">column_type</span><span class="o">|</span>
    <span class="nb">module_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
      def </span><span class="si">#{</span><span class="n">column_type</span><span class="si">}</span><span class="sh">(*args, **options)
        args.each { |name| column(name, :</span><span class="si">#{</span><span class="n">column_type</span><span class="si">}</span><span class="sh">, options) }
      end
</span><span class="no">    CODE</span>
  <span class="k">end</span>
  <span class="kp">alias_method</span> <span class="ss">:numeric</span><span class="p">,</span> <span class="ss">:decimal</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">#column</code> 方法非常神奇，它从各处收集有关当前表的定义，最终为表中的每一个字段创建一个 <code class="highlighter-rouge">ColumnDefinition</code> 实例，并存储到自己持有的 <code class="highlighter-rouge">@columns_hash</code> 中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">column</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="nb">name</span> <span class="o">=</span> <span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span>
  <span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">.</span><span class="nf">to_sym</span> <span class="k">if</span> <span class="n">type</span>
  <span class="n">options</span> <span class="o">=</span> <span class="n">options</span><span class="p">.</span><span class="nf">dup</span>

  <span class="n">index_options</span> <span class="o">=</span> <span class="n">options</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="ss">:index</span><span class="p">)</span>
  <span class="n">index</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">index_options</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Hash</span><span class="p">)</span> <span class="p">?</span> <span class="n">index_options</span> <span class="p">:</span> <span class="p">{})</span> <span class="k">if</span> <span class="n">index_options</span>
  <span class="vi">@columns_hash</span><span class="p">[</span><span class="nb">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_column_definition</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
  <span class="nb">self</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">new_column_definition</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
  <span class="n">type</span> <span class="o">=</span> <span class="n">aliased_types</span><span class="p">(</span><span class="n">type</span><span class="p">.</span><span class="nf">to_s</span><span class="p">,</span> <span class="n">type</span><span class="p">)</span>
  <span class="n">options</span><span class="p">[</span><span class="ss">:primary_key</span><span class="p">]</span> <span class="o">||=</span> <span class="n">type</span> <span class="o">==</span> <span class="ss">:primary_key</span>
  <span class="n">options</span><span class="p">[</span><span class="ss">:null</span><span class="p">]</span> <span class="o">=</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="ss">:primary_key</span><span class="p">]</span>
  <span class="n">create_column_definition</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">create_column_definition</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
  <span class="no">ColumnDefinition</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>除了 <code class="highlighter-rouge">ColumnDefinition</code> 之外，在 ActiveRecord 中还存在 <code class="highlighter-rouge">PrimaryKeyDefinition</code>、<code class="highlighter-rouge">IndexDefinition</code> 等等类和结构体用于表示数据库中的某一种元素。</p>

<p>表结构在最后会被 <code class="highlighter-rouge">SchemaCreation</code> 类的 <code class="highlighter-rouge">#accept</code> 方法展开，最后在数据库中执行。</p>

<h3 id="小结-3">小结</h3>

<p>到这里整个 Migrations 部分的实现就已经阅读分析完了，整个『模块』包含两个部分，一部分是 rake 任务执行 DSL 代码的过程，另一部分是 DSL 的实现，两部分的结合最终构成了整个 Migrations 模块的全部内容。</p>

<p>ActiveRecord 对于 Migration 迁移机制的设计确实很好的解决数据库中的表结构不断变更的问题，同时因为所有的 Migration 文件都在版本控制中管理，我们也能够随时还原数据库中的表结构。</p>

<h2 id="总结">总结</h2>

<p>文章对 ActiveRecord 中涉及的很多问题都进行了分析和介绍，包括模型的创建、查询以及关系，还包括数据库表迁移的实现，本来想将文中的几个部分分开进行介绍，但是写着写着就懒得分开了，如果对文章的内容有疑问，请在博客下面的评论系统中留言。</p>

<blockquote>

</blockquote>


	  ]]></description>
	</item>

	<item>
	  <title>如何从 MongoDB 迁移到 MySQL</title>
	  <link>/blogs//mongodb-to-mysql</link>
	  <author></author>
	  <pubDate>2017-10-10T00:00:00+00:00</pubDate>
	  <guid>/blogs//mongodb-to-mysql</guid>
	  <description><![CDATA[
	     <p>最近的一个多月时间其实都在做数据库的迁移工作，我目前在开发的项目其实在上古时代是使用 MySQL 作为主要数据库的，后来由于一些业务上的原因从 MySQL 迁移到了 MongoDB，使用了几个月的时间后，由于数据库服务非常不稳定，再加上无人看管，同时 MongoDB 本身就是无 Schema 的数据库，最后导致数据库的脏数据问题非常严重。目前团队的成员没有较为丰富的 Rails 开发经验，所以还是希望使用 ActiveRecord 加上 Migration 的方式对数据进行一些强限制，保证数据库中数据的合法。</p>

<p><img src="https://img.draveness.me/2017-10-10-mysql-and-mongodb.png" alt="mysql-and-mongodb" /></p>

<p>文中会介绍作者在迁移数据库的过程中遇到的一些问题，并为各位读者提供需要<strong>停机</strong>迁移数据库的可行方案，如果需要不停机迁移数据库还是需要别的方案来解决，在这里提供的方案用于百万数据量的 MongoDB，预计的停机时间在两小时左右，如果数据量在千万级别以上，过长的停机时间可能是无法接受的，应该设计不停机的迁移方案；无论如何，作者希望这篇文章能够给想要做数据库迁移的开发者带来一些思路，少走一些坑。</p>

<h2 id="从关系到文档">从关系到文档</h2>

<p>虽然这篇文章的重点是从 MongoDB 迁移到 MySQL，但是作者还是想简单提一下从 MySQL 到 MongoDB 的迁移，如果我们仅仅是将 MySQL 中的全部数据导入到 MongoDB 中其实是一间比较简单的事情，其中最重要的原因就是 <strong>MySQL 支持的数据类型是 MongoDB 的子集</strong>：</p>

<p><img src="https://img.draveness.me/2017-10-10-mongodb-mysql-datatype-relation.png" alt="mongodb-mysql-datatype-relation" /></p>

<p>在迁移的过程中可以将 MySQL 中的全部数据以 csv 的格式导出，然后再将所有 csv 格式的数据使用 <code class="highlighter-rouge">mongoimport</code> 全部导入到 MongoDB 中：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>mysqldump <span class="nt">-u</span>&lt;username&gt; <span class="nt">-p</span>&lt;password&gt; <span class="se">\</span>
    <span class="nt">-T</span> &lt;output_directory&gt; <span class="se">\</span>
    <span class="nt">--fields-terminated-by</span> <span class="s1">','</span> <span class="se">\</span>
    <span class="nt">--fields-enclosed-by</span> <span class="s1">'\"'</span> <span class="se">\</span>
    <span class="nt">--fields-escaped-by</span> <span class="s1">'\'</span> <span class="se">\</span>
    <span class="nt">--no-create-info</span> &lt;database_name&gt;

<span class="nv">$ </span>mongoimport <span class="nt">--db</span> &lt;database_name&gt; <span class="nt">--collection</span> &lt;collection_name&gt; <span class="se">\</span>
    <span class="nt">--type</span> csv <span class="se">\</span>
    <span class="nt">--file</span> &lt;data.csv&gt; <span class="se">\</span>
    <span class="nt">--headerline</span>
</code></pre></div></div>

<p>虽然整个过程看起来只需要两个命令非常简单，但是等到你真要去做的时候你会遇到非常多的问题，作者没有过从 MySQL 或者其他关系型数据库迁移到 MongoDB 的经验，但是 Google 上相关的资料特别多，所以这总是一个有无数前人踩过坑的问题，而前人的经验也能够帮助我们节省很多时间。</p>

<p><img src="https://img.draveness.me/2017-10-24-mysql-to-mongodb.png" alt="mysql-to-mongodb" /></p>

<blockquote>
  <p>使用 csv 的方式导出数据在绝大多数的情况都不会出现问题，但是如果数据库中的某些文档中存储的是富文本，那么虽然在导出数据时不会出现问题，最终导入时可能出现一些比较奇怪的错误。</p>
</blockquote>

<h2 id="从文档到关系">从文档到关系</h2>

<p>相比于从 MySQL 到 MongoDB 的迁移，反向的迁移就麻烦了不止一倍，这主要是因为 MongoDB 中的很多数据类型和集合之间的关系在 MySQL 中都并不存在，比如嵌入式的数据结构、数组和哈希等集合类型、多对多关系的实现，很多的问题都不是仅仅能通过数据上的迁移解决的，我们需要在对数据进行迁移之前先对部分数据结构进行重构，本文中的后半部分会介绍需要处理的数据结构和逻辑。</p>

<p><img src="https://img.draveness.me/2017-10-10-mongodb-mysql-problems-to-be-solved.png" alt="mongodb-mysql-problems-to-be-solved" /></p>

<p>当我们准备将数据库彻底迁移到 MySQL 之前，需要做一些准备工作，将最后迁移所需要的工作尽可能地减少，保证停机的时间不会太长，准备工作的目标就是尽量消灭工程中复杂的数据结构。</p>

<h3 id="数据的预处理">数据的预处理</h3>

<p>在进行迁移之前要做很多准备工作，第一件事情是要把所有嵌入的数据结构改成非嵌入式的数据结构：</p>

<p><img src="https://img.draveness.me/2017-10-10-embedded-reference-documents.png" alt="embedded-reference-documents" /></p>

<p>也就是把所有 <code class="highlighter-rouge">embeds_many</code> 和 <code class="highlighter-rouge">embeds_one</code> 的关系都改成 <code class="highlighter-rouge">has_many</code> 和 <code class="highlighter-rouge">has_one</code>，同时将 <code class="highlighter-rouge">embedded_in</code> 都替换成 <code class="highlighter-rouge">belongs_to</code>，同时我们需要将工程中对应的测试都改成这种引用的关系，然而只改变代码中的关系并没有真正改变 MongoDB 中的数据。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">embeds_many_to_has_many</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
  <span class="n">child_key_name</span> <span class="o">=</span> <span class="n">child</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">underscore</span><span class="p">.</span><span class="nf">pluralize</span>
  <span class="n">parent</span><span class="p">.</span><span class="nf">collection</span><span class="p">.</span><span class="nf">find</span><span class="p">({}).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">parent_document</span><span class="o">|</span>
    <span class="k">next</span> <span class="k">unless</span> <span class="n">parent_document</span><span class="p">[</span><span class="n">child_key_name</span><span class="p">]</span>
    <span class="n">parent_document</span><span class="p">[</span><span class="n">child_key_name</span><span class="p">].</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">child_document</span><span class="o">|</span>
      <span class="n">new_child</span> <span class="o">=</span> <span class="n">child_document</span><span class="p">.</span><span class="nf">merge</span> <span class="s2">"</span><span class="si">#{</span><span class="n">parent</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">underscore</span><span class="si">}</span><span class="s2">_id"</span><span class="p">:</span> <span class="n">parent_document</span><span class="p">[</span><span class="s1">'_id'</span><span class="p">]</span>
      <span class="n">child</span><span class="p">.</span><span class="nf">collection</span><span class="p">.</span><span class="nf">insert_one</span> <span class="n">new_child</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="n">parent</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">unset</span><span class="p">(</span><span class="n">child_key_name</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">embeds_many_to_has_many</span><span class="p">(</span><span class="no">Person</span><span class="p">,</span> <span class="no">Address</span><span class="p">)</span>
</code></pre></div></div>

<p>我们可以使用上述的代码将关系为嵌入的模型都转换成引用，拍平所有复杂的数据关系，这段代码的运行时间与嵌入关系中的两个模型的数量有关，需要注意的是，MongoDB 中嵌入模型的数据可能因为某些原因出现相同的 <code class="highlighter-rouge">_id</code> 在插入时会发生冲突导致崩溃，你可以对 <code class="highlighter-rouge">insert_one</code> 使用 <code class="highlighter-rouge">resuce</code> 来保证这段代码的运行不会因为上述原因而停止。</p>

<p><img src="https://img.draveness.me/2017-10-10-embedded-to-reference.png" alt="embedded-to-reference" /></p>

<p>通过这段代码我们就可以轻松将原有的嵌入关系全部展开变成引用的关系，将嵌入的关系变成引用除了做这两个改变之外，不需要做其他的事情，无论是数据的查询还是模型的创建都不需要改变代码的实现，不过记得为子模型中父模型的外键<strong>添加索引</strong>，否则会导致父模型在获取自己持有的全部子模型时造成<strong>全表扫描</strong>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Comment</span>
  <span class="kp">include</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Document</span>
  <span class="n">index</span> <span class="ss">post_id: </span><span class="mi">1</span>
  <span class="n">belongs_to</span> <span class="ss">:post</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在处理了 MongoDB 中独有的嵌入式关系之后，我们就需要解决一些复杂的集合类型了，比如数组和哈希，如果我们使用 MySQL5.7 或者 PostgreSQL 的话，其实并不需要对他们进行处理，因为最新版本的 MySQL 和 PostgreSQL 已经提供了对 JSON 的支持，不过作者还是将项目中的数组和哈希都变成了常见的数据结构。</p>

<p>在这个可选的过程中，其实并没有什么标准答案，我们可以根据需要将不同的数据转换成不同的数据结构：</p>

<p><img src="https://img.draveness.me/2017-10-10-array-to-string-or-relation.png" alt="array-to-string-or-relation" /></p>

<p>比如，将数组变成字符串或者一对多关系，将哈希变成当前文档的键值对等等，如何处理这些集合数据其实都要看我们的业务逻辑，在改变这些字段的同时尽量为上层提供一个与原来直接 <code class="highlighter-rouge">.tags</code> 或者 <code class="highlighter-rouge">.categories</code> 结果相同的 API：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Post</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="nf">tag_titles</span>
    <span class="n">tags</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:title</span><span class="p">)</span>
  <span class="k">end</span>
  
  <span class="k">def</span> <span class="nf">split_categories</span>
    <span class="n">categories</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">','</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这一步其实也是可选的，上述代码只是为了减少其他地方的修改负担，当然如果你想使用 MySQL5.7 或者 PostgreSQL 数据库对 JSON 的支持也没有什么太大的问题，只是在查询集合字段时有一些不方便。</p>

<h3 id="mongoid-的小兄弟们">Mongoid 的『小兄弟』们</h3>

<p>在使用 Mongoid 进行开发期间难免会用到一些相关插件，比如 <a href="https://github.com/thetron/mongoid-enum">mongoid-enum</a>、<a href="https://github.com/mongoid/mongoid-slug">mongoid-slug</a> 和 <a href="https://github.com/mongoid/mongoid-history">mongoid-history</a> 等，这些插件的实现与 ActiveRecord 中具有相同功能的插件在实现上有很大的不同。</p>

<p>对于有些插件，比如 mongoid-slug 只是在引入插件的模型的文档中插入了 <code class="highlighter-rouge">_slugs</code> 字段，我们只需要在进行数据迁移忽略这些添加的字段并将所有的 <code class="highlighter-rouge">#slug</code> 方法改成 <code class="highlighter-rouge">#id</code>，不需要在预处理的过程中做其它的改变。而枚举的实现在 Mongoid 的插件和 ActiveRecord 中就截然不同了：</p>

<p><img src="https://img.draveness.me/2017-10-10-mongodb-mysql-enum.png" alt="mongodb-mysql-enu" /></p>

<p>mongoid-enum 使用字符串和 <code class="highlighter-rouge">_status</code> 来保存枚举类型的字段，而 ActiveRecord 使用整数和 <code class="highlighter-rouge">status</code> 表示枚举类型，两者在底层数据结构的存储上有一些不同，我们会在之后的迁移脚本中解决这个问题。</p>

<p><img src="https://img.draveness.me/2017-10-10-mongoid-activerecord-enum.png" alt="mongoid-activerecord-enum" /></p>

<p>如果在项目中使用了很多 Mongoid 的插件，由于其实现不同，我们也只能根据不同的插件的具体实现来决定如何对其进行迁移，如果使用了一些支持特殊功能的插件可能很难在 ActiveRecord 中找到对应的支持，在迁移时可以考虑暂时将部分不重要的功能移除。</p>

<h3 id="主键与-uuid">主键与 UUID</h3>

<p>我们希望从 MongoDB 迁移到 MySQL 的另一个重要原因就是 MongoDB 每一个文档的主键实在是太过冗长，一个 32 字节的 <code class="highlighter-rouge">_id</code> 无法给我们提供特别多的信息，只能增加我们的阅读障碍，再加上项目中并没有部署 MongoDB 集群，所以没能享受到用默认的 UUID 生成机制带来的好处。</p>

<p><img src="https://img.draveness.me/2017-10-10-mongodb-mysql-id.png" alt="mongodb-mysql-id" /></p>

<p>我们不仅没有享受到 UUID 带来的优点，它还在迁移 MySQL 的过程中为我们带来了很大的麻烦，一方面是因为 ActiveRecord 的默认主键是整数，不支持 32 字节长度的 UUID，如果我们想要不改变 MongoDB 的 UUID，直接迁移到 MySQL 中使用其实也没有什么问题，只是我们要将默认的整数类型的主键变成字符串类型，同时要使用一个 UUID 生成器来保证所有的主键都是根据时间递增的并且不会冲突。</p>

<p>如果准备使用 UUID 加生成器的方式，其实会省去很多迁移的时间，不过看起来确实不是特别的优雅，如何选择还是要权衡和评估，但是如果我们选择了使用 <code class="highlighter-rouge">integer</code> 类型的自增主键时，就需要做很多额外的工作了，首先是为所有的表添加 <code class="highlighter-rouge">uuid</code> 字段，同时为所有的外键例如 <code class="highlighter-rouge">post_id</code> 创建对应的 <code class="highlighter-rouge">post_uuid</code> 字段，通过 <code class="highlighter-rouge">uuid</code> 将两者关联起来：</p>

<p><img src="https://img.draveness.me/2017-10-10-mysql-before-migrations.png" alt="mysql-before-migrations" /></p>

<p>在数据的迁移过程中，我们会将原有的 <code class="highlighter-rouge">_id</code> 映射到 <code class="highlighter-rouge">uuid</code> 中，<code class="highlighter-rouge">post_id</code> 映射到 <code class="highlighter-rouge">post_uuid</code> 上，我们通过保持 <code class="highlighter-rouge">uuid</code> 和 <code class="highlighter-rouge">post_uuid</code> 之间的关系保证模型之间的关系没有丢失，在迁移数据的过程中 <code class="highlighter-rouge">id</code> 和 <code class="highlighter-rouge">post_id</code> 是完全不存在任何联系的。</p>

<p>当我们按照 <code class="highlighter-rouge">_id</code> 的顺序遍历整个文档，将文档中的数据被插入到表中时，MySQL 会为所有的数据行自动生成的递增的主键 <code class="highlighter-rouge">id</code>，而 <code class="highlighter-rouge">post_id</code> 在这时都为空。</p>

<p><img src="https://img.draveness.me/2017-10-10-mysql-after-migrations.png" alt="mysql-after-migrations" /></p>

<p>在全部的数据都被插入到 MySQL 之后，我们通过 <code class="highlighter-rouge">#find_by_uuid</code> 查询的方式将 <code class="highlighter-rouge">uuid</code> 和 <code class="highlighter-rouge">post_uuid</code> 中的关系迁移到 <code class="highlighter-rouge">id</code> 和 <code class="highlighter-rouge">post_id</code> 中，并将与 <code class="highlighter-rouge">uuid</code> 相关的字段全部删除，这样我们能够保证模型之间的关系不会消失，并且数据行的相对位置与迁移前完全一致。</p>

<h3 id="代码的迁移">代码的迁移</h3>

<p>Mongoid 在使用时都是通过 <code class="highlighter-rouge">include</code> 将相关方法加载到当前模型中的，而 ActiveRecord 是通过继承 <code class="highlighter-rouge">ActiveRecord::Base</code> 的方式使用的，完成了对数据的预处理，我们就可以对现有模型层的代码进行修改了。</p>

<p>首先当然是更改模型的『父类』，把所有的 <code class="highlighter-rouge">Mongoid::Document</code> 都改成 <code class="highlighter-rouge">ActiveRecord::Base</code>，然后创建类对应的 Migration 迁移文件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/models/post.rb</span>
<span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">validate_presence_of</span> <span class="ss">:title</span><span class="p">,</span> <span class="ss">:content</span>
<span class="k">end</span>

<span class="c1"># db/migrate/20170908075625_create_posts.rb</span>
<span class="k">class</span> <span class="nc">CreatePosts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span><span class="p">[</span><span class="mf">5.1</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:posts</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:title</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">text</span> <span class="ss">:content</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:uuid</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span>

      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span> <span class="ss">null: </span><span class="kp">false</span>
    <span class="k">end</span>
    
    <span class="n">add_index</span> <span class="ss">:posts</span><span class="p">,</span> <span class="ss">:uuid</span><span class="p">,</span> <span class="ss">unique: </span><span class="kp">true</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<blockquote>
  <p>注意：要为每一张表添加类型为字符串的 <code class="highlighter-rouge">uuid</code> 字段，同时为 <code class="highlighter-rouge">uuid</code> 建立唯一索引，以加快通过 <code class="highlighter-rouge">uuid</code> 建立不同数据模型之间关系的速度。</p>
</blockquote>

<p>除了建立数据库的迁移文件并修改基类，我们还需要修改一些 <code class="highlighter-rouge">include</code> 的模块和 Mongoid 中独有的查询，比如使用 <code class="highlighter-rouge">gte</code> 或者 <code class="highlighter-rouge">lte</code> 的日期查询和使用正则进行模式匹配的查询，这些查询在 ActiveRecord 中的使用方式与 Mongoid 中完全不同，我们需要通过手写 SQL 来解决这些问题。</p>

<p><img src="https://img.draveness.me/2017-10-10-mongoid-to-activerecord-model-and-query.png" alt="mongoid-to-activerecord-model-and-query" /></p>

<p>除此之外，我们也需要处理一些复杂的模型关系，比如 Mongoid 中的 <code class="highlighter-rouge">inverse_of</code> 在 ActiveRecord 中叫做  <code class="highlighter-rouge">foreign_key</code> 等等，这些修改其实都并不复杂，只是如果想要将这部分的代码全部处理掉，就需要对业务逻辑进行详细地测试以保证不会有遗留的问题，这也就对我们项目的测试覆盖率有着比较高的要求了，不过我相信绝大多数的 Rails 工程都有着非常好的测试覆盖率，能够保证这一部分代码和逻辑能够顺利迁移，但是如果项目中完全没有测试或者测试覆盖率很低，就只能人肉进行测试或者自求多福了，或者<strong>就别做迁移了，多写点测试再考虑这些重构的事情吧</strong>。</p>

<h3 id="数据的迁移">数据的迁移</h3>

<p>为每一个模型创建对应的迁移文件并建表其实一个不得不做的体力活，虽然有一些工作我们没法省略，但是我们可以考虑使用自动化的方式为所有的模型添加 <code class="highlighter-rouge">uuid</code> 字段和索引，同时也为类似 <code class="highlighter-rouge">post_id</code> 的字段添加相应的 <code class="highlighter-rouge">post_uuid</code> 列：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AddUuidColumns</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span><span class="p">[</span><span class="mf">5.1</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">eager_load!</span>
    <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">descendants</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">klass</span><span class="o">|</span>
      <span class="c1"># add `uuid` column and create unique index on `uuid`.</span>
      <span class="n">add_column</span> <span class="n">klass</span><span class="p">.</span><span class="nf">table_name</span><span class="p">,</span> <span class="ss">:uuid</span><span class="p">,</span> <span class="ss">:string</span><span class="p">,</span> <span class="ss">unique: </span><span class="kp">true</span>
      <span class="n">add_index</span> <span class="n">klass</span><span class="p">.</span><span class="nf">table_name</span><span class="p">,</span> <span class="ss">unique: </span><span class="kp">true</span>
      
      <span class="c1"># add `xxx_uuid` columns, ex: `post_uuid`, `comment_uuid` and etc.</span>
      <span class="n">uuids</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">attribute_names</span>
        <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="kp">attr</span><span class="o">|</span> <span class="kp">attr</span><span class="p">.</span><span class="nf">include?</span> <span class="s1">'_id'</span> <span class="p">}</span>
        <span class="p">.</span><span class="nf">map</span>    <span class="p">{</span> <span class="o">|</span><span class="kp">attr</span><span class="o">|</span> <span class="kp">attr</span><span class="p">.</span><span class="nf">gsub</span> <span class="s1">'_id'</span><span class="p">,</span> <span class="s1">'_uuid'</span> <span class="p">}</span>
      <span class="k">next</span> <span class="k">unless</span> <span class="n">uuids</span><span class="p">.</span><span class="nf">present?</span>
      <span class="n">uuids</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">uuid</span><span class="o">|</span>
        <span class="n">add_column</span> <span class="n">klass</span><span class="p">.</span><span class="nf">table_name</span><span class="p">,</span> <span class="n">uuid</span><span class="p">,</span> <span class="ss">:string</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在添加 <code class="highlighter-rouge">uuid</code> 列并建立好索引之后，我们就可以开始对数据库进行迁移了，如果我们决定在迁移的过程中改变原有数据的主键，那么我们会将迁移分成两个步骤，数据的迁移和关系的重建，前者仅指将 MongoDB 中的所有数据全部迁移到 MySQL 中对应的表中，并将所有的 <code class="highlighter-rouge">_id</code> 转换成 <code class="highlighter-rouge">uuid</code>、<code class="highlighter-rouge">xx_id</code> 转换成 <code class="highlighter-rouge">xx_uuid</code>，而后者就是前面提到的：通过 <code class="highlighter-rouge">uuid</code> 和 <code class="highlighter-rouge">xx_uuid</code> 的关联重新建立模型之间的关系并在最后删除所有的 <code class="highlighter-rouge">uuid</code> 字段。</p>

<p>我们可以使用如下的代码对数据进行迁移，这段代码从 MongoDB 中遍历某个集合 Collection 中的全部数据，然后将文档作为参数传入 block，然后再分别通过 <code class="highlighter-rouge">DatabaseTransformer#delete_obsolete_columns</code> 和 <code class="highlighter-rouge">DatabaseTransformer#update_rename_columns</code> 方法删除部分已有的列、更新一些数据列最后将所有的 <code class="highlighter-rouge">id</code> 列都变成 <code class="highlighter-rouge">uuid</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">DatabaseTransformer</span>
  <span class="k">def</span> <span class="nf">import</span><span class="p">(</span><span class="n">collection_name</span><span class="p">,</span> <span class="o">*</span><span class="n">obsolete_columns</span><span class="p">,</span> <span class="o">**</span><span class="n">rename_columns</span><span class="p">)</span>
    <span class="n">collection</span> <span class="o">=</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Clients</span><span class="p">.</span><span class="nf">default</span><span class="p">.</span><span class="nf">collections</span><span class="p">.</span><span class="nf">select</span> <span class="k">do</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span>
      <span class="n">c</span><span class="p">.</span><span class="nf">namespace</span> <span class="o">==</span> <span class="s2">"</span><span class="si">#{</span><span class="n">database</span><span class="si">}</span><span class="s2">.</span><span class="si">#{</span><span class="n">collection_name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">pluralize</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span><span class="p">.</span><span class="nf">first</span>

    <span class="k">unless</span> <span class="n">collection</span><span class="p">.</span><span class="nf">present?</span>
      <span class="no">STDOUT</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="n">collection_name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">yellow</span><span class="si">}</span><span class="s2">: skipped"</span>
      <span class="no">STDOUT</span><span class="p">.</span><span class="nf">puts</span>
      <span class="k">return</span>
    <span class="k">end</span>

    <span class="n">constant</span> <span class="o">=</span> <span class="n">collection_name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">singularize</span><span class="p">.</span><span class="nf">camelcase</span><span class="p">.</span><span class="nf">constantize</span>
    <span class="n">reset_callbacks</span> <span class="n">constant</span>

    <span class="no">DatabaseTransformer</span><span class="p">.</span><span class="nf">profiling</span> <span class="k">do</span>
      <span class="n">collection_count</span> <span class="o">=</span> <span class="n">collection</span><span class="p">.</span><span class="nf">find</span><span class="p">.</span><span class="nf">count</span>
      <span class="n">collection</span><span class="p">.</span><span class="nf">find</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">document</span><span class="p">,</span> <span class="n">index</span><span class="o">|</span>
        <span class="n">document</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">document</span> <span class="k">if</span> <span class="nb">block_given?</span>
        <span class="n">delete_obsolete_columns</span> <span class="n">document</span><span class="p">,</span> <span class="n">obsolete_columns</span>
        <span class="n">update_rename_columns</span> <span class="n">document</span><span class="p">,</span> <span class="n">rename_columns</span>
        <span class="n">update_id_columns</span> <span class="n">document</span>

        <span class="n">insert_record</span> <span class="n">constant</span><span class="p">,</span> <span class="n">document</span>
        <span class="no">STDOUT</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="n">index</span><span class="si">}</span><span class="s2">/</span><span class="si">#{</span><span class="n">collection_count</span><span class="si">}</span><span class="se">\n</span><span class="s2">"</span> <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">).</span><span class="nf">zero?</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当完成了对文档的各种操作之后，该方法会直接调用 <code class="highlighter-rouge">DatabaseTransformer#insert_record</code> 将数据插入 MySQL 对应的表中；我们可以直接使用如下的代码将某个 Collection 中的全部文档迁移到 MySQL 中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">transformer</span> <span class="o">=</span> <span class="no">DatabaseTransformer</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'draven_production'</span>
<span class="n">transformer</span><span class="p">.</span><span class="nf">import</span> <span class="ss">:post</span><span class="p">,</span> <span class="ss">:_slugs</span><span class="p">,</span> <span class="ss">name: :title</span><span class="p">,</span> <span class="ss">_status: :status</span>
</code></pre></div></div>

<p>上述代码会在迁移时将集合每一个文档的 <code class="highlighter-rouge">_slugs</code> 字段全部忽略，同时将 <code class="highlighter-rouge">name</code> 重命名成 <code class="highlighter-rouge">title</code>、<code class="highlighter-rouge">_status</code> 重命名成 <code class="highlighter-rouge">status</code>，虽然作为枚举类型的字段 mongoid-enum 和 ActiveRecord 的枚举类型完全不同，但是在这里可以直接插入也没有什么问题，ActiveRecord 的模型在创建时会自己处理字符串和整数之间的转换：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">insert_record</span><span class="p">(</span><span class="n">constant</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
  <span class="n">model</span> <span class="o">=</span> <span class="n">constant</span><span class="p">.</span><span class="nf">new</span> <span class="n">params</span>
  <span class="n">model</span><span class="p">.</span><span class="nf">save!</span> <span class="ss">validate: </span><span class="kp">false</span>
<span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">exception</span>
  <span class="no">STDERR</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"Import Error: </span><span class="si">#{</span><span class="n">exception</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">raise</span> <span class="n">exception</span>
<span class="k">end</span>
</code></pre></div></div>

<p>为了加快数据的插入速度，同时避免所有由于插入操作带来的副作用，我们会在数据迁移期间重置所有的回调：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">reset_callbacks</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span>
  <span class="sx">%i(create save update)</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">callback</span><span class="o">|</span>
    <span class="n">constant</span><span class="p">.</span><span class="nf">reset_callbacks</span> <span class="n">callback</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这段代码的作用仅在这个脚本运行的过程中才会生效，不会对工程中的其他地方造成任何的影响；同时，该脚本会在每 1000 个模型插入成功后向标准输出打印当前进度，帮助我们快速发现问题和预估迁移的时间。</p>

<blockquote>
  <p>你可以在 <a href="https://gist.github.com/Draveness/10476fe67a10128a37ba27a4c6967d07">database_transformer.rb</a> 找到完整的数据迁移代码。</p>
</blockquote>

<p>将所有的数据全部插入到 MySQL 的表之后，模型之间还没有任何显式的关系，我们还需要将通过 <code class="highlighter-rouge">uuid</code> 连接的模型转换成使用 <code class="highlighter-rouge">id</code> 的方式，对象之间的关系才能通过点语法直接访问，关系的建立其实非常简单，我们获得当前类所有结尾为 <code class="highlighter-rouge">_uuid</code> 的属性，然后遍历所有的数据行，根据 <code class="highlighter-rouge">uuid</code> 的值和 <code class="highlighter-rouge">post_uuid</code> 属性中的 “post” 部分获取到表名，最终得到对应的关联模型，在这里我们也处理了类似多态的特殊情况：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">RelationBuilder</span>
  <span class="k">def</span> <span class="nf">build_relations</span><span class="p">(</span><span class="n">class_name</span><span class="p">,</span> <span class="n">polymorphic_associations</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">rename_associations</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="n">uuids</span> <span class="o">=</span> <span class="n">class_name</span><span class="p">.</span><span class="nf">attribute_names</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="nb">name</span><span class="p">.</span><span class="nf">end_with?</span> <span class="s1">'_uuid'</span> <span class="p">}</span>

    <span class="k">unless</span> <span class="n">uuids</span><span class="p">.</span><span class="nf">present?</span>
      <span class="no">STDOUT</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="n">class_name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">yellow</span><span class="si">}</span><span class="s2">: skipped"</span>
      <span class="no">STDOUT</span><span class="p">.</span><span class="nf">puts</span>
      <span class="k">return</span>
    <span class="k">end</span>

    <span class="n">reset_callbacks</span> <span class="n">class_name</span>

    <span class="no">RelationBuilder</span><span class="p">.</span><span class="nf">profiling</span> <span class="k">do</span>
      <span class="n">models_count</span> <span class="o">=</span> <span class="n">class_name</span><span class="p">.</span><span class="nf">count</span>
      <span class="n">class_name</span><span class="p">.</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">model</span><span class="p">,</span> <span class="n">index</span><span class="o">|</span>
        <span class="n">update_params</span> <span class="o">=</span> <span class="n">uuids</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">uuid</span><span class="o">|</span>
          <span class="n">original_association_name</span> <span class="o">=</span> <span class="n">uuid</span><span class="p">[</span><span class="mi">0</span><span class="o">...-</span><span class="mi">5</span><span class="p">]</span>

          <span class="n">association_model</span> <span class="o">=</span> <span class="n">association_model</span><span class="p">(</span>
            <span class="n">original_association_name</span><span class="p">,</span>
            <span class="n">model</span><span class="p">[</span><span class="n">uuid</span><span class="p">],</span>
            <span class="n">polymorphic_associations</span><span class="p">,</span>
            <span class="n">rename_associations</span>
          <span class="p">)</span>

          <span class="p">[</span><span class="n">original_association_name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">,</span> <span class="n">association_model</span><span class="p">]</span>
        <span class="k">end</span><span class="p">.</span><span class="nf">compact</span>

        <span class="k">begin</span>
          <span class="no">Hash</span><span class="p">[</span><span class="n">update_params</span><span class="p">].</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
            <span class="n">model</span><span class="p">.</span><span class="nf">send</span> <span class="s2">"</span><span class="si">#{</span><span class="n">key</span><span class="si">}</span><span class="s2">="</span><span class="p">,</span> <span class="n">value</span>
          <span class="k">end</span>
          <span class="n">model</span><span class="p">.</span><span class="nf">save!</span> <span class="ss">validate: </span><span class="kp">false</span>
        <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
          <span class="no">STDERR</span><span class="p">.</span><span class="nf">puts</span> <span class="n">e</span>
          <span class="k">raise</span> <span class="n">e</span>
        <span class="k">end</span>

        <span class="no">STDOUT</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="n">index</span><span class="si">}</span><span class="s2">/</span><span class="si">#{</span><span class="n">models_count</span><span class="si">}</span><span class="se">\n</span><span class="s2">"</span> <span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">).</span><span class="nf">zero?</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在查找到对应的数据行之后就非常简单了，我们调用对应的 <code class="highlighter-rouge">post=</code> 等方法更新外键最后直接将外键的值保存到数据库中，与数据的迁移过程一样，我们在这段代码的执行过程中也会打印出当前的进度。</p>

<p>在初始化 <code class="highlighter-rouge">RelationBuilder</code> 时，如果我们传入了 <code class="highlighter-rouge">constants</code>，那么在调用 <code class="highlighter-rouge">RelationBuilder#build!</code> 时就会重建其中的全部关系，但是如果没有传入就会默认加载 ActiveRecord 中所有的子类，并去掉其中包含 <code class="highlighter-rouge">::</code> 的模型，也就是 ActiveRecord 中使用 <code class="highlighter-rouge">has_and_belongs_to_many</code> 创建的中间类，我们会在下一节中介绍如何单独处理多对多关系：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="nb">constants</span> <span class="o">=</span> <span class="p">[])</span>
  <span class="k">if</span> <span class="nb">constants</span><span class="p">.</span><span class="nf">present?</span>
    <span class="vi">@constants</span> <span class="o">=</span> <span class="nb">constants</span>
  <span class="k">else</span>
    <span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">eager_load!</span>
    <span class="vi">@constants</span> <span class="o">=</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">descendants</span>
        <span class="p">.</span><span class="nf">reject</span> <span class="p">{</span> <span class="o">|</span><span class="n">constant</span><span class="o">|</span> <span class="n">constant</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="s1">'::'</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<blockquote>
  <p>跟关系重建相关的代码可以在 <a href="https://gist.github.com/Draveness/c0798fb1272f483a176fa67741a3f1ee">relation_builder.rb</a> 找到完整的用于关系迁移的代码。</p>
</blockquote>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">builder</span> <span class="o">=</span> <span class="no">RelationBuilder</span><span class="p">.</span><span class="nf">new</span><span class="p">([</span><span class="no">Post</span><span class="p">,</span> <span class="no">Comment</span><span class="p">])</span>
<span class="n">builder</span><span class="p">.</span><span class="nf">build!</span>
</code></pre></div></div>

<p>通过这数据迁移和关系重建两个步骤就已经可以解决绝大部分的数据迁移问题了，但是由于 MongoDB 和 ActiveRecord 中对于多对多关系的处理比较特殊，所以我们需要单独进行解决，如果所有的迁移问题到这里都已经解决了，那么我们就可以使用下面的迁移文件将数据库中与 <code class="highlighter-rouge">uuid</code> 有关的全部列都删除了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">RemoveAllUuidColumns</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span><span class="p">[</span><span class="mf">5.1</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">eager_load!</span>
    <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">descendants</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">klass</span><span class="o">|</span>
      <span class="n">attrs</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">attribute_names</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">n</span><span class="o">|</span> <span class="n">n</span><span class="p">.</span><span class="nf">include?</span> <span class="s1">'uuid'</span> <span class="p">}</span>
      <span class="k">next</span> <span class="k">unless</span> <span class="n">attrs</span><span class="p">.</span><span class="nf">present?</span>
      <span class="n">remove_columns</span> <span class="n">klass</span><span class="p">.</span><span class="nf">table_name</span><span class="p">,</span> <span class="o">*</span><span class="n">attrs</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>到这里位置整个迁移的过程就基本完成了，接下来就是跟整个迁移过程中有关的其他事项，例如：对多对关系、测试的重要性等话题。</p>

<h3 id="多对多关系的处理">多对多关系的处理</h3>

<p>多对多关系在数据的迁移过程中其实稍微有一些复杂，在 Mongoid 中使用 <code class="highlighter-rouge">has_and_belongs_to_many</code> 会在相关的文档下添加一个 <code class="highlighter-rouge">tag_ids</code> 或者 <code class="highlighter-rouge">post_ids</code> 数组：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># The post document.</span>
<span class="p">{</span>
  <span class="s2">"_id"</span> <span class="p">:</span> <span class="no">ObjectId</span><span class="p">(</span><span class="s2">"4d3ed089fb60ab534684b7e9"</span><span class="p">),</span>
  <span class="s2">"tag_ids"</span> <span class="p">:</span> <span class="p">[</span>
    <span class="no">ObjectId</span><span class="p">(</span><span class="s2">"4d3ed089fb60ab534684b7f2"</span><span class="p">),</span> 
    <span class="no">ObjectId</span><span class="p">(</span><span class="s2">"4d3ed089fb60ab53468831f1"</span><span class="p">)</span>
  <span class="p">],</span>
  <span class="s2">"title"</span><span class="p">:</span> <span class="s2">"xxx"</span><span class="p">,</span>
  <span class="s2">"content"</span><span class="p">:</span> <span class="s2">"xxx"</span>
<span class="p">}</span>
</code></pre></div></div>

<p>而 ActiveRecord 中会建立一张单独的表，表的名称是两张表名按照字母表顺序的拼接，如果是 <code class="highlighter-rouge">Post</code> 和 <code class="highlighter-rouge">Tag</code>，对应的多对多表就是 <code class="highlighter-rouge">posts_tags</code>，除了创建多对多表，<code class="highlighter-rouge">has_and_belongs_to_many</code> 还会创建两个 <code class="highlighter-rouge">ActiveRecord::Base</code> 的子类 <code class="highlighter-rouge">Tag::HABTM_Posts</code> 和 <code class="highlighter-rouge">Post::HABTM_Tags</code>，我们可以使用下面的代码简单实验一下：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'active_record'</span>

<span class="k">class</span> <span class="nc">Tag</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">;</span> <span class="k">end</span>
<span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:tags</span>
<span class="k">end</span>
<span class="k">class</span> <span class="nc">Tag</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:posts</span>
<span class="k">end</span>
<span class="nb">puts</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">descendants</span>
<span class="c1"># =&gt; [Tag, Post, Post::HABTM_Tags, Tag::HABTM_Posts]</span>
</code></pre></div></div>

<p>上述代码打印出了两个 <code class="highlighter-rouge">has_and_belongs_to_many</code> 生成的类 <code class="highlighter-rouge">Tag::HABTM_Posts</code> 和 <code class="highlighter-rouge">Post::HABTM_Tags</code>，它们有着完全相同的表 <code class="highlighter-rouge">posts_tags</code>，处理多对多关系时，我们只需要在使用 <code class="highlighter-rouge">DatabaseTransformer</code> 导入表中的所有的数据之后，再通过遍历 <code class="highlighter-rouge">posts_tags</code> 表中的数据更新多对多的关系表就可以了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PostsTag</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">;</span> <span class="k">end</span>

<span class="c1"># migrate data from mongodb to mysql.</span>
<span class="n">transformer</span> <span class="o">=</span> <span class="no">DatabaseTransformer</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'draven_production'</span>
<span class="n">transformer</span><span class="p">.</span><span class="nf">import</span> <span class="ss">:posts_tags</span>

<span class="c1"># establish association between posts and tags.</span>
<span class="no">PostsTag</span><span class="p">.</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">model</span><span class="o">|</span>
  <span class="n">post</span> <span class="o">=</span> <span class="no">Post</span><span class="p">.</span><span class="nf">find_by_uuid</span> <span class="n">model</span><span class="p">.</span><span class="nf">post_uuid</span>
  <span class="n">tag</span> <span class="o">=</span> <span class="no">Tag</span><span class="p">.</span><span class="nf">find_by_uuid</span> <span class="n">model</span><span class="p">.</span><span class="nf">tag_uuid</span>
  <span class="k">next</span> <span class="k">unless</span> <span class="n">post</span><span class="p">.</span><span class="nf">present?</span> <span class="o">&amp;&amp;</span> <span class="n">tag</span><span class="p">.</span><span class="nf">present?</span>
  <span class="n">model</span><span class="p">.</span><span class="nf">update_columns</span> <span class="ss">post_id: </span><span class="n">post</span><span class="p">.</span><span class="nf">id</span><span class="p">,</span> <span class="ss">tag_id: </span><span class="n">tag</span><span class="p">.</span><span class="nf">id</span>
<span class="k">end</span>
</code></pre></div></div>

<p>所有使用 <code class="highlighter-rouge">has_and_belongs_to_many</code> 的多对多关系都需要通过上述代码进行迁移，这一步需要在删除数据库中的所有 <code class="highlighter-rouge">uuid</code> 字段之前完成。</p>

<h3 id="测试的重要性">测试的重要性</h3>

<p>在真正对线上的服务进行停机迁移之前，我们其实需要对数据库已有的数据进行部分和全量测试，在部分测试阶段，我们可以在本地准备一个数据量为生产环境数据量 1/10 或者 1/100 的 MongoDB 数据库，通过在本地模拟 MongoDB 和 MySQL 的环境进行预迁移，确保我们能够尽快地发现迁移脚本中的错误。</p>

<p><img src="https://img.draveness.me/2017-10-10-mongodb-pre-migration.png" alt="mongodb-pre-migration" /></p>

<p>准备测试数据库的办法是通过关系删除一些主要模型的数据行，在删除时可以通过 MongoDB 中的 <code class="highlighter-rouge">dependent: :destroy</code> 删除相关的模型，这样可以尽可能的保证数据的一致性和完整性，但是在对线上数据库进行迁移之前，我们依然需要对 MongoDB 中的全部数据进行全量的迁移测试，这样可以发现一些更加隐蔽的问题，保证真正上线时可以出现更少的状况。</p>

<p>数据库的迁移其实也属于重构，在进行 MongoDB 的数据库迁移之前一定要保证项目有着完善的测试体系和测试用例，这样才能让我们在项目重构之后，确定不会出现我们难以预料的问题，整个项目才是可控的，如果工程中没有足够的测试甚至没有测试，那么就不要再说重构这件事情了 – <strong>单元测试是重构的基础</strong>。</p>

<h2 id="总结">总结</h2>

<p>如何从 MongoDB 迁移到 MySQL 其实是一个工程问题，我们需要在整个过程中不断寻找可能出错的问题，将一个比较复杂的任务进行拆分，在真正做迁移之前尽可能地减少迁移对服务可用性以及稳定性带来的影响。</p>

<p><img src="https://img.draveness.me/2017-10-10-mysql-and-mongodb-work-together.png" alt="mysql-and-mongodb-work-together" /></p>

<p>除此之外，MongoDB 和 MySQL 之间的选择也不一定是非此即彼，我们将项目中的大部分数据都迁移到了 MySQL 中，但是将一部分用于计算和分析的数据留在了 MongoDB，这样就可以保证 MongoDB 宕机之后仍然不会影响项目的主要任务，同时，MySQL 的备份和恢复速度也会因为数据库变小而非常迅速。</p>

<p>最后一点，测试真的很重要，如果没有测试，没有人能够做到在<strong>修改大量的业务代码的过程中不丢失任何的业务逻辑</strong>，甚至如果没有测试，很多业务逻辑可能在开发的那一天就已经丢失了。</p>

<p>如果对文章的内容有疑问或者有 MongoDB 迁移相关的问题，可以在评论中留言。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://www.quora.com/How-do-I-migrate-data-from-a-MongoDB-to-MySQL-database-Can-it-be-done-in-a-real-time-scenario-What-are-the-pros-and-cons-for-each-migration-Which-one-do-you-advice-What-is-your-experience-Any-reference-DB-expert-who-can-do-it">How do I migrate data from a MongoDB to MySQL database? · Quora</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Sidekiq 如何处理异步任务</title>
	  <link>/blogs//sidekiq</link>
	  <author></author>
	  <pubDate>2017-08-28T00:00:00+00:00</pubDate>
	  <guid>/blogs//sidekiq</guid>
	  <description><![CDATA[
	     <p><a href="https://github.com/mperham/sidekiq">Sidekiq</a> 是 Ruby 和 Rails 项目中常用的后台任务处理系统，其本身提供的 API 十分简洁，源代码也非常易于阅读，是一个轻量级的异步处理组件；虽然其本身没有提供太多复杂的功能，但是它的使用和部署非常简单。在这篇文章中，我们将对 Sidekiq 的实现原理进行介绍和分析。</p>

<p><img src="https://img.draveness.me/2017-08-28-Sidekiq-Cover.jpg-1000width" alt="Sidekiq-Cover" /></p>

<p>文章中并不会详细介绍 Sidekiq 的使用，也并不是一篇 Sidekiq 的教程，在这里我们会介绍任务的入队过程、Sidekiq 任务在 Redis 中的存储方式和消费者对任务的处理过程，除此之外，文章将介绍 Sidekiq 中间件的实现以及任务重试的原理。</p>

<h2 id="概述">概述</h2>

<p>在具体分析介绍 Sidekiq 的实现原理之前，我们需要对整个组件的使用过程进行概述，保证我们对 Sidekiq 的结构有一个总体上的了解。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HardWorker</span>
  <span class="kp">include</span> <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Worker</span>
  <span class="k">def</span> <span class="nf">perform</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
    <span class="c1"># do something</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">HardWorker</span><span class="p">.</span><span class="nf">perform_async</span><span class="p">(</span><span class="s1">'bob'</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</code></pre></div></div>

<p>在这里，我们直接照搬 Sidekiq Wiki 中 <a href="https://github.com/mperham/sidekiq/wiki/Getting-Started">Getting Started</a> 部分的代码简单展示下它是如何使用的，当我们执行 <code class="highlighter-rouge">HardWorker.perform_async</code> 方法时，Sidekiq 的 Worker 会将一个异步任务以 JSON 的形式将相关的信息加入 Redis 中并等待消费者对任务的拉取和处理。</p>

<p><img src="https://img.draveness.me/2017-08-28-Sidekiq-Arch.jpg-1000width" alt="Sidekiq-Arch" /></p>

<p>Sidekiq 的消费者有三个部分组成，分别是 <code class="highlighter-rouge">Manager</code>、<code class="highlighter-rouge">Processor</code> 和 <code class="highlighter-rouge">Poller</code>；他们三者会相互协作共同完成对 Redis 中任务消费的过程。</p>

<blockquote>
  <p>需要注意的是，Sidekiq 中的 <code class="highlighter-rouge">Sidekiq::Worker</code> 并不是真正用于处理任务的 Worker，负责执行执行任务的类型其实是 <code class="highlighter-rouge">Sidekiq::Processor</code>；在文章中，当我们提到 Sidekiq Worker 时，其实说的是 <code class="highlighter-rouge">Sidekiq::Processor</code>，当我们使用了形如 <code class="highlighter-rouge">Sidekiq::Worker</code> 或者 <code class="highlighter-rouge">Worker</code> 的形式时，我们说的就是对应的类。</p>
</blockquote>

<h2 id="异步任务的入队">异步任务的入队</h2>

<p>当我们对需要异步执行的任务调用类似 <code class="highlighter-rouge">Worker.perform_async</code> 的方法时，Sidekiq 其实并不会真正去创建一个 <code class="highlighter-rouge">HardWorker</code> 等 <code class="highlighter-rouge">Worker</code> 的对象，它实际上会调用 <code class="highlighter-rouge">Worker.client_push</code> 方法并将当前的 <code class="highlighter-rouge">class</code> 和 <code class="highlighter-rouge">args</code> 参数传进去，也就是需要异步执行的类和参数：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">perform_async</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">client_push</span><span class="p">(</span><span class="s1">'class'</span><span class="p">.</span><span class="nf">freeze</span> <span class="o">=&gt;</span> <span class="nb">self</span><span class="p">,</span> <span class="s1">'args'</span><span class="p">.</span><span class="nf">freeze</span> <span class="o">=&gt;</span> <span class="n">args</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>除了 <code class="highlighter-rouge">Worker.perform_async</code> 之外，<code class="highlighter-rouge">Worker</code> 还提供了另外一对用于<strong>在一段时间之后或者某个时间点</strong>执行相应任务的方法 <code class="highlighter-rouge">Worker.perform_at</code> 和 <code class="highlighter-rouge">Worker.perform_in</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">perform_in</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">int</span> <span class="o">=</span> <span class="n">interval</span><span class="p">.</span><span class="nf">to_f</span>
  <span class="n">now</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span>
  <span class="n">ts</span> <span class="o">=</span> <span class="p">(</span><span class="n">int</span> <span class="o">&lt;</span> <span class="mi">1_000_000_000</span> <span class="p">?</span> <span class="n">now</span> <span class="o">+</span> <span class="n">int</span> <span class="p">:</span> <span class="n">int</span><span class="p">)</span>
  <span class="n">item</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">'class'</span><span class="p">.</span><span class="nf">freeze</span> <span class="o">=&gt;</span> <span class="nb">self</span><span class="p">,</span> <span class="s1">'args'</span><span class="p">.</span><span class="nf">freeze</span> <span class="o">=&gt;</span> <span class="n">args</span><span class="p">,</span> <span class="s1">'at'</span><span class="p">.</span><span class="nf">freeze</span> <span class="o">=&gt;</span> <span class="n">ts</span> <span class="p">}</span>
  <span class="n">item</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="s1">'at'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">)</span> <span class="k">if</span> <span class="n">ts</span> <span class="o">&lt;=</span> <span class="n">now</span>
  <span class="n">client_push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="k">end</span>
<span class="kp">alias_method</span> <span class="ss">:perform_at</span><span class="p">,</span> <span class="ss">:perform_in</span>
</code></pre></div></div>

<p>为了使用同一个接口支持两种不同的安排方式（时间点和多久之后），方法内部对传入的 <code class="highlighter-rouge">internal</code> 进行了判断，当 <code class="highlighter-rouge">interval.to_f &lt; 1_000_000_000</code> 时就会在一段时间之后执行任务，否则就会以时间点的方式执行任务，虽然 <code class="highlighter-rouge">Worker.perform_at</code> 和 <code class="highlighter-rouge">Worker.perform_in</code> 是完全相同的方法，不过我们在使用时还是尽量遵循方法的语义选择两者中更符合逻辑的方法。</p>

<p><img src="https://img.draveness.me/2017-08-28-Client-Push-Item.jpg-1000width" alt="Client-Push-Item" /></p>

<p>两种创建异步任务的方式，最终都执行了 <code class="highlighter-rouge">Worker.client_push</code> 方法并传入了一个哈希，其中可能包含以上三个部分的内容；在方法的实现中，它获取了上下文中的 Redis 池并将传入的 <code class="highlighter-rouge">item</code> 对象传入 Redis 中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">client_push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
  <span class="n">pool</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">[</span><span class="ss">:sidekiq_via_pool</span><span class="p">]</span> <span class="o">||</span> <span class="n">get_sidekiq_options</span><span class="p">[</span><span class="s1">'pool'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span> <span class="o">||</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">redis_pool</span>
  <span class="n">item</span><span class="p">.</span><span class="nf">keys</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="o">|</span>
    <span class="n">item</span><span class="p">[</span><span class="n">key</span><span class="p">.</span><span class="nf">to_s</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Client</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">pool</span><span class="p">).</span><span class="nf">push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>简单整理一下，从 <code class="highlighter-rouge">Worker.perform_async</code> 方法到 <code class="highlighter-rouge">Client#push</code> 方法整个过程都在对即将加入到 Redis 中队列的哈希进行操作，从添加 <code class="highlighter-rouge">at</code> 字段到字符串化、再到 <code class="highlighter-rouge">Client#normalize_item</code> 方法中添加 <code class="highlighter-rouge">jid</code> 和 <code class="highlighter-rouge">created_at</code> 字段。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
  <span class="n">normed</span> <span class="o">=</span> <span class="n">normalize_item</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
  <span class="n">payload</span> <span class="o">=</span> <span class="n">process_single</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s1">'class'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">],</span> <span class="n">normed</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">payload</span>
    <span class="n">raw_push</span><span class="p">([</span><span class="n">payload</span><span class="p">])</span>
    <span class="n">payload</span><span class="p">[</span><span class="s1">'jid'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>所有添加异步任务的方法最终都调用了私有方法 <code class="highlighter-rouge">Client#raw_push</code> 以及 <code class="highlighter-rouge">Client#atomic_push</code> 向 Redis 中添加数据，在这时会有两种不同的情况发生，当异步任务需要在未来的某一时间点进行安排时，它会加入 Redis 的一个有序集合：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">atomc_push</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">payloads</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">payloads</span><span class="p">.</span><span class="nf">first</span><span class="p">[</span><span class="s1">'at'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
    <span class="n">conn</span><span class="p">.</span><span class="nf">zadd</span><span class="p">(</span><span class="s1">'schedule'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">,</span> <span class="n">payloads</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="nb">hash</span><span class="o">|</span>
                <span class="n">at</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="s1">'at'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">).</span><span class="nf">to_s</span>
                <span class="p">[</span><span class="n">at</span><span class="p">,</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">dump_json</span><span class="p">(</span><span class="nb">hash</span><span class="p">)]</span>
              <span class="k">end</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个有序集合中，Sidekiq 理所应当地将 <code class="highlighter-rouge">schedule</code> 作为权重，而其他的全部字段都以 JSON 的格式作为负载传入；但是当 Sidekiq 遇到需要立即执行的异步任务时，实现就有一些不同了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">atomc_push</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">payloads</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">payloads</span><span class="p">.</span><span class="nf">first</span><span class="p">[</span><span class="s1">'at'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
  <span class="c1"># ...</span>
  <span class="k">else</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">payloads</span><span class="p">.</span><span class="nf">first</span><span class="p">[</span><span class="s1">'queue'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
    <span class="n">now</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span>
    <span class="n">to_push</span> <span class="o">=</span> <span class="n">payloads</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">entry</span><span class="o">|</span>
      <span class="n">entry</span><span class="p">[</span><span class="s1">'enqueued_at'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span> <span class="o">=</span> <span class="n">now</span>
      <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">dump_json</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">conn</span><span class="p">.</span><span class="nf">sadd</span><span class="p">(</span><span class="s1">'queues'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">conn</span><span class="p">.</span><span class="nf">lpush</span><span class="p">(</span><span class="s2">"queue:</span><span class="si">#{</span><span class="n">q</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="n">to_push</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>除了设置当前任务的入队时间 <code class="highlighter-rouge">enqueued_at</code> 之外，Sidekiq 将队列加入到一个大队列 <code class="highlighter-rouge">queues</code> 的集合中，并且将负载直接推到 <code class="highlighter-rouge">"queue:#{q}"</code> 数组中等待消费者的拉取，我们稍微梳理一下两种安排异步队列方法的调用过程：</p>

<p><img src="https://img.draveness.me/2017-08-28-Async-Schedule.jpg-1000width" alt="Async-Schedule" /></p>

<h3 id="redis-中的存储">Redis 中的存储</h3>

<p>无论是立即执行还是需要安排的异步任务都会进入 Redis 的队列中，但是它们之间还是有一些区别的，<code class="highlighter-rouge">Worker.perform_in/at</code> 会将任务以 <code class="highlighter-rouge">[at, args]</code> 的形式加入到 <code class="highlighter-rouge">schedules</code> 有序集中，而
<code class="highlighter-rouge">Worker.perform_async</code> 将负载加入到指定的队列，并向整个 Sidekiq 的队列集合 <code class="highlighter-rouge">queues</code> 中添加该队列。</p>

<p><img src="https://img.draveness.me/2017-08-28-Perform-async-in-Redis.jpg-1000width" alt="Perform-async-in-Redis" /></p>

<p>所有的 <code class="highlighter-rouge">payload</code> 中都包含了一个异步任务需要执行的全部信息，包括该任务的执行的队列 <code class="highlighter-rouge">queue</code>、异步队列的类 <code class="highlighter-rouge">class</code>、参数 <code class="highlighter-rouge">args</code> 以及 <code class="highlighter-rouge">sidekiq_options</code> 中的全部参数。</p>

<p><img src="https://img.draveness.me/2017-08-28-Job-in-Redis.jpg-1000width" alt="Job-in-Redis" /></p>

<p>除了上述参数，一个异步任务还包含诸如 <code class="highlighter-rouge">created_at</code>、<code class="highlighter-rouge">enqueued_at</code> 等信息，也有一个通过 <code class="highlighter-rouge">SecureRandom.hex(12)</code> 生成的任务唯一标识符 <code class="highlighter-rouge">jid</code>。</p>

<h2 id="sidekiq-的启动过程">Sidekiq 的启动过程</h2>

<p>作者对于 Sidekiq 印象最深刻的就是它在命令行启动的时候输出的一个字符画，我们能在 <code class="highlighter-rouge">cli.rb</code> 的 <code class="highlighter-rouge">Cli.banner</code> 方法中找到这个字符画：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>         m,
         `$b
    .ss,  $$:         .,d$
    `$$P,d$P'    .,md$P"'
     ,$$$$$bmmd$$$P^'
   .d$$$$$$$$$$P'
   $$^' `"^$$$'       ____  _     _      _    _
   $:     ,$$:       / ___|(_) __| | ___| | _(_) __ _
   `b     :$$        \___ \| |/ _` |/ _ \ |/ / |/ _` |
          $$:         ___) | | (_| |  __/   &lt;| | (_| |
          $$         |____/|_|\__,_|\___|_|\_\_|\__, |
        .d$$                                       |_|
</code></pre></div></div>

<p>这一节也将介绍 Sidekiq 的启动过程，在 <code class="highlighter-rouge">bin</code> 文件夹中的 sidekiq 文件包含的内容就是在命令行执行 <code class="highlighter-rouge">sidekiq</code> 时执行的代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">begin</span>
  <span class="n">cli</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="o">::</span><span class="no">CLI</span><span class="p">.</span><span class="nf">instance</span>
  <span class="n">cli</span><span class="p">.</span><span class="nf">parse</span>
  <span class="n">cli</span><span class="p">.</span><span class="nf">run</span>
<span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这里的代码就是创建了一个 <code class="highlighter-rouge">CLI</code> 对象，执行 <code class="highlighter-rouge">CLI#parse</code> 方法对参数进行解析，最后调用 <code class="highlighter-rouge">CLI#run</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run</span>
  <span class="n">print_banner</span>

  <span class="n">self_read</span><span class="p">,</span> <span class="n">self_write</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>
  <span class="c1"># ...</span>

  <span class="n">launcher</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Launcher</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
  <span class="k">begin</span>
    <span class="n">launcher</span><span class="p">.</span><span class="nf">run</span>
    <span class="k">while</span> <span class="n">readable_io</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">select</span><span class="p">([</span><span class="n">self_read</span><span class="p">])</span>
      <span class="n">signal</span> <span class="o">=</span> <span class="n">readable_io</span><span class="p">.</span><span class="nf">first</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">gets</span><span class="p">.</span><span class="nf">strip</span>
      <span class="n">handle_signal</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="no">Interrupt</span>
    <span class="n">launcher</span><span class="p">.</span><span class="nf">stop</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="从-launcher-到-manager">从 Launcher 到 Manager</h3>

<p><code class="highlighter-rouge">CLI#run</code> 在执行最开始就会打印 banner，也就是我们在每次启动 Sidekiq 时看到的字符画，而在之后会执行 <code class="highlighter-rouge">Launcher#run</code> 运行用于处理异步任务的 <code class="highlighter-rouge">Processor</code> 等对象。</p>

<p><img src="https://img.draveness.me/2017-08-28-Launcher-Poller-Manager-Processors.jpg-1000width" alt="Launcher-Poller-Manager-Processors" /></p>

<p>每一个 <code class="highlighter-rouge">Launcher</code> 都会启动一个 <code class="highlighter-rouge">Manager</code> 对象和一个 <code class="highlighter-rouge">Poller</code>，其中 <code class="highlighter-rouge">Manager</code> 同时管理了多个 <code class="highlighter-rouge">Processor</code> 对象，这些不同的类之间有着如上图所示的关系。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run</span>
  <span class="vi">@thread</span> <span class="o">=</span> <span class="n">safe_thread</span><span class="p">(</span><span class="s2">"heartbeat"</span><span class="p">,</span> <span class="o">&amp;</span><span class="nb">method</span><span class="p">(</span><span class="ss">:start_heartbeat</span><span class="p">))</span>
  <span class="vi">@poller</span><span class="p">.</span><span class="nf">start</span>
  <span class="vi">@manager</span><span class="p">.</span><span class="nf">start</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Manager</code> 会在初始化时根据传入的 <code class="highlighter-rouge">concurrency</code> 的值创建对应数量的 <code class="highlighter-rouge">Processor</code>，默认的并行数量为 25；当执行 <code class="highlighter-rouge">Manager#start</code> 时，就会启动对应数量的<strong>线程</strong>和处理器开始对任务进行处理：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Manager</span>
  <span class="k">def</span> <span class="nf">start</span>
    <span class="vi">@workers</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
      <span class="n">x</span><span class="p">.</span><span class="nf">start</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Processor</span>
  <span class="k">def</span> <span class="nf">start</span>
    <span class="vi">@thread</span> <span class="o">||=</span> <span class="n">safe_thread</span><span class="p">(</span><span class="s2">"processor"</span><span class="p">,</span> <span class="o">&amp;</span><span class="nb">method</span><span class="p">(</span><span class="ss">:run</span><span class="p">))</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>从 <code class="highlighter-rouge">Launcher</code> 的启动到现在只是一个调用 <code class="highlighter-rouge">initialize</code> 和 <code class="highlighter-rouge">start</code> 方法的过程，再加上 Sidekiq 源代码非常简单，所以阅读起没有丝毫的难度，也就不做太多的解释了。</p>

<h3 id="并行模型">并行模型</h3>

<p>当处理器开始执行 <code class="highlighter-rouge">Processor#run</code> 方法时，就开始对所有的任务进行处理了；从总体来看，Sidekiq 使用了多线程的模型对任务进行处理，每一个 <code class="highlighter-rouge">Processor</code> 都是使用了 <code class="highlighter-rouge">safe_thread</code> 方法在一个新的线程里面运行的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">safe_thread</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">[</span><span class="s1">'sidekiq_label'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span> <span class="o">=</span> <span class="nb">name</span>
    <span class="n">watchdog</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在使用 Sidekiq 时，我们也会在不同的机器上开启多个 Sidekiq Worker，也就是说 Sidekiq 可以以多进程、多线程的方式运行，同时处理大量的异步任务。</p>

<p><img src="https://img.draveness.me/2017-08-28-Sidekiq-Multi-Processes.jpg-1000width" alt="Sidekiq-Multi-Processes" /></p>

<p>到目前为止，我们已经分析了异步任务的入队以及 Sidekiq Worker 的启动过程了，接下来即将分析 Sidekiq 对异步任务的处理过程。</p>

<h3 id="主题的订阅">『主题』的订阅</h3>

<p>作为一个 Sidekiq Worker 进程，它在启动时就会决定选择订阅哪些『主题』去执行，比如当我们使用下面的命令时：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> sidekiq <span class="nt">-q</span> critical,2 <span class="nt">-q</span> default
</code></pre></div></div>

<p><code class="highlighter-rouge">CLI#parse</code> 方法会对传入的 <code class="highlighter-rouge">-q</code> 参数进行解析，但是当执行 <code class="highlighter-rouge">sidekiq</code> 命令却没有传入队列参数时，Sidekiq 只会订阅 <code class="highlighter-rouge">default</code> 队列中的任务：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="no">ARGV</span><span class="p">)</span>
  <span class="c1"># ...</span>
  <span class="n">validate!</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">validate!</span>
  <span class="n">options</span><span class="p">[</span><span class="ss">:queues</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s1">'default'</span> <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="ss">:queues</span><span class="p">].</span><span class="nf">empty?</span>
<span class="k">end</span>
</code></pre></div></div>

<p>同时，默认情况下的队列的优先级都为 <code class="highlighter-rouge">1</code>，高优先级的队列在当前的任务中可以得到更多的执行机会，实现的方法是通过增加同一个 <code class="highlighter-rouge">queues</code> 集合中高优先级队列的数量，我们可以在 <code class="highlighter-rouge">CLI#parse_queue</code> 中找到实现这一功能的代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parse_queue</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kp">nil</span><span class="p">)</span>
  <span class="p">[</span><span class="n">weight</span><span class="p">.</span><span class="nf">to_i</span><span class="p">,</span> <span class="mi">1</span><span class="p">].</span><span class="nf">max</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
    <span class="p">(</span><span class="n">opts</span><span class="p">[</span><span class="ss">:queues</span><span class="p">]</span> <span class="o">||=</span> <span class="p">[])</span> <span class="o">&lt;&lt;</span> <span class="n">q</span>
  <span class="k">end</span>
  <span class="n">opts</span><span class="p">[</span><span class="ss">:strict</span><span class="p">]</span> <span class="o">=</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">weight</span><span class="p">.</span><span class="nf">to_i</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="k">end</span>
</code></pre></div></div>

<p>到这里，其实我们就完成了设置过程中 Sidekiq Worker 『主题』订阅的功能了，我们将在后面 <a href="#执行任务">执行任务</a> 的部分具体介绍 Sidekiq 是如何使用这些参数的。</p>

<h2 id="异步任务的处理">异步任务的处理</h2>

<p>从异步任务的入队一节中，我们可以清楚地看到使用 <code class="highlighter-rouge">#perform_async</code> 和 <code class="highlighter-rouge">#perform_in</code> 两种方法创建的数据结构 <code class="highlighter-rouge">payload</code> 最终以不同的方式进入了 Redis 中，所以在这里我们将异步任务的处理分为定时任务和『立即』任务两个部分，分别对它们不同的处理方式进行分析。</p>

<h3 id="定时任务">定时任务</h3>

<p>Sidekiq 使用 <code class="highlighter-rouge">Scheduled::Poller</code> 对 Redis 中 <code class="highlighter-rouge">schedules</code> 有序集合中的负载进行处理，其中包括 <code class="highlighter-rouge">retry</code> 和 <code class="highlighter-rouge">schedule</code> 两个有序集合中的内容。</p>

<p><img src="https://img.draveness.me/2017-08-28-Redis-Sorted-Set.jpg-1000width" alt="Redis-Sorted-Set" /></p>

<p>在 <code class="highlighter-rouge">Poller</code> 被 <code class="highlighter-rouge">Scheduled::Poller</code> 启动时会调用 <code class="highlighter-rouge">#start</code> 方法开始对上述两个有序集合轮训，<code class="highlighter-rouge">retry</code> 中包含了所有重试的任务，而 <code class="highlighter-rouge">schedule</code> 就是被安排到指定时间执行的定时任务了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">start</span>
  <span class="vi">@thread</span> <span class="o">||=</span> <span class="n">safe_thread</span><span class="p">(</span><span class="s2">"scheduler"</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">initial_wait</span>
    <span class="k">while</span> <span class="o">!</span><span class="vi">@done</span>
      <span class="n">enqueue</span>
      <span class="n">wait</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Scheduled::Poller#start</code> 方法内部执行了一个 <code class="highlighter-rouge">while</code> 循环，在循环内部也只包含入队和等待两个操作，用于入队的方法最终调用了 <code class="highlighter-rouge">Scheduled::Poll::Enq#enqueue_jobs</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">enqueue_jobs</span><span class="p">(</span><span class="n">now</span><span class="o">=</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span><span class="p">.</span><span class="nf">to_s</span><span class="p">,</span> <span class="n">sorted_sets</span><span class="o">=</span><span class="no">SETS</span><span class="p">)</span>
  <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">redis</span> <span class="k">do</span> <span class="o">|</span><span class="n">conn</span><span class="o">|</span>
    <span class="n">sorted_sets</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">sorted_set</span><span class="o">|</span>
      <span class="k">while</span> <span class="n">job</span> <span class="o">=</span> <span class="n">conn</span><span class="p">.</span><span class="nf">zrangebyscore</span><span class="p">(</span><span class="n">sorted_set</span><span class="p">,</span> <span class="s1">'-inf'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="ss">:limit</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]).</span><span class="nf">first</span> <span class="k">do</span>
        <span class="k">if</span> <span class="n">conn</span><span class="p">.</span><span class="nf">zrem</span><span class="p">(</span><span class="n">sorted_set</span><span class="p">,</span> <span class="n">job</span><span class="p">)</span>
          <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Client</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="no">Sidekiq</span><span class="p">.</span><span class="nf">load_json</span><span class="p">(</span><span class="n">job</span><span class="p">))</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>传入的 <code class="highlighter-rouge">SETS</code> 其实就是 <code class="highlighter-rouge">retry</code> 和 <code class="highlighter-rouge">schedule</code> 构成的数组，在上述方法中，Sidekiq 通过一个 <code class="highlighter-rouge">Redis#zrangebyscore</code> 和 <code class="highlighter-rouge">Redis#zrem</code> 将集合中小于当前时间的任务全部加到立即任务中，最终调用是在前面已经提到过的 <code class="highlighter-rouge">Client#push</code> 方法将任务推到指定的队列中。</p>

<p><img src="https://img.draveness.me/2017-08-28-Redis-Sidekiq-Poller.jpg-1000width" alt="Redis-Sidekiq-Poller" /></p>

<p>由于 <code class="highlighter-rouge">Scheduled::Poller</code> 并不是不停地对 Redis 中的数据进行处理的，因为当前进程一直都在执行 <code class="highlighter-rouge">Poller#enqueue</code> 其实是一个非常低效的方式，所以 Sidekiq 会在每次执行 <code class="highlighter-rouge">Poller#enqueue</code> 之后，执行 <code class="highlighter-rouge">Poller#wait</code> 方法，随机等待一段时间：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">wait</span>
  <span class="vi">@sleeper</span><span class="p">.</span><span class="nf">pop</span><span class="p">(</span><span class="n">random_poll_interval</span><span class="p">)</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">random_poll_interval</span>
  <span class="n">poll_interval_average</span> <span class="o">*</span> <span class="nb">rand</span> <span class="o">+</span> <span class="n">poll_interval_average</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">/</span> <span class="mi">2</span>
<span class="k">end</span>
</code></pre></div></div>

<p>随机等待时间的范围在 <code class="highlighter-rouge">[0.5 * poll_interval_average, 1.5 * poll_interval_average]</code> 之间；通过随机的方式，Sidekiq 可以避免在多个线程处理任务时，短时间内 Redis 接受大量的请求发生延迟等问题，能够保证从长期来看 Redis 接受的请求数是平均的；同时因为 <code class="highlighter-rouge">Scheduled::Poller</code> 使用了 <code class="highlighter-rouge">#enqueue</code> 加 <code class="highlighter-rouge">#wait</code> 对 Redis 中的数据进行消费，所以没有办法保证任务会在指定的时间点执行，<strong>执行的时间一定比安排的时间要晚</strong>，这也是我们在使用 Sidekiq 时需要注意的。</p>

<blockquote>
  <p>随机等待的时间其实不止与 <code class="highlighter-rouge">poll_interval_average</code> 有关，在默认情况下，它是当前进程数的 15 倍，在有 30 个 Sidekiq 线程时，每个线程会每隔 225 ~ 675s 的时间请求一次。</p>
</blockquote>

<h3 id="执行任务">执行任务</h3>

<p>定时任务是由 <code class="highlighter-rouge">Scheduled::Poller</code> 进行处理的，将其中需要执行的异步任务加入到指定的队列中，而这些任务最终都会在 <code class="highlighter-rouge">Processor#run</code> 真正被执行：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run</span>
  <span class="k">begin</span>
    <span class="k">while</span> <span class="o">!</span><span class="vi">@done</span>
      <span class="n">process_one</span>
    <span class="k">end</span>
    <span class="vi">@mgr</span><span class="p">.</span><span class="nf">processor_stopped</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
  <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">ex</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当处理结束或者发生异常时会调用 <code class="highlighter-rouge">Manager#processor_stopped</code> 或者 <code class="highlighter-rouge">Manager#processor_died</code> 方法对 <code class="highlighter-rouge">Processor</code> 进行处理；在处理任务时其实也分为两个部分，也就是 <code class="highlighter-rouge">#fetch</code> 和 <code class="highlighter-rouge">#process</code> 两个方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">process_one</span>
  <span class="vi">@job</span> <span class="o">=</span> <span class="n">fetch</span>
  <span class="n">process</span><span class="p">(</span><span class="vi">@job</span><span class="p">)</span> <span class="k">if</span> <span class="vi">@job</span>
  <span class="vi">@job</span> <span class="o">=</span> <span class="kp">nil</span>
<span class="k">end</span>
</code></pre></div></div>

<p>我们先来看一下整个方法的调用栈，任务的获取从 <code class="highlighter-rouge">Processor#process_one</code> 一路调用下来，直到 <code class="highlighter-rouge">BasicFetch#retrive_work</code> 返回了 <code class="highlighter-rouge">UnitOfWork</code> 对象，返回的对象会经过分发最后执行对应类的 <code class="highlighter-rouge">#perform</code> 传入参数真正运行该任务：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Processor#process_one
├── Processor#fetch
│   └── Processor#get_one
│       └── BasicFetch#retrive_work
│           ├── Redis#brpop
│           └── UnitOfWork#new
└── Processor#process
    ├── Processor#dispatch
    ├── Processor#execute_job
    └── Worker#perform
</code></pre></div></div>

<p>对于任务的获取，我们需要关注的就是 <code class="highlighter-rouge">BasicFetch#retrive_work</code> 方法，他会从 Redis 中相应队列的有序数组中 <code class="highlighter-rouge">Redis#brpop</code> 出一个任务，然后封装成 <code class="highlighter-rouge">UnitOfWork</code> 对象后返回。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">retrieve_work</span>
  <span class="n">work</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">redis</span> <span class="p">{</span> <span class="o">|</span><span class="n">conn</span><span class="o">|</span> <span class="n">conn</span><span class="p">.</span><span class="nf">brpop</span><span class="p">(</span><span class="o">*</span><span class="n">queues_cmd</span><span class="p">)</span> <span class="p">}</span>
  <span class="no">UnitOfWork</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="o">*</span><span class="n">work</span><span class="p">)</span> <span class="k">if</span> <span class="n">work</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">#queues_cmd</code> 这个实例方法其实就用到了在主题的订阅一节中的 <code class="highlighter-rouge">queues</code> 参数，该参数会在 <code class="highlighter-rouge">Processor</code> 初始化是创建一个 <code class="highlighter-rouge">BasicFetch</code> 策略对象，最终在 <code class="highlighter-rouge">BasicFetch#queues_cmd</code> 方法调用时返回一个类似下面的数组：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">queue</span><span class="ss">:high</span>
<span class="n">queue</span><span class="ss">:high</span>
<span class="n">queue</span><span class="ss">:high</span>
<span class="n">queue</span><span class="ss">:low</span>
<span class="n">queue</span><span class="ss">:low</span>
<span class="n">queue</span><span class="ss">:default</span>
</code></pre></div></div>

<p>这样就可以实现了队列的优先级这一个功能了，返回的 <code class="highlighter-rouge">UnitOfWork</code> 其实是一个通过 <code class="highlighter-rouge">Struct.new</code> 创建的结构体，它会在 <code class="highlighter-rouge">Processor#process</code> 方法中作为资源被处理：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">work</span><span class="p">)</span>
  <span class="n">jobstr</span> <span class="o">=</span> <span class="n">work</span><span class="p">.</span><span class="nf">job</span>
  <span class="n">queue</span> <span class="o">=</span> <span class="n">work</span><span class="p">.</span><span class="nf">queue_name</span>

  <span class="k">begin</span>
    <span class="c1"># ...</span>

    <span class="n">job_hash</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">load_json</span><span class="p">(</span><span class="n">jobstr</span><span class="p">)</span>
    <span class="n">dispatch</span><span class="p">(</span><span class="n">job_hash</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">worker</span><span class="o">|</span>
      <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">server_middleware</span><span class="p">.</span><span class="nf">invoke</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">job_hash</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="k">do</span>
        <span class="n">execute_job</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">cloned</span><span class="p">(</span><span class="n">job_hash</span><span class="p">[</span><span class="s1">'args'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]))</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">ex</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>该方法对任务的执行其实总共有四个步骤：</p>

<ol>
  <li>将 Redis 中存储的字符串加载为 JSON；</li>
  <li>执行 <code class="highlighter-rouge">Processor#dispatch</code> 方法并在内部提供方法重试等功能，同时也实例化一个 <code class="highlighter-rouge">Sidekiq::Worker</code> 对象；</li>
  <li>依次执行服务端的中间件，可能会对参数进行更新；</li>
  <li>调用 <code class="highlighter-rouge">Processor#execute_job</code> 方法执行任务；</li>
</ol>

<p>而最后调用的时用于执行任务的方法 <code class="highlighter-rouge">Processor#execute_job</code>，它的实现也是到目前为止最为简单的方法之一了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_job</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">cloned_args</span><span class="p">)</span>
  <span class="n">worker</span><span class="p">.</span><span class="nf">perform</span><span class="p">(</span><span class="o">*</span><span class="n">cloned_args</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>该方法在<strong>线程</strong>中执行了客户端创建的 <code class="highlighter-rouge">Worker</code> 类的实例方法 <code class="highlighter-rouge">#perform</code> 并传入了经过两侧中间件处理后的参数。</p>

<h3 id="小结">小结</h3>

<p>到目前为止，Sidekiq Worker 对任务的消费过程就是圆满的了，从客户端创建一个拥有 <code class="highlighter-rouge">#perform</code> 方法的 <code class="highlighter-rouge">Worker</code> 到消费者去执行该方法形成了一个闭环，完成了对任务的调度。</p>

<p><img src="https://img.draveness.me/2017-08-28-Client-Redis-Sidekiq-Worker.jpg-1000width" alt="Client-Redis-Sidekiq-Worker" /></p>

<p>Sidekiq 是一个非常轻量级的任务调度系统，它使用 Redis 作为整个系统的消息队列，在两侧分别建立了生产者和消费者的模块，不过除了这几个比较重要的模块，Sidekiq 中还有一些功能是我们无法忽略的，比如中间件、兼容 ActiveJob 甚至是测试的实现，都是我们需要去了解的；接下来，我们将介绍和分析主干之外的『分叉』功能。</p>

<h2 id="中间件">中间件</h2>

<p>中间件模块是 Sidekiq 为我们在整个任务的处理流程提供的两个钩子，一个是在客户端的钩子，另一个在 Sidekiq Worker 中。</p>

<p><img src="https://img.draveness.me/2017-08-28-Middlewares-Client-Redis-Sidekiq-Worker.jpg-1000width" alt="Middlewares-Client-Redis-Sidekiq-Worker" /></p>

<p>中间件的使用其实非常简单，我们默认所有的中间件都会拥有一个实例方法 <code class="highlighter-rouge">#call</code> 并接受 <code class="highlighter-rouge">worker</code>、<code class="highlighter-rouge">job</code> 和 <code class="highlighter-rouge">queue</code> 三个参数，在使用时也只需要直接调用 <code class="highlighter-rouge">Chain#add</code> 方法将其加入数组就可以了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AcmeCo</span><span class="o">::</span><span class="no">MyMiddleware</span>
  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># config/initializers/sidekiq.rb</span>
<span class="no">Sidekiq</span><span class="p">.</span><span class="nf">configure_server</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">server_middleware</span> <span class="k">do</span> <span class="o">|</span><span class="n">chain</span><span class="o">|</span>
    <span class="n">chain</span><span class="p">.</span><span class="nf">add</span> <span class="no">AcmeCo</span><span class="o">::</span><span class="no">MyMiddleware</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Sidekiq 将中间件分为了客户端和服务端两个部分，这两个部分的中间件其实并不是严格意义上的在执行之前，由于执行时间点的不同，导致它们有不同的功能：</p>

<ul>
  <li>服务端中间件是『包围』了任务执行过程的，我们可以在中间件中使用 <code class="highlighter-rouge">begin</code>、<code class="highlighter-rouge">rescue</code> 语句，这样当任务出现问题时，我们就可以拿到异常了；</li>
  <li>客户端中间件在任务即将被推入 Redis 之前运行，它能够阻止任务进入 Redis 并且允许我们在任务入队前对其进行修改和停止；</li>
</ul>

<p>当我们对 Sidekiq 中间的使用都有一定的了解时，就可以开始分析中间件的实现了。</p>

<h3 id="实现">实现</h3>

<p>无论是异步任务真正进入队列之前，还是在客户端处理，跟任务有关的信息都会先通过一个预处理流程，客户端和服务端两个中间件的链式调用都使用 <code class="highlighter-rouge">Middleware::Chain</code> 中的类进行处理的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Chain</span>
  <span class="kp">include</span> <span class="no">Enumerable</span>
  <span class="nb">attr_reader</span> <span class="ss">:entries</span>

  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@entries</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">yield</span> <span class="nb">self</span> <span class="k">if</span> <span class="nb">block_given?</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="n">klass</span><span class="p">);</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">prepend</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">insert_before</span><span class="p">(</span><span class="n">oldklass</span><span class="p">,</span> <span class="n">newklass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">insert_after</span><span class="p">(</span><span class="n">oldklass</span><span class="p">,</span> <span class="n">newklass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span> <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>每一个 <code class="highlighter-rouge">Middleware::Chain</code> 中都包含一系列的 <code class="highlighter-rouge">Entry</code>，其中存储了中间件的相关信息，无论是客户端还是服务端都会在执行之前对每一个异步任务的参数执行 <code class="highlighter-rouge">invoke</code> 方法调用 <code class="highlighter-rouge">Middleware::Chain</code> 对象中的所有中间件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">invoke</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">chain</span> <span class="o">=</span> <span class="n">retrieve</span><span class="p">.</span><span class="nf">dup</span>
  <span class="n">traverse_chain</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="k">do</span>
    <span class="k">if</span> <span class="n">chain</span><span class="p">.</span><span class="nf">empty?</span>
      <span class="k">yield</span>
    <span class="k">else</span>
      <span class="n">chain</span><span class="p">.</span><span class="nf">shift</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">traverse_chain</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="n">traverse_chain</span><span class="p">.</span><span class="nf">call</span>
<span class="k">end</span>

</code></pre></div></div>

<p><code class="highlighter-rouge">Chain#invoke</code> 会对其持有的每一个中间件都执行 <code class="highlighter-rouge">#call</code> 方法，中间件都可以对异步任务的参数进行改变或者进行一些记录日志等操作，最后执行传入的 block 并返回结果。</p>

<p><img src="https://img.draveness.me/2017-08-28-Sidekiq-Middlewares.jpg-1000width" alt="Sidekiq-Middlewares" /></p>

<p>当异步队列入队时，就会执行 <code class="highlighter-rouge">Client#process_single</code> 方法调用 Sidekiq 载入中的全部中间件最后返回新的 <code class="highlighter-rouge">item</code> 对象：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">process_single</span><span class="p">(</span><span class="n">worker_class</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
  <span class="n">queue</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="s1">'queue'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
  <span class="n">middleware</span><span class="p">.</span><span class="nf">invoke</span><span class="p">(</span><span class="n">worker_class</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="vi">@redis_pool</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">item</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>每一个 Sidekiq Worker 在处理中间件时也基本遵循相同的逻辑，如 <code class="highlighter-rouge">#process</code> 方法先先执行各种中间件，最后再运行 block 中的内容。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">work</span><span class="p">)</span>
  <span class="n">jobstr</span> <span class="o">=</span> <span class="n">work</span><span class="p">.</span><span class="nf">job</span>
  <span class="n">queue</span> <span class="o">=</span> <span class="n">work</span><span class="p">.</span><span class="nf">queue_name</span>

  <span class="k">begin</span>
    <span class="c1"># ...</span>

    <span class="n">job_hash</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">load_json</span><span class="p">(</span><span class="n">jobstr</span><span class="p">)</span>
    <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">server_middleware</span><span class="p">.</span><span class="nf">invoke</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">job_hash</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">execute_job</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">cloned</span><span class="p">(</span><span class="n">job_hash</span><span class="p">[</span><span class="s1">'args'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]))</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">ex</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">#execute_job</code> 方法执行期间，由于异步任务可能抛出异常，在这时，我们注册的中间件就可以根据情况对异常进行捕获并选择是否对异常进行处理或者抛给上层了。</p>

<h2 id="任务的重试">任务的重试</h2>

<p>Sidekiq 中任务的重试是由 <code class="highlighter-rouge">JobRetry</code> 负责的，<code class="highlighter-rouge">Prcessor</code> 中的 <code class="highlighter-rouge">#dispatch</code> 方法中调用了 <code class="highlighter-rouge">JobRetry#global</code> 方法捕获在异步任务执行过程中发生的错误：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="n">job_hash</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span>
  <span class="n">pristine</span> <span class="o">=</span> <span class="n">cloned</span><span class="p">(</span><span class="n">job_hash</span><span class="p">)</span>

  <span class="c1"># ...</span>
  <span class="vi">@retrier</span><span class="p">.</span><span class="nf">global</span><span class="p">(</span><span class="n">pristine</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">klass</span>  <span class="o">=</span> <span class="n">constantize</span><span class="p">(</span><span class="n">job_hash</span><span class="p">[</span><span class="s1">'class'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">])</span>
    <span class="n">worker</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">new</span>
    <span class="n">worker</span><span class="p">.</span><span class="nf">jid</span> <span class="o">=</span> <span class="n">job_hash</span><span class="p">[</span><span class="s1">'jid'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
    <span class="vi">@retrier</span><span class="p">.</span><span class="nf">local</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">pristine</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="k">do</span>
      <span class="k">yield</span> <span class="n">worker</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>任务的执行过程分别调用了两个 <code class="highlighter-rouge">JobRetry</code> 的方法 <code class="highlighter-rouge">#global</code> 和 <code class="highlighter-rouge">#local</code>，这两个方法在实现上差不多，都将执行异步任务的 block 包在了一个 <code class="highlighter-rouge">begin</code>、<code class="highlighter-rouge">rescue</code> 中，选择在合适的时间重试：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">local</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span>
  <span class="k">yield</span>
<span class="c1"># ...</span>
<span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="k">raise</span> <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Shutdown</span> <span class="k">if</span> <span class="n">exception_caused_by_shutdown?</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">msg</span><span class="p">[</span><span class="s1">'retry'</span><span class="p">]</span> <span class="o">==</span> <span class="kp">nil</span>
    <span class="n">msg</span><span class="p">[</span><span class="s1">'retry'</span><span class="p">]</span> <span class="o">=</span> <span class="n">worker</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">get_sidekiq_options</span><span class="p">[</span><span class="s1">'retry'</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">raise</span> <span class="n">e</span> <span class="k">unless</span> <span class="n">msg</span><span class="p">[</span><span class="s1">'retry'</span><span class="p">]</span>
  <span class="n">attempt_retry</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
  <span class="k">raise</span> <span class="no">Skip</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果我们在定义 <code class="highlighter-rouge">Worker</code> 时就禁用了重试，那么在这里就会直接抛出上层的异常，否则就会进入 <code class="highlighter-rouge">#attempt_retry</code> 方法安排任务进行重试：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">attempt_retry</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">exception</span><span class="p">)</span>
  <span class="n">max_retry_attempts</span> <span class="o">=</span> <span class="n">retry_attempts_from</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="s1">'retry'</span><span class="p">],</span> <span class="vi">@max_retries</span><span class="p">)</span>

  <span class="n">msg</span><span class="p">[</span><span class="s1">'queue'</span><span class="p">]</span> <span class="o">=</span> <span class="k">if</span> <span class="n">msg</span><span class="p">[</span><span class="s1">'retry_queue'</span><span class="p">]</span>
                   <span class="n">msg</span><span class="p">[</span><span class="s1">'retry_queue'</span><span class="p">]</span>
                 <span class="k">else</span>
                   <span class="n">queue</span>
                 <span class="k">end</span>

  <span class="n">count</span> <span class="o">=</span> <span class="k">if</span> <span class="n">msg</span><span class="p">[</span><span class="s1">'retry_count'</span><span class="p">]</span>
            <span class="n">msg</span><span class="p">[</span><span class="s1">'retried_at'</span><span class="p">]</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span>
            <span class="n">msg</span><span class="p">[</span><span class="s1">'retry_count'</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
          <span class="k">else</span>
            <span class="n">msg</span><span class="p">[</span><span class="s1">'failed_at'</span><span class="p">]</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span>
            <span class="n">msg</span><span class="p">[</span><span class="s1">'retry_count'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
          <span class="k">end</span>

  <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">max_retry_attempts</span>
    <span class="n">delay</span> <span class="o">=</span> <span class="n">delay_for</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">exception</span><span class="p">)</span>
    <span class="n">retry_at</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">+</span> <span class="n">delay</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">dump_json</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">redis</span> <span class="k">do</span> <span class="o">|</span><span class="n">conn</span><span class="o">|</span>
      <span class="n">conn</span><span class="p">.</span><span class="nf">zadd</span><span class="p">(</span><span class="s1">'retry'</span><span class="p">,</span> <span class="n">retry_at</span><span class="p">.</span><span class="nf">to_s</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">else</span>
    <span class="n">retries_exhausted</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">exception</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在上面其实我们提到过，<code class="highlighter-rouge">Poller</code> 每次会从两个有序集合 <code class="highlighter-rouge">retry</code> 和 <code class="highlighter-rouge">schedule</code> 中查找到时的任务加入到对应的队列中，在 <code class="highlighter-rouge">#attempt_retry</code> 方法中，就可以找到看到 <code class="highlighter-rouge">retry</code> 队列中的元素是如何加入的了。</p>

<p>当任务的重试次数超过了限定的重试次数之后，就会执行 <code class="highlighter-rouge">#retries_exhausted</code> 以及 <code class="highlighter-rouge"># send_to_morgue</code> 这一方法，将任务的负载加入 <code class="highlighter-rouge">DeadSet</code> 对象中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">send_to_morgue</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="n">payload</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">dump_json</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="no">DeadSet</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">kill</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这样整个任务的重试过程就结束了，Sidekiq 使用 <code class="highlighter-rouge">begin</code>、<code class="highlighter-rouge">rescue</code> 捕获整个流程中出现的异常，并根据传入的 <code class="highlighter-rouge">retry_count</code> 参数进行重试，调度过程还是非常简洁也非常容易理解的。</p>

<h2 id="总结">总结</h2>

<p>作为一个 Ruby 社区中广泛被使用的异步任务处理的依赖，它的实现是很简单的并且其源代码非常易于阅读，整体的架构也非常清晰。</p>

<p><img src="https://img.draveness.me/2017-08-28-Middlewares-Client-Redis-Sidekiq-Worker.jpg-1000width" alt="Middlewares-Client-Redis-Sidekiq-Worker" /></p>

<p>使用键值的内存数据库 Redis 作为客户端和 Worker 之间的桥梁，Redis 的使用简化了 Sidekiq 的很多逻辑，同时对中间件的支持也使其有着良好的扩展性，不过正其实现简单，所以例如任务取消以及定时任务这种比较常见的功能其本身都没有实现，有的是 Sidekiq 本身设计问题导致的，有的需要另外的插件，不过在绝大多数情况下，Sidekiq 都能完全满足我们的需要，解决绝大多数的问题。</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://github.com/mperham/sidekiq">Sidekiq</a></li>
  <li><a href="https://ruby-china.org/topics/31470">Sidekiq 任务调度流程分析</a></li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>
