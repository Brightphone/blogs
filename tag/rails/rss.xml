<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>brightphone.github.io/blogs/</title>
   
   <link></link>
   <description>A beautiful narrative written with the world's most elegant publishing platform. The story begins here.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>谈谈 Rack 的协议与实现</title>
	  <link>/blogs//rack</link>
	  <author></author>
	  <pubDate>2017-10-29T00:00:00+00:00</pubDate>
	  <guid>/blogs//rack</guid>
	  <description><![CDATA[
	     <ul>
  <li><a href="https://draveness.me/rack">谈谈 Rack 协议与实现</a></li>
  <li><a href="https://draveness.me/rack-webrick">浅谈 WEBrick 的多线程模型</a></li>
  <li><a href="https://draveness.me/rack-thin">浅谈 Thin 的事件驱动模型</a></li>
  <li><a href="https://draveness.me/rack-unicorn">浅谈 Unicorn 的多进程模型</a></li>
  <li><a href="https://draveness.me/rack-puma">浅谈 Puma 的并发模型与实现</a></li>
  <li><a href="https://draveness.me/ruby-webserver">Ruby Web 服务器的并发模型与性能</a></li>
</ul>

<p>作为 Rails 开发者，基本上每天都与 Rails 的各种 API 以及数据库打交道，Rails 的世界虽然非常简洁，不过其内部的实现还是很复杂的，很多刚刚接触 Rails 的开发者可能都不知道 Rails 其实就是一个 <a href="https://github.com/rack/rack">Rack</a> 应用，在这一系列的文章中，我们会分别介绍 Rack 以及一些常见的遵循 Rack 协议的 webserver 的实现原理。</p>

<p><img src="https://img.draveness.me/2017-10-29-rack-logo.png" alt="rack-logo" /></p>

<p>不只是 Rails，几乎所有的 Ruby 的 Web 框架都是一个 Rack 的应用，除了 Web 框架之外，Rack 也支持相当多的 Web 服务器，可以说 Ruby 世界几乎一切与 Web 相关的服务都与 Rack 有关。</p>

<p><img src="https://img.draveness.me/2017-10-29-rack-and-web-servers-frameworks.png" alt="rack-and-web-servers-frameworks" /></p>

<p>所以如果想要了解 Rails 或者其他 Web 服务底层的实现，那么一定需要了解 Rack 是如何成为应用容器（webserver）和应用框架之间的桥梁的，本文中介绍的是 2.0.3 版本的 rack。</p>

<h2 id="rack-协议">Rack 协议</h2>

<p>在 Rack 的协议中，将 Rack 应用描述成一个可以响应 <code class="highlighter-rouge">call</code> 方法的 Ruby 对象，它仅接受来自外界的一个参数，也就是环境，然后返回一个只包含三个值的数组，按照顺序分别是状态码、HTTP Headers 以及响应请求的正文。</p>

<blockquote>
  <p>A Rack application is a Ruby object (not a class) that responds to call. It takes exactly one argument, the environment and returns an Array of exactly three values: The status, the headers, and the body.</p>
</blockquote>

<p><img src="https://img.draveness.me/2017-10-29-rack-protocol.png" alt="rack-protoco" /></p>

<p>Rack 在 webserver 和应用框架之间提供了一套最小的 API 接口，如果 webserver 都遵循 Rack 提供的这套规则，那么所有的框架都能通过协议任意地改变底层使用 webserver；所有的 webserver 只需要在 <code class="highlighter-rouge">Rack::Handler</code> 的模块中创建一个实现了 <code class="highlighter-rouge">.run</code> 方法的类就可以了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Rack</span>
  <span class="k">module</span> <span class="nn">Handler</span>
    <span class="k">class</span> <span class="nc">WEBrick</span> <span class="o">&lt;</span> <span class="o">::</span><span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServlet</span><span class="o">::</span><span class="no">AbstractServlet</span>
      <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">run</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{})</span>
        <span class="c1"># ..</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这个类方法接受两个参数，分别是一个 Rack 应用对象和一个包含各种参数的 <code class="highlighter-rouge">options</code> 字典，其中可能包括自定义的 ip 地址和端口号以及各种配置，根据 Rack 协议，所有应用对象在接受到一个 <code class="highlighter-rouge">#call</code> 方法并且传入 <code class="highlighter-rouge">env</code> 时，都会返回一个三元组：</p>

<p><img src="https://img.draveness.me/2017-10-29-rack-app.png" alt="rack-app" /></p>

<p>最后的 <code class="highlighter-rouge">body</code> 响应体其实是一个由多个响应内容组成的数组，Rack 使用的 webserver 会将 <code class="highlighter-rouge">body</code> 中几个部分的连接到一起最后拼接成一个 HTTP 响应后返回。</p>

<h2 id="rack-的使用">Rack 的使用</h2>

<p>我们在大致了解 Rack 协议之后，其实可以从一段非常简单的代码入手来了解 Rack 是如何启动 webserver 来处理来自用户的请求的，我们可以在任意目录下创建如下所示的 config.ru 文件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># config.ru</span>

<span class="n">run</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">env</span><span class="o">|</span> <span class="p">[</span><span class="s1">'200'</span><span class="p">,</span> <span class="p">{</span><span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'text/html'</span><span class="p">},</span> <span class="p">[</span><span class="s1">'get rack\'d'</span><span class="p">]]</span> <span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>因为 <code class="highlighter-rouge">Proc</code> 对象也能够响应 <code class="highlighter-rouge">#call</code> 方法，所以上述的 Proc 对象也可以看做是一个 Rack 应用。</p>
</blockquote>

<p>接下来，我们在同一目录使用 <code class="highlighter-rouge">rackup</code> 命令在命令行中启动一个 webserver 进程：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>rackup config.ru
<span class="o">[</span>2017-10-26 22:59:26] INFO  WEBrick 1.3.1
<span class="o">[</span>2017-10-26 22:59:26] INFO  ruby 2.3.3 <span class="o">(</span>2016-11-21<span class="o">)</span> <span class="o">[</span>x86_64-darwin16]
<span class="o">[</span>2017-10-26 22:59:26] INFO  WEBrick::HTTPServer#start: <span class="nv">pid</span><span class="o">=</span>83546 <span class="nv">port</span><span class="o">=</span>9292
</code></pre></div></div>

<p>从命令的输出我们可以看到，使用 rackup 运行了一个 WEBrick 的进程，监听了 9292 端口，如果我们使用 curl 来访问对应的请求，就可以得到在 config.ru 文件中出现的 <code class="highlighter-rouge">'get rack\'d'</code> 文本：</p>

<blockquote>
  <p>在这篇文章中，作者都会使用开源的工具 <a href="https://github.com/jakubroztocil/httpie">httpie</a> 代替 curl 在命令行中发出 HTTP 请求，相比 curl 而言 httpie 能够提供与 HTTP 响应有关的更多信息。</p>
</blockquote>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">http</span> <span class="n">http</span><span class="ss">:/</span><span class="o">/</span><span class="n">localhost</span><span class="p">:</span><span class="mi">9292</span>
<span class="no">HTTP</span><span class="o">/</span><span class="mf">1.1</span> <span class="mi">200</span> <span class="no">OK</span>
<span class="no">Connection</span><span class="p">:</span> <span class="no">Keep</span><span class="o">-</span><span class="no">Alive</span>
<span class="no">Content</span><span class="o">-</span><span class="no">Type</span><span class="p">:</span> <span class="n">text</span><span class="o">/</span><span class="n">html</span>
<span class="no">Date</span><span class="p">:</span> <span class="no">Thu</span><span class="p">,</span> <span class="mi">26</span> <span class="no">Oct</span> <span class="mi">2017</span> <span class="mi">15</span><span class="p">:</span><span class="mo">07</span><span class="p">:</span><span class="mi">47</span> <span class="no">GMT</span>
<span class="no">Server</span><span class="p">:</span> <span class="no">WEBrick</span><span class="o">/</span><span class="mf">1.3</span><span class="o">.</span><span class="mi">1</span> <span class="p">(</span><span class="no">Ruby</span><span class="o">/</span><span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span><span class="o">/</span><span class="mi">2016</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">21</span><span class="p">)</span>
<span class="no">Transfer</span><span class="o">-</span><span class="no">Encoding</span><span class="p">:</span> <span class="n">chunked</span>

<span class="n">get</span> <span class="n">rack</span><span class="err">'</span><span class="n">d</span>
</code></pre></div></div>

<p>从上述请求返回的 HTTP 响应头中的信息，我们可以看到 WEBrick 确实按照 config.ru 文件中的代码对当前的 HTTP 请求进行了处理。</p>

<h3 id="中间件">中间件</h3>

<p>Rack 协议和中间件是 Rack 能达到今天地位不可或缺的两个功能或者说特性，Rack 协议规定了 webserver 和 Rack 应用之间应该如何通信，而 Rack 中间件能够在上层改变 HTTP 的响应或者请求，在不改变应用的基础上为 Rack 应用增加新的功能。</p>

<p>Rack 的中间件是一个实现了两个方法 <code class="highlighter-rouge">.initialize</code> 和 <code class="highlighter-rouge">#call</code> 的类，初始化方法会接受两个参数，分别是 <code class="highlighter-rouge">app</code> 和 <code class="highlighter-rouge">options</code> 字典，而 <code class="highlighter-rouge">#call</code> 方法接受一个参数也就是 HTTP 请求的环境参数 <code class="highlighter-rouge">env</code>，在这里我们创建了一个新的 Rack 中间件 <code class="highlighter-rouge">StatusLogger</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">StatusLogger</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{})</span>
    <span class="vi">@app</span> <span class="o">=</span> <span class="n">app</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">body</span> <span class="o">=</span> <span class="vi">@app</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="n">status</span>
    <span class="p">[</span><span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">body</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在所有的 <code class="highlighter-rouge">#call</code> 方法中都<strong>应该</strong>调用 <code class="highlighter-rouge">app.call</code> 让应用对 HTTP 请求进行处理并在方法结束时将所有的参数按照顺序返回。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">use</span> <span class="no">StatusLogger</span>
<span class="n">run</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">env</span><span class="o">|</span> <span class="p">[</span><span class="s1">'200'</span><span class="p">,</span> <span class="p">{</span><span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'text/html'</span><span class="p">},</span> <span class="p">[</span><span class="s1">'get rack\'d'</span><span class="p">]]</span> <span class="p">}</span>
</code></pre></div></div>

<p>如果需要使用某一个 Rack 中间件只需要在当前文件中使用 <code class="highlighter-rouge">use</code> 方法，在每次接收到来自用户的 HTTP 请求时都会打印出当前响应的状态码。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">rackup</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">19</span><span class="p">:</span><span class="mi">46</span><span class="p">:</span><span class="mi">40</span><span class="p">]</span> <span class="no">INFO</span>  <span class="no">WEBrick</span> <span class="mf">1.3</span><span class="o">.</span><span class="mi">1</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">19</span><span class="p">:</span><span class="mi">46</span><span class="p">:</span><span class="mi">40</span><span class="p">]</span> <span class="no">INFO</span>  <span class="n">ruby</span> <span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span> <span class="p">(</span><span class="mi">2016</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">21</span><span class="p">)</span> <span class="p">[</span><span class="n">x86_64</span><span class="o">-</span><span class="n">darwin16</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">19</span><span class="p">:</span><span class="mi">46</span><span class="p">:</span><span class="mi">40</span><span class="p">]</span> <span class="no">INFO</span>  <span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServer</span><span class="c1">#start: pid=5274 port=9292</span>
<span class="mi">200</span>
<span class="mf">127.0</span><span class="o">.</span><span class="mf">0.1</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">27</span><span class="o">/</span><span class="no">Oct</span><span class="o">/</span><span class="mi">2017</span><span class="p">:</span><span class="mi">19</span><span class="p">:</span><span class="mi">46</span><span class="p">:</span><span class="mi">53</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s2">"GET / HTTP/1.1"</span> <span class="mi">200</span> <span class="o">-</span> <span class="mf">0.0004</span>
</code></pre></div></div>

<p>除了直接通过 <code class="highlighter-rouge">use</code> 方法直接传入 <code class="highlighter-rouge">StatusLogger</code> 中间件之外，我们也可以在 <code class="highlighter-rouge">use</code> 中传入配置参数，所有的配置都会通过 <code class="highlighter-rouge">options</code> 最终初始化一个中间件的实例，比如，我们有以下的中间件 <code class="highlighter-rouge">BodyTransformer</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BodyTransformer</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{})</span>
    <span class="vi">@app</span> <span class="o">=</span> <span class="n">app</span>
    <span class="vi">@count</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:count</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">body</span> <span class="o">=</span> <span class="vi">@app</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="n">body</span> <span class="o">=</span> <span class="n">body</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">str</span><span class="o">|</span> <span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="o">...</span><span class="vi">@count</span><span class="p">].</span><span class="nf">upcase</span> <span class="o">+</span> <span class="n">str</span><span class="p">[</span><span class="vi">@count</span><span class="o">..-</span><span class="mi">1</span><span class="p">]</span> <span class="p">}</span>
    <span class="p">[</span><span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">body</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述中间件会在每次调用时都将 Rack 应用返回的 <code class="highlighter-rouge">body</code> 中前 <code class="highlighter-rouge">count</code> 个字符变成大写的，我们可以在 config.ru 中添加一个新的中间件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">use</span> <span class="no">StatusLogger</span>
<span class="n">use</span> <span class="no">BodyTransformer</span><span class="p">,</span> <span class="ss">count: </span><span class="mi">3</span>
<span class="n">run</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">env</span><span class="o">|</span> <span class="p">[</span><span class="s1">'200'</span><span class="p">,</span> <span class="p">{</span><span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'text/html'</span><span class="p">},</span> <span class="p">[</span><span class="s1">'get rack\'d'</span><span class="p">]]</span> <span class="p">}</span>
</code></pre></div></div>

<p>当我们再次使用 http 命令请求相同的 URL 时，就会获得不同的结果，同时由于我们保留了 <code class="highlighter-rouge">StatusLogger</code>，所以在 console 中也会打印出当前响应的状态码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># session 1</span>
<span class="err">$</span> <span class="n">rackup</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">21</span><span class="p">:</span><span class="mo">04</span><span class="p">:</span><span class="mo">05</span><span class="p">]</span> <span class="no">INFO</span>  <span class="no">WEBrick</span> <span class="mf">1.3</span><span class="o">.</span><span class="mi">1</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">21</span><span class="p">:</span><span class="mo">04</span><span class="p">:</span><span class="mo">05</span><span class="p">]</span> <span class="no">INFO</span>  <span class="n">ruby</span> <span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span> <span class="p">(</span><span class="mi">2016</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">21</span><span class="p">)</span> <span class="p">[</span><span class="n">x86_64</span><span class="o">-</span><span class="n">darwin16</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">21</span><span class="p">:</span><span class="mo">04</span><span class="p">:</span><span class="mo">05</span><span class="p">]</span> <span class="no">INFO</span>  <span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServer</span><span class="c1">#start: pid=7524 port=9292</span>
<span class="mi">200</span>
<span class="mf">127.0</span><span class="o">.</span><span class="mf">0.1</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">27</span><span class="o">/</span><span class="no">Oct</span><span class="o">/</span><span class="mi">2017</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span><span class="mo">04</span><span class="p">:</span><span class="mi">19</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s2">"GET / HTTP/1.1"</span> <span class="mi">200</span> <span class="o">-</span> <span class="mf">0.0005</span>

<span class="c1"># session 2</span>
<span class="err">$</span> <span class="n">http</span> <span class="n">http</span><span class="ss">:/</span><span class="o">/</span><span class="n">localhost</span><span class="p">:</span><span class="mi">9292</span>
<span class="no">HTTP</span><span class="o">/</span><span class="mf">1.1</span> <span class="mi">200</span> <span class="no">OK</span>
<span class="no">Connection</span><span class="p">:</span> <span class="no">Keep</span><span class="o">-</span><span class="no">Alive</span>
<span class="no">Content</span><span class="o">-</span><span class="no">Type</span><span class="p">:</span> <span class="n">text</span><span class="o">/</span><span class="n">html</span>
<span class="no">Date</span><span class="p">:</span> <span class="no">Fri</span><span class="p">,</span> <span class="mi">27</span> <span class="no">Oct</span> <span class="mi">2017</span> <span class="mi">13</span><span class="p">:</span><span class="mo">04</span><span class="p">:</span><span class="mi">19</span> <span class="no">GMT</span>
<span class="no">Server</span><span class="p">:</span> <span class="no">WEBrick</span><span class="o">/</span><span class="mf">1.3</span><span class="o">.</span><span class="mi">1</span> <span class="p">(</span><span class="no">Ruby</span><span class="o">/</span><span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span><span class="o">/</span><span class="mi">2016</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">21</span><span class="p">)</span>
<span class="no">Transfer</span><span class="o">-</span><span class="no">Encoding</span><span class="p">:</span> <span class="n">chunked</span>

<span class="no">GET</span> <span class="n">rack</span><span class="err">'</span><span class="n">d</span>
</code></pre></div></div>

<p>Rack 的中间件的使用其实非常简单，我们只需要定义符合要求的类，然后在合适的方法中返回合适的结果就可以了，在接下来的部分我们将介绍 Rack 以及中间件的实现原理。</p>

<h2 id="rack-的实现原理">Rack 的实现原理</h2>

<p>到这里，我们已经对 Rack 的使用有一些基本的了解了，包括如何使用 <code class="highlighter-rouge">rackup</code> 命令启动一个 webserver，也包括 Rack 的中间件如何使用，接下来我们就准备开始对 Rack 是如何实现上述功能进行分析了。</p>

<h3 id="rackup-命令">rackup 命令</h3>

<p>那么 <code class="highlighter-rouge">rackup</code> 到底是如何工作的呢，首先我们通过 <code class="highlighter-rouge">which</code> 命令来查找当前 <code class="highlighter-rouge">rackup</code> 的执行路径并打印出该文件的全部内容：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">which</span> <span class="n">rackup</span>
<span class="sr">/Users/</span><span class="n">draveness</span><span class="o">/</span><span class="p">.</span><span class="nf">rvm</span><span class="o">/</span><span class="n">gems</span><span class="o">/</span><span class="n">ruby</span><span class="o">-</span><span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">rackup</span>

<span class="err">$</span> <span class="n">cat</span> <span class="sr">/Users/</span><span class="n">draveness</span><span class="o">/</span><span class="p">.</span><span class="nf">rvm</span><span class="o">/</span><span class="n">gems</span><span class="o">/</span><span class="n">ruby</span><span class="o">-</span><span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">rackup</span>
<span class="c1">#!/usr/bin/env ruby_executable_hooks</span>
<span class="c1">#</span>
<span class="c1"># This file was generated by RubyGems.</span>
<span class="c1">#</span>
<span class="c1"># The application 'rack' is installed as part of a gem, and</span>
<span class="c1"># this file is here to facilitate running it.</span>
<span class="c1">#</span>

<span class="nb">require</span> <span class="s1">'rubygems'</span>

<span class="n">version</span> <span class="o">=</span> <span class="s2">"&gt;= 0.a"</span>

<span class="k">if</span> <span class="no">ARGV</span><span class="p">.</span><span class="nf">first</span>
  <span class="n">str</span> <span class="o">=</span> <span class="no">ARGV</span><span class="p">.</span><span class="nf">first</span>
  <span class="n">str</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="nf">dup</span><span class="p">.</span><span class="nf">force_encoding</span><span class="p">(</span><span class="s2">"BINARY"</span><span class="p">)</span> <span class="k">if</span> <span class="n">str</span><span class="p">.</span><span class="nf">respond_to?</span> <span class="ss">:force_encoding</span>
  <span class="k">if</span> <span class="n">str</span> <span class="o">=~</span> <span class="sr">/\A_(.*)_\z/</span> <span class="n">and</span> <span class="no">Gem</span><span class="o">::</span><span class="no">Version</span><span class="p">.</span><span class="nf">correct?</span><span class="p">(</span><span class="vg">$1</span><span class="p">)</span> <span class="k">then</span>
    <span class="n">version</span> <span class="o">=</span> <span class="vg">$1</span>
    <span class="no">ARGV</span><span class="p">.</span><span class="nf">shift</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="nb">load</span> <span class="no">Gem</span><span class="p">.</span><span class="nf">activate_bin_path</span><span class="p">(</span><span class="s1">'rack'</span><span class="p">,</span> <span class="s1">'rackup'</span><span class="p">,</span> <span class="n">version</span><span class="p">)</span>
</code></pre></div></div>

<p>从上述文件中的注释中可以看到当前文件是由 RubyGems 自动生成的，在文件的最后由一个 <code class="highlighter-rouge">load</code> 方法加载了某一个文件中的代码，我们可以在 pry 中尝试运行一下这个命令。</p>

<p>首先，通过 <code class="highlighter-rouge">gem list</code> 命令得到当前机器中所有 rack 的版本，然后进入 pry 执行 <code class="highlighter-rouge">.activate_bin_path</code> 命令：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">gem</span> <span class="n">list</span> <span class="s2">"^rack$"</span>

<span class="o">***</span> <span class="no">LOCAL</span> <span class="no">GEMS</span> <span class="o">***</span>

<span class="n">rack</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">.</span><span class="mi">3</span><span class="p">,</span> <span class="mf">2.0</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.6</span><span class="o">.</span><span class="mi">8</span><span class="p">,</span> <span class="mf">1.2</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>

<span class="err">$</span> <span class="n">pry</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">Gem</span><span class="p">.</span><span class="nf">activate_bin_path</span><span class="p">(</span><span class="s1">'rack'</span><span class="p">,</span> <span class="s1">'rackup'</span><span class="p">,</span> <span class="s1">'2.0.3'</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="s2">"/Users/draveness/.rvm/gems/ruby-2.3.3/gems/rack-2.0.3/bin/rackup"</span>

<span class="err">$</span> <span class="n">cat</span> <span class="sr">/Users/</span><span class="n">draveness</span><span class="o">/</span><span class="p">.</span><span class="nf">rvm</span><span class="o">/</span><span class="n">gems</span><span class="o">/</span><span class="n">ruby</span><span class="o">-</span><span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span><span class="o">/</span><span class="n">gems</span><span class="o">/</span><span class="n">rack</span><span class="o">-</span><span class="mf">2.0</span><span class="o">.</span><span class="mi">3</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">rackup</span>
<span class="c1">#!/usr/bin/env ruby</span>

<span class="nb">require</span> <span class="s2">"rack"</span>
<span class="no">Rack</span><span class="o">::</span><span class="no">Server</span><span class="p">.</span><span class="nf">start</span>
</code></pre></div></div>

<blockquote>
  <p><code class="highlighter-rouge">rackup</code> 命令定义在 rack 工程的 bin/rackup 文件中，在通过 rubygems 安装后会生成另一个加载该文件的可执行文建。</p>
</blockquote>

<p>在最后打印了该文件的内容，到这里我们就应该知道 <code class="highlighter-rouge">.activate_bin_path</code> 方法会查找对应 gem 当前生效的版本，并返回文件的路径；在这个可执行文件中，上述代码只是简单的 <code class="highlighter-rouge">require</code> 了一下 rack 方法，之后运行 <code class="highlighter-rouge">.start</code> 启动了一个 <code class="highlighter-rouge">Rack::Server</code>。</p>

<h3 id="server-的启动">Server 的启动</h3>

<p>从这里开始，我们就已经从 rackup 命令的执行进入了 rack 的源代码，可以直接使用 pry 找到 <code class="highlighter-rouge">.start</code> 方法所在的文件，从方法中可以看到当前类方法初始化了一个新的实例后，在新的对象上执行了 <code class="highlighter-rouge">#start</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">pry</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="nb">require</span> <span class="s1">'rack'</span>
<span class="o">=&gt;</span> <span class="kp">true</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span><span class="p">.</span><span class="nf">start</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">147</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Rack::Server&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">start</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="n">new</span><span class="p">(</span><span class="n">options</span><span class="p">).</span><span class="nf">start</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="初始化和配置">初始化和配置</h3>

<p>在 <code class="highlighter-rouge">Rack::Server</code> 启动的过程中初始化了一个新的对象，初始化的过程中其实也包含了整个服务器的配置过程：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">185</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Rack::Server&gt;</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="vi">@ignore_options</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">if</span> <span class="n">options</span>
    <span class="vi">@use_default_options</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="vi">@options</span> <span class="o">=</span> <span class="n">options</span>
    <span class="vi">@app</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:app</span><span class="p">]</span> <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="ss">:app</span><span class="p">]</span>
  <span class="k">else</span>
    <span class="n">argv</span> <span class="o">=</span> <span class="n">defined?</span><span class="p">(</span><span class="no">SPEC_ARGV</span><span class="p">)</span> <span class="p">?</span> <span class="no">SPEC_ARGV</span> <span class="p">:</span> <span class="no">ARGV</span>
    <span class="vi">@use_default_options</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="vi">@options</span> <span class="o">=</span> <span class="n">parse_options</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个 <code class="highlighter-rouge">Server</code> 对象的初始化器中，虽然可以通过 <code class="highlighter-rouge">options</code> 从外界传入参数，但是当前类中仍然存在这个 <code class="highlighter-rouge">#options</code> 和 <code class="highlighter-rouge">#default_options</code> 两个实例方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">199</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">options</span>
  <span class="n">merged_options</span> <span class="o">=</span> <span class="vi">@use_default_options</span> <span class="p">?</span> <span class="n">default_options</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="vi">@options</span><span class="p">)</span> <span class="p">:</span> <span class="vi">@options</span>
  <span class="n">merged_options</span><span class="p">.</span><span class="nf">reject</span> <span class="p">{</span> <span class="o">|</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">|</span> <span class="vi">@ignore_options</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">204</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">default_options</span>
  <span class="n">environment</span>  <span class="o">=</span> <span class="no">ENV</span><span class="p">[</span><span class="s1">'RACK_ENV'</span><span class="p">]</span> <span class="o">||</span> <span class="s1">'development'</span>
  <span class="n">default_host</span> <span class="o">=</span> <span class="n">environment</span> <span class="o">==</span> <span class="s1">'development'</span> <span class="p">?</span> <span class="s1">'localhost'</span> <span class="p">:</span> <span class="s1">'0.0.0.0'</span>
  <span class="p">{</span>
    <span class="ss">:environment</span> <span class="o">=&gt;</span> <span class="n">environment</span><span class="p">,</span>
    <span class="ss">:pid</span>         <span class="o">=&gt;</span> <span class="kp">nil</span><span class="p">,</span>
    <span class="ss">:Port</span>        <span class="o">=&gt;</span> <span class="mi">9292</span><span class="p">,</span>
    <span class="ss">:Host</span>        <span class="o">=&gt;</span> <span class="n">default_host</span><span class="p">,</span>
    <span class="ss">:AccessLog</span>   <span class="o">=&gt;</span> <span class="p">[],</span>
    <span class="ss">:config</span>      <span class="o">=&gt;</span> <span class="s2">"config.ru"</span>
  <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述两个方法中处理了一些对象本身定义的一些参数，比如默认的端口号 9292 以及默认的 config 文件，config 文件也就是 <code class="highlighter-rouge">rackup</code> 命令接受的一个文件参数，文件中的内容就是用来配置一个 Rack 服务器的代码，在默认情况下为 config.ru，也就是如果文件名是 config.ru，我们不需要向 <code class="highlighter-rouge">rackup</code> 命令传任何参数，它会自动找当前目录的该文件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">rackup</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">09</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mi">34</span><span class="p">]</span> <span class="no">INFO</span>  <span class="no">WEBrick</span> <span class="mf">1.3</span><span class="o">.</span><span class="mi">1</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">09</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mi">34</span><span class="p">]</span> <span class="no">INFO</span>  <span class="n">ruby</span> <span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span> <span class="p">(</span><span class="mi">2016</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">21</span><span class="p">)</span> <span class="p">[</span><span class="n">x86_64</span><span class="o">-</span><span class="n">darwin16</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">09</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mi">34</span><span class="p">]</span> <span class="no">INFO</span>  <span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServer</span><span class="c1">#start: pid=96302 port=9292</span>
</code></pre></div></div>

<p>访问相同的 URL 能得到完全一致的结果，在这里就不再次展示了，有兴趣的读者可以亲自尝试一下。</p>

<h3 id="包装应用">『包装』应用</h3>

<p>当我们执行了 <code class="highlighter-rouge">.initialize</code> 方法初始化了一个新的实例之后，接下来就会进入 <code class="highlighter-rouge">#start</code> 实例方法尝试启动一个 webserver 处理 config.ru 中定义的应用了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">258</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">start</span> <span class="o">&amp;</span><span class="n">blk</span>
  <span class="c1"># ...</span>

  <span class="n">wrapped_app</span>
  <span class="c1"># ..</span>

  <span class="n">server</span><span class="p">.</span><span class="nf">run</span> <span class="n">wrapped_app</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blk</span>
<span class="k">end</span>
</code></pre></div></div>

<p>我们已经从上述方法中删除了很多对于本文来说不重要的代码实现，所以上述方法中最重要的部分就是 <code class="highlighter-rouge">#wrapped_app</code> 方法，以及另一个 <code class="highlighter-rouge">#server</code> 方法，首先来看 <code class="highlighter-rouge">#wrapped_app</code> 方法的实现。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">353</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">wrapped_app</span>
  <span class="vi">@wrapped_app</span> <span class="o">||=</span> <span class="n">build_app</span> <span class="n">app</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法有两部分组成，分别是 <code class="highlighter-rouge">#app</code> 和 <code class="highlighter-rouge">#build_app</code> 两个实例方法，其中 <code class="highlighter-rouge">#app</code> 方法的调用栈比较复杂：</p>

<p><img src="https://img.draveness.me/2017-10-29-server-app-call-stack.png" alt="server-app-call-stack" /></p>

<p>整个方法在最终会执行 <code class="highlighter-rouge">Builder.new_from_string</code> 通过 Ruby 中元编程中经常使用的 <code class="highlighter-rouge">eval</code> 方法，将输入文件中的全部内容与两端字符串拼接起来，并直接执行这段代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">builder</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">48</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">new_from_string</span><span class="p">(</span><span class="n">builder_script</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="s2">"(rackup)"</span><span class="p">)</span>
  <span class="nb">eval</span> <span class="s2">"Rack::Builder.new {</span><span class="se">\n</span><span class="s2">"</span> <span class="o">+</span> <span class="n">builder_script</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">}.to_app"</span><span class="p">,</span>
    <span class="no">TOPLEVEL_BINDING</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="mi">0</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">eval</code> 方法中执行代码的作用其实就是如下所示的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span>
  <span class="n">use</span> <span class="no">StatusLogger</span>
  <span class="n">use</span> <span class="no">BodyTransformer</span><span class="p">,</span> <span class="ss">count: </span><span class="mi">3</span>
  <span class="n">run</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">env</span><span class="o">|</span> <span class="p">[</span><span class="s1">'200'</span><span class="p">,</span> <span class="p">{</span><span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'text/html'</span><span class="p">},</span> <span class="p">[</span><span class="s1">'get rack\'d'</span><span class="p">]]</span> <span class="p">}</span>
<span class="p">}.</span><span class="nf">to_app</span>
</code></pre></div></div>

<p>我们先暂时不管这段代码是如何执行的，我们只需要知道上述代码存储了所有的中间件以及 Proc 对象，最后通过 <code class="highlighter-rouge">#to_app</code> 方法返回一个 Rack 应用。</p>

<p>在这之后会使用 <code class="highlighter-rouge">#build_app</code> 方法将所有的中间件都包括在 Rack 应用周围，因为所有的中间件也都是一个响应 <code class="highlighter-rouge">#call</code> 方法，返回三元组的对象，其实也就是一个遵循协议的 App，唯一的区别就是中间件中会调用初始化时传入的 Rack App：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">343</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">build_app</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
  <span class="n">middleware</span><span class="p">[</span><span class="n">options</span><span class="p">[</span><span class="ss">:environment</span><span class="p">]].</span><span class="nf">reverse_each</span> <span class="k">do</span> <span class="o">|</span><span class="n">middleware</span><span class="o">|</span>
    <span class="n">middleware</span> <span class="o">=</span> <span class="n">middleware</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="k">if</span> <span class="n">middleware</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:call</span><span class="p">)</span>
    <span class="k">next</span> <span class="k">unless</span> <span class="n">middleware</span>
    <span class="n">klass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">middleware</span>
    <span class="n">app</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">app</span>
<span class="k">end</span>
</code></pre></div></div>

<p>经过上述方法，我们在一个 Rack 应用周围一层一层包装上了所有的中间件，最后调用的中间件在整个调用栈中的最外层，当包装后的应用接受来自外界的请求时，会按照如下的方式进行调用：</p>

<p><img src="https://img.draveness.me/2017-10-29-wrapped-app.png" alt="wrapped-app" /></p>

<p>所有的请求都会先经过中间件，每一个中间件都会在 <code class="highlighter-rouge">#call</code> 方法内部调用另一个中间件或者应用，在接收到应用的返回之后会分别对响应进行处理最后由最先定义的中间件返回。</p>

<h3 id="中间件的实现">中间件的实现</h3>

<p>在 Rack 中，中间件是由两部分的代码共同处理的，分别是 <code class="highlighter-rouge">Rack::Builder</code> 和 <code class="highlighter-rouge">Rack::Server</code> 两个类，前者包含所有的能够在 config.ru 文件中使用的 DSL 方法，当我们使用 <code class="highlighter-rouge">eval</code> 执行 config.ru 文件中的代码时，会先初始化一个 <code class="highlighter-rouge">Builder</code> 的实例，然后执行 <code class="highlighter-rouge">instance_eval</code> 运行代码块中的所有内容：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">builder</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">53</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">default_app</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="vi">@use</span><span class="p">,</span> <span class="vi">@map</span><span class="p">,</span> <span class="vi">@run</span><span class="p">,</span> <span class="vi">@warmup</span> <span class="o">=</span> <span class="p">[],</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">default_app</span><span class="p">,</span> <span class="kp">nil</span>
  <span class="nb">instance_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="k">if</span> <span class="nb">block_given?</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这时，config.ru 文件中的代码就会在当前实例的环境下执行，文件中的 <code class="highlighter-rouge">#use</code> 和 <code class="highlighter-rouge">#run</code> 方法在调用时就会执行 <code class="highlighter-rouge">Builder</code> 的实例方法，我们可以先看一下 <code class="highlighter-rouge">#use</code> 方法是如何实现的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">builder</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">81</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span>

<span class="k">def</span> <span class="nf">use</span><span class="p">(</span><span class="n">middleware</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="vi">@use</span> <span class="o">&lt;&lt;</span> <span class="nb">proc</span> <span class="p">{</span> <span class="o">|</span><span class="n">app</span><span class="o">|</span> <span class="n">middleware</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法会将传入的参数组合成一个接受 <code class="highlighter-rouge">app</code> 作为入参的 <code class="highlighter-rouge">Proc</code> 对象，然后加入到 <code class="highlighter-rouge">@use</code> 数组中存储起来，在这里并没有发生任何其他的事情，另一个 <code class="highlighter-rouge">#run</code> 方法的实现其实就更简单了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">builder</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">103</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span>

<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
  <span class="vi">@run</span> <span class="o">=</span> <span class="n">app</span>
<span class="k">end</span>
</code></pre></div></div>

<p>它只是将传入的 <code class="highlighter-rouge">app</code> 对象存储到持有的 <code class="highlighter-rouge">@run</code> 实例变量中，如果我们想要获取当前的 <code class="highlighter-rouge">Builder</code> 生成的应用，只需要通过 <code class="highlighter-rouge">#to_app</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">builder</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">144</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span>

<span class="k">def</span> <span class="nf">to_app</span>
  <span class="nb">fail</span> <span class="s2">"missing run or map statement"</span> <span class="k">unless</span> <span class="vi">@run</span>
  <span class="vi">@use</span><span class="p">.</span><span class="nf">reverse</span><span class="p">.</span><span class="nf">inject</span><span class="p">(</span><span class="vi">@run</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span><span class="n">e</span><span class="o">|</span> <span class="n">e</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法将所有传入 <code class="highlighter-rouge">#use</code> 和 <code class="highlighter-rouge">#run</code> 命令的应用和中间件进行了组合，通过 <code class="highlighter-rouge">#inject</code> 方法达到了如下所示的效果：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># config.ru</span>
<span class="n">use</span> <span class="no">MiddleWare1</span>
<span class="n">use</span> <span class="no">MiddleWare2</span>
<span class="n">run</span> <span class="no">RackApp</span>

<span class="c1"># equals to</span>
<span class="no">MiddleWare1</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">MiddleWare2</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">RackApp</span><span class="p">)))</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Builder</code> 类其实简单来看就做了这件事情，将一种非常难以阅读的代码，变成比较清晰可读的 DSL，最终返回了一个中间件（也可以说是应用）对象，虽然在 <code class="highlighter-rouge">Builder</code> 中也包含其他的 DSL 语法元素，但是在这里都没有介绍。</p>

<p>上一小节提到的 <code class="highlighter-rouge">#build_app</code> 方法其实也只是根据当前的环境选择合适的中间件继续包裹到这个链式的调用中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">343</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">build_app</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
  <span class="n">middleware</span><span class="p">[</span><span class="n">options</span><span class="p">[</span><span class="ss">:environment</span><span class="p">]].</span><span class="nf">reverse_each</span> <span class="k">do</span> <span class="o">|</span><span class="n">middleware</span><span class="o">|</span>
    <span class="n">middleware</span> <span class="o">=</span> <span class="n">middleware</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="k">if</span> <span class="n">middleware</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:call</span><span class="p">)</span>
    <span class="k">next</span> <span class="k">unless</span> <span class="n">middleware</span>
    <span class="n">klass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">middleware</span>
    <span class="n">app</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">app</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这里的 <code class="highlighter-rouge">#middleware</code> 方法可以被子类覆写，如果不覆写该方法会根据环境的不同选择不同的中间件数组包裹当前的应用：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">229</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Rack::Server&gt;</span>

<span class="k">def</span> <span class="nf">default_middleware_by_environment</span>
  <span class="n">m</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span><span class="o">|</span><span class="n">h</span><span class="p">,</span><span class="n">k</span><span class="o">|</span> <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]}</span>
  <span class="n">m</span><span class="p">[</span><span class="s2">"deployment"</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">ContentLength</span><span class="p">],</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">Chunked</span><span class="p">],</span>
    <span class="n">logging_middleware</span><span class="p">,</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">TempfileReaper</span><span class="p">]</span>
  <span class="p">]</span>
  <span class="n">m</span><span class="p">[</span><span class="s2">"development"</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">ContentLength</span><span class="p">],</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">Chunked</span><span class="p">],</span>
    <span class="n">logging_middleware</span><span class="p">,</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">ShowExceptions</span><span class="p">],</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">Lint</span><span class="p">],</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">TempfileReaper</span><span class="p">]</span>
  <span class="p">]</span>
  <span class="n">m</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">.default_middleware_by_environment</code> 中就包含了不同环境下应该使用的中间件，<code class="highlighter-rouge">#build_app</code> 会视情况选择中间件加载。</p>

<h3 id="webserver-的选择">webserver 的选择</h3>

<p>在 <code class="highlighter-rouge">Server#start</code> 方法中，我们已经通过 <code class="highlighter-rouge">#wrapped_app</code> 方法将应用和中间件打包到了一起，然后分别执行 <code class="highlighter-rouge">#server</code> 和 <code class="highlighter-rouge">Server#run</code> 方法选择并运行 webserver，先来看 webserver 是如何选择的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">300</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">server</span>
  <span class="vi">@_server</span> <span class="o">||=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Handler</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="ss">:server</span><span class="p">])</span>
  <span class="k">unless</span> <span class="vi">@_server</span>
    <span class="vi">@_server</span> <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Handler</span><span class="p">.</span><span class="nf">default</span>
  <span class="k">end</span>
  <span class="vi">@_server</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果我们在运行 <code class="highlighter-rouge">rackup</code> 命令时传入了 <code class="highlighter-rouge">server</code> 选项，例如 <code class="highlighter-rouge">rackup -s WEBrick</code>，就会直接使用传入的 webserver，否则就会使用默认的 Rack 处理器：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">handler</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">46</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Rack::Handler&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">default</span>
  <span class="c1"># Guess.</span>
  <span class="k">if</span> <span class="no">ENV</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="s2">"PHP_FCGI_CHILDREN"</span><span class="p">)</span>
    <span class="no">Rack</span><span class="o">::</span><span class="no">Handler</span><span class="o">::</span><span class="no">FastCGI</span>
  <span class="k">elsif</span> <span class="no">ENV</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="no">REQUEST_METHOD</span><span class="p">)</span>
    <span class="no">Rack</span><span class="o">::</span><span class="no">Handler</span><span class="o">::</span><span class="no">CGI</span>
  <span class="k">elsif</span> <span class="no">ENV</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="s2">"RACK_HANDLER"</span><span class="p">)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="no">ENV</span><span class="p">[</span><span class="s2">"RACK_HANDLER"</span><span class="p">])</span>
  <span class="k">else</span>
    <span class="n">pick</span> <span class="p">[</span><span class="s1">'puma'</span><span class="p">,</span> <span class="s1">'thin'</span><span class="p">,</span> <span class="s1">'webrick'</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个方法中，调用 <code class="highlighter-rouge">.pick</code> 其实最终也会落到 <code class="highlighter-rouge">.get</code> 方法上，在 <code class="highlighter-rouge">.pick</code> 中我们通过遍历传入的数组<strong>尝试</strong>对其进行加载：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">handler</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">34</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Rack::Handler&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">pick</span><span class="p">(</span><span class="n">server_names</span><span class="p">)</span>
  <span class="n">server_names</span> <span class="o">=</span> <span class="no">Array</span><span class="p">(</span><span class="n">server_names</span><span class="p">)</span>
  <span class="n">server_names</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">server_name</span><span class="o">|</span>
    <span class="k">begin</span>
      <span class="k">return</span> <span class="n">get</span><span class="p">(</span><span class="n">server_name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">)</span>
    <span class="k">rescue</span> <span class="no">LoadError</span><span class="p">,</span> <span class="no">NameError</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">raise</span> <span class="no">LoadError</span><span class="p">,</span> <span class="s2">"Couldn't find handler for: </span><span class="si">#{</span><span class="n">server_names</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">', '</span><span class="p">)</span><span class="si">}</span><span class="s2">."</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">.get</code> 方法是用于加载 webserver 对应处理器的方法，方法中会通过一定的命名规范从对应的文件目录下加载相应的常量：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">handler</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">11</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Rack::Handler&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">get</span><span class="p">(</span><span class="n">server</span><span class="p">)</span>
  <span class="k">return</span> <span class="k">unless</span> <span class="n">server</span>
  <span class="n">server</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="nf">to_s</span>

  <span class="k">unless</span> <span class="vi">@handlers</span><span class="p">.</span><span class="nf">include?</span> <span class="n">server</span>
    <span class="n">load_error</span> <span class="o">=</span> <span class="n">try_require</span><span class="p">(</span><span class="s1">'rack/handler'</span><span class="p">,</span> <span class="n">server</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">if</span> <span class="n">klass</span> <span class="o">=</span> <span class="vi">@handlers</span><span class="p">[</span><span class="n">server</span><span class="p">]</span>
    <span class="n">klass</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s2">"::"</span><span class="p">).</span><span class="nf">inject</span><span class="p">(</span><span class="no">Object</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">o</span><span class="p">,</span> <span class="n">x</span><span class="o">|</span> <span class="n">o</span><span class="p">.</span><span class="nf">const_get</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">else</span>
    <span class="nb">const_get</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span>
  <span class="k">end</span>

<span class="k">rescue</span> <span class="no">NameError</span> <span class="o">=&gt;</span> <span class="n">name_error</span>
  <span class="k">raise</span> <span class="n">load_error</span> <span class="o">||</span> <span class="n">name_error</span>
<span class="k">end</span>
</code></pre></div></div>

<p>一部分常量是预先定义在 handler.rb 文件中的，另一部分是由各个 webserver 的开发者自己定义或者遵循一定的命名规范加载的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">register</span> <span class="s1">'cgi'</span><span class="p">,</span> <span class="s1">'Rack::Handler::CGI'</span>
<span class="n">register</span> <span class="s1">'fastcgi'</span><span class="p">,</span> <span class="s1">'Rack::Handler::FastCGI'</span>
<span class="n">register</span> <span class="s1">'webrick'</span><span class="p">,</span> <span class="s1">'Rack::Handler::WEBrick'</span>
<span class="n">register</span> <span class="s1">'lsws'</span><span class="p">,</span> <span class="s1">'Rack::Handler::LSWS'</span>
<span class="n">register</span> <span class="s1">'scgi'</span><span class="p">,</span> <span class="s1">'Rack::Handler::SCGI'</span>
<span class="n">register</span> <span class="s1">'thin'</span><span class="p">,</span> <span class="s1">'Rack::Handler::Thin'</span>
</code></pre></div></div>

<p>在默认的情况下，如果不在启动服务时指定服务器就会按照 puma、thin 和 webrick 的顺序依次尝试加载响应的处理器。</p>

<h3 id="webserver-的启动">webserver 的启动</h3>

<p>当 Rack 已经使用中间件对应用进行包装并且选择了对应的 webserver 之后，我们就可以将处理好的应用作为参数传入 <code class="highlighter-rouge">WEBrick.run</code> 方法了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Rack</span>
  <span class="k">module</span> <span class="nn">Handler</span>
    <span class="k">class</span> <span class="nc">WEBrick</span> <span class="o">&lt;</span> <span class="o">::</span><span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServlet</span><span class="o">::</span><span class="no">AbstractServlet</span>
      <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">run</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{})</span>
        <span class="n">environment</span>  <span class="o">=</span> <span class="no">ENV</span><span class="p">[</span><span class="s1">'RACK_ENV'</span><span class="p">]</span> <span class="o">||</span> <span class="s1">'development'</span>
        <span class="n">default_host</span> <span class="o">=</span> <span class="n">environment</span> <span class="o">==</span> <span class="s1">'development'</span> <span class="p">?</span> <span class="s1">'localhost'</span> <span class="p">:</span> <span class="kp">nil</span>

        <span class="n">options</span><span class="p">[</span><span class="ss">:BindAddress</span><span class="p">]</span> <span class="o">=</span> <span class="n">options</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="ss">:Host</span><span class="p">)</span> <span class="o">||</span> <span class="n">default_host</span>
        <span class="n">options</span><span class="p">[</span><span class="ss">:Port</span><span class="p">]</span> <span class="o">||=</span> <span class="mi">8080</span>
        <span class="vi">@server</span> <span class="o">=</span> <span class="o">::</span><span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
        <span class="vi">@server</span><span class="p">.</span><span class="nf">mount</span> <span class="s2">"/"</span><span class="p">,</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Handler</span><span class="o">::</span><span class="no">WEBrick</span><span class="p">,</span> <span class="n">app</span>
        <span class="k">yield</span> <span class="vi">@server</span>  <span class="k">if</span> <span class="nb">block_given?</span>
        <span class="vi">@server</span><span class="p">.</span><span class="nf">start</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>所有遵循 Rack 协议的 webserver 都会实现上述 <code class="highlighter-rouge">.run</code> 方法接受 <code class="highlighter-rouge">app</code>、<code class="highlighter-rouge">options</code> 和一个 block 作为参数运行一个进程来处理所有的来自用户的 HTTP 请求，在这里就是每个 webserver 自己需要解决的了，它其实并不属于 Rack 负责的部门，但是 Rack 实现了一些常见 webserver 的 handler，比如 CGI、Thin 和 WEBrick 等等，这些 handler 的实现原理都不会包含在这篇文章中。</p>

<h2 id="rails-和-rack">Rails 和 Rack</h2>

<p>在了解了 Rack 的实现之后，其实我们可以发现 Rails 应用就是一堆 Rake 中间件和一个 Rack 应用的集合，在任意的工程中我们执行 <code class="highlighter-rouge">rake middleware</code> 的命令都可以得到以下的输出：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">rake</span> <span class="n">middleware</span>
<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Sendfile</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">Static</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">Executor</span>
<span class="n">use</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Cache</span><span class="o">::</span><span class="no">Strategy</span><span class="o">::</span><span class="no">LocalCache</span><span class="o">::</span><span class="no">Middleware</span>
<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Runtime</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">RequestId</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">RemoteIp</span>
<span class="n">use</span> <span class="no">Rails</span><span class="o">::</span><span class="no">Rack</span><span class="o">::</span><span class="no">Logger</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">ShowExceptions</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">DebugExceptions</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">Reloader</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">Callbacks</span>
<span class="n">use</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span><span class="o">::</span><span class="no">CheckPending</span>
<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Head</span>
<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">ConditionalGet</span>
<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">ETag</span>
<span class="n">run</span> <span class="no">ApplicationName</span><span class="o">::</span><span class="no">Application</span><span class="p">.</span><span class="nf">routes</span>
</code></pre></div></div>

<p>在这里包含了很多使用 <code class="highlighter-rouge">use</code> 加载的 Rack 中间件，当然在最后也包含一个 Rack 应用，也就是 <code class="highlighter-rouge">ApplicationName::Application.routes</code>，这个对象其实是一个 <code class="highlighter-rouge">RouteSet</code> 实例，也就是说在 Rails 中所有的请求在经过中间件之后都会先有一个路由表来处理，路由会根据一定的规则将请求交给其他控制器处理：</p>

<p><img src="https://img.draveness.me/2017-10-29-rails-application.png" alt="rails-application" /></p>

<p>除此之外，<code class="highlighter-rouge">rake middleware</code> 命令的输出也告诉我们 Rack 其实为我们提供了很多非常方便的中间件比如 <code class="highlighter-rouge">Rack::Sendfile</code> 等可以减少我们在开发一个 webserver 时需要处理的事情。</p>

<h2 id="总结">总结</h2>

<p>Rack 协议可以说占领了整个 Ruby 服务端的市场，无论是常见的服务器还是框架都遵循 Rack 协议进行了设计，而正因为 Rack 以及 Rack 协议的存在我们在使用 Rails 或者 Sinatra 开发 Web 应用时才可以对底层使用的 webserver 进行无缝的替换，在接下来的文章中会逐一介绍不同的 webserver 是如何对 HTTP 请求进行处理以及它们拥有怎样的 I/O 模型。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://github.com/rack/rack">Rack · A modular Ruby webserver interface</a></li>
  <li><a href="http://rack.github.io">Rack: a Ruby Webserver Interface</a></li>
  <li><a href="http://rubydoc.info/github/rack/rack/master/file/SPEC">Rack interface specification</a></li>
  <li><a href="http://guides.rubyonrails.org/rails_on_rack.html">Rails on Rack</a></li>
  <li><a href="http://railscasts.com/episodes/151-rack-middleware">Rack Middleware</a></li>
  <li><a href="http://chneukirchen.org/blog/archive/2007/02/introducing-rack.html">Introducing Rack</a></li>
  <li><a href="https://stackoverflow.com/questions/4113299/ruby-on-rails-server-options">Ruby on Rails Server options</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>全面理解 ActiveRecord</title>
	  <link>/blogs//activerecord</link>
	  <author></author>
	  <pubDate>2017-10-21T00:00:00+00:00</pubDate>
	  <guid>/blogs//activerecord</guid>
	  <description><![CDATA[
	     <p>最近事情并不是特别多，看了一些数据库相关的书籍，最后想到自己并不了解每天都在用的 ActiveRecord，对于它是如何创建模型、建立关系、执行 SQL 查询以及完成数据库迁移的，作者一直都有着自己的猜测，但是真正到源代码中去寻找答案一直都是没有做过的。</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-architecture.png" alt="activerecord-architecture" /></p>

<p>我们可以将 ActiveRecord 理解为一个不同 SQL 数据库的 Wrapper，同时为上层提供一种简洁、优雅的 API 或者说 DSL，能够极大得减轻开发者的负担并提升工作效率。</p>

<p>文章分四个部分介绍了 ActiveRecord 中的重要内容，模型的创建过程、Scope 和查询的实现、模型关系的实现以及最后的 Migrations 任务的实现和执行过程，各个模块之间没有太多的关联，由于文章内容比较多，如果读者只对某一部分的内容感兴趣，可以只挑选一部分进行阅读。</p>

<h2 id="模型的创建过程">模型的创建过程</h2>

<p>在这篇文章中，我们会先分析阅读 ActiveRecord 是如何创建模型并将数据插入到数据库中的，由于 ActiveRecord 的源码变更非常迅速，这里使用的 ActiveRecord 版本是 v5.1.4，如果希望重现文中对方法的追踪过程可以 checkout 到 v5.1.4 的标签上并使用如下所示的命令安装指定版本的 ActiveRecord：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gem install activerecord <span class="nt">-v</span> <span class="s1">'5.1.4'</span>
</code></pre></div></div>

<h3 id="引入-activerecord">引入 ActiveRecord</h3>

<p>在正式开始使用 <a href="https://github.com/pry/pry">pry</a> 对方法进行追踪之前，我们需要现在 pry 中 <code class="highlighter-rouge">require</code> 对应的 gem，并且创建一个用于追踪的模型类：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="nb">require</span> <span class="s1">'active_record'</span>
<span class="o">=&gt;</span> <span class="kp">true</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">;</span> <span class="k">end</span>
<span class="o">=&gt;</span> <span class="kp">nil</span>
</code></pre></div></div>

<p>这个步骤非常的简单，这里也不多说什么了，只是创建了一个继承自 <code class="highlighter-rouge">ActiveRecord::Base</code> 的类 <code class="highlighter-rouge">Post</code>，虽然我们并没有在数据库中创建对应的表结构，不过目前来说已经够用了。</p>

<h3 id="从-postcreate-开始">从 Post.create 开始</h3>

<p>使用过 ActiveRecord 的人都知道，当我们使用 <code class="highlighter-rouge">Post.create</code> 方法的时候就会在数据库中创建一条数据记录，所以在这里我们就将该方法作为入口一探究竟：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="no">Post</span><span class="p">.</span><span class="nf">create</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">persistence</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">29</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Persistence</span><span class="o">::</span><span class="no">ClassMethods</span>

<span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="n">attributes</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">attributes</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Array</span><span class="p">)</span>
    <span class="n">attributes</span><span class="p">.</span><span class="nf">collect</span> <span class="p">{</span> <span class="o">|</span><span class="kp">attr</span><span class="o">|</span> <span class="n">create</span><span class="p">(</span><span class="kp">attr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">else</span>
    <span class="n">object</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">attributes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">object</span><span class="p">.</span><span class="nf">save</span>
    <span class="n">object</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<blockquote>
  <p><code class="highlighter-rouge">$</code> 是 pry 为我们提供的用于查看方法源代码的工具，这篇文章中会省略 <code class="highlighter-rouge">$</code> 方法的一部分输出，还可能会对方法做一些简化减少理解方法实现时的干扰。</p>
</blockquote>

<p>通过 pry 的输出，我们可以在 ActiveRecord 的 <code class="highlighter-rouge">lib/active_record/persistence.rb</code> 文件中找到 <code class="highlighter-rouge">ActiveRecord::Base.create</code> 方法的实现，如果传入的参数是一个 <code class="highlighter-rouge">Hash</code>，该方法会先后执行 <code class="highlighter-rouge">ActiveRecord::Base.new</code> 和 <code class="highlighter-rouge">ActiveRecord::Base#save!</code> 创建一个新的对象并保存。</p>

<h4 id="使用-pry-追踪-save">使用 pry 追踪 #save!</h4>

<p><code class="highlighter-rouge">ActiveRecord::Base.new</code> 在大多数情况下都会调用父类的 <code class="highlighter-rouge">#initialize</code> 方法初始化实例，所以没有什么好说的，而 <code class="highlighter-rouge">ActiveRecord::Base#save!</code> 方法就做了很多事情：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="c1">#save!</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">suppressor</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">45</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Suppressor</span>

<span class="k">def</span> <span class="nf">save!</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="c1"># :nodoc:</span>
  <span class="no">SuppressorRegistry</span><span class="p">.</span><span class="nf">suppressed</span><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">name</span><span class="p">]</span> <span class="p">?</span> <span class="kp">true</span> <span class="p">:</span> <span class="k">super</span>
<span class="k">end</span>
</code></pre></div></div>

<p>首先是使用 <code class="highlighter-rouge">SuppressorRegistry</code> 来判断是否需要对当前的存取请求进行抑制，然后执行 <code class="highlighter-rouge">super</code> 方法，由于从上述代码中没有办法知道这里的 <code class="highlighter-rouge">super</code> 到底是什么，所以我们就需要通过 <code class="highlighter-rouge">.ancestors</code> 方法看看 <code class="highlighter-rouge">ActiveRecord::Base</code> 到底有哪些父类了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">ancestors</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">,</span>
 <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Suppressor</span><span class="p">,</span>
 <span class="o">...</span>
 <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Persistence</span><span class="p">,</span>
 <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Core</span><span class="p">,</span>
 <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">ToJsonWithActiveSupportEncoder</span><span class="p">,</span>
 <span class="no">Object</span><span class="p">,</span>
 <span class="o">...</span>
 <span class="no">Kernel</span><span class="p">,</span>
 <span class="no">BasicObject</span><span class="p">]</span>

<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">ancestors</span><span class="p">.</span><span class="nf">count</span>
<span class="o">=&gt;</span> <span class="mi">65</span>
</code></pre></div></div>

<p>使用 <code class="highlighter-rouge">.ancestors</code> 方法，你就可以看到整个方法调用链上包含 64 个父类，在这时简单的使用 pry 就已经不能帮助我们理解方法的调用过程了，因为 pry 没法查看当前的方法在父类中是否存在，我们需要从工程中分析哪些类的 <code class="highlighter-rouge">#save!</code> 方法在整个过程中被执行了并根据上述列表排出它们执行的顺序；经过分析，我们得到如下的结果：</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-base-save.png" alt="activerecord-base-save" /></p>

<p>从 <code class="highlighter-rouge">ActiveRecord::Suppressor</code> 到 <code class="highlighter-rouge">ActiveRecord::Persistence</code> 一共有五个 module 实现了 <code class="highlighter-rouge">#save!</code> 方法，上面我们已经知道了 <code class="highlighter-rouge">ActiveRecord::Suppressor#save!</code> 模块提供了对保存的抑制功能，接下来将依次看后四个方法都在保存模型的过程中做了什么。</p>

<h4 id="事务的执行">事务的执行</h4>

<p>从名字就可以看出 <code class="highlighter-rouge">ActiveRecord::Transactions</code> 主要是为数据库事务提供支持，并在数据库事务的不同阶段执行不同的回调，这个 module 中的 <code class="highlighter-rouge">#save!</code> 方法仅在 <code class="highlighter-rouge">#with_transaction_returning_status</code> 的 block 中执行了 <code class="highlighter-rouge">super</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">ActiveRecord</span>
  <span class="k">module</span> <span class="nn">Transactions</span>
    <span class="k">def</span> <span class="nf">save!</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="c1">#:nodoc:</span>
      <span class="n">with_transaction_returning_status</span> <span class="p">{</span> <span class="k">super</span> <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">#with_transaction_returning_status</code> 方法会运行外部传入的 block 通过 <code class="highlighter-rouge">super</code> 执行父类的 <code class="highlighter-rouge">#save!</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">with_transaction_returning_status</span>
  <span class="n">status</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
    <span class="n">add_to_transaction</span>
    <span class="k">begin</span>
      <span class="n">status</span> <span class="o">=</span> <span class="k">yield</span>
    <span class="k">rescue</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Rollback</span>
      <span class="n">clear_transaction_record_state</span>
      <span class="n">status</span> <span class="o">=</span> <span class="kp">nil</span>
    <span class="k">end</span>

    <span class="k">raise</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Rollback</span> <span class="k">unless</span> <span class="n">status</span>
  <span class="k">end</span>
  <span class="n">status</span>
<span class="k">ensure</span>
  <span class="k">if</span> <span class="vi">@transaction_state</span> <span class="o">&amp;&amp;</span> <span class="vi">@transaction_state</span><span class="p">.</span><span class="nf">committed?</span>
    <span class="n">clear_transaction_record_state</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>通过上述方法，我们将所有的 SQL 请求都包装在了一个 <code class="highlighter-rouge">.transaction</code> 中，开启一个新的数据库事务并在其中执行请求，在这里统一处理一些跟事务回滚以及异常相关的逻辑，同时 <code class="highlighter-rouge">ActiveRecord::Transactions</code> 又能为当前的模型添加一些回调的支持：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">ActiveRecord</span>
  <span class="k">module</span> <span class="nn">Transactions</span>
    <span class="n">included</span> <span class="k">do</span>
      <span class="n">define_callbacks</span> <span class="ss">:commit</span><span class="p">,</span> <span class="ss">:rollback</span><span class="p">,</span>
                       <span class="ss">:before_commit</span><span class="p">,</span>
                       <span class="ss">:before_commit_without_transaction_enrollment</span><span class="p">,</span>
                       <span class="ss">:commit_without_transaction_enrollment</span><span class="p">,</span>
                       <span class="ss">:rollback_without_transaction_enrollment</span><span class="p">,</span>
                       <span class="ss">scope: </span><span class="p">[</span><span class="ss">:kind</span><span class="p">,</span> <span class="ss">:name</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>开发者就能够在模型中根据需要注册回调用来监听各种数据库事务相关的事件，绝大多数的事务最终都会在 <code class="highlighter-rouge">ActiveRecord::ConnectionAdapters::Transaction#within_new_transaction</code> 方法中执行：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">within_new_transaction</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="vi">@connection</span><span class="p">.</span><span class="nf">lock</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
    <span class="k">begin</span>
      <span class="n">transaction</span> <span class="o">=</span> <span class="n">begin_transaction</span> <span class="n">options</span>
      <span class="k">yield</span>
    <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">error</span>
      <span class="k">if</span> <span class="n">transaction</span>
        <span class="n">rollback_transaction</span>
        <span class="n">after_failure_actions</span><span class="p">(</span><span class="n">transaction</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
      <span class="k">end</span>
      <span class="k">raise</span>
    <span class="k">ensure</span>
      <span class="k">unless</span> <span class="n">error</span>
        <span class="k">if</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">status</span> <span class="o">==</span> <span class="s2">"aborting"</span>
          <span class="n">rollback_transaction</span> <span class="k">if</span> <span class="n">transaction</span>
        <span class="k">else</span>
          <span class="k">begin</span>
            <span class="n">commit_transaction</span>
          <span class="k">rescue</span> <span class="no">Exception</span>
            <span class="n">rollback_transaction</span><span class="p">(</span><span class="n">transaction</span><span class="p">)</span> <span class="k">unless</span> <span class="n">transaction</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">completed?</span>
            <span class="k">raise</span>
          <span class="k">end</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法虽然看起来非常复杂，但是方法的逻辑还是还是非常清晰的，如果事务没有抛出任何的异常，就可以将上述代码简化成以下的几行代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">within_new_transaction</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="vi">@connection</span><span class="p">.</span><span class="nf">lock</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
      <span class="n">begin_transaction</span> <span class="n">options</span>
      <span class="k">yield</span>
      <span class="n">commit_transaction</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>我们可以看到，经过一系列的方法调用最后会在数据库中执行 <code class="highlighter-rouge">BEGIN</code>、SQL 语句和 <code class="highlighter-rouge">COMMIT</code> 来完成数据的持久化。</p>

<h4 id="追踪属性的重置">追踪属性的重置</h4>

<p>当 <code class="highlighter-rouge">ActiveRecord::Transactions#save!</code> 通过 <code class="highlighter-rouge">super</code> 将方法抛给上层之后，就由 <code class="highlighter-rouge">ActiveRecord::AttributesMethod::Dirty</code> 来处理了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">save!</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
  <span class="k">super</span><span class="p">.</span><span class="nf">tap</span> <span class="k">do</span>
    <span class="n">changes_applied</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果 <code class="highlighter-rouge">#save!</code> 最终执行成功，在这个阶段会将所有模型改变的标记全部清除，对包括 <code class="highlighter-rouge">@changed_attributes</code>、<code class="highlighter-rouge">@mutation_tracker</code> 在内的实例变量全部重置，为追踪下一次模型的修改做准备。</p>

<h4 id="字段的验证">字段的验证</h4>

<p>沿着整个继承链往下走，下一个被执行的模块就是 <code class="highlighter-rouge">ActiveRecord::Validations</code> 了，正如这么模块名字所暗示的，我们在这里会对模型中的字段进行验证：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">save!</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="n">perform_validations</span><span class="p">(</span><span class="n">options</span><span class="p">)</span> <span class="p">?</span> <span class="k">super</span> <span class="p">:</span> <span class="n">raise_validation_error</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述代码使用 <code class="highlighter-rouge">#perform_validations</code> 方法验证模型中的全部字段，以此来保证所有的字段都符合我们的预期：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">perform_validations</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="n">options</span><span class="p">[</span><span class="ss">:validate</span><span class="p">]</span> <span class="o">==</span> <span class="kp">false</span> <span class="o">||</span> <span class="n">valid?</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="ss">:context</span><span class="p">])</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个方法中我们可以看到如果在调用 <code class="highlighter-rouge">save!</code> 方法时，传入了 <code class="highlighter-rouge">validate: false</code> 所有的验证就都会被跳过，我们通过 <code class="highlighter-rouge">#valid?</code> 来判断当前的模型是否合法，而这个方法的执行过程其实也包含两个过程：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">ActiveRecord</span>
  <span class="k">module</span> <span class="nn">Validations</span>
    <span class="k">def</span> <span class="nf">valid?</span><span class="p">(</span><span class="n">context</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
      <span class="n">context</span> <span class="o">||=</span> <span class="n">default_validation_context</span>
      <span class="n">output</span> <span class="o">=</span> <span class="k">super</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
      <span class="n">errors</span><span class="p">.</span><span class="nf">empty?</span> <span class="o">&amp;&amp;</span> <span class="n">output</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">ActiveModel</span>
  <span class="k">module</span> <span class="nn">Validations</span>
    <span class="k">def</span> <span class="nf">valid?</span><span class="p">(</span><span class="n">context</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
      <span class="n">current_context</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="nf">validation_context</span> <span class="o">=</span> <span class="n">validation_context</span><span class="p">,</span> <span class="n">context</span>
      <span class="n">errors</span><span class="p">.</span><span class="nf">clear</span>
      <span class="n">run_validations!</span>
    <span class="k">ensure</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">validation_context</span> <span class="o">=</span> <span class="n">current_context</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>由于 <code class="highlighter-rouge">ActiveModel::Validations</code> 是 <code class="highlighter-rouge">ActiveRecord::Validations</code> 的『父类』，所以在 <code class="highlighter-rouge">ActiveRecord::Validations</code> 执行 <code class="highlighter-rouge">#valid?</code> 方法时，最终会执行父类 <code class="highlighter-rouge">#run_validations</code> 运行全部的验证回调。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">ActiveModel</span>
  <span class="k">module</span> <span class="nn">Validations</span>
    <span class="k">def</span> <span class="nf">run_validations!</span>
      <span class="n">_run_validate_callbacks</span>
      <span class="n">errors</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>通过上述方法的实现，我们可以发现验证是否成功其实并不是通过我们在 <code class="highlighter-rouge">validate</code> 中传入一个返回 <code class="highlighter-rouge">true/false</code> 的方法决定的，而是要向当前模型的 <code class="highlighter-rouge">errors</code> 中添加更多的错误：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Invoice</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">validate</span> <span class="ss">:active_customer</span>
 
  <span class="k">def</span> <span class="nf">active_customer</span>
    <span class="n">errors</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="ss">:customer_id</span><span class="p">,</span> <span class="s2">"is not active"</span><span class="p">)</span> <span class="k">unless</span> <span class="n">customer</span><span class="p">.</span><span class="nf">active?</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个过程中执行的另一个方法 <code class="highlighter-rouge">#_run_validate_callbacks</code> 其实是通过 <code class="highlighter-rouge">ActiveSupport::Callbacks</code> 提供的 <code class="highlighter-rouge">#define_callbacks</code> 方法动态生成的，所以我们没有办法在工程中搜索到：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">define_callbacks</span><span class="p">(</span><span class="o">*</span><span class="n">names</span><span class="p">)</span>
  <span class="n">options</span> <span class="o">=</span> <span class="n">names</span><span class="p">.</span><span class="nf">extract_options!</span>

  <span class="n">names</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
    <span class="nb">name</span> <span class="o">=</span> <span class="nb">name</span><span class="p">.</span><span class="nf">to_sym</span>
    <span class="n">set_callbacks</span> <span class="nb">name</span><span class="p">,</span> <span class="no">CallbackChain</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="nb">module_eval</span> <span class="o">&lt;&lt;-</span><span class="no">RUBY</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
      def _run_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">_callbacks(&amp;block)
        run_callbacks </span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="sh">, &amp;block
      end

      def self._</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">_callbacks
        get_callbacks(</span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="sh">)
      end

      def self._</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">_callbacks=(value)
        set_callbacks(</span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="sh">, value)
      end

      def _</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">_callbacks
        __callbacks[</span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="sh">]
      end
</span><span class="no">    RUBY</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这篇文章中，我们只需要知道该 <code class="highlighter-rouge">#save!</code> 在合适的时机运行了正确的回调就可以了，在后面的文章（可能）中会详细介绍整个 callbacks 的具体执行流程。</p>

<h4 id="数据的持久化">数据的持久化</h4>

<p><code class="highlighter-rouge">#save!</code> 的调用栈最顶端就是 <code class="highlighter-rouge">ActiveRecord::Persistence#save!</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">save!</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">create_or_update</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="o">||</span> <span class="k">raise</span><span class="p">(</span><span class="no">RecordNotSaved</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"Failed to save the record"</span><span class="p">,</span> <span class="nb">self</span><span class="p">))</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">create_or_update</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">_raise_readonly_record_error</span> <span class="k">if</span> <span class="n">readonly?</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">new_record?</span> <span class="p">?</span> <span class="n">_create_record</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="p">:</span> <span class="n">_update_record</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">!=</span> <span class="kp">false</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个方法中，我们执行了 <code class="highlighter-rouge">#create_or_update</code> 以及 <code class="highlighter-rouge">#_create_record</code> 两个方法来创建模型：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_create_record</span><span class="p">(</span><span class="n">attribute_names</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">attribute_names</span><span class="p">)</span>
  <span class="n">attributes_values</span> <span class="o">=</span> <span class="n">arel_attributes_with_values_for_create</span><span class="p">(</span><span class="n">attribute_names</span><span class="p">)</span>
  <span class="n">new_id</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">insert</span> <span class="n">attributes_values</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">id</span> <span class="o">||=</span> <span class="n">new_id</span> <span class="k">if</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">primary_key</span>
  <span class="vi">@new_record</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="k">yield</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="k">if</span> <span class="nb">block_given?</span>
  <span class="nb">id</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个私有方法中开始执行数据的插入操作了，首先是通过 <code class="highlighter-rouge">ActiveRecord::AttributeMethods#arel_attributes_with_values_for_create</code> 方法获取一个用于插入数据的字典，其中包括了数据库中的表字段和对应的待插入值。</p>

<p><img src="https://img.draveness.me/2017-10-21-database-statement-insert.png" alt="database-statement-insert" /></p>

<p>而下面的 <code class="highlighter-rouge">.insert</code> 方法就会将这个字典转换成 SQL 语句，经过上图所示的调用栈最终到不同的数据库中执行语句并返回最新的主键。</p>

<h3 id="小结">小结</h3>

<p>从整个模型的创建过程中，我们可以看到 ActiveRecord 对于不同功能的组织非常优雅，每一个方法都非常简短并且易于阅读，通过对应的方法名和模块名我们就能够明确的知道这个东西是干什么的，对于同一个方法的不同执行逻辑也分散了不同的模块中，最终使用 module 加上 include 的方式组织起来，如果要对某个方法添加一些新的逻辑也可以通过增加更多的 module 达到目的。</p>

<p>通过对源代码的阅读，我们可以看到对于 ActiveRecord 来说，<code class="highlighter-rouge">#create</code> 和 <code class="highlighter-rouge">#save!</code> 方法的执行路径其实是差不多的，只是在细节上有一些不同之处。</p>

<p><img src="https://img.draveness.me/2017-10-21-actual-callstack-for-activerecord-base-save.png" alt="actual-callstack-for-activerecord-base-save" /></p>

<p>虽然模型或者说数据行的创建过程最终会从子类一路执行到父类的 <code class="highlighter-rouge">#save!</code> 方法，但是逻辑的<strong>处理顺序</strong>并不是按照从子类到父类执行的，我们可以通过上图了解不同模块的真正执行过程。</p>

<h2 id="scope-和查询的实现">Scope 和查询的实现</h2>

<p>除了模型的插入、创建和迁移模块，ActiveRecord 中还有另一个非常重要的模块，也就是 Scope 和查询；为什么同时介绍这两个看起来毫不相干的内容呢？这是因为 Scope 和查询是完全分不开的一个整体，在 ActiveRecord 的实现中，两者有着非常紧密的联系。</p>

<h3 id="activerecordrelation">ActiveRecord::Relation</h3>

<p>对 ActiveRecord 稍有了解的人都知道，在使用 ActiveRecord 进行查询时，所有的查询方法其实都会返回一个 <code class="highlighter-rouge">#{Model}::ActiveRecord_Relation</code> 类的对象，比如 <code class="highlighter-rouge">User.all</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">class</span>
<span class="o">=&gt;</span> <span class="no">User</span><span class="o">::</span><span class="no">ActiveRecord_Relation</span>
</code></pre></div></div>

<p>在这里使用 pry 来可以帮助我们快速理解整个过程到底都发生了什么事情：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">scoping</span><span class="o">/</span><span class="n">named</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">24</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Scoping</span><span class="o">::</span><span class="no">Named</span><span class="o">::</span><span class="no">ClassMethods</span>

<span class="k">def</span> <span class="nf">all</span>
  <span class="k">if</span> <span class="n">current_scope</span>
    <span class="n">current_scope</span><span class="p">.</span><span class="nf">clone</span>
  <span class="k">else</span>
    <span class="n">default_scoped</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">#all</code> 方法中的注释中也写着它会返回一个 <code class="highlighter-rouge">ActiveRecord::Relation</code> 对象，它其实可以理解为 ActiveRecord 查询体系中的单位元，它的调用并不改变当前查询；而如果我们使用 pry 去看其他的方法例如 <code class="highlighter-rouge">User.where</code> 的时候：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="no">User</span><span class="p">.</span><span class="nf">where</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">querying</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">10</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Querying</span>

<span class="n">delegate</span> <span class="ss">:select</span><span class="p">,</span> <span class="ss">:group</span><span class="p">,</span> <span class="ss">:order</span><span class="p">,</span> <span class="ss">:except</span><span class="p">,</span> <span class="ss">:reorder</span><span class="p">,</span> <span class="ss">:limit</span><span class="p">,</span> <span class="ss">:offset</span><span class="p">,</span> <span class="ss">:joins</span><span class="p">,</span> <span class="ss">:left_joins</span><span class="p">,</span> <span class="ss">:left_outer_joins</span><span class="p">,</span> <span class="ss">:or</span><span class="p">,</span>
         <span class="ss">:where</span><span class="p">,</span> <span class="ss">:rewhere</span><span class="p">,</span> <span class="ss">:preload</span><span class="p">,</span> <span class="ss">:eager_load</span><span class="p">,</span> <span class="ss">:includes</span><span class="p">,</span> <span class="ss">:from</span><span class="p">,</span> <span class="ss">:lock</span><span class="p">,</span> <span class="ss">:readonly</span><span class="p">,</span> <span class="ss">:extending</span><span class="p">,</span>
         <span class="ss">:having</span><span class="p">,</span> <span class="ss">:create_with</span><span class="p">,</span> <span class="ss">:distinct</span><span class="p">,</span> <span class="ss">:references</span><span class="p">,</span> <span class="ss">:none</span><span class="p">,</span> <span class="ss">:unscope</span><span class="p">,</span> <span class="ss">:merge</span><span class="p">,</span> <span class="ss">to: :all</span>
</code></pre></div></div>

<p>从这里我们可以看出，真正实现为 <code class="highlighter-rouge">User</code> 类方法的只有 <code class="highlighter-rouge">.all</code>，其他的方法都会代理给 <code class="highlighter-rouge">all</code> 方法，在 <code class="highlighter-rouge">.all</code> 方法返回的对象上执行：</p>

<p><img src="https://img.draveness.me/2017-10-21-active-record-relation-delegation.png" alt="active-record-relation-delegation" /></p>

<p>所有直接在类上调用的方法都会先执行 <code class="highlighter-rouge">#all</code>，也就是说下面的几种写法是完全相同的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">User</span>    <span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">name: </span><span class="s1">'draven'</span><span class="p">)</span>
<span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">name: </span><span class="s1">'draven'</span><span class="p">)</span>
<span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">name: </span><span class="s1">'draven'</span><span class="p">).</span><span class="nf">all</span>
</code></pre></div></div>

<p>当我们了解了 <code class="highlighter-rouge">.where == .all + #where</code> 就可以再一次使用 pry 来查找真正被 ActiveRecord 实现的 <code class="highlighter-rouge">#where</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">where</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">relation</span><span class="o">/</span><span class="n">query_methods</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">599</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">QueryMethods</span>

<span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="n">opts</span> <span class="o">=</span> <span class="ss">:chain</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">)</span>
  <span class="k">if</span> <span class="ss">:chain</span> <span class="o">==</span> <span class="n">opts</span>
    <span class="no">WhereChain</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">spawn</span><span class="p">)</span>
  <span class="k">elsif</span> <span class="n">opts</span><span class="p">.</span><span class="nf">blank?</span>
    <span class="nb">self</span>
  <span class="k">else</span>
    <span class="n">spawn</span><span class="p">.</span><span class="nf">where!</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在分析查询的过程中，我们会选择几个常见的方法作为入口，尽可能得覆盖较多的查询相关的代码，增加我们对 ActiveRecord 的理解和认识。</p>

<h3 id="从-userall-开始">从 User.all 开始</h3>

<p>再来看一下上面看到的 <code class="highlighter-rouge">ActiveRecord::Relation.all</code> 方法，无论是 <code class="highlighter-rouge">#current_scope</code> 还是 <code class="highlighter-rouge">#default_scoped</code> 其实返回的都是当前的 <code class="highlighter-rouge">ActiveRecord</code> 对象：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">all</span>
  <span class="k">if</span> <span class="n">current_scope</span>
    <span class="n">current_scope</span><span class="p">.</span><span class="nf">clone</span>
  <span class="k">else</span>
    <span class="n">default_scoped</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="current_scope-和-default_scope">current_scope 和 default_scope</h4>

<p>如果当前没有 <code class="highlighter-rouge">#current_scope</code> 那么，就会调用 <code class="highlighter-rouge">#default_scoped</code> 返回响应的结果，否则就会 clone 当前对象并返回，可以简单举一个例子证明这里的猜测：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">current_scope</span>
<span class="o">=&gt;</span> <span class="kp">nil</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">current_scope</span>
  <span class="no">User</span> <span class="no">Load</span> <span class="p">(</span><span class="mf">0.1</span><span class="n">ms</span><span class="p">)</span>  <span class="no">SELECT</span> <span class="s2">"users"</span><span class="p">.</span><span class="nf">*</span> <span class="no">FROM</span> <span class="s2">"users"</span>
<span class="o">=&gt;</span> <span class="p">[]</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">current_scope</span><span class="p">.</span><span class="nf">class</span>
<span class="o">=&gt;</span> <span class="no">User</span><span class="o">::</span><span class="no">ActiveRecord_Relation</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">.current_scope</code> 是存储在位于线程变量的 <code class="highlighter-rouge">ScopeRegistry</code> 中，它其实就是当前的查询语句的上下文，存储着这一次链式调用造成的全部副作用：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">current_scope</span><span class="p">(</span><span class="n">skip_inherited_scope</span> <span class="o">=</span> <span class="kp">false</span><span class="p">)</span>
  <span class="no">ScopeRegistry</span><span class="p">.</span><span class="nf">value_for</span><span class="p">(</span><span class="ss">:current_scope</span><span class="p">,</span> <span class="nb">self</span><span class="p">,</span> <span class="n">skip_inherited_scope</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>而 <code class="highlighter-rouge">.default_scoped</code> 就是在当前查询链刚开始时执行的第一个方法，因为在执行第一个查询方法之前 <code class="highlighter-rouge">.current_scope</code> 一定为空：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">default_scoped</span><span class="p">(</span><span class="n">scope</span> <span class="o">=</span> <span class="n">relation</span><span class="p">)</span>
  <span class="n">build_default_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span> <span class="o">||</span> <span class="n">scope</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">build_default_scope</span><span class="p">(</span><span class="n">base_rel</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="k">return</span> <span class="k">if</span> <span class="n">abstract_class?</span>

  <span class="k">if</span> <span class="n">default_scopes</span><span class="p">.</span><span class="nf">any?</span>
    <span class="n">base_rel</span> <span class="o">||=</span> <span class="n">relation</span>
    <span class="n">evaluate_default_scope</span> <span class="k">do</span>
      <span class="n">default_scopes</span><span class="p">.</span><span class="nf">inject</span><span class="p">(</span><span class="n">base_rel</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">default_scope</span><span class="p">,</span> <span class="n">scope</span><span class="o">|</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:to_proc</span><span class="p">)</span> <span class="p">?</span> <span class="n">scope</span> <span class="p">:</span> <span class="n">scope</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="ss">:call</span><span class="p">)</span>
        <span class="n">default_scope</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">base_rel</span><span class="p">.</span><span class="nf">instance_exec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scope</span><span class="p">))</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当我们在 Rails 的模型层中使用 <code class="highlighter-rouge">.default_scope</code> 定义一些默认的上下文时，所有的 block 都换被转换成 <code class="highlighter-rouge">Proc</code> 对象最终添加到 <code class="highlighter-rouge">default_scopes</code> 数组中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">default_scope</span><span class="p">(</span><span class="n">scope</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span> <span class="c1"># :doc:</span>
  <span class="n">scope</span> <span class="o">=</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="k">if</span> <span class="nb">block_given?</span>
  <span class="c1"># ...</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">default_scopes</span> <span class="o">+=</span> <span class="p">[</span><span class="n">scope</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上面提到的 <code class="highlighter-rouge">.build_default_scope</code> 方法其实只是在 <code class="highlighter-rouge">default_scopes</code> 数组不为空时，将当前的 <code class="highlighter-rouge">Relation</code> 对象和数组中的全部 scope 一一 <code class="highlighter-rouge">#merge</code> 并返回一个新的 <code class="highlighter-rouge">Relation</code> 对象。</p>

<h4 id="activerecordrelation-对象">ActiveRecord::Relation 对象</h4>

<p><code class="highlighter-rouge">.default_scoped</code> 方法的参数 <code class="highlighter-rouge">scope</code> 其实就有一个默认值 <code class="highlighter-rouge">#relation</code>，这个默认值其实就是一个 <code class="highlighter-rouge">Relation</code> 类的实例：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">relation</span>
  <span class="n">relation</span> <span class="o">=</span> <span class="no">Relation</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">arel_table</span><span class="p">,</span> <span class="n">predicate_builder</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">finder_needs_type_condition?</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ignore_default_scope?</span>
    <span class="n">relation</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">type_condition</span><span class="p">).</span><span class="nf">create_with</span><span class="p">(</span><span class="n">inheritance_column</span><span class="p">.</span><span class="nf">to_s</span> <span class="o">=&gt;</span> <span class="n">sti_name</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="n">relation</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Relation.create</code> 对象的创建过程其实比较复杂，我们只需要知道经过 ActiveRecord 一系列的疯狂操作，最终会将几个参数传入 <code class="highlighter-rouge">.new</code> 方法初始化一个 <code class="highlighter-rouge">ActiveRecord::Relation</code> 实例：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Relation</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">predicate_builder</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="vi">@klass</span>  <span class="o">=</span> <span class="n">klass</span>
    <span class="vi">@table</span>  <span class="o">=</span> <span class="n">table</span>
    <span class="vi">@values</span> <span class="o">=</span> <span class="n">values</span>
    <span class="vi">@offsets</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="vi">@loaded</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="vi">@predicate_builder</span> <span class="o">=</span> <span class="n">predicate_builder</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当执行的是 <code class="highlighter-rouge">#all</code>、<code class="highlighter-rouge">.all</code> 或者绝大多数查询方法时，都会直接将这个初始化的对象返回来接受随后的链式调用。</p>

<h3 id="where-方法">where 方法</h3>

<p>相比于 <code class="highlighter-rouge">#all</code>、<code class="highlighter-rouge">#where</code> 查询的实现就复杂多了，不像 <code class="highlighter-rouge">#all</code> 会返回一个默认的 <code class="highlighter-rouge">Relation</code> 对象，<code class="highlighter-rouge">#where</code> 由 <code class="highlighter-rouge">WhereClause</code> 以及 <code class="highlighter-rouge">WhereClauseFactory</code> 等类共同处理；在 <code class="highlighter-rouge">#where</code> 的最正常的执行路径中，它会执行 <code class="highlighter-rouge">#where!</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="n">opts</span> <span class="o">=</span> <span class="ss">:chain</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">)</span>
  <span class="k">if</span> <span class="ss">:chain</span> <span class="o">==</span> <span class="n">opts</span>
    <span class="no">WhereChain</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">spawn</span><span class="p">)</span>
  <span class="k">elsif</span> <span class="n">opts</span><span class="p">.</span><span class="nf">blank?</span>
    <span class="nb">self</span>
  <span class="k">else</span>
    <span class="n">spawn</span><span class="p">.</span><span class="nf">where!</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">where!</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">)</span>
  <span class="n">opts</span> <span class="o">=</span> <span class="n">sanitize_forbidden_attributes</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
  <span class="n">references!</span><span class="p">(</span><span class="no">PredicateBuilder</span><span class="p">.</span><span class="nf">references</span><span class="p">(</span><span class="n">opts</span><span class="p">))</span> <span class="k">if</span> <span class="no">Hash</span> <span class="o">===</span> <span class="n">opts</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">where_clause</span> <span class="o">+=</span> <span class="n">where_clause_factory</span><span class="p">.</span><span class="nf">build</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span>
  <span class="nb">self</span>
<span class="k">end</span>
</code></pre></div></div>

<blockquote>
  <p><code class="highlighter-rouge">#spawn</code> 其实就是对当前的 <code class="highlighter-rouge">Relation</code> 对象进行 <code class="highlighter-rouge">#clone</code>。</p>
</blockquote>

<p>查询方法 <code class="highlighter-rouge">#where!</code> 中的四行代码只有一行代码是我们需要关注的，该方法调用 <code class="highlighter-rouge">WhereClauseFactory#build</code> 生成一条 where 查询并存储到当前对象的 <code class="highlighter-rouge">where_clause</code> 中，在这个过程中并不会生成 SQL，而是会生成一个 <code class="highlighter-rouge">WhereClause</code> 对象，其中存储着 SQL 节点树：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">name: </span><span class="s1">'draven'</span><span class="p">).</span><span class="nf">where_clause</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;ActiveRecord::Relation::WhereClause:0x007fe5a10bf2c8</span>
 <span class="vi">@binds</span><span class="o">=</span>
  <span class="p">[</span><span class="c1">#&lt;ActiveRecord::Relation::QueryAttribute:0x007fe5a10bf4f8</span>
    <span class="vi">@name</span><span class="o">=</span><span class="s2">"name"</span><span class="p">,</span>
    <span class="vi">@original_attribute</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span>
    <span class="vi">@type</span><span class="o">=</span><span class="c1">#&lt;ActiveModel::Type::String:0x007fe59d33f2e0 @limit=nil, @precision=nil, @scale=nil&gt;,</span>
    <span class="vi">@value_before_type_cast</span><span class="o">=</span><span class="s2">"draven"</span><span class="o">&gt;</span><span class="p">],</span>
 <span class="vi">@predicates</span><span class="o">=</span>
  <span class="p">[</span><span class="c1">#&lt;Arel::Nodes::Equality:0x007fe5a10bf368</span>
    <span class="vi">@left</span><span class="o">=</span>
     <span class="c1">#&lt;struct Arel::Attributes::Attribute</span>
      <span class="n">relation</span><span class="o">=</span>
       <span class="c1">#&lt;Arel::Table:0x007fe59cc87830</span>
        <span class="vi">@name</span><span class="o">=</span><span class="s2">"users"</span><span class="p">,</span>
        <span class="vi">@table_alias</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span>
        <span class="vi">@type_caster</span><span class="o">=</span>
         <span class="c1">#&lt;ActiveRecord::TypeCaster::Map:0x007fe59cc87bf0</span>
          <span class="vi">@types</span><span class="o">=</span>
           <span class="no">User</span><span class="p">(</span><span class="ss">id: </span><span class="n">integer</span><span class="p">,</span> <span class="ss">avatar: </span><span class="n">string</span><span class="p">,</span> <span class="ss">nickname: </span><span class="n">string</span><span class="p">,</span> <span class="ss">wechat: </span><span class="n">string</span><span class="p">,</span> <span class="ss">name: </span><span class="n">string</span><span class="p">,</span> <span class="ss">gender: </span><span class="n">integer</span><span class="p">,</span> <span class="ss">school: </span><span class="n">string</span><span class="p">,</span> <span class="ss">grade: </span><span class="n">string</span><span class="p">,</span> <span class="ss">major: </span><span class="n">string</span><span class="p">,</span> <span class="ss">completed: </span><span class="n">boolean</span><span class="p">,</span> <span class="ss">created_at: </span><span class="n">datetime</span><span class="p">,</span> <span class="ss">updated_at: </span><span class="n">datetime</span><span class="p">,</span> <span class="ss">mobile: </span><span class="n">string</span><span class="p">,</span> <span class="ss">admin: </span><span class="n">boolean</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">,</span>
      <span class="nb">name</span><span class="o">=</span><span class="s2">"name"</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="vi">@right</span><span class="o">=</span><span class="c1">#&lt;Arel::Nodes::BindParam:0x007fe5a10bf520&gt;&gt;]&gt;</span>
</code></pre></div></div>

<blockquote>
  <p><a href="https://github.com/rails/arel">Arel</a> 是一个 Ruby 的 SQL 抽象语法树的管理器，ActiveRecord 查询的过程都是惰性的，在真正进入数据库查询之前，查询条件都是以语法树的形式存储的。</p>
</blockquote>

<p>在这里不像展开介绍 SQL 语法树的生成过程，因为过程比较复杂，详细分析也没有太大的意义。</p>

<h3 id="order-方法">order 方法</h3>

<p>除了 <code class="highlighter-rouge">#where</code> 方法之外，在这里还想简单介绍一下另外一个常用的方法 <code class="highlighter-rouge">#order</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">check_if_method_has_arguments!</span><span class="p">(</span><span class="ss">:order</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
  <span class="n">spawn</span><span class="p">.</span><span class="nf">order!</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">order!</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">preprocess_order_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">order_values</span> <span class="o">+=</span> <span class="n">args</span>
  <span class="nb">self</span>
<span class="k">end</span>
</code></pre></div></div>

<p>该方法的调用栈与 <code class="highlighter-rouge">#where</code> 非常相似，在调用栈中都会执行另一个带有 <code class="highlighter-rouge">!</code> 的方法，也都会向自己持有的某个『属性』追加一些参数，参数的处理也有点复杂，在这里简单看一看就好：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">preprocess_order_args</span><span class="p">(</span><span class="n">order_args</span><span class="p">)</span>
  <span class="n">order_args</span><span class="p">.</span><span class="nf">map!</span> <span class="k">do</span> <span class="o">|</span><span class="n">arg</span><span class="o">|</span>
    <span class="n">klass</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="ss">:sanitize_sql_for_order</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">order_args</span><span class="p">.</span><span class="nf">flatten!</span>
  <span class="n">validate_order_args</span><span class="p">(</span><span class="n">order_args</span><span class="p">)</span>

  <span class="n">references</span> <span class="o">=</span> <span class="n">order_args</span><span class="p">.</span><span class="nf">grep</span><span class="p">(</span><span class="no">String</span><span class="p">)</span>
  <span class="n">references</span><span class="p">.</span><span class="nf">map!</span> <span class="p">{</span> <span class="o">|</span><span class="n">arg</span><span class="o">|</span> <span class="n">arg</span> <span class="o">=~</span> <span class="sr">/^([a-zA-Z]\w*)\.(\w+)/</span> <span class="o">&amp;&amp;</span> <span class="vg">$1</span> <span class="p">}.</span><span class="nf">compact!</span>
  <span class="n">references!</span><span class="p">(</span><span class="n">references</span><span class="p">)</span> <span class="k">if</span> <span class="n">references</span><span class="p">.</span><span class="nf">any?</span>

  <span class="c1"># if a symbol is given we prepend the quoted table name</span>
  <span class="n">order_args</span><span class="p">.</span><span class="nf">map!</span> <span class="k">do</span> <span class="o">|</span><span class="n">arg</span><span class="o">|</span>
    <span class="k">case</span> <span class="n">arg</span>
    <span class="k">when</span> <span class="no">Symbol</span>
      <span class="n">arel_attribute</span><span class="p">(</span><span class="n">arg</span><span class="p">).</span><span class="nf">asc</span>
    <span class="k">when</span> <span class="no">Hash</span>
      <span class="n">arg</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">field</span><span class="p">,</span> <span class="n">dir</span><span class="o">|</span>
        <span class="k">case</span> <span class="n">field</span>
        <span class="k">when</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">SqlLiteral</span>
          <span class="n">field</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">dir</span><span class="p">.</span><span class="nf">downcase</span><span class="p">)</span>
        <span class="k">else</span>
          <span class="n">arel_attribute</span><span class="p">(</span><span class="n">field</span><span class="p">).</span><span class="nf">send</span><span class="p">(</span><span class="n">dir</span><span class="p">.</span><span class="nf">downcase</span><span class="p">)</span>
        <span class="k">end</span>
      <span class="p">}</span>
    <span class="k">else</span>
      <span class="n">arg</span>
    <span class="k">end</span>
  <span class="k">end</span><span class="p">.</span><span class="nf">flatten!</span>
<span class="k">end</span>
</code></pre></div></div>

<p>同样的，<code class="highlighter-rouge">#order</code> 方法的使用也会向 <code class="highlighter-rouge">order_values</code> 数组中添加对应的语法元素：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">name: :desc</span><span class="p">).</span><span class="nf">order_values</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="c1">#&lt;Arel::Nodes::Descending:0x007fe59ce4f190</span>
  <span class="vi">@expr</span><span class="o">=</span>
   <span class="c1">#&lt;struct Arel::Attributes::Attribute</span>
    <span class="n">relation</span><span class="o">=</span>
     <span class="c1">#&lt;Arel::Table:0x007fe59cc87830</span>
      <span class="vi">@name</span><span class="o">=</span><span class="s2">"users"</span><span class="p">,</span>
      <span class="vi">@table_alias</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span>
      <span class="vi">@type_caster</span><span class="o">=</span>
       <span class="c1">#&lt;ActiveRecord::TypeCaster::Map:0x007fe59cc87bf0</span>
        <span class="vi">@types</span><span class="o">=</span>
         <span class="no">User</span><span class="p">(</span><span class="ss">id: </span><span class="n">integer</span><span class="p">,</span> <span class="ss">avatar: </span><span class="n">string</span><span class="p">,</span> <span class="ss">nickname: </span><span class="n">string</span><span class="p">,</span> <span class="ss">wechat: </span><span class="n">string</span><span class="p">,</span> <span class="ss">name: </span><span class="n">string</span><span class="p">,</span> <span class="ss">gender: </span><span class="n">integer</span><span class="p">,</span> <span class="ss">school: </span><span class="n">string</span><span class="p">,</span> <span class="ss">grade: </span><span class="n">string</span><span class="p">,</span> <span class="ss">major: </span><span class="n">string</span><span class="p">,</span> <span class="ss">completed: </span><span class="n">boolean</span><span class="p">,</span> <span class="ss">created_at: </span><span class="n">datetime</span><span class="p">,</span> <span class="ss">updated_at: </span><span class="n">datetime</span><span class="p">,</span> <span class="ss">mobile: </span><span class="n">string</span><span class="p">,</span> <span class="ss">admin: </span><span class="n">boolean</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="nb">name</span><span class="o">=</span><span class="ss">:name</span><span class="o">&gt;&gt;</span><span class="p">]</span>
</code></pre></div></div>

<p>在这个方法的返回值中，我们也能看到与 Arel 相关的各种节点，可以大致理解上述语法树的作用。</p>

<h3 id="语法树的存储">语法树的存储</h3>

<p>无论是 <code class="highlighter-rouge">#where</code> 还是 <code class="highlighter-rouge">#order</code> 方法，它们其实都会向当前的 <code class="highlighter-rouge">Relation</code> 对象中追加相应的语法树节点，而除了上述的两个方法之外 <code class="highlighter-rouge">#from</code>、<code class="highlighter-rouge">#distinct</code>、<code class="highlighter-rouge">#lock</code>、<code class="highlighter-rouge">#limit</code> 等等，几乎所有的查询方法都会改变 <code class="highlighter-rouge">Relation</code> 中的某个值，然而所有的值其实都是通过 <code class="highlighter-rouge">@values</code> 这个实例变量存储的：</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-relation-value-methods.png" alt="activerecord-relation-value-methods" /></p>

<p><code class="highlighter-rouge">@values</code> 中存储的值分为三类，<code class="highlighter-rouge">SINGLE_VALUE</code>、<code class="highlighter-rouge">MULTI_VALUE</code> 和 <code class="highlighter-rouge">CLAUSE</code>，这三类属性会按照下面的规则存储在 <code class="highlighter-rouge">@values</code> 中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Relation</span><span class="o">::</span><span class="no">VALUE_METHODS</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
  <span class="n">method_name</span> <span class="o">=</span> <span class="p">\</span>
    <span class="k">case</span> <span class="nb">name</span>
    <span class="k">when</span> <span class="o">*</span><span class="no">Relation</span><span class="o">::</span><span class="no">MULTI_VALUE_METHODS</span> <span class="k">then</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">_values"</span>
    <span class="k">when</span> <span class="o">*</span><span class="no">Relation</span><span class="o">::</span><span class="no">SINGLE_VALUE_METHODS</span> <span class="k">then</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">_value"</span>
    <span class="k">when</span> <span class="o">*</span><span class="no">Relation</span><span class="o">::</span><span class="no">CLAUSE_METHODS</span> <span class="k">then</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">_clause"</span>
    <span class="k">end</span>
  <span class="nb">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
    def </span><span class="si">#{</span><span class="n">method_name</span><span class="si">}</span><span class="sh">                   # def includes_values
      get_value(</span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="sh">)         #   get_value(:includes)
    end                                  # end

    def </span><span class="si">#{</span><span class="n">method_name</span><span class="si">}</span><span class="sh">=(value)           # def includes_values=(value)
      set_value(</span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="sh">, value)  #   set_value(:includes, value)
    end                                  # end
</span><span class="no">  CODE</span>
<span class="k">end</span>
</code></pre></div></div>

<p>各种不同的值在最后都会按照一定的命名规则，存储在这个 <code class="highlighter-rouge">@values</code> 字典中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="vi">@values</span><span class="p">[</span><span class="nb">name</span><span class="p">]</span> <span class="o">||</span> <span class="n">default_value_for</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
  <span class="n">assert_mutability!</span>
  <span class="vi">@values</span><span class="p">[</span><span class="nb">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果我们直接在一个查询链中访问 <code class="highlighter-rouge">#values</code> 方法可以获得其中存储的所有查询条件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">name: </span><span class="s1">'draven'</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="ss">name: :desc</span><span class="p">).</span><span class="nf">values</span>
<span class="o">=&gt;</span> <span class="p">{</span><span class="ss">:references</span><span class="o">=&gt;</span><span class="p">[],</span>
 <span class="ss">:where</span><span class="o">=&gt;</span>
  <span class="c1">#&lt;ActiveRecord::Relation::WhereClause:0x007fe59d14d860&gt;,</span>
 <span class="ss">:order</span><span class="o">=&gt;</span>
  <span class="p">[</span><span class="c1">#&lt;Arel::Nodes::Descending:0x007fe59d14cd98&gt;]}</span>
</code></pre></div></div>

<p>很多 ActiveRecord 的使用者其实在使用的过程中都感觉在各种链式方法调用时没有改变任何事情，所有的方法都可以任意组合进行链式调用，其实每一个方法的调用都会对 <code class="highlighter-rouge">@values</code> 中存储的信息进行了修改，只是 ActiveRecord 很好地将它隐藏了幕后，让我们没有感知到它的存在。</p>

<h3 id="scope-方法">scope 方法</h3>

<p>相比于 <code class="highlighter-rouge">.default_scope</code> 这个类方法只是改变了当前模型中的 <code class="highlighter-rouge">default_scopes</code> 数组，另一个方法 <code class="highlighter-rouge">.scope</code> 会为当前类定义一个新的类方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">scoping</span><span class="o">/</span><span class="n">named</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">155</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Scoping</span><span class="o">::</span><span class="no">Named</span><span class="o">::</span><span class="no">ClassMethods</span>

<span class="k">def</span> <span class="nf">scope</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">extension</span> <span class="o">=</span> <span class="no">Module</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="k">if</span> <span class="n">block</span>

  <span class="k">if</span> <span class="n">body</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:to_proc</span><span class="p">)</span>
    <span class="n">singleton_class</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="ss">:define_method</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span> <span class="k">do</span> <span class="o">|*</span><span class="n">args</span><span class="o">|</span>
      <span class="n">scope</span> <span class="o">=</span> <span class="n">all</span><span class="p">.</span><span class="nf">scoping</span> <span class="p">{</span> <span class="n">instance_exec</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">body</span><span class="p">)</span> <span class="p">}</span>
      <span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span><span class="p">.</span><span class="nf">extending</span><span class="p">(</span><span class="n">extension</span><span class="p">)</span> <span class="k">if</span> <span class="n">extension</span>
      <span class="n">scope</span> <span class="o">||</span> <span class="n">all</span>
    <span class="k">end</span>
  <span class="k">else</span>
    <span class="n">singleton_class</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="ss">:define_method</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span> <span class="k">do</span> <span class="o">|*</span><span class="n">args</span><span class="o">|</span>
      <span class="n">scope</span> <span class="o">=</span> <span class="n">all</span><span class="p">.</span><span class="nf">scoping</span> <span class="p">{</span> <span class="n">body</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="p">}</span>
      <span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span><span class="p">.</span><span class="nf">extending</span><span class="p">(</span><span class="n">extension</span><span class="p">)</span> <span class="k">if</span> <span class="n">extension</span>
      <span class="n">scope</span> <span class="o">||</span> <span class="n">all</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法会直接在当前类的单类上通过 <code class="highlighter-rouge">define_methods</code> 为当前类定义类方法，定义的方法会在上面提到的 <code class="highlighter-rouge">.all</code> 的返回结果上执行 <code class="highlighter-rouge">#scoping</code>，存储当前执行的上下文，执行传入的 block，再恢复 <code class="highlighter-rouge">current_scope</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">scoping</span>
  <span class="n">previous</span><span class="p">,</span> <span class="n">klass</span><span class="p">.</span><span class="nf">current_scope</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">current_scope</span><span class="p">(</span><span class="kp">true</span><span class="p">),</span> <span class="nb">self</span>
  <span class="k">yield</span>
<span class="k">ensure</span>
  <span class="n">klass</span><span class="p">.</span><span class="nf">current_scope</span> <span class="o">=</span> <span class="n">previous</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这里其实有一个可能很多人从来没用过的特性，就是在 <code class="highlighter-rouge">.scope</code> 方法中传入一个 block：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span>
  <span class="n">scope</span> <span class="ss">:male</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="ss">gender: :male</span> <span class="p">}</span> <span class="k">do</span>
    <span class="k">def</span> <span class="nf">twenty</span>
      <span class="n">where</span> <span class="ss">age: </span><span class="mi">20</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">male</span><span class="p">.</span><span class="nf">twenty</span>
<span class="c1">#=&gt; &lt;#User:0x007f98f3d61c38&gt;</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">twenty</span>
<span class="c1">#=&gt; NoMethodError: undefined method `twenty' for #&lt;Class:0x007f98f5c7b2b8&gt;</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">female</span><span class="p">.</span><span class="nf">twenty</span>
<span class="c1">#=&gt; NoMethodError: undefined method `twenty' for #&lt;User::ActiveRecord_Relation:0x007f98f5d950e0&gt;</span>
</code></pre></div></div>

<p>这个传入的 block 只会在当前 <code class="highlighter-rouge">Relation</code> 对象的单类上添加方法，如果我们想定义一些不想在其他作用域使用的方法就可以使用这种方式：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">extending</span><span class="p">(</span><span class="o">*</span><span class="n">modules</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">modules</span><span class="p">.</span><span class="nf">any?</span> <span class="o">||</span> <span class="n">block</span>
    <span class="n">spawn</span><span class="p">.</span><span class="nf">extending!</span><span class="p">(</span><span class="o">*</span><span class="n">modules</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="nb">self</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">extending!</span><span class="p">(</span><span class="o">*</span><span class="n">modules</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">modules</span> <span class="o">&lt;&lt;</span> <span class="no">Module</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="k">if</span> <span class="n">block</span>
  <span class="n">modules</span><span class="p">.</span><span class="nf">flatten!</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">extending_values</span> <span class="o">+=</span> <span class="n">modules</span>
  <span class="kp">extend</span><span class="p">(</span><span class="o">*</span><span class="n">extending_values</span><span class="p">)</span> <span class="k">if</span> <span class="n">extending_values</span><span class="p">.</span><span class="nf">any?</span>
  <span class="nb">self</span>
<span class="k">end</span>
</code></pre></div></div>

<p>而 <code class="highlighter-rouge">extending</code> 方法的实现确实与我们预期的一样，创建了新的 <code class="highlighter-rouge">Module</code> 对象之后，直接使用 <code class="highlighter-rouge">#extend</code> 将其中的方法挂载当前对象的单类上。</p>

<h3 id="小结-1">小结</h3>

<p>到这里为止，我们对 ActiveRecord 中查询的分析就已经比较全面了，从最终要的 <code class="highlighter-rouge">Relation</code> 对象，到常见的 <code class="highlighter-rouge">#all</code>、<code class="highlighter-rouge">#where</code> 和 <code class="highlighter-rouge">#order</code> 方法，到 ActiveRecord 对语法树的存储，如何与 Arel 进行协作，在最后我们也介绍了 <code class="highlighter-rouge">.scope</code> 方法的工作原理，对于其它方法或者功能的实现其实也都大同小异，在这里就不展开细谈了。</p>

<h2 id="模型的关系">模型的关系</h2>

<p>作为一个关系型数据库的 ORM，ActiveRecord 一定要提供对模型之间关系的支持，它为模型之间的关系建立提供了四个类方法 <code class="highlighter-rouge">has_many</code>、<code class="highlighter-rouge">has_one</code>、<code class="highlighter-rouge">belongs_to</code> 和 <code class="highlighter-rouge">has_and_belongs_to_many</code>，在文章的这一部分，我们会从上面几个方法中选择一部分介绍 ActiveRecord 是如何建立模型之间的关系的。</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-associations.png" alt="activerecord-associations" /></p>

<h3 id="association-和继承链">Association 和继承链</h3>

<p>首先来看 <code class="highlighter-rouge">.has_many</code> 方法是如何实现的，我们可以通过 pry 直接找到该方法的源代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="no">User</span><span class="p">.</span><span class="nf">has_many</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">associations</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">1401</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Associations</span><span class="o">::</span><span class="no">ClassMethods</span>

<span class="k">def</span> <span class="nf">has_many</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">scope</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{},</span> <span class="o">&amp;</span><span class="n">extension</span><span class="p">)</span>
  <span class="n">reflection</span> <span class="o">=</span> <span class="no">Builder</span><span class="o">::</span><span class="no">HasMany</span><span class="p">.</span><span class="nf">build</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extension</span><span class="p">)</span>
  <span class="no">Reflection</span><span class="p">.</span><span class="nf">add_reflection</span> <span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">reflection</span>
<span class="k">end</span>
</code></pre></div></div>

<p>整个 <code class="highlighter-rouge">.has_many</code> 方法的实现也只有两行代码，总共涉及两个类 <code class="highlighter-rouge">Builder::HasMany</code> 和 <code class="highlighter-rouge">Reflection</code>，其中前者用于创建新的 <code class="highlighter-rouge">HasMany</code> 关系，后者负责将关系添加到当前类中。</p>

<p><code class="highlighter-rouge">HasMany</code> 类的实现其实非常简单，但是它从父类和整个继承链中继承了很多方法：</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-hasmany-ancestors.png" alt="activerecord-hasmany-ancestors" /></p>

<p>我们暂时先忘记 <code class="highlighter-rouge">.has_many</code> 方法的实现，先来看一下这里涉及的两个非常重要的类都是如何工作的，首先是 <code class="highlighter-rouge">Association</code> 以及它的子类；在 ActiveRecord 的实现中，我们其实能够找到四种关系的 Builder，它们有着非常清晰简单的继承关系：</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-ancestor-builders.png" alt="activerecord-ancestor-builders" /></p>

<p>在这里定义的 <code class="highlighter-rouge">.build</code> 方法其实实现也很清晰，它通过调用当前抽象类 <code class="highlighter-rouge">Association</code> 或者子类的响应方法完成一些建立关系必要的工作：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">build</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">extension</span> <span class="o">=</span> <span class="n">define_extensions</span> <span class="n">model</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span>
  <span class="n">reflection</span> <span class="o">=</span> <span class="n">create_reflection</span> <span class="n">model</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">extension</span>
  <span class="n">define_accessors</span> <span class="n">model</span><span class="p">,</span> <span class="n">reflection</span>
  <span class="n">define_callbacks</span> <span class="n">model</span><span class="p">,</span> <span class="n">reflection</span>
  <span class="n">define_validations</span> <span class="n">model</span><span class="p">,</span> <span class="n">reflection</span>
  <span class="n">reflection</span>
<span class="k">end</span>
</code></pre></div></div>

<p>其中包括创建用于操作、查询和管理当前关系扩展 Module 的 <code class="highlighter-rouge">.define_extensions</code> 方法，同时也会使用 <code class="highlighter-rouge">.create_reflection</code> 创建一个用于检查 ActiveRecord 类的关系的 <code class="highlighter-rouge">Reflection</code> 对象，我们会在下一节中展开介绍，在创建了 <code class="highlighter-rouge">Reflection</code> 后，我们会根据传入的模型和 <code class="highlighter-rouge">Reflection</code> 对象为当前的类，例如 <code class="highlighter-rouge">User</code> 定义属性存取方法、回调以及验证:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_accessors</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">reflection</span><span class="p">)</span>
  <span class="n">mixin</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="nf">generated_association_methods</span>
  <span class="nb">name</span> <span class="o">=</span> <span class="n">reflection</span><span class="p">.</span><span class="nf">name</span>
  <span class="n">define_readers</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
  <span class="n">define_writers</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_readers</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
  <span class="n">mixin</span><span class="p">.</span><span class="nf">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
    def </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">(*args)
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).reader(*args)
    end
</span><span class="no">  CODE</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_writers</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
  <span class="n">mixin</span><span class="p">.</span><span class="nf">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
    def </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">=(value)
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).writer(value)
    end
</span><span class="no">  CODE</span>
<span class="k">end</span>
</code></pre></div></div>

<p>存取方法还是通过 Ruby 的元编程能力定义的，在这里通过 <code class="highlighter-rouge">.class_eval</code> 方法非常轻松地就能在当前的模型中定义方法，关于回调和验证的定义在这里就不在展开介绍了。</p>

<h3 id="reflection-和继承链">Reflection 和继承链</h3>

<p><code class="highlighter-rouge">Reflection</code> 启用了检查 ActiveRecord 类和对象的关系和聚合的功能，它能够在 Builder 中使用为 ActiveRecord 中的类创建对应属性和方法。</p>

<p>与 <code class="highlighter-rouge">Association</code> 一样，ActiveRecord 中的不同关系也有不同的 <code class="highlighter-rouge">Reflection</code>，根据不同的关系和不同的配置，ActiveRecord 中建立了一套 Reflection 的继承体系与数据库中的不同关系一一对应：</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-reflections.png" alt="activerecord-reflections" /></p>

<p>当我们在上面使用 <code class="highlighter-rouge">.has_many</code> 方法时，会通过 <code class="highlighter-rouge">.create_reflection</code> 创建一个 <code class="highlighter-rouge">HasManyReflection</code> 对象：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">create_reflection</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">extension</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">scope</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Hash</span><span class="p">)</span>
    <span class="n">options</span> <span class="o">=</span> <span class="n">scope</span>
    <span class="n">scope</span>   <span class="o">=</span> <span class="kp">nil</span>
  <span class="k">end</span>

  <span class="n">validate_options</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
  <span class="n">scope</span> <span class="o">=</span> <span class="n">build_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="n">extension</span><span class="p">)</span>
  <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Reflection</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="n">macro</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Reflection#create</code> 方法是一个工厂方法，它会根据传入的 <code class="highlighter-rouge">macro</code> 和 <code class="highlighter-rouge">options</code> 中的值选择合适的类实例化：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">create</span><span class="p">(</span><span class="n">macro</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">ar</span><span class="p">)</span>
  <span class="n">klass</span> <span class="o">=</span> <span class="p">\</span>
    <span class="k">case</span> <span class="n">macro</span>
    <span class="k">when</span> <span class="ss">:composed_of</span>
      <span class="no">AggregateReflection</span>
    <span class="k">when</span> <span class="ss">:has_many</span>
      <span class="no">HasManyReflection</span>
    <span class="k">when</span> <span class="ss">:has_one</span>
      <span class="no">HasOneReflection</span>
    <span class="k">when</span> <span class="ss">:belongs_to</span>
      <span class="no">BelongsToReflection</span>
    <span class="k">else</span>
      <span class="k">raise</span> <span class="s2">"Unsupported Macro: </span><span class="si">#{</span><span class="n">macro</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>

  <span class="n">reflection</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">ar</span><span class="p">)</span>
  <span class="n">options</span><span class="p">[</span><span class="ss">:through</span><span class="p">]</span> <span class="p">?</span> <span class="no">ThroughReflection</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">reflection</span><span class="p">)</span> <span class="p">:</span> <span class="n">reflection</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这个创建的 <code class="highlighter-rouge">Reflection</code> 在很多时候都有非常重要的作用，在创建存储方法、回调和验证时，都需要将这个对象作为参数传入提供一定的支持，起到了数据源和提供 Helper 方法的作用。</p>

<p>在整个定义方法、属性以及回调的工作完成之后，会将当前的对象以 <code class="highlighter-rouge">name</code> 作为键存储到自己持有的一个 <code class="highlighter-rouge">_reflections</code> 字典中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class_attribute :_reflections, instance_writer: false</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">add_reflection</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">reflection</span><span class="p">)</span>
  <span class="n">ar</span><span class="p">.</span><span class="nf">clear_reflections_cache</span>
  <span class="n">ar</span><span class="p">.</span><span class="nf">_reflections</span> <span class="o">=</span> <span class="n">ar</span><span class="p">.</span><span class="nf">_reflections</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span> <span class="o">=&gt;</span> <span class="n">reflection</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这个字典中存储着所有在当前类中使用 <code class="highlighter-rouge">has_many</code>、<code class="highlighter-rouge">has_one</code>、<code class="highlighter-rouge">belongs_to</code> 等方法定义的关系对应的映射。</p>

<h3 id="一对多关系">一对多关系</h3>

<p>一对多关系的这一节会分别介绍两个极其重要的方法 <code class="highlighter-rouge">.has_many</code> 和 <code class="highlighter-rouge">.belongs_to</code> 的实现；在这里，会先通过 <code class="highlighter-rouge">.has_many</code> 关系了解它是如何通过覆写父类方法定制自己的特性的，之后会通过 <code class="highlighter-rouge">.belongs_to</code> 研究 getter/setter 方法的调用栈。</p>

<p><img src="https://img.draveness.me/2017-10-21-one-to-many-association.png" alt="one-to-many-association" /></p>

<p>一对多关系在数据库的模型之间非常常见，而这两个方法在 ActiveRecord 也经常成对出现。</p>

<h4 id="has_many">has_many</h4>

<p>当我们对构建关系模块的两大支柱都已经有所了解之后，再来看这几个常用的方法就没有太多的难度了，首先来看一下一对多关系中的『多』是怎么实现的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">has_many</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">scope</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{},</span> <span class="o">&amp;</span><span class="n">extension</span><span class="p">)</span>
  <span class="n">reflection</span> <span class="o">=</span> <span class="no">Builder</span><span class="o">::</span><span class="no">HasMany</span><span class="p">.</span><span class="nf">build</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extension</span><span class="p">)</span>
  <span class="no">Reflection</span><span class="p">.</span><span class="nf">add_reflection</span> <span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">reflection</span>
<span class="k">end</span>
</code></pre></div></div>

<p>由于已经对 <code class="highlighter-rouge">Reflection.add_reflection</code> 方法的实现有所了解，所以这里直接看 <code class="highlighter-rouge">.has_many</code> 调用的 <code class="highlighter-rouge">Builder::HasMany.build</code> 方法的实现就可以知道这个类方法究竟做了什么，：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">build</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">extension</span> <span class="o">=</span> <span class="n">define_extensions</span> <span class="n">model</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span>
  <span class="n">reflection</span> <span class="o">=</span> <span class="n">create_reflection</span> <span class="n">model</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">extension</span>
  <span class="n">define_accessors</span> <span class="n">model</span><span class="p">,</span> <span class="n">reflection</span>
  <span class="n">define_callbacks</span> <span class="n">model</span><span class="p">,</span> <span class="n">reflection</span>
  <span class="n">define_validations</span> <span class="n">model</span><span class="p">,</span> <span class="n">reflection</span>
  <span class="n">reflection</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这里执行的 <code class="highlighter-rouge">.build</code> 方法与抽象类中的方法实现完全相同，子类并没有覆盖父类实现的方法，我们来找一下 <code class="highlighter-rouge">.define_accessors</code>、<code class="highlighter-rouge">.define_callbacks</code> 和 <code class="highlighter-rouge">.define_validations</code> 三个方法在 has_many 关系中都做了什么。</p>

<p><code class="highlighter-rouge">HasMany</code> 作为 has_many 关系的 Builder 类，其本身并没有实现太多的方法，只是对一些关系选项有一些自己独有的声明：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">ActiveRecord::Associations::Builder</span>
  <span class="k">class</span> <span class="nc">HasMany</span> <span class="o">&lt;</span> <span class="no">CollectionAssociation</span>
    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">macro</span>
      <span class="ss">:has_many</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">valid_options</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
      <span class="k">super</span> <span class="o">+</span> <span class="p">[</span><span class="ss">:primary_key</span><span class="p">,</span> <span class="ss">:dependent</span><span class="p">,</span> <span class="ss">:as</span><span class="p">,</span> <span class="ss">:through</span><span class="p">,</span> <span class="ss">:source</span><span class="p">,</span> <span class="ss">:source_type</span><span class="p">,</span> <span class="ss">:inverse_of</span><span class="p">,</span> <span class="ss">:counter_cache</span><span class="p">,</span> <span class="ss">:join_table</span><span class="p">,</span> <span class="ss">:foreign_type</span><span class="p">,</span> <span class="ss">:index_errors</span><span class="p">]</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">valid_dependent_options</span>
      <span class="p">[</span><span class="ss">:destroy</span><span class="p">,</span> <span class="ss">:delete_all</span><span class="p">,</span> <span class="ss">:nullify</span><span class="p">,</span> <span class="ss">:restrict_with_error</span><span class="p">,</span> <span class="ss">:restrict_with_exception</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>由于本身 has_many 关系中的读写方法都是对集合的操作，所以首先覆写了 <code class="highlighter-rouge">.define_writers</code> 和 <code class="highlighter-rouge">.define_readers</code> 两个方法生成了另外一组操作 id 的 getter/setter 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_readers</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
  <span class="k">super</span>

  <span class="n">mixin</span><span class="p">.</span><span class="nf">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
    def </span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">singularize</span><span class="si">}</span><span class="sh">_ids
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).ids_reader
    end
</span><span class="no">  CODE</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_writers</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
  <span class="k">super</span>

  <span class="n">mixin</span><span class="p">.</span><span class="nf">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
    def </span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">singularize</span><span class="si">}</span><span class="sh">_ids=(ids)
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).ids_writer(ids)
    end
</span><span class="no">  CODE</span>
<span class="k">end</span>
</code></pre></div></div>

<p>has_many 关系在 <code class="highlighter-rouge">CollectionAssociation</code> 和 <code class="highlighter-rouge">HasManyAssociation</code> 中实现的几个方法 <code class="highlighter-rouge">#reader</code>、<code class="highlighter-rouge">#writer</code>、<code class="highlighter-rouge">#ids_reader</code> 和 <code class="highlighter-rouge">#ids_writer</code> 其实还是比较复杂的，在这里就跳过不谈了。</p>

<p>而 <code class="highlighter-rouge">.define_callbacks</code> 和 <code class="highlighter-rouge">.define_extensions</code> 其实都大同小异，在作者看来没有什么值得讲的，has_many 中最重要的部分还是读写方法的实现过程，不过由于篇幅所限这里就不多说了。</p>

<h4 id="belongs_to">belongs_to</h4>

<p>在一对多关系中，经常与 has_many 对应的关系 belongs_to 其实实现和调用栈也几乎完全相同：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">belongs_to</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">scope</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="n">reflection</span> <span class="o">=</span> <span class="no">Builder</span><span class="o">::</span><span class="no">BelongsTo</span><span class="p">.</span><span class="nf">build</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
  <span class="no">Reflection</span><span class="p">.</span><span class="nf">add_reflection</span> <span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">reflection</span>
<span class="k">end</span>
</code></pre></div></div>

<p>但是与 has_many 比较大的不同是 <code class="highlighter-rouge">Builder::BelongsTo</code> 通过继承的父类定义了很多用于创建新关系的方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_accessors</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">reflection</span><span class="p">)</span>
  <span class="k">super</span>
  <span class="n">mixin</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="nf">generated_association_methods</span>
  <span class="nb">name</span> <span class="o">=</span> <span class="n">reflection</span><span class="p">.</span><span class="nf">name</span>
  <span class="n">define_constructors</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span> <span class="k">if</span> <span class="n">reflection</span><span class="p">.</span><span class="nf">constructable?</span>
  <span class="n">mixin</span><span class="p">.</span><span class="nf">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
    def reload_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).force_reload_reader
    end
</span><span class="no">  CODE</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_constructors</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
  <span class="n">mixin</span><span class="p">.</span><span class="nf">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
    def build_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">(*args, &amp;block)
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).build(*args, &amp;block)
    end
    def create_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">(*args, &amp;block)
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).create(*args, &amp;block)
    end
    def create_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">!(*args, &amp;block)
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).create!(*args, &amp;block)
    end
</span><span class="no">  CODE</span>
<span class="k">end</span>
</code></pre></div></div>

<p>其他的部分虽然实现上也与 has_many 有着非常大的不同，但是原理基本上完全一致，不过在这里我们可以来看一下 belongs_to 关系创建的两个方法 <code class="highlighter-rouge">association</code> 和 <code class="highlighter-rouge">association=</code> 究竟是如何对数据库进行操作的。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Topic</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:subtopics</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Subtopic</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:topic</span>
<span class="k">end</span>
</code></pre></div></div>

<p>假设我们有着如上所示的两个模型，它们之间是一对多关系，我们以这对模型为例先来看一下 <code class="highlighter-rouge">association</code> 这个读方法的调用栈。</p>

<p><img src="https://img.draveness.me/2017-10-21-callstack-for-belongs-to-association-getter.png" alt="callstack-for-belongs-to-association-gette" /></p>

<p>通过我们对源代码和调用栈的阅读，我们可以发现其实如下的所有方法调用在大多数情况下是完全等价的，假设我们已经持有了一个 <code class="highlighter-rouge">Subtopic</code> 对象：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">subtopic</span> <span class="o">=</span> <span class="no">Subtopic</span><span class="p">.</span><span class="nf">first</span> <span class="c1">#=&gt; #&lt;Subtopic:0x007ff513f67768&gt;</span>

<span class="n">subtopic</span><span class="p">.</span><span class="nf">topic</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">reader</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">target</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">load_target</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">send</span><span class="p">(</span><span class="ss">:find_target</span><span class="p">)</span>
</code></pre></div></div>

<p>上述的五种方式都可以获得当前 <code class="highlighter-rouge">Subtopic</code> 对象的 belongs_to 关系对应的 <code class="highlighter-rouge">Topic</code> 数据行，而最后一个方法 <code class="highlighter-rouge">#find_target</code> 其实也就是真正创建、绑定到最后执行查询 SQL 的方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">find_target</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">associations</span><span class="o">/</span><span class="n">singular_association</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">38</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Associations</span><span class="o">::</span><span class="no">SingularAssociation</span>

<span class="k">def</span> <span class="nf">find_target</span>
  <span class="k">return</span> <span class="n">scope</span><span class="p">.</span><span class="nf">take</span> <span class="k">if</span> <span class="n">skip_statement_cache?</span>

  <span class="n">conn</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">connection</span>
  <span class="n">sc</span> <span class="o">=</span> <span class="n">reflection</span><span class="p">.</span><span class="nf">association_scope_cache</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">owner</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">StatementCache</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">params</span><span class="o">|</span>
      <span class="n">as</span> <span class="o">=</span> <span class="no">AssociationScope</span><span class="p">.</span><span class="nf">create</span> <span class="p">{</span> <span class="n">params</span><span class="p">.</span><span class="nf">bind</span> <span class="p">}</span>
      <span class="n">target_scope</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">as</span><span class="p">.</span><span class="nf">scope</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">conn</span><span class="p">)).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="k">end</span>

  <span class="n">binds</span> <span class="o">=</span> <span class="no">AssociationScope</span><span class="p">.</span><span class="nf">get_bind_values</span><span class="p">(</span><span class="n">owner</span><span class="p">,</span> <span class="n">reflection</span><span class="p">.</span><span class="nf">chain</span><span class="p">)</span>
  <span class="n">sc</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">binds</span><span class="p">,</span> <span class="n">klass</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">record</span><span class="o">|</span>
    <span class="n">set_inverse_instance</span> <span class="n">record</span>
  <span class="k">end</span><span class="p">.</span><span class="nf">first</span>
<span class="k">rescue</span> <span class="o">::</span><span class="no">RangeError</span>
  <span class="kp">nil</span>
<span class="k">end</span>
</code></pre></div></div>

<p>我们已经对 <code class="highlighter-rouge">association</code> 方法的实现有了非常清楚的认知了，下面再来过一下 <code class="highlighter-rouge">association=</code> 方法的实现，首先还是来看一下 setter 方法的调用栈：</p>

<p><img src="https://img.draveness.me/2017-10-21-callstack-for-belongs-to-association-setter.png" alt="callstack-for-belongs-to-association-sette" /></p>

<p>相比于 getter 的调用栈，setter 方法的调用栈都复杂了很多，在研究 setter 方法实现的过程中我们一定要记住这个方法并不会改变数据库中对应的数据行，只会改变当前对应的某个属性，经过对调用栈和源代码的分析，我们可以有以下的结论：假设现在有一个 <code class="highlighter-rouge">Subtopic</code> 对象和一个新的 <code class="highlighter-rouge">Topic</code> 实例，那么下面的一系列操作其实是完全相同的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">subtopic</span> <span class="o">=</span> <span class="no">Subtopic</span><span class="p">.</span><span class="nf">first</span> <span class="c1">#=&gt; #&lt;Subtopic:0x007ff513f67768&gt;</span>
<span class="n">new_topic</span> <span class="o">=</span> <span class="no">Topic</span><span class="p">.</span><span class="nf">first</span>   <span class="c1">#=&gt; #&lt;Topic:0x007ff514b24cb8&gt;</span>

<span class="n">subtopic</span><span class="p">.</span><span class="nf">topic</span> <span class="o">=</span> <span class="n">new_topic</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">topic_id</span> <span class="o">=</span> <span class="n">new_topic</span><span class="p">.</span><span class="nf">id</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">writer</span><span class="p">(</span><span class="n">new_topic</span><span class="p">)</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">replace</span><span class="p">(</span><span class="n">new_topic</span><span class="p">)</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">replace_keys</span><span class="p">(</span><span class="n">new_topic</span><span class="p">)</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">owner</span><span class="p">[</span><span class="ss">:topic_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_topic</span><span class="p">.</span><span class="nf">id</span>
<span class="n">subtopic</span><span class="p">[</span><span class="ss">:topic_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_topic</span><span class="p">.</span><span class="nf">id</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">write_attribute</span><span class="p">(</span><span class="ss">:topic_id</span><span class="p">,</span> <span class="n">new_topic</span><span class="p">.</span><span class="nf">id</span><span class="p">)</span>
</code></pre></div></div>

<p>虽然这些方法最后返回的结果可能有所不同，但是它们最终都会将 <code class="highlighter-rouge">subtopic</code> 对象的 <code class="highlighter-rouge">topic_id</code> 属性更新成 <code class="highlighter-rouge">topic.id</code>，上面的方法中有简单的，也有复杂的，不过都能达到相同的目的；我相信如果读者亲手创建上述的关系并使用 pry 查看源代码一定会对 getter 和 setter 的执行过程有着非常清楚的认识。</p>

<h3 id="多对多关系-habtm">多对多关系 habtm</h3>

<p>无论是 has_many 还是 belongs_to 其实都是一个 ORM 原生需要支持的关系，但是 habtm(has_and_belongs_to_many) 却是 ActiveRecord 为我们提供的一个非常方便的语法糖，哪怕是并没有 <code class="highlighter-rouge">.has_and_belongs_to_many</code> 这个方法，我们也能通过 <code class="highlighter-rouge">.has_many</code> 实现多对多关系，得到与前者完全等价的效果，只是实现的过程稍微麻烦一些。</p>

<p>在这一小节中，我们想要了解 habtm 这个语法糖是如何工作的，它是如何将现有的关系组成更复杂的 habtm 的多对多关系的；想要了解它的工作原理，我们自然要分析它的源代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">has_and_belongs_to_many</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">scope</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extension</span><span class="p">)</span>
  <span class="n">builder</span> <span class="o">=</span> <span class="no">Builder</span><span class="o">::</span><span class="no">HasAndBelongsToMany</span><span class="p">.</span><span class="nf">new</span> <span class="nb">name</span><span class="p">,</span> <span class="nb">self</span><span class="p">,</span> <span class="n">options</span>
  <span class="n">join_model</span> <span class="o">=</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Deprecation</span><span class="p">.</span><span class="nf">silence</span> <span class="p">{</span> <span class="n">builder</span><span class="p">.</span><span class="nf">through_model</span> <span class="p">}</span>
  <span class="nb">const_set</span> <span class="n">join_model</span><span class="p">.</span><span class="nf">name</span><span class="p">,</span> <span class="n">join_model</span>
  <span class="n">private_constant</span> <span class="n">join_model</span><span class="p">.</span><span class="nf">name</span>

  <span class="n">habtm_reflection</span> <span class="o">=</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Reflection</span><span class="o">::</span><span class="no">HasAndBelongsToManyReflection</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="nb">self</span><span class="p">)</span>
  <span class="n">middle_reflection</span> <span class="o">=</span> <span class="n">builder</span><span class="p">.</span><span class="nf">middle_reflection</span> <span class="n">join_model</span>
  <span class="no">Builder</span><span class="o">::</span><span class="no">HasMany</span><span class="p">.</span><span class="nf">define_callbacks</span> <span class="nb">self</span><span class="p">,</span> <span class="n">middle_reflection</span>
  <span class="no">Reflection</span><span class="p">.</span><span class="nf">add_reflection</span> <span class="nb">self</span><span class="p">,</span> <span class="n">middle_reflection</span><span class="p">.</span><span class="nf">name</span><span class="p">,</span> <span class="n">middle_reflection</span>
  <span class="n">middle_reflection</span><span class="p">.</span><span class="nf">parent_reflection</span> <span class="o">=</span> <span class="n">habtm_reflection</span>

  <span class="c1"># ...</span>

  <span class="n">hm_options</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="n">hm_options</span><span class="p">[</span><span class="ss">:through</span><span class="p">]</span> <span class="o">=</span> <span class="n">middle_reflection</span><span class="p">.</span><span class="nf">name</span>
  <span class="n">hm_options</span><span class="p">[</span><span class="ss">:source</span><span class="p">]</span> <span class="o">=</span> <span class="n">join_model</span><span class="p">.</span><span class="nf">right_reflection</span><span class="p">.</span><span class="nf">name</span>

  <span class="c1"># ...</span>

  <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Deprecation</span><span class="p">.</span><span class="nf">silence</span> <span class="p">{</span> <span class="n">has_many</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">hm_options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extension</span> <span class="p">}</span>
  <span class="n">_reflections</span><span class="p">[</span><span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">].</span><span class="nf">parent_reflection</span> <span class="o">=</span> <span class="n">habtm_reflection</span>
<span class="k">end</span>
</code></pre></div></div>

<blockquote>
  <p>在这里，我们对该方法的源代码重新进行组织和排序，方法的作用与 v5.1.4 中的完全相同。</p>
</blockquote>

<p>上述方法在最开始先创建了一个 <code class="highlighter-rouge">HasAndBelongsToMany</code> 的 Builder 实例，然后在 block 中执行了这个 Builder 的 <code class="highlighter-rouge">#through_model</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">through_model</span>
  <span class="n">habtm</span> <span class="o">=</span> <span class="no">JoinTableResolver</span><span class="p">.</span><span class="nf">build</span> <span class="n">lhs_model</span><span class="p">,</span> <span class="n">association_name</span><span class="p">,</span> <span class="n">options</span>

  <span class="n">join_model</span> <span class="o">=</span> <span class="no">Class</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span><span class="p">;</span>
      <span class="nb">attr_accessor</span> <span class="ss">:left_model</span>
      <span class="nb">attr_accessor</span> <span class="ss">:name</span>
      <span class="nb">attr_accessor</span> <span class="ss">:table_name_resolver</span>
      <span class="nb">attr_accessor</span> <span class="ss">:left_reflection</span>
      <span class="nb">attr_accessor</span> <span class="ss">:right_reflection</span>
    <span class="k">end</span>

    <span class="c1"># ...</span>
  <span class="p">}</span>

  <span class="n">join_model</span><span class="p">.</span><span class="nf">name</span>                <span class="o">=</span> <span class="s2">"HABTM_</span><span class="si">#{</span><span class="n">association_name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">camelize</span><span class="si">}</span><span class="s2">"</span>
  <span class="n">join_model</span><span class="p">.</span><span class="nf">table_name_resolver</span> <span class="o">=</span> <span class="n">habtm</span>
  <span class="n">join_model</span><span class="p">.</span><span class="nf">left_model</span>          <span class="o">=</span> <span class="n">lhs_model</span>
  <span class="n">join_model</span><span class="p">.</span><span class="nf">add_left_association</span> <span class="ss">:left_side</span><span class="p">,</span> <span class="ss">anonymous_class: </span><span class="n">lhs_model</span>
  <span class="n">join_model</span><span class="p">.</span><span class="nf">add_right_association</span> <span class="n">association_name</span><span class="p">,</span> <span class="n">belongs_to_options</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
  <span class="n">join_model</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">#through_model</code> 方法会返回一个新的继承自 <code class="highlighter-rouge">ActiveRecord::Base</code> 的类，我们通过一下的例子来说明一下这里究竟做了什么，假设在我们的工程中定义了如下的两个类：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:tags</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Tag</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:posts</span>
<span class="k">end</span>
</code></pre></div></div>

<p>它们每个类都通过 <code class="highlighter-rouge">.has_and_belongs_to_many</code> 创建了一个 <code class="highlighter-rouge">join_model</code> 类，这两个类都是在当前类的命名空间下的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Post</span><span class="o">::</span><span class="no">HABTM_Posts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">;</span> <span class="k">end</span>
<span class="k">class</span> <span class="nc">Tags</span><span class="o">::</span><span class="no">HABTM_Posts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">;</span> <span class="k">end</span>
</code></pre></div></div>

<p>除了在当前类的命名空间下定义两个新的类之外，<code class="highlighter-rouge">#through_model</code> 方法还通过 <code class="highlighter-rouge">#add_left_association</code> 和 <code class="highlighter-rouge">#add_right_association</code> 为创建的私有类添加了两个 <code class="highlighter-rouge">.belongs_to</code> 方法的调用：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">join_model</span> <span class="o">=</span> <span class="no">Class</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1"># ...</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">add_left_association</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="n">belongs_to</span> <span class="nb">name</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">left_reflection</span> <span class="o">=</span> <span class="n">_reflect_on_association</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">add_right_association</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="n">rhs_name</span> <span class="o">=</span> <span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">singularize</span><span class="p">.</span><span class="nf">to_sym</span>
    <span class="n">belongs_to</span> <span class="n">rhs_name</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">right_reflection</span> <span class="o">=</span> <span class="n">_reflect_on_association</span><span class="p">(</span><span class="n">rhs_name</span><span class="p">)</span>
  <span class="k">end</span>
<span class="p">}</span>
</code></pre></div></div>

<p>所以在这里，每一个 HABTM 类中都通过 <code class="highlighter-rouge">.belongs_to</code> 增加了两个对数据库表中对应列的映射：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Post</span><span class="o">::</span><span class="no">HABTM_Posts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:post_id</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span>
  <span class="n">belongs_to</span> <span class="ss">:tag_id</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Tags</span><span class="o">::</span><span class="no">HABTM_Posts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:tag_id</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span>
  <span class="n">belongs_to</span> <span class="ss">:post_id</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span>
<span class="k">end</span>
</code></pre></div></div>

<p>看到这里，你可能会认为既然有两个模型，那么应该会有两张表分别对应这两个模型，但是实际情况却不是这样。</p>

<p><img src="https://img.draveness.me/2017-10-21-habtm-association-table-name.png" alt="habtm-association-table-name" /></p>

<p>ActiveRecord 通过覆写这两个类的 <code class="highlighter-rouge">.table_name</code> 方法，使用一个 <code class="highlighter-rouge">JoinTableResolver</code> 来解决不同的模型拥有相同的数据库表的问题：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Migration</span>
  <span class="k">module</span> <span class="nn">JoinTable</span>
    <span class="k">def</span> <span class="nf">join_table_name</span><span class="p">(</span><span class="n">table_1</span><span class="p">,</span> <span class="n">table_2</span><span class="p">)</span>
      <span class="no">ModelSchema</span><span class="p">.</span><span class="nf">derive_join_table_name</span><span class="p">(</span><span class="n">table_1</span><span class="p">,</span> <span class="n">table_2</span><span class="p">).</span><span class="nf">to_sym</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">ModelSchema</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">derive_join_table_name</span><span class="p">(</span><span class="n">first_table</span><span class="p">,</span> <span class="n">second_table</span><span class="p">)</span> 
    <span class="p">[</span><span class="n">first_table</span><span class="p">.</span><span class="nf">to_s</span><span class="p">,</span> <span class="n">second_table</span><span class="p">.</span><span class="nf">to_s</span><span class="p">].</span><span class="nf">sort</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s2">"</span><span class="se">\0</span><span class="s2">"</span><span class="p">).</span><span class="nf">gsub</span><span class="p">(</span><span class="sr">/^(.*_)(.+)\0\1(.+)/</span><span class="p">,</span> <span class="s1">'\1\2_\3'</span><span class="p">).</span><span class="nf">tr</span><span class="p">(</span><span class="s2">"</span><span class="se">\0</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"_"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在默认的 <code class="highlighter-rouge">join_table</code> 规则中，两张表会按照字母顺序排序，最后通过 <code class="highlighter-rouge">_</code> 连接到一起，但是如果两张表有着完全相同的前缀，比如 music_artists 和 music_records 两张表，它们连接的结果就是 music_artists_records，公共的前缀会被删除，这种情况经常发生在包含命名空间的模型中，例如：<code class="highlighter-rouge">Music::Artist</code>。</p>

<p>当我们已经通过多对多关系的 Builder 创建了一个中间模型之后，就会建立两个 <code class="highlighter-rouge">Reflection</code> 对象：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">habtm_reflection</span> <span class="o">=</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Reflection</span><span class="o">::</span><span class="no">HasAndBelongsToManyReflection</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="nb">self</span><span class="p">)</span>
<span class="n">middle_reflection</span> <span class="o">=</span> <span class="n">builder</span><span class="p">.</span><span class="nf">middle_reflection</span> <span class="n">join_model</span>
<span class="no">Builder</span><span class="o">::</span><span class="no">HasMany</span><span class="p">.</span><span class="nf">define_callbacks</span> <span class="nb">self</span><span class="p">,</span> <span class="n">middle_reflection</span>
<span class="no">Reflection</span><span class="p">.</span><span class="nf">add_reflection</span> <span class="nb">self</span><span class="p">,</span> <span class="n">middle_reflection</span><span class="p">.</span><span class="nf">name</span><span class="p">,</span> <span class="n">middle_reflection</span>
<span class="n">middle_reflection</span><span class="p">.</span><span class="nf">parent_reflection</span> <span class="o">=</span> <span class="n">habtm_reflection</span>
</code></pre></div></div>

<p>其中一个对象是 <code class="highlighter-rouge">HasAndBelongsToManyReflection</code> 实例，表示当前的多对多关系，另一个对象是 <code class="highlighter-rouge">#middle_reflection</code> 方法返回的 <code class="highlighter-rouge">HasMany</code>，表示当前的类与 <code class="highlighter-rouge">join_model</code> 之间有一个一对多关系，这个关系是隐式的，不过我们可以通过下面的代码来『理解』它：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># has_and_belongs_to_many :posts</span>
  <span class="c1"># =</span>
  <span class="n">has_many</span> <span class="ss">:posts_tag</span>
  <span class="c1"># + </span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述的代码构成了整个多对多关系的一部分，而另一部分由下面的代码来处理，当模型持有了一个跟中间模型相关的一对多关系之后，就会创建另一个以中间模型为桥梁 has_many 关系：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hm_options</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">hm_options</span><span class="p">[</span><span class="ss">:through</span><span class="p">]</span> <span class="o">=</span> <span class="n">middle_reflection</span><span class="p">.</span><span class="nf">name</span>
<span class="n">hm_options</span><span class="p">[</span><span class="ss">:source</span><span class="p">]</span> <span class="o">=</span> <span class="n">join_model</span><span class="p">.</span><span class="nf">right_reflection</span><span class="p">.</span><span class="nf">name</span>

<span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Deprecation</span><span class="p">.</span><span class="nf">silence</span> <span class="p">{</span> <span class="n">has_many</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">hm_options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extension</span> <span class="p">}</span>
</code></pre></div></div>

<p>这里还是使用 <code class="highlighter-rouge">Post</code> 和 <code class="highlighter-rouge">Tag</code> 这两个模型之间的关系举例子，通过上述代码，我们会在两个类中分别建立如下的关系：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># has_many :posts_tag</span>
  <span class="n">has_many</span> <span class="ss">:tags</span><span class="p">,</span> <span class="ss">through: :posts_tag</span><span class="p">,</span> <span class="ss">source: :tag</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Tag</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># has_many :tags_post</span>
  <span class="n">has_many</span> <span class="ss">:post</span><span class="p">,</span> <span class="ss">through: :tags_post</span><span class="p">,</span> <span class="ss">source: :post</span>
<span class="k">end</span>
</code></pre></div></div>

<p>通过两个隐式的 has_many 关系，两个显示的 has_many 就能够通过 <code class="highlighter-rouge">through</code> 和 <code class="highlighter-rouge">source</code> 间接找到自己对应的多个数据行，而从开发者的角度来看，整个工程中只使用了一行代码 <code class="highlighter-rouge">has_and_belongs_to_many :models</code>，其他的工作完全都是隐式的。</p>

<p><img src="https://img.draveness.me/2017-10-21-many-to-many-associations.png" alt="many-to-many-associations" /></p>

<p>由于关系型数据库其实并没有物理上的多对多关系，只有在逻辑上才能实现多对多，所以对于每一个模型来说，它实现的都是一对多关系；只有从整体来看，通过 <code class="highlighter-rouge">PostsTags</code> 第三张表的引入，我们实现的才是从 <code class="highlighter-rouge">Post</code> 到 <code class="highlighter-rouge">Tag</code> 之间的多对多关系。</p>

<h3 id="小结-2">小结</h3>

<p>ActiveRecord 对关系的支持其实非常全面，从最常见的一对一、一对多关系，再到多对多关系，都有着非常优雅、简洁的实现，虽然这一小节中没能全面的介绍所有关系的实现，但是对整个模块中重要类和整体架构的介绍已经非常具体了；不得不感叹 ActiveRecord 对多对多关系方法 <code class="highlighter-rouge">has_and_belongs_to_many</code> 的实现非常整洁，我们在分析其实现时也非常顺畅。</p>

<h2 id="migrations-任务和执行过程">Migrations 任务和执行过程</h2>

<p>Migrations（迁移）是 ActiveRecord 提供的一种用于更改数据库 Schema 的方式，它提供了可以直接操作数据库的 DSL，这样我们就不需要自己去手写所有的 SQL 来更新数据库中的表结构了。</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-migrations.png" alt="activerecord-migrations" /></p>

<p>每一个 Migration 都具有一个唯一的时间戳，每次进行迁移时都会在现有的数据库中执行当前 Migration 文件的 DSL 更新数据库 Schema 得到新的数据库版本。而想要理解 Migrations 是如何工作的，就需要知道 <code class="highlighter-rouge">#create_table</code>、<code class="highlighter-rouge">#add_column</code> 等 DSL 是怎么实现的。</p>

<h3 id="migration51">Migration[5.1]</h3>

<p>我在使用 ActiveRecord 提供的数据库迁移的时候一直都特别好奇 <code class="highlighter-rouge">Migration[5.1]</code> 后面跟着的这个 <code class="highlighter-rouge">[5.1]</code> 是个什么工作原理，看了源代码之后我才知道：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Migration</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">[]</span><span class="p">(</span><span class="n">version</span><span class="p">)</span>
    <span class="no">Compatibility</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">version</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">.[]</code> 是 <code class="highlighter-rouge">ActiveRecord::Migration</code> 的类方法，它通过执行 <code class="highlighter-rouge">Compatibility.find</code> 来判断当前的代码中使用的数据库迁移版本是否与 gem 中的版本兼容：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Current</span> <span class="o">&lt;</span> <span class="no">Migration</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">compatibility.rb</code> 在兼容性方面做了很多事情，保证 ActiveRecord 中的迁移都是可以向前兼容的，在这里也就不准备介绍太多了。</p>

<h3 id="从-rake-dbmigrate-开始">从 rake db:migrate 开始</h3>

<p>作者在阅读迁移部分的源代码时最开始以 <code class="highlighter-rouge">Migration</code> 类作为入口，结果发现这并不是一个好的选择，最终也没能找到定义 DSL 的位置，所以重新选择了 <code class="highlighter-rouge">rake db:migrate</code> 作为入口分析迁移的实现；通过对工程目录的分析，很快就能发现 ActiveRecord 中所有的 rake 命令都位于 <code class="highlighter-rouge">lib/railties/database.rake</code> 文件中，在文件中也能找到 <code class="highlighter-rouge">db:migrate</code> 对应的 rake 任务：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">db_namespace</span> <span class="o">=</span> <span class="n">namespace</span> <span class="ss">:db</span> <span class="k">do</span>
  <span class="n">desc</span> <span class="s2">"Migrate the database (options: VERSION=x, VERBOSE=false, SCOPE=blog)."</span>
  <span class="n">task</span> <span class="ss">migrate: </span><span class="p">[</span><span class="ss">:environment</span><span class="p">,</span> <span class="ss">:load_config</span><span class="p">]</span> <span class="k">do</span>
    <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Tasks</span><span class="o">::</span><span class="no">DatabaseTasks</span><span class="p">.</span><span class="nf">migrate</span>
    <span class="n">db_namespace</span><span class="p">[</span><span class="s2">"_dump"</span><span class="p">].</span><span class="nf">invoke</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述代码中的 <code class="highlighter-rouge">DatabaseTasks</code> 类就包含在 <code class="highlighter-rouge">lib/active_record/tasks</code> 目录中的 <code class="highlighter-rouge">database_tasks.rb</code> 文件里：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">tasks</span><span class="o">/</span>
<span class="err">├──</span> <span class="n">database_tasks</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">├──</span> <span class="n">mysql_database_tasks</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">├──</span> <span class="n">postgresql_database_tasks</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">└──</span> <span class="n">sqlite_database_tasks</span><span class="p">.</span><span class="nf">rb</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">#migrate</code> 方法就是 <code class="highlighter-rouge">DatabaseTasks</code> 的一个实例方法，同时 ActiveRecord 通过 <code class="highlighter-rouge">extend self</code> 将 <code class="highlighter-rouge">#migrate</code> 方法添加到了当前类的单类上，成为了当前类的类方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Tasks</span>
  <span class="k">module</span> <span class="nn">DatabaseTasks</span>
    <span class="kp">extend</span> <span class="nb">self</span>
    
    <span class="k">def</span> <span class="nf">migrate</span>
      <span class="k">raise</span> <span class="s2">"Empty VERSION provided"</span> <span class="k">if</span> <span class="no">ENV</span><span class="p">[</span><span class="s2">"VERSION"</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="no">ENV</span><span class="p">[</span><span class="s2">"VERSION"</span><span class="p">].</span><span class="nf">empty?</span>

      <span class="n">version</span> <span class="o">=</span> <span class="no">ENV</span><span class="p">[</span><span class="s2">"VERSION"</span><span class="p">]</span> <span class="p">?</span> <span class="no">ENV</span><span class="p">[</span><span class="s2">"VERSION"</span><span class="p">].</span><span class="nf">to_i</span> <span class="p">:</span> <span class="kp">nil</span>
      <span class="n">scope</span> <span class="o">=</span> <span class="no">ENV</span><span class="p">[</span><span class="s2">"SCOPE"</span><span class="p">]</span>
      <span class="no">Migrator</span><span class="p">.</span><span class="nf">migrate</span><span class="p">(</span><span class="n">migrations_paths</span><span class="p">,</span> <span class="n">version</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">migration</span><span class="o">|</span>
        <span class="n">scope</span><span class="p">.</span><span class="nf">blank?</span> <span class="o">||</span> <span class="n">scope</span> <span class="o">==</span> <span class="n">migration</span><span class="p">.</span><span class="nf">scope</span>
      <span class="k">end</span>
      <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">clear_cache!</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="迁移器migrator">『迁移器』Migrator</h4>

<p>迁移任务中主要使用了 <code class="highlighter-rouge">Migrator.migrate</code> 方法，通过传入迁移文件的路径和期望的迁移版本对数据库进行迁移：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Migrator</span><span class="c1">#:nodoc:</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">migrate</span><span class="p">(</span><span class="n">migrations_paths</span><span class="p">,</span> <span class="n">target_version</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
      <span class="k">case</span>
      <span class="k">when</span> <span class="n">target_version</span><span class="p">.</span><span class="nf">nil?</span>
        <span class="n">up</span><span class="p">(</span><span class="n">migrations_paths</span><span class="p">,</span> <span class="n">target_version</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
      <span class="k">when</span> <span class="n">current_version</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">target_version</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">[]</span>
      <span class="k">when</span> <span class="n">current_version</span> <span class="o">&gt;</span> <span class="n">target_version</span>
        <span class="n">down</span><span class="p">(</span><span class="n">migrations_paths</span><span class="p">,</span> <span class="n">target_version</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
      <span class="k">else</span>
        <span class="n">up</span><span class="p">(</span><span class="n">migrations_paths</span><span class="p">,</span> <span class="n">target_version</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在默认情况下，显然我们是不会传入目标的数据库版本的，也就是 <code class="highlighter-rouge">target_version.nil? == true</code>，这时会执行 <code class="highlighter-rouge">.up</code> 方法，对数据库向『上』迁移：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">up</span><span class="p">(</span><span class="n">migrations_paths</span><span class="p">,</span> <span class="n">target_version</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="n">migrations</span> <span class="o">=</span> <span class="n">migrations</span><span class="p">(</span><span class="n">migrations_paths</span><span class="p">)</span>
  <span class="n">migrations</span><span class="p">.</span><span class="nf">select!</span> <span class="p">{</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="k">yield</span> <span class="n">m</span> <span class="p">}</span> <span class="k">if</span> <span class="nb">block_given?</span>

  <span class="n">new</span><span class="p">(</span><span class="ss">:up</span><span class="p">,</span> <span class="n">migrations</span><span class="p">,</span> <span class="n">target_version</span><span class="p">).</span><span class="nf">migrate</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="方法调用栈">方法调用栈</h4>

<p>通过 <code class="highlighter-rouge">.new</code> 方法 ActiveRecord 初始化了一个新的 <code class="highlighter-rouge">Migrator</code> 实例，然后执行了 <code class="highlighter-rouge">Migrator#migrate</code>，在整个迁移执行的过程中，我们有以下的方法调用栈：</p>

<p><img src="https://img.draveness.me/2017-10-21-rake-db-migrate.png" alt="rake-db-migrate" /></p>

<p>在整个迁移过程的调用栈中，我们会关注以下的四个部分，首先是 <code class="highlighter-rouge">Migrator#migrate_without_lock</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">migrate_without_lock</span>
  <span class="k">if</span> <span class="n">invalid_target?</span>
    <span class="k">raise</span> <span class="no">UnknownMigrationVersionError</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@target_version</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">runnable</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">migration</span><span class="o">|</span>
    <span class="n">execute_migration_in_transaction</span><span class="p">(</span><span class="n">migration</span><span class="p">,</span> <span class="vi">@direction</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">record_environment</span>
  <span class="n">result</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这个方法其实并没有那么重要，但是这里调用了 <code class="highlighter-rouge">Migrator#runnable</code> 方法，这个无参的方法返回了所有需要运行的 <code class="highlighter-rouge">Migration</code> 文件，<code class="highlighter-rouge">Migrator#runnable</code> 是如何选择需要迁移的文件是作者比较想要了解的，也是作者认为比较重要的地方：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">runnable</span>
  <span class="n">runnable</span> <span class="o">=</span> <span class="n">migrations</span><span class="p">[</span><span class="n">start</span><span class="o">..</span><span class="n">finish</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">up?</span>
    <span class="n">runnable</span><span class="p">.</span><span class="nf">reject</span> <span class="p">{</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">ran?</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">else</span>
    <span class="n">runnable</span><span class="p">.</span><span class="nf">pop</span> <span class="k">if</span> <span class="n">target</span>
    <span class="n">runnable</span><span class="p">.</span><span class="nf">find_all</span> <span class="p">{</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">ran?</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">ran?</span><span class="p">(</span><span class="n">migration</span><span class="p">)</span>
  <span class="n">migrated</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="n">migration</span><span class="p">.</span><span class="nf">version</span><span class="p">.</span><span class="nf">to_i</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>通过对这个方法的阅读的分析，我们可以看到，如果迁移模式是 <code class="highlighter-rouge">:up</code>，那么就会选择所有未迁移的文件，也就是说在这时<strong>迁移文件的选择与创建的顺序是无关的</strong>。</p>

<h4 id="迁移的执行">迁移的执行</h4>

<p>当我们通过 <code class="highlighter-rouge">#runnable</code> 获得了整个待运行的迁移文件数组之后，就可以遍历所有的文件一次执行 <code class="highlighter-rouge">Migrator#execute_migrate_in_transaction</code> 方法了，在调用栈的最后会执行 <code class="highlighter-rouge">Migration#exec_migration</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">exec_migration</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span>
  <span class="vi">@connection</span> <span class="o">=</span> <span class="n">conn</span>
  <span class="k">if</span> <span class="nb">respond_to?</span><span class="p">(</span><span class="ss">:change</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="ss">:down</span>
      <span class="n">revert</span> <span class="p">{</span> <span class="n">change</span> <span class="p">}</span>
    <span class="k">else</span>
      <span class="n">change</span>
    <span class="k">end</span>
  <span class="k">else</span>
    <span class="nb">send</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">ensure</span>
  <span class="vi">@connection</span> <span class="o">=</span> <span class="kp">nil</span>
<span class="k">end</span>
</code></pre></div></div>

<p>到这里就能与我们平时在 <code class="highlighter-rouge">Migration</code> 中实现的 <code class="highlighter-rouge">#change</code>、<code class="highlighter-rouge">#up</code> 和 <code class="highlighter-rouge">#down</code> 连到一起，逻辑也走通了；上述代码的逻辑还是很清晰的，如果当前的 <code class="highlighter-rouge">Migratoin</code> 实现了 <code class="highlighter-rouge">#change</code> 方法就会根据 <code class="highlighter-rouge">direction</code> 选择执行 <code class="highlighter-rouge">#change</code> 还是 <code class="highlighter-rouge">#revert + #change</code>，否则就会按照迁移的方向执行对应的方法。</p>

<h3 id="migrations-的-dsl">Migrations 的 DSL</h3>

<p>在数据迁移的模块执行的 Migration 文件中包含的都是 ActiveRecord 提供的 DSL 语法，这部分语法包含两部分，一部分是 Schema 相关的 DSL <code class="highlighter-rouge">schema_statements.rb</code>，其中包括表格的创建和删除以及一些用于辅助 Schema 创建的 <code class="highlighter-rouge">#column_exists?</code> 等方法，另一部分是表定义相关的 DSL <code class="highlighter-rouge">schema_definitions.rb</code>，其中包括处理表结构的 <code class="highlighter-rouge">TableDefinition</code> 类和抽象代表一张数据库中表的 <code class="highlighter-rouge">Table</code> 类。</p>

<h4 id="抽象适配器">抽象适配器</h4>

<p>在整个 <code class="highlighter-rouge">connection_adapters</code> 的子模块中，绝大多数模块在三大 SQL 数据库，MySQL、PostgreSQL 和 sqlite3 中都有着各自的实现：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">connection_adapters</span>
<span class="err">├──</span> <span class="n">abstract</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">connection_pool</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">database_limits</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">database_statements</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">query_cache</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">quoting</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">savepoints</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_creation</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_definitions</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_dumper</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_statements</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">└──</span> <span class="n">transaction</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">├──</span> <span class="n">mysql</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">column</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">database_statements</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">explain_pretty_printer</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">quoting</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_creation</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_definitions</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_dumper</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_statements</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">└──</span> <span class="n">type_metadata</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">├──</span> <span class="n">postgresql</span>
<span class="err">│  </span> <span class="err">└──</span> <span class="o">...</span>
<span class="err">├──</span> <span class="n">sqlite3</span>
<span class="err">│  </span> <span class="err">└──</span> <span class="o">...</span>
<span class="err">├──</span> <span class="n">abstract_adapter</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">├──</span> <span class="o">...</span>
<span class="err">└──</span> <span class="n">sqlite3_adapter</span><span class="p">.</span><span class="nf">rb</span>
</code></pre></div></div>

<p>不过这三个数据库的所有子模块都继承自 <code class="highlighter-rouge">AbstractAdapter</code> 下面对应的子模块，以获得一些三者共用的能力，包括数据库、Schema 的声明与管理等功能。</p>

<p><img src="https://img.draveness.me/2017-10-21-abstract-adapter-and-much-more.png" alt="abstract-adapter-and-much-more" /></p>

<p>通过 <code class="highlighter-rouge">AbstractAdapter</code> 抽离出的公用功能，我们可以通过新的适配器随时适配其他的 SQL 数据库。</p>

<h4 id="schema-dsl">Schema DSL</h4>

<p>数据库的 Schema DSL 部分就包含我们经常使用的 <code class="highlighter-rouge">#create_table</code>、<code class="highlighter-rouge">#rename_table</code> 以及 <code class="highlighter-rouge">#add_column</code> 这些需要表名才能执行的方法，在这里以最常见的 <code class="highlighter-rouge">#create_table</code> 为例，简单分析一下这部分代码的实现：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">create_table</span><span class="p">(</span><span class="n">table_name</span><span class="p">,</span> <span class="ss">comment: </span><span class="kp">nil</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
  <span class="n">td</span> <span class="o">=</span> <span class="n">create_table_definition</span> <span class="n">table_name</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="ss">:temporary</span><span class="p">],</span> <span class="n">options</span><span class="p">[</span><span class="ss">:options</span><span class="p">],</span> <span class="n">options</span><span class="p">[</span><span class="ss">:as</span><span class="p">],</span> <span class="ss">comment: </span><span class="n">comment</span>

  <span class="k">yield</span> <span class="n">td</span> <span class="k">if</span> <span class="nb">block_given?</span>

  <span class="n">execute</span> <span class="n">schema_creation</span><span class="p">.</span><span class="nf">accept</span> <span class="n">td</span>
<span class="k">end</span>
</code></pre></div></div>

<p>首先，在创建表时先通过 <code class="highlighter-rouge">#create_table_definition</code> 方法创建一个新的 <code class="highlighter-rouge">TableDefinition</code> 实例，然后将这个实例作为参数传入 block：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">create_table</span> <span class="ss">:users</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 block 对这个 <code class="highlighter-rouge">TableDefinition</code> 对象一顿操作后，会通过 <code class="highlighter-rouge">SchemaCreation#accept</code> 方法获得一个用于在数据库中，能够创建表的 SQL 语句：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">accept</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
  <span class="n">m</span> <span class="o">=</span> <span class="vi">@cache</span><span class="p">[</span><span class="n">o</span><span class="p">.</span><span class="nf">class</span><span class="p">]</span> <span class="o">||=</span> <span class="s2">"visit_</span><span class="si">#{</span><span class="n">o</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">name</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">'::'</span><span class="p">).</span><span class="nf">last</span><span class="si">}</span><span class="s2">"</span>
  <span class="nb">send</span> <span class="n">m</span><span class="p">,</span> <span class="n">o</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">visit_TableDefinition</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
  <span class="n">create_sql</span> <span class="o">=</span> <span class="s2">"CREATE</span><span class="si">#{</span><span class="s1">' TEMPORARY'</span> <span class="k">if</span> <span class="n">o</span><span class="p">.</span><span class="nf">temporary</span><span class="si">}</span><span class="s2"> TABLE </span><span class="si">#{</span><span class="n">quote_table_name</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="nf">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> "</span>

  <span class="n">statements</span> <span class="o">=</span> <span class="n">o</span><span class="p">.</span><span class="nf">columns</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="n">accept</span> <span class="n">c</span> <span class="p">}</span>
  <span class="n">statements</span> <span class="o">&lt;&lt;</span> <span class="n">accept</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="nf">primary_keys</span><span class="p">)</span> <span class="k">if</span> <span class="n">o</span><span class="p">.</span><span class="nf">primary_keys</span>

  <span class="n">create_sql</span> <span class="o">&lt;&lt;</span> <span class="s2">"(</span><span class="si">#{</span><span class="n">statements</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">', '</span><span class="p">)</span><span class="si">}</span><span class="s2">)"</span> <span class="k">if</span> <span class="n">statements</span><span class="p">.</span><span class="nf">present?</span>
  <span class="n">add_table_options!</span><span class="p">(</span><span class="n">create_sql</span><span class="p">,</span> <span class="n">table_options</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
  <span class="n">create_sql</span> <span class="o">&lt;&lt;</span> <span class="s2">" AS </span><span class="si">#{</span><span class="vi">@conn</span><span class="p">.</span><span class="nf">to_sql</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="nf">as</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span> <span class="k">if</span> <span class="n">o</span><span class="p">.</span><span class="nf">as</span>
  <span class="n">create_sql</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">SchemaCreation</code> 类就是一个接受各种各样的 <code class="highlighter-rouge">TableDefinition</code>、<code class="highlighter-rouge">PrimaryKeyDefinition</code> 对象返回 SQL 的一个工具，可以将 <code class="highlighter-rouge">SchemaCreation</code> 理解为一个表结构的解释器；最后的 <code class="highlighter-rouge">#execute</code> 会在数据库中执行 SQL 改变数据库中的表结构。</p>

<p>在 <code class="highlighter-rouge">SchemaStatements</code> 中定义的其它方法的实现也都是大同小异，比如 <code class="highlighter-rouge">#drop_table</code> 其实都是删除数据库中的某张表：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">drop_table</span><span class="p">(</span><span class="n">table_name</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="n">execute</span> <span class="s2">"DROP TABLE</span><span class="si">#{</span><span class="s1">' IF EXISTS'</span> <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="ss">:if_exists</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">quote_table_name</span><span class="p">(</span><span class="n">table_name</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="表定义-dsl">表定义 DSL</h4>

<p><code class="highlighter-rouge">SchemaStatements</code> 中定义的方法，参数大都包含 <code class="highlighter-rouge">table_name</code>，而另一个类 <code class="highlighter-rouge">TableDefinitions</code> 就包含了直接对表操作的 DSL：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">create_table</span> <span class="ss">:foo</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">t</span><span class="p">.</span><span class="nf">class</span>  <span class="c1"># =&gt; "ActiveRecord::ConnectionAdapters::TableDefinition"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当我们在 <code class="highlighter-rouge">#create_table</code> 中使用例如 <code class="highlighter-rouge">#string</code>、<code class="highlighter-rouge">#integer</code> 等方法时，所有的方法都会通过元编程的魔法最终执行 <code class="highlighter-rouge">TableDefinition#column</code> 改变表的定义：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">ColumnMethods</span>
  <span class="p">[</span>
    <span class="ss">:bigint</span><span class="p">,</span>
    <span class="c1"># ...</span>
    <span class="ss">:integer</span><span class="p">,</span>
    <span class="ss">:string</span><span class="p">,</span>
    <span class="ss">:text</span><span class="p">,</span>
    <span class="ss">:time</span><span class="p">,</span>
    <span class="ss">:timestamp</span><span class="p">,</span>
    <span class="ss">:virtual</span><span class="p">,</span>
  <span class="p">].</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">column_type</span><span class="o">|</span>
    <span class="nb">module_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
      def </span><span class="si">#{</span><span class="n">column_type</span><span class="si">}</span><span class="sh">(*args, **options)
        args.each { |name| column(name, :</span><span class="si">#{</span><span class="n">column_type</span><span class="si">}</span><span class="sh">, options) }
      end
</span><span class="no">    CODE</span>
  <span class="k">end</span>
  <span class="kp">alias_method</span> <span class="ss">:numeric</span><span class="p">,</span> <span class="ss">:decimal</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">#column</code> 方法非常神奇，它从各处收集有关当前表的定义，最终为表中的每一个字段创建一个 <code class="highlighter-rouge">ColumnDefinition</code> 实例，并存储到自己持有的 <code class="highlighter-rouge">@columns_hash</code> 中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">column</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="nb">name</span> <span class="o">=</span> <span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span>
  <span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">.</span><span class="nf">to_sym</span> <span class="k">if</span> <span class="n">type</span>
  <span class="n">options</span> <span class="o">=</span> <span class="n">options</span><span class="p">.</span><span class="nf">dup</span>

  <span class="n">index_options</span> <span class="o">=</span> <span class="n">options</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="ss">:index</span><span class="p">)</span>
  <span class="n">index</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">index_options</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Hash</span><span class="p">)</span> <span class="p">?</span> <span class="n">index_options</span> <span class="p">:</span> <span class="p">{})</span> <span class="k">if</span> <span class="n">index_options</span>
  <span class="vi">@columns_hash</span><span class="p">[</span><span class="nb">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_column_definition</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
  <span class="nb">self</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">new_column_definition</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
  <span class="n">type</span> <span class="o">=</span> <span class="n">aliased_types</span><span class="p">(</span><span class="n">type</span><span class="p">.</span><span class="nf">to_s</span><span class="p">,</span> <span class="n">type</span><span class="p">)</span>
  <span class="n">options</span><span class="p">[</span><span class="ss">:primary_key</span><span class="p">]</span> <span class="o">||=</span> <span class="n">type</span> <span class="o">==</span> <span class="ss">:primary_key</span>
  <span class="n">options</span><span class="p">[</span><span class="ss">:null</span><span class="p">]</span> <span class="o">=</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="ss">:primary_key</span><span class="p">]</span>
  <span class="n">create_column_definition</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">create_column_definition</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
  <span class="no">ColumnDefinition</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>除了 <code class="highlighter-rouge">ColumnDefinition</code> 之外，在 ActiveRecord 中还存在 <code class="highlighter-rouge">PrimaryKeyDefinition</code>、<code class="highlighter-rouge">IndexDefinition</code> 等等类和结构体用于表示数据库中的某一种元素。</p>

<p>表结构在最后会被 <code class="highlighter-rouge">SchemaCreation</code> 类的 <code class="highlighter-rouge">#accept</code> 方法展开，最后在数据库中执行。</p>

<h3 id="小结-3">小结</h3>

<p>到这里整个 Migrations 部分的实现就已经阅读分析完了，整个『模块』包含两个部分，一部分是 rake 任务执行 DSL 代码的过程，另一部分是 DSL 的实现，两部分的结合最终构成了整个 Migrations 模块的全部内容。</p>

<p>ActiveRecord 对于 Migration 迁移机制的设计确实很好的解决数据库中的表结构不断变更的问题，同时因为所有的 Migration 文件都在版本控制中管理，我们也能够随时还原数据库中的表结构。</p>

<h2 id="总结">总结</h2>

<p>文章对 ActiveRecord 中涉及的很多问题都进行了分析和介绍，包括模型的创建、查询以及关系，还包括数据库表迁移的实现，本来想将文中的几个部分分开进行介绍，但是写着写着就懒得分开了，如果对文章的内容有疑问，请在博客下面的评论系统中留言。</p>

<blockquote>

</blockquote>


	  ]]></description>
	</item>

	<item>
	  <title>如何从 MongoDB 迁移到 MySQL</title>
	  <link>/blogs//mongodb-to-mysql</link>
	  <author></author>
	  <pubDate>2017-10-10T00:00:00+00:00</pubDate>
	  <guid>/blogs//mongodb-to-mysql</guid>
	  <description><![CDATA[
	     <p>最近的一个多月时间其实都在做数据库的迁移工作，我目前在开发的项目其实在上古时代是使用 MySQL 作为主要数据库的，后来由于一些业务上的原因从 MySQL 迁移到了 MongoDB，使用了几个月的时间后，由于数据库服务非常不稳定，再加上无人看管，同时 MongoDB 本身就是无 Schema 的数据库，最后导致数据库的脏数据问题非常严重。目前团队的成员没有较为丰富的 Rails 开发经验，所以还是希望使用 ActiveRecord 加上 Migration 的方式对数据进行一些强限制，保证数据库中数据的合法。</p>

<p><img src="https://img.draveness.me/2017-10-10-mysql-and-mongodb.png" alt="mysql-and-mongodb" /></p>

<p>文中会介绍作者在迁移数据库的过程中遇到的一些问题，并为各位读者提供需要<strong>停机</strong>迁移数据库的可行方案，如果需要不停机迁移数据库还是需要别的方案来解决，在这里提供的方案用于百万数据量的 MongoDB，预计的停机时间在两小时左右，如果数据量在千万级别以上，过长的停机时间可能是无法接受的，应该设计不停机的迁移方案；无论如何，作者希望这篇文章能够给想要做数据库迁移的开发者带来一些思路，少走一些坑。</p>

<h2 id="从关系到文档">从关系到文档</h2>

<p>虽然这篇文章的重点是从 MongoDB 迁移到 MySQL，但是作者还是想简单提一下从 MySQL 到 MongoDB 的迁移，如果我们仅仅是将 MySQL 中的全部数据导入到 MongoDB 中其实是一间比较简单的事情，其中最重要的原因就是 <strong>MySQL 支持的数据类型是 MongoDB 的子集</strong>：</p>

<p><img src="https://img.draveness.me/2017-10-10-mongodb-mysql-datatype-relation.png" alt="mongodb-mysql-datatype-relation" /></p>

<p>在迁移的过程中可以将 MySQL 中的全部数据以 csv 的格式导出，然后再将所有 csv 格式的数据使用 <code class="highlighter-rouge">mongoimport</code> 全部导入到 MongoDB 中：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>mysqldump <span class="nt">-u</span>&lt;username&gt; <span class="nt">-p</span>&lt;password&gt; <span class="se">\</span>
    <span class="nt">-T</span> &lt;output_directory&gt; <span class="se">\</span>
    <span class="nt">--fields-terminated-by</span> <span class="s1">','</span> <span class="se">\</span>
    <span class="nt">--fields-enclosed-by</span> <span class="s1">'\"'</span> <span class="se">\</span>
    <span class="nt">--fields-escaped-by</span> <span class="s1">'\'</span> <span class="se">\</span>
    <span class="nt">--no-create-info</span> &lt;database_name&gt;

<span class="nv">$ </span>mongoimport <span class="nt">--db</span> &lt;database_name&gt; <span class="nt">--collection</span> &lt;collection_name&gt; <span class="se">\</span>
    <span class="nt">--type</span> csv <span class="se">\</span>
    <span class="nt">--file</span> &lt;data.csv&gt; <span class="se">\</span>
    <span class="nt">--headerline</span>
</code></pre></div></div>

<p>虽然整个过程看起来只需要两个命令非常简单，但是等到你真要去做的时候你会遇到非常多的问题，作者没有过从 MySQL 或者其他关系型数据库迁移到 MongoDB 的经验，但是 Google 上相关的资料特别多，所以这总是一个有无数前人踩过坑的问题，而前人的经验也能够帮助我们节省很多时间。</p>

<p><img src="https://img.draveness.me/2017-10-24-mysql-to-mongodb.png" alt="mysql-to-mongodb" /></p>

<blockquote>
  <p>使用 csv 的方式导出数据在绝大多数的情况都不会出现问题，但是如果数据库中的某些文档中存储的是富文本，那么虽然在导出数据时不会出现问题，最终导入时可能出现一些比较奇怪的错误。</p>
</blockquote>

<h2 id="从文档到关系">从文档到关系</h2>

<p>相比于从 MySQL 到 MongoDB 的迁移，反向的迁移就麻烦了不止一倍，这主要是因为 MongoDB 中的很多数据类型和集合之间的关系在 MySQL 中都并不存在，比如嵌入式的数据结构、数组和哈希等集合类型、多对多关系的实现，很多的问题都不是仅仅能通过数据上的迁移解决的，我们需要在对数据进行迁移之前先对部分数据结构进行重构，本文中的后半部分会介绍需要处理的数据结构和逻辑。</p>

<p><img src="https://img.draveness.me/2017-10-10-mongodb-mysql-problems-to-be-solved.png" alt="mongodb-mysql-problems-to-be-solved" /></p>

<p>当我们准备将数据库彻底迁移到 MySQL 之前，需要做一些准备工作，将最后迁移所需要的工作尽可能地减少，保证停机的时间不会太长，准备工作的目标就是尽量消灭工程中复杂的数据结构。</p>

<h3 id="数据的预处理">数据的预处理</h3>

<p>在进行迁移之前要做很多准备工作，第一件事情是要把所有嵌入的数据结构改成非嵌入式的数据结构：</p>

<p><img src="https://img.draveness.me/2017-10-10-embedded-reference-documents.png" alt="embedded-reference-documents" /></p>

<p>也就是把所有 <code class="highlighter-rouge">embeds_many</code> 和 <code class="highlighter-rouge">embeds_one</code> 的关系都改成 <code class="highlighter-rouge">has_many</code> 和 <code class="highlighter-rouge">has_one</code>，同时将 <code class="highlighter-rouge">embedded_in</code> 都替换成 <code class="highlighter-rouge">belongs_to</code>，同时我们需要将工程中对应的测试都改成这种引用的关系，然而只改变代码中的关系并没有真正改变 MongoDB 中的数据。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">embeds_many_to_has_many</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
  <span class="n">child_key_name</span> <span class="o">=</span> <span class="n">child</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">underscore</span><span class="p">.</span><span class="nf">pluralize</span>
  <span class="n">parent</span><span class="p">.</span><span class="nf">collection</span><span class="p">.</span><span class="nf">find</span><span class="p">({}).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">parent_document</span><span class="o">|</span>
    <span class="k">next</span> <span class="k">unless</span> <span class="n">parent_document</span><span class="p">[</span><span class="n">child_key_name</span><span class="p">]</span>
    <span class="n">parent_document</span><span class="p">[</span><span class="n">child_key_name</span><span class="p">].</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">child_document</span><span class="o">|</span>
      <span class="n">new_child</span> <span class="o">=</span> <span class="n">child_document</span><span class="p">.</span><span class="nf">merge</span> <span class="s2">"</span><span class="si">#{</span><span class="n">parent</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">underscore</span><span class="si">}</span><span class="s2">_id"</span><span class="p">:</span> <span class="n">parent_document</span><span class="p">[</span><span class="s1">'_id'</span><span class="p">]</span>
      <span class="n">child</span><span class="p">.</span><span class="nf">collection</span><span class="p">.</span><span class="nf">insert_one</span> <span class="n">new_child</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="n">parent</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">unset</span><span class="p">(</span><span class="n">child_key_name</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">embeds_many_to_has_many</span><span class="p">(</span><span class="no">Person</span><span class="p">,</span> <span class="no">Address</span><span class="p">)</span>
</code></pre></div></div>

<p>我们可以使用上述的代码将关系为嵌入的模型都转换成引用，拍平所有复杂的数据关系，这段代码的运行时间与嵌入关系中的两个模型的数量有关，需要注意的是，MongoDB 中嵌入模型的数据可能因为某些原因出现相同的 <code class="highlighter-rouge">_id</code> 在插入时会发生冲突导致崩溃，你可以对 <code class="highlighter-rouge">insert_one</code> 使用 <code class="highlighter-rouge">resuce</code> 来保证这段代码的运行不会因为上述原因而停止。</p>

<p><img src="https://img.draveness.me/2017-10-10-embedded-to-reference.png" alt="embedded-to-reference" /></p>

<p>通过这段代码我们就可以轻松将原有的嵌入关系全部展开变成引用的关系，将嵌入的关系变成引用除了做这两个改变之外，不需要做其他的事情，无论是数据的查询还是模型的创建都不需要改变代码的实现，不过记得为子模型中父模型的外键<strong>添加索引</strong>，否则会导致父模型在获取自己持有的全部子模型时造成<strong>全表扫描</strong>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Comment</span>
  <span class="kp">include</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Document</span>
  <span class="n">index</span> <span class="ss">post_id: </span><span class="mi">1</span>
  <span class="n">belongs_to</span> <span class="ss">:post</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在处理了 MongoDB 中独有的嵌入式关系之后，我们就需要解决一些复杂的集合类型了，比如数组和哈希，如果我们使用 MySQL5.7 或者 PostgreSQL 的话，其实并不需要对他们进行处理，因为最新版本的 MySQL 和 PostgreSQL 已经提供了对 JSON 的支持，不过作者还是将项目中的数组和哈希都变成了常见的数据结构。</p>

<p>在这个可选的过程中，其实并没有什么标准答案，我们可以根据需要将不同的数据转换成不同的数据结构：</p>

<p><img src="https://img.draveness.me/2017-10-10-array-to-string-or-relation.png" alt="array-to-string-or-relation" /></p>

<p>比如，将数组变成字符串或者一对多关系，将哈希变成当前文档的键值对等等，如何处理这些集合数据其实都要看我们的业务逻辑，在改变这些字段的同时尽量为上层提供一个与原来直接 <code class="highlighter-rouge">.tags</code> 或者 <code class="highlighter-rouge">.categories</code> 结果相同的 API：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Post</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="nf">tag_titles</span>
    <span class="n">tags</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:title</span><span class="p">)</span>
  <span class="k">end</span>
  
  <span class="k">def</span> <span class="nf">split_categories</span>
    <span class="n">categories</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">','</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这一步其实也是可选的，上述代码只是为了减少其他地方的修改负担，当然如果你想使用 MySQL5.7 或者 PostgreSQL 数据库对 JSON 的支持也没有什么太大的问题，只是在查询集合字段时有一些不方便。</p>

<h3 id="mongoid-的小兄弟们">Mongoid 的『小兄弟』们</h3>

<p>在使用 Mongoid 进行开发期间难免会用到一些相关插件，比如 <a href="https://github.com/thetron/mongoid-enum">mongoid-enum</a>、<a href="https://github.com/mongoid/mongoid-slug">mongoid-slug</a> 和 <a href="https://github.com/mongoid/mongoid-history">mongoid-history</a> 等，这些插件的实现与 ActiveRecord 中具有相同功能的插件在实现上有很大的不同。</p>

<p>对于有些插件，比如 mongoid-slug 只是在引入插件的模型的文档中插入了 <code class="highlighter-rouge">_slugs</code> 字段，我们只需要在进行数据迁移忽略这些添加的字段并将所有的 <code class="highlighter-rouge">#slug</code> 方法改成 <code class="highlighter-rouge">#id</code>，不需要在预处理的过程中做其它的改变。而枚举的实现在 Mongoid 的插件和 ActiveRecord 中就截然不同了：</p>

<p><img src="https://img.draveness.me/2017-10-10-mongodb-mysql-enum.png" alt="mongodb-mysql-enu" /></p>

<p>mongoid-enum 使用字符串和 <code class="highlighter-rouge">_status</code> 来保存枚举类型的字段，而 ActiveRecord 使用整数和 <code class="highlighter-rouge">status</code> 表示枚举类型，两者在底层数据结构的存储上有一些不同，我们会在之后的迁移脚本中解决这个问题。</p>

<p><img src="https://img.draveness.me/2017-10-10-mongoid-activerecord-enum.png" alt="mongoid-activerecord-enum" /></p>

<p>如果在项目中使用了很多 Mongoid 的插件，由于其实现不同，我们也只能根据不同的插件的具体实现来决定如何对其进行迁移，如果使用了一些支持特殊功能的插件可能很难在 ActiveRecord 中找到对应的支持，在迁移时可以考虑暂时将部分不重要的功能移除。</p>

<h3 id="主键与-uuid">主键与 UUID</h3>

<p>我们希望从 MongoDB 迁移到 MySQL 的另一个重要原因就是 MongoDB 每一个文档的主键实在是太过冗长，一个 32 字节的 <code class="highlighter-rouge">_id</code> 无法给我们提供特别多的信息，只能增加我们的阅读障碍，再加上项目中并没有部署 MongoDB 集群，所以没能享受到用默认的 UUID 生成机制带来的好处。</p>

<p><img src="https://img.draveness.me/2017-10-10-mongodb-mysql-id.png" alt="mongodb-mysql-id" /></p>

<p>我们不仅没有享受到 UUID 带来的优点，它还在迁移 MySQL 的过程中为我们带来了很大的麻烦，一方面是因为 ActiveRecord 的默认主键是整数，不支持 32 字节长度的 UUID，如果我们想要不改变 MongoDB 的 UUID，直接迁移到 MySQL 中使用其实也没有什么问题，只是我们要将默认的整数类型的主键变成字符串类型，同时要使用一个 UUID 生成器来保证所有的主键都是根据时间递增的并且不会冲突。</p>

<p>如果准备使用 UUID 加生成器的方式，其实会省去很多迁移的时间，不过看起来确实不是特别的优雅，如何选择还是要权衡和评估，但是如果我们选择了使用 <code class="highlighter-rouge">integer</code> 类型的自增主键时，就需要做很多额外的工作了，首先是为所有的表添加 <code class="highlighter-rouge">uuid</code> 字段，同时为所有的外键例如 <code class="highlighter-rouge">post_id</code> 创建对应的 <code class="highlighter-rouge">post_uuid</code> 字段，通过 <code class="highlighter-rouge">uuid</code> 将两者关联起来：</p>

<p><img src="https://img.draveness.me/2017-10-10-mysql-before-migrations.png" alt="mysql-before-migrations" /></p>

<p>在数据的迁移过程中，我们会将原有的 <code class="highlighter-rouge">_id</code> 映射到 <code class="highlighter-rouge">uuid</code> 中，<code class="highlighter-rouge">post_id</code> 映射到 <code class="highlighter-rouge">post_uuid</code> 上，我们通过保持 <code class="highlighter-rouge">uuid</code> 和 <code class="highlighter-rouge">post_uuid</code> 之间的关系保证模型之间的关系没有丢失，在迁移数据的过程中 <code class="highlighter-rouge">id</code> 和 <code class="highlighter-rouge">post_id</code> 是完全不存在任何联系的。</p>

<p>当我们按照 <code class="highlighter-rouge">_id</code> 的顺序遍历整个文档，将文档中的数据被插入到表中时，MySQL 会为所有的数据行自动生成的递增的主键 <code class="highlighter-rouge">id</code>，而 <code class="highlighter-rouge">post_id</code> 在这时都为空。</p>

<p><img src="https://img.draveness.me/2017-10-10-mysql-after-migrations.png" alt="mysql-after-migrations" /></p>

<p>在全部的数据都被插入到 MySQL 之后，我们通过 <code class="highlighter-rouge">#find_by_uuid</code> 查询的方式将 <code class="highlighter-rouge">uuid</code> 和 <code class="highlighter-rouge">post_uuid</code> 中的关系迁移到 <code class="highlighter-rouge">id</code> 和 <code class="highlighter-rouge">post_id</code> 中，并将与 <code class="highlighter-rouge">uuid</code> 相关的字段全部删除，这样我们能够保证模型之间的关系不会消失，并且数据行的相对位置与迁移前完全一致。</p>

<h3 id="代码的迁移">代码的迁移</h3>

<p>Mongoid 在使用时都是通过 <code class="highlighter-rouge">include</code> 将相关方法加载到当前模型中的，而 ActiveRecord 是通过继承 <code class="highlighter-rouge">ActiveRecord::Base</code> 的方式使用的，完成了对数据的预处理，我们就可以对现有模型层的代码进行修改了。</p>

<p>首先当然是更改模型的『父类』，把所有的 <code class="highlighter-rouge">Mongoid::Document</code> 都改成 <code class="highlighter-rouge">ActiveRecord::Base</code>，然后创建类对应的 Migration 迁移文件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/models/post.rb</span>
<span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">validate_presence_of</span> <span class="ss">:title</span><span class="p">,</span> <span class="ss">:content</span>
<span class="k">end</span>

<span class="c1"># db/migrate/20170908075625_create_posts.rb</span>
<span class="k">class</span> <span class="nc">CreatePosts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span><span class="p">[</span><span class="mf">5.1</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:posts</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:title</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">text</span> <span class="ss">:content</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:uuid</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span>

      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span> <span class="ss">null: </span><span class="kp">false</span>
    <span class="k">end</span>
    
    <span class="n">add_index</span> <span class="ss">:posts</span><span class="p">,</span> <span class="ss">:uuid</span><span class="p">,</span> <span class="ss">unique: </span><span class="kp">true</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<blockquote>
  <p>注意：要为每一张表添加类型为字符串的 <code class="highlighter-rouge">uuid</code> 字段，同时为 <code class="highlighter-rouge">uuid</code> 建立唯一索引，以加快通过 <code class="highlighter-rouge">uuid</code> 建立不同数据模型之间关系的速度。</p>
</blockquote>

<p>除了建立数据库的迁移文件并修改基类，我们还需要修改一些 <code class="highlighter-rouge">include</code> 的模块和 Mongoid 中独有的查询，比如使用 <code class="highlighter-rouge">gte</code> 或者 <code class="highlighter-rouge">lte</code> 的日期查询和使用正则进行模式匹配的查询，这些查询在 ActiveRecord 中的使用方式与 Mongoid 中完全不同，我们需要通过手写 SQL 来解决这些问题。</p>

<p><img src="https://img.draveness.me/2017-10-10-mongoid-to-activerecord-model-and-query.png" alt="mongoid-to-activerecord-model-and-query" /></p>

<p>除此之外，我们也需要处理一些复杂的模型关系，比如 Mongoid 中的 <code class="highlighter-rouge">inverse_of</code> 在 ActiveRecord 中叫做  <code class="highlighter-rouge">foreign_key</code> 等等，这些修改其实都并不复杂，只是如果想要将这部分的代码全部处理掉，就需要对业务逻辑进行详细地测试以保证不会有遗留的问题，这也就对我们项目的测试覆盖率有着比较高的要求了，不过我相信绝大多数的 Rails 工程都有着非常好的测试覆盖率，能够保证这一部分代码和逻辑能够顺利迁移，但是如果项目中完全没有测试或者测试覆盖率很低，就只能人肉进行测试或者自求多福了，或者<strong>就别做迁移了，多写点测试再考虑这些重构的事情吧</strong>。</p>

<h3 id="数据的迁移">数据的迁移</h3>

<p>为每一个模型创建对应的迁移文件并建表其实一个不得不做的体力活，虽然有一些工作我们没法省略，但是我们可以考虑使用自动化的方式为所有的模型添加 <code class="highlighter-rouge">uuid</code> 字段和索引，同时也为类似 <code class="highlighter-rouge">post_id</code> 的字段添加相应的 <code class="highlighter-rouge">post_uuid</code> 列：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AddUuidColumns</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span><span class="p">[</span><span class="mf">5.1</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">eager_load!</span>
    <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">descendants</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">klass</span><span class="o">|</span>
      <span class="c1"># add `uuid` column and create unique index on `uuid`.</span>
      <span class="n">add_column</span> <span class="n">klass</span><span class="p">.</span><span class="nf">table_name</span><span class="p">,</span> <span class="ss">:uuid</span><span class="p">,</span> <span class="ss">:string</span><span class="p">,</span> <span class="ss">unique: </span><span class="kp">true</span>
      <span class="n">add_index</span> <span class="n">klass</span><span class="p">.</span><span class="nf">table_name</span><span class="p">,</span> <span class="ss">unique: </span><span class="kp">true</span>
      
      <span class="c1"># add `xxx_uuid` columns, ex: `post_uuid`, `comment_uuid` and etc.</span>
      <span class="n">uuids</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">attribute_names</span>
        <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="kp">attr</span><span class="o">|</span> <span class="kp">attr</span><span class="p">.</span><span class="nf">include?</span> <span class="s1">'_id'</span> <span class="p">}</span>
        <span class="p">.</span><span class="nf">map</span>    <span class="p">{</span> <span class="o">|</span><span class="kp">attr</span><span class="o">|</span> <span class="kp">attr</span><span class="p">.</span><span class="nf">gsub</span> <span class="s1">'_id'</span><span class="p">,</span> <span class="s1">'_uuid'</span> <span class="p">}</span>
      <span class="k">next</span> <span class="k">unless</span> <span class="n">uuids</span><span class="p">.</span><span class="nf">present?</span>
      <span class="n">uuids</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">uuid</span><span class="o">|</span>
        <span class="n">add_column</span> <span class="n">klass</span><span class="p">.</span><span class="nf">table_name</span><span class="p">,</span> <span class="n">uuid</span><span class="p">,</span> <span class="ss">:string</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在添加 <code class="highlighter-rouge">uuid</code> 列并建立好索引之后，我们就可以开始对数据库进行迁移了，如果我们决定在迁移的过程中改变原有数据的主键，那么我们会将迁移分成两个步骤，数据的迁移和关系的重建，前者仅指将 MongoDB 中的所有数据全部迁移到 MySQL 中对应的表中，并将所有的 <code class="highlighter-rouge">_id</code> 转换成 <code class="highlighter-rouge">uuid</code>、<code class="highlighter-rouge">xx_id</code> 转换成 <code class="highlighter-rouge">xx_uuid</code>，而后者就是前面提到的：通过 <code class="highlighter-rouge">uuid</code> 和 <code class="highlighter-rouge">xx_uuid</code> 的关联重新建立模型之间的关系并在最后删除所有的 <code class="highlighter-rouge">uuid</code> 字段。</p>

<p>我们可以使用如下的代码对数据进行迁移，这段代码从 MongoDB 中遍历某个集合 Collection 中的全部数据，然后将文档作为参数传入 block，然后再分别通过 <code class="highlighter-rouge">DatabaseTransformer#delete_obsolete_columns</code> 和 <code class="highlighter-rouge">DatabaseTransformer#update_rename_columns</code> 方法删除部分已有的列、更新一些数据列最后将所有的 <code class="highlighter-rouge">id</code> 列都变成 <code class="highlighter-rouge">uuid</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">DatabaseTransformer</span>
  <span class="k">def</span> <span class="nf">import</span><span class="p">(</span><span class="n">collection_name</span><span class="p">,</span> <span class="o">*</span><span class="n">obsolete_columns</span><span class="p">,</span> <span class="o">**</span><span class="n">rename_columns</span><span class="p">)</span>
    <span class="n">collection</span> <span class="o">=</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Clients</span><span class="p">.</span><span class="nf">default</span><span class="p">.</span><span class="nf">collections</span><span class="p">.</span><span class="nf">select</span> <span class="k">do</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span>
      <span class="n">c</span><span class="p">.</span><span class="nf">namespace</span> <span class="o">==</span> <span class="s2">"</span><span class="si">#{</span><span class="n">database</span><span class="si">}</span><span class="s2">.</span><span class="si">#{</span><span class="n">collection_name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">pluralize</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span><span class="p">.</span><span class="nf">first</span>

    <span class="k">unless</span> <span class="n">collection</span><span class="p">.</span><span class="nf">present?</span>
      <span class="no">STDOUT</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="n">collection_name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">yellow</span><span class="si">}</span><span class="s2">: skipped"</span>
      <span class="no">STDOUT</span><span class="p">.</span><span class="nf">puts</span>
      <span class="k">return</span>
    <span class="k">end</span>

    <span class="n">constant</span> <span class="o">=</span> <span class="n">collection_name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">singularize</span><span class="p">.</span><span class="nf">camelcase</span><span class="p">.</span><span class="nf">constantize</span>
    <span class="n">reset_callbacks</span> <span class="n">constant</span>

    <span class="no">DatabaseTransformer</span><span class="p">.</span><span class="nf">profiling</span> <span class="k">do</span>
      <span class="n">collection_count</span> <span class="o">=</span> <span class="n">collection</span><span class="p">.</span><span class="nf">find</span><span class="p">.</span><span class="nf">count</span>
      <span class="n">collection</span><span class="p">.</span><span class="nf">find</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">document</span><span class="p">,</span> <span class="n">index</span><span class="o">|</span>
        <span class="n">document</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">document</span> <span class="k">if</span> <span class="nb">block_given?</span>
        <span class="n">delete_obsolete_columns</span> <span class="n">document</span><span class="p">,</span> <span class="n">obsolete_columns</span>
        <span class="n">update_rename_columns</span> <span class="n">document</span><span class="p">,</span> <span class="n">rename_columns</span>
        <span class="n">update_id_columns</span> <span class="n">document</span>

        <span class="n">insert_record</span> <span class="n">constant</span><span class="p">,</span> <span class="n">document</span>
        <span class="no">STDOUT</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="n">index</span><span class="si">}</span><span class="s2">/</span><span class="si">#{</span><span class="n">collection_count</span><span class="si">}</span><span class="se">\n</span><span class="s2">"</span> <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">).</span><span class="nf">zero?</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当完成了对文档的各种操作之后，该方法会直接调用 <code class="highlighter-rouge">DatabaseTransformer#insert_record</code> 将数据插入 MySQL 对应的表中；我们可以直接使用如下的代码将某个 Collection 中的全部文档迁移到 MySQL 中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">transformer</span> <span class="o">=</span> <span class="no">DatabaseTransformer</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'draven_production'</span>
<span class="n">transformer</span><span class="p">.</span><span class="nf">import</span> <span class="ss">:post</span><span class="p">,</span> <span class="ss">:_slugs</span><span class="p">,</span> <span class="ss">name: :title</span><span class="p">,</span> <span class="ss">_status: :status</span>
</code></pre></div></div>

<p>上述代码会在迁移时将集合每一个文档的 <code class="highlighter-rouge">_slugs</code> 字段全部忽略，同时将 <code class="highlighter-rouge">name</code> 重命名成 <code class="highlighter-rouge">title</code>、<code class="highlighter-rouge">_status</code> 重命名成 <code class="highlighter-rouge">status</code>，虽然作为枚举类型的字段 mongoid-enum 和 ActiveRecord 的枚举类型完全不同，但是在这里可以直接插入也没有什么问题，ActiveRecord 的模型在创建时会自己处理字符串和整数之间的转换：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">insert_record</span><span class="p">(</span><span class="n">constant</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
  <span class="n">model</span> <span class="o">=</span> <span class="n">constant</span><span class="p">.</span><span class="nf">new</span> <span class="n">params</span>
  <span class="n">model</span><span class="p">.</span><span class="nf">save!</span> <span class="ss">validate: </span><span class="kp">false</span>
<span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">exception</span>
  <span class="no">STDERR</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"Import Error: </span><span class="si">#{</span><span class="n">exception</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">raise</span> <span class="n">exception</span>
<span class="k">end</span>
</code></pre></div></div>

<p>为了加快数据的插入速度，同时避免所有由于插入操作带来的副作用，我们会在数据迁移期间重置所有的回调：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">reset_callbacks</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span>
  <span class="sx">%i(create save update)</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">callback</span><span class="o">|</span>
    <span class="n">constant</span><span class="p">.</span><span class="nf">reset_callbacks</span> <span class="n">callback</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这段代码的作用仅在这个脚本运行的过程中才会生效，不会对工程中的其他地方造成任何的影响；同时，该脚本会在每 1000 个模型插入成功后向标准输出打印当前进度，帮助我们快速发现问题和预估迁移的时间。</p>

<blockquote>
  <p>你可以在 <a href="https://gist.github.com/Draveness/10476fe67a10128a37ba27a4c6967d07">database_transformer.rb</a> 找到完整的数据迁移代码。</p>
</blockquote>

<p>将所有的数据全部插入到 MySQL 的表之后，模型之间还没有任何显式的关系，我们还需要将通过 <code class="highlighter-rouge">uuid</code> 连接的模型转换成使用 <code class="highlighter-rouge">id</code> 的方式，对象之间的关系才能通过点语法直接访问，关系的建立其实非常简单，我们获得当前类所有结尾为 <code class="highlighter-rouge">_uuid</code> 的属性，然后遍历所有的数据行，根据 <code class="highlighter-rouge">uuid</code> 的值和 <code class="highlighter-rouge">post_uuid</code> 属性中的 “post” 部分获取到表名，最终得到对应的关联模型，在这里我们也处理了类似多态的特殊情况：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">RelationBuilder</span>
  <span class="k">def</span> <span class="nf">build_relations</span><span class="p">(</span><span class="n">class_name</span><span class="p">,</span> <span class="n">polymorphic_associations</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">rename_associations</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="n">uuids</span> <span class="o">=</span> <span class="n">class_name</span><span class="p">.</span><span class="nf">attribute_names</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="nb">name</span><span class="p">.</span><span class="nf">end_with?</span> <span class="s1">'_uuid'</span> <span class="p">}</span>

    <span class="k">unless</span> <span class="n">uuids</span><span class="p">.</span><span class="nf">present?</span>
      <span class="no">STDOUT</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="n">class_name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">yellow</span><span class="si">}</span><span class="s2">: skipped"</span>
      <span class="no">STDOUT</span><span class="p">.</span><span class="nf">puts</span>
      <span class="k">return</span>
    <span class="k">end</span>

    <span class="n">reset_callbacks</span> <span class="n">class_name</span>

    <span class="no">RelationBuilder</span><span class="p">.</span><span class="nf">profiling</span> <span class="k">do</span>
      <span class="n">models_count</span> <span class="o">=</span> <span class="n">class_name</span><span class="p">.</span><span class="nf">count</span>
      <span class="n">class_name</span><span class="p">.</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">model</span><span class="p">,</span> <span class="n">index</span><span class="o">|</span>
        <span class="n">update_params</span> <span class="o">=</span> <span class="n">uuids</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">uuid</span><span class="o">|</span>
          <span class="n">original_association_name</span> <span class="o">=</span> <span class="n">uuid</span><span class="p">[</span><span class="mi">0</span><span class="o">...-</span><span class="mi">5</span><span class="p">]</span>

          <span class="n">association_model</span> <span class="o">=</span> <span class="n">association_model</span><span class="p">(</span>
            <span class="n">original_association_name</span><span class="p">,</span>
            <span class="n">model</span><span class="p">[</span><span class="n">uuid</span><span class="p">],</span>
            <span class="n">polymorphic_associations</span><span class="p">,</span>
            <span class="n">rename_associations</span>
          <span class="p">)</span>

          <span class="p">[</span><span class="n">original_association_name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">,</span> <span class="n">association_model</span><span class="p">]</span>
        <span class="k">end</span><span class="p">.</span><span class="nf">compact</span>

        <span class="k">begin</span>
          <span class="no">Hash</span><span class="p">[</span><span class="n">update_params</span><span class="p">].</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
            <span class="n">model</span><span class="p">.</span><span class="nf">send</span> <span class="s2">"</span><span class="si">#{</span><span class="n">key</span><span class="si">}</span><span class="s2">="</span><span class="p">,</span> <span class="n">value</span>
          <span class="k">end</span>
          <span class="n">model</span><span class="p">.</span><span class="nf">save!</span> <span class="ss">validate: </span><span class="kp">false</span>
        <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
          <span class="no">STDERR</span><span class="p">.</span><span class="nf">puts</span> <span class="n">e</span>
          <span class="k">raise</span> <span class="n">e</span>
        <span class="k">end</span>

        <span class="no">STDOUT</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="n">index</span><span class="si">}</span><span class="s2">/</span><span class="si">#{</span><span class="n">models_count</span><span class="si">}</span><span class="se">\n</span><span class="s2">"</span> <span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">).</span><span class="nf">zero?</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在查找到对应的数据行之后就非常简单了，我们调用对应的 <code class="highlighter-rouge">post=</code> 等方法更新外键最后直接将外键的值保存到数据库中，与数据的迁移过程一样，我们在这段代码的执行过程中也会打印出当前的进度。</p>

<p>在初始化 <code class="highlighter-rouge">RelationBuilder</code> 时，如果我们传入了 <code class="highlighter-rouge">constants</code>，那么在调用 <code class="highlighter-rouge">RelationBuilder#build!</code> 时就会重建其中的全部关系，但是如果没有传入就会默认加载 ActiveRecord 中所有的子类，并去掉其中包含 <code class="highlighter-rouge">::</code> 的模型，也就是 ActiveRecord 中使用 <code class="highlighter-rouge">has_and_belongs_to_many</code> 创建的中间类，我们会在下一节中介绍如何单独处理多对多关系：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="nb">constants</span> <span class="o">=</span> <span class="p">[])</span>
  <span class="k">if</span> <span class="nb">constants</span><span class="p">.</span><span class="nf">present?</span>
    <span class="vi">@constants</span> <span class="o">=</span> <span class="nb">constants</span>
  <span class="k">else</span>
    <span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">eager_load!</span>
    <span class="vi">@constants</span> <span class="o">=</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">descendants</span>
        <span class="p">.</span><span class="nf">reject</span> <span class="p">{</span> <span class="o">|</span><span class="n">constant</span><span class="o">|</span> <span class="n">constant</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="s1">'::'</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<blockquote>
  <p>跟关系重建相关的代码可以在 <a href="https://gist.github.com/Draveness/c0798fb1272f483a176fa67741a3f1ee">relation_builder.rb</a> 找到完整的用于关系迁移的代码。</p>
</blockquote>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">builder</span> <span class="o">=</span> <span class="no">RelationBuilder</span><span class="p">.</span><span class="nf">new</span><span class="p">([</span><span class="no">Post</span><span class="p">,</span> <span class="no">Comment</span><span class="p">])</span>
<span class="n">builder</span><span class="p">.</span><span class="nf">build!</span>
</code></pre></div></div>

<p>通过这数据迁移和关系重建两个步骤就已经可以解决绝大部分的数据迁移问题了，但是由于 MongoDB 和 ActiveRecord 中对于多对多关系的处理比较特殊，所以我们需要单独进行解决，如果所有的迁移问题到这里都已经解决了，那么我们就可以使用下面的迁移文件将数据库中与 <code class="highlighter-rouge">uuid</code> 有关的全部列都删除了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">RemoveAllUuidColumns</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span><span class="p">[</span><span class="mf">5.1</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">eager_load!</span>
    <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">descendants</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">klass</span><span class="o">|</span>
      <span class="n">attrs</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">attribute_names</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">n</span><span class="o">|</span> <span class="n">n</span><span class="p">.</span><span class="nf">include?</span> <span class="s1">'uuid'</span> <span class="p">}</span>
      <span class="k">next</span> <span class="k">unless</span> <span class="n">attrs</span><span class="p">.</span><span class="nf">present?</span>
      <span class="n">remove_columns</span> <span class="n">klass</span><span class="p">.</span><span class="nf">table_name</span><span class="p">,</span> <span class="o">*</span><span class="n">attrs</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>到这里位置整个迁移的过程就基本完成了，接下来就是跟整个迁移过程中有关的其他事项，例如：对多对关系、测试的重要性等话题。</p>

<h3 id="多对多关系的处理">多对多关系的处理</h3>

<p>多对多关系在数据的迁移过程中其实稍微有一些复杂，在 Mongoid 中使用 <code class="highlighter-rouge">has_and_belongs_to_many</code> 会在相关的文档下添加一个 <code class="highlighter-rouge">tag_ids</code> 或者 <code class="highlighter-rouge">post_ids</code> 数组：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># The post document.</span>
<span class="p">{</span>
  <span class="s2">"_id"</span> <span class="p">:</span> <span class="no">ObjectId</span><span class="p">(</span><span class="s2">"4d3ed089fb60ab534684b7e9"</span><span class="p">),</span>
  <span class="s2">"tag_ids"</span> <span class="p">:</span> <span class="p">[</span>
    <span class="no">ObjectId</span><span class="p">(</span><span class="s2">"4d3ed089fb60ab534684b7f2"</span><span class="p">),</span> 
    <span class="no">ObjectId</span><span class="p">(</span><span class="s2">"4d3ed089fb60ab53468831f1"</span><span class="p">)</span>
  <span class="p">],</span>
  <span class="s2">"title"</span><span class="p">:</span> <span class="s2">"xxx"</span><span class="p">,</span>
  <span class="s2">"content"</span><span class="p">:</span> <span class="s2">"xxx"</span>
<span class="p">}</span>
</code></pre></div></div>

<p>而 ActiveRecord 中会建立一张单独的表，表的名称是两张表名按照字母表顺序的拼接，如果是 <code class="highlighter-rouge">Post</code> 和 <code class="highlighter-rouge">Tag</code>，对应的多对多表就是 <code class="highlighter-rouge">posts_tags</code>，除了创建多对多表，<code class="highlighter-rouge">has_and_belongs_to_many</code> 还会创建两个 <code class="highlighter-rouge">ActiveRecord::Base</code> 的子类 <code class="highlighter-rouge">Tag::HABTM_Posts</code> 和 <code class="highlighter-rouge">Post::HABTM_Tags</code>，我们可以使用下面的代码简单实验一下：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'active_record'</span>

<span class="k">class</span> <span class="nc">Tag</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">;</span> <span class="k">end</span>
<span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:tags</span>
<span class="k">end</span>
<span class="k">class</span> <span class="nc">Tag</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:posts</span>
<span class="k">end</span>
<span class="nb">puts</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">descendants</span>
<span class="c1"># =&gt; [Tag, Post, Post::HABTM_Tags, Tag::HABTM_Posts]</span>
</code></pre></div></div>

<p>上述代码打印出了两个 <code class="highlighter-rouge">has_and_belongs_to_many</code> 生成的类 <code class="highlighter-rouge">Tag::HABTM_Posts</code> 和 <code class="highlighter-rouge">Post::HABTM_Tags</code>，它们有着完全相同的表 <code class="highlighter-rouge">posts_tags</code>，处理多对多关系时，我们只需要在使用 <code class="highlighter-rouge">DatabaseTransformer</code> 导入表中的所有的数据之后，再通过遍历 <code class="highlighter-rouge">posts_tags</code> 表中的数据更新多对多的关系表就可以了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PostsTag</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">;</span> <span class="k">end</span>

<span class="c1"># migrate data from mongodb to mysql.</span>
<span class="n">transformer</span> <span class="o">=</span> <span class="no">DatabaseTransformer</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'draven_production'</span>
<span class="n">transformer</span><span class="p">.</span><span class="nf">import</span> <span class="ss">:posts_tags</span>

<span class="c1"># establish association between posts and tags.</span>
<span class="no">PostsTag</span><span class="p">.</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">model</span><span class="o">|</span>
  <span class="n">post</span> <span class="o">=</span> <span class="no">Post</span><span class="p">.</span><span class="nf">find_by_uuid</span> <span class="n">model</span><span class="p">.</span><span class="nf">post_uuid</span>
  <span class="n">tag</span> <span class="o">=</span> <span class="no">Tag</span><span class="p">.</span><span class="nf">find_by_uuid</span> <span class="n">model</span><span class="p">.</span><span class="nf">tag_uuid</span>
  <span class="k">next</span> <span class="k">unless</span> <span class="n">post</span><span class="p">.</span><span class="nf">present?</span> <span class="o">&amp;&amp;</span> <span class="n">tag</span><span class="p">.</span><span class="nf">present?</span>
  <span class="n">model</span><span class="p">.</span><span class="nf">update_columns</span> <span class="ss">post_id: </span><span class="n">post</span><span class="p">.</span><span class="nf">id</span><span class="p">,</span> <span class="ss">tag_id: </span><span class="n">tag</span><span class="p">.</span><span class="nf">id</span>
<span class="k">end</span>
</code></pre></div></div>

<p>所有使用 <code class="highlighter-rouge">has_and_belongs_to_many</code> 的多对多关系都需要通过上述代码进行迁移，这一步需要在删除数据库中的所有 <code class="highlighter-rouge">uuid</code> 字段之前完成。</p>

<h3 id="测试的重要性">测试的重要性</h3>

<p>在真正对线上的服务进行停机迁移之前，我们其实需要对数据库已有的数据进行部分和全量测试，在部分测试阶段，我们可以在本地准备一个数据量为生产环境数据量 1/10 或者 1/100 的 MongoDB 数据库，通过在本地模拟 MongoDB 和 MySQL 的环境进行预迁移，确保我们能够尽快地发现迁移脚本中的错误。</p>

<p><img src="https://img.draveness.me/2017-10-10-mongodb-pre-migration.png" alt="mongodb-pre-migration" /></p>

<p>准备测试数据库的办法是通过关系删除一些主要模型的数据行，在删除时可以通过 MongoDB 中的 <code class="highlighter-rouge">dependent: :destroy</code> 删除相关的模型，这样可以尽可能的保证数据的一致性和完整性，但是在对线上数据库进行迁移之前，我们依然需要对 MongoDB 中的全部数据进行全量的迁移测试，这样可以发现一些更加隐蔽的问题，保证真正上线时可以出现更少的状况。</p>

<p>数据库的迁移其实也属于重构，在进行 MongoDB 的数据库迁移之前一定要保证项目有着完善的测试体系和测试用例，这样才能让我们在项目重构之后，确定不会出现我们难以预料的问题，整个项目才是可控的，如果工程中没有足够的测试甚至没有测试，那么就不要再说重构这件事情了 – <strong>单元测试是重构的基础</strong>。</p>

<h2 id="总结">总结</h2>

<p>如何从 MongoDB 迁移到 MySQL 其实是一个工程问题，我们需要在整个过程中不断寻找可能出错的问题，将一个比较复杂的任务进行拆分，在真正做迁移之前尽可能地减少迁移对服务可用性以及稳定性带来的影响。</p>

<p><img src="https://img.draveness.me/2017-10-10-mysql-and-mongodb-work-together.png" alt="mysql-and-mongodb-work-together" /></p>

<p>除此之外，MongoDB 和 MySQL 之间的选择也不一定是非此即彼，我们将项目中的大部分数据都迁移到了 MySQL 中，但是将一部分用于计算和分析的数据留在了 MongoDB，这样就可以保证 MongoDB 宕机之后仍然不会影响项目的主要任务，同时，MySQL 的备份和恢复速度也会因为数据库变小而非常迅速。</p>

<p>最后一点，测试真的很重要，如果没有测试，没有人能够做到在<strong>修改大量的业务代码的过程中不丢失任何的业务逻辑</strong>，甚至如果没有测试，很多业务逻辑可能在开发的那一天就已经丢失了。</p>

<p>如果对文章的内容有疑问或者有 MongoDB 迁移相关的问题，可以在评论中留言。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://www.quora.com/How-do-I-migrate-data-from-a-MongoDB-to-MySQL-database-Can-it-be-done-in-a-real-time-scenario-What-are-the-pros-and-cons-for-each-migration-Which-one-do-you-advice-What-is-your-experience-Any-reference-DB-expert-who-can-do-it">How do I migrate data from a MongoDB to MySQL database? · Quora</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Sidekiq 如何处理异步任务</title>
	  <link>/blogs//sidekiq</link>
	  <author></author>
	  <pubDate>2017-08-28T00:00:00+00:00</pubDate>
	  <guid>/blogs//sidekiq</guid>
	  <description><![CDATA[
	     <p><a href="https://github.com/mperham/sidekiq">Sidekiq</a> 是 Ruby 和 Rails 项目中常用的后台任务处理系统，其本身提供的 API 十分简洁，源代码也非常易于阅读，是一个轻量级的异步处理组件；虽然其本身没有提供太多复杂的功能，但是它的使用和部署非常简单。在这篇文章中，我们将对 Sidekiq 的实现原理进行介绍和分析。</p>

<p><img src="https://img.draveness.me/2017-08-28-Sidekiq-Cover.jpg-1000width" alt="Sidekiq-Cover" /></p>

<p>文章中并不会详细介绍 Sidekiq 的使用，也并不是一篇 Sidekiq 的教程，在这里我们会介绍任务的入队过程、Sidekiq 任务在 Redis 中的存储方式和消费者对任务的处理过程，除此之外，文章将介绍 Sidekiq 中间件的实现以及任务重试的原理。</p>

<h2 id="概述">概述</h2>

<p>在具体分析介绍 Sidekiq 的实现原理之前，我们需要对整个组件的使用过程进行概述，保证我们对 Sidekiq 的结构有一个总体上的了解。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HardWorker</span>
  <span class="kp">include</span> <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Worker</span>
  <span class="k">def</span> <span class="nf">perform</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
    <span class="c1"># do something</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">HardWorker</span><span class="p">.</span><span class="nf">perform_async</span><span class="p">(</span><span class="s1">'bob'</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</code></pre></div></div>

<p>在这里，我们直接照搬 Sidekiq Wiki 中 <a href="https://github.com/mperham/sidekiq/wiki/Getting-Started">Getting Started</a> 部分的代码简单展示下它是如何使用的，当我们执行 <code class="highlighter-rouge">HardWorker.perform_async</code> 方法时，Sidekiq 的 Worker 会将一个异步任务以 JSON 的形式将相关的信息加入 Redis 中并等待消费者对任务的拉取和处理。</p>

<p><img src="https://img.draveness.me/2017-08-28-Sidekiq-Arch.jpg-1000width" alt="Sidekiq-Arch" /></p>

<p>Sidekiq 的消费者有三个部分组成，分别是 <code class="highlighter-rouge">Manager</code>、<code class="highlighter-rouge">Processor</code> 和 <code class="highlighter-rouge">Poller</code>；他们三者会相互协作共同完成对 Redis 中任务消费的过程。</p>

<blockquote>
  <p>需要注意的是，Sidekiq 中的 <code class="highlighter-rouge">Sidekiq::Worker</code> 并不是真正用于处理任务的 Worker，负责执行执行任务的类型其实是 <code class="highlighter-rouge">Sidekiq::Processor</code>；在文章中，当我们提到 Sidekiq Worker 时，其实说的是 <code class="highlighter-rouge">Sidekiq::Processor</code>，当我们使用了形如 <code class="highlighter-rouge">Sidekiq::Worker</code> 或者 <code class="highlighter-rouge">Worker</code> 的形式时，我们说的就是对应的类。</p>
</blockquote>

<h2 id="异步任务的入队">异步任务的入队</h2>

<p>当我们对需要异步执行的任务调用类似 <code class="highlighter-rouge">Worker.perform_async</code> 的方法时，Sidekiq 其实并不会真正去创建一个 <code class="highlighter-rouge">HardWorker</code> 等 <code class="highlighter-rouge">Worker</code> 的对象，它实际上会调用 <code class="highlighter-rouge">Worker.client_push</code> 方法并将当前的 <code class="highlighter-rouge">class</code> 和 <code class="highlighter-rouge">args</code> 参数传进去，也就是需要异步执行的类和参数：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">perform_async</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">client_push</span><span class="p">(</span><span class="s1">'class'</span><span class="p">.</span><span class="nf">freeze</span> <span class="o">=&gt;</span> <span class="nb">self</span><span class="p">,</span> <span class="s1">'args'</span><span class="p">.</span><span class="nf">freeze</span> <span class="o">=&gt;</span> <span class="n">args</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>除了 <code class="highlighter-rouge">Worker.perform_async</code> 之外，<code class="highlighter-rouge">Worker</code> 还提供了另外一对用于<strong>在一段时间之后或者某个时间点</strong>执行相应任务的方法 <code class="highlighter-rouge">Worker.perform_at</code> 和 <code class="highlighter-rouge">Worker.perform_in</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">perform_in</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">int</span> <span class="o">=</span> <span class="n">interval</span><span class="p">.</span><span class="nf">to_f</span>
  <span class="n">now</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span>
  <span class="n">ts</span> <span class="o">=</span> <span class="p">(</span><span class="n">int</span> <span class="o">&lt;</span> <span class="mi">1_000_000_000</span> <span class="p">?</span> <span class="n">now</span> <span class="o">+</span> <span class="n">int</span> <span class="p">:</span> <span class="n">int</span><span class="p">)</span>
  <span class="n">item</span> <span class="o">=</span> <span class="p">{</span> <span class="s1">'class'</span><span class="p">.</span><span class="nf">freeze</span> <span class="o">=&gt;</span> <span class="nb">self</span><span class="p">,</span> <span class="s1">'args'</span><span class="p">.</span><span class="nf">freeze</span> <span class="o">=&gt;</span> <span class="n">args</span><span class="p">,</span> <span class="s1">'at'</span><span class="p">.</span><span class="nf">freeze</span> <span class="o">=&gt;</span> <span class="n">ts</span> <span class="p">}</span>
  <span class="n">item</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="s1">'at'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">)</span> <span class="k">if</span> <span class="n">ts</span> <span class="o">&lt;=</span> <span class="n">now</span>
  <span class="n">client_push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="k">end</span>
<span class="kp">alias_method</span> <span class="ss">:perform_at</span><span class="p">,</span> <span class="ss">:perform_in</span>
</code></pre></div></div>

<p>为了使用同一个接口支持两种不同的安排方式（时间点和多久之后），方法内部对传入的 <code class="highlighter-rouge">internal</code> 进行了判断，当 <code class="highlighter-rouge">interval.to_f &lt; 1_000_000_000</code> 时就会在一段时间之后执行任务，否则就会以时间点的方式执行任务，虽然 <code class="highlighter-rouge">Worker.perform_at</code> 和 <code class="highlighter-rouge">Worker.perform_in</code> 是完全相同的方法，不过我们在使用时还是尽量遵循方法的语义选择两者中更符合逻辑的方法。</p>

<p><img src="https://img.draveness.me/2017-08-28-Client-Push-Item.jpg-1000width" alt="Client-Push-Item" /></p>

<p>两种创建异步任务的方式，最终都执行了 <code class="highlighter-rouge">Worker.client_push</code> 方法并传入了一个哈希，其中可能包含以上三个部分的内容；在方法的实现中，它获取了上下文中的 Redis 池并将传入的 <code class="highlighter-rouge">item</code> 对象传入 Redis 中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">client_push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
  <span class="n">pool</span> <span class="o">=</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">[</span><span class="ss">:sidekiq_via_pool</span><span class="p">]</span> <span class="o">||</span> <span class="n">get_sidekiq_options</span><span class="p">[</span><span class="s1">'pool'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span> <span class="o">||</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">redis_pool</span>
  <span class="n">item</span><span class="p">.</span><span class="nf">keys</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="o">|</span>
    <span class="n">item</span><span class="p">[</span><span class="n">key</span><span class="p">.</span><span class="nf">to_s</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Client</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">pool</span><span class="p">).</span><span class="nf">push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>简单整理一下，从 <code class="highlighter-rouge">Worker.perform_async</code> 方法到 <code class="highlighter-rouge">Client#push</code> 方法整个过程都在对即将加入到 Redis 中队列的哈希进行操作，从添加 <code class="highlighter-rouge">at</code> 字段到字符串化、再到 <code class="highlighter-rouge">Client#normalize_item</code> 方法中添加 <code class="highlighter-rouge">jid</code> 和 <code class="highlighter-rouge">created_at</code> 字段。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">push</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
  <span class="n">normed</span> <span class="o">=</span> <span class="n">normalize_item</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
  <span class="n">payload</span> <span class="o">=</span> <span class="n">process_single</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="s1">'class'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">],</span> <span class="n">normed</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">payload</span>
    <span class="n">raw_push</span><span class="p">([</span><span class="n">payload</span><span class="p">])</span>
    <span class="n">payload</span><span class="p">[</span><span class="s1">'jid'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>所有添加异步任务的方法最终都调用了私有方法 <code class="highlighter-rouge">Client#raw_push</code> 以及 <code class="highlighter-rouge">Client#atomic_push</code> 向 Redis 中添加数据，在这时会有两种不同的情况发生，当异步任务需要在未来的某一时间点进行安排时，它会加入 Redis 的一个有序集合：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">atomc_push</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">payloads</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">payloads</span><span class="p">.</span><span class="nf">first</span><span class="p">[</span><span class="s1">'at'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
    <span class="n">conn</span><span class="p">.</span><span class="nf">zadd</span><span class="p">(</span><span class="s1">'schedule'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">,</span> <span class="n">payloads</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="nb">hash</span><span class="o">|</span>
                <span class="n">at</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="s1">'at'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">).</span><span class="nf">to_s</span>
                <span class="p">[</span><span class="n">at</span><span class="p">,</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">dump_json</span><span class="p">(</span><span class="nb">hash</span><span class="p">)]</span>
              <span class="k">end</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个有序集合中，Sidekiq 理所应当地将 <code class="highlighter-rouge">schedule</code> 作为权重，而其他的全部字段都以 JSON 的格式作为负载传入；但是当 Sidekiq 遇到需要立即执行的异步任务时，实现就有一些不同了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">atomc_push</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">payloads</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">payloads</span><span class="p">.</span><span class="nf">first</span><span class="p">[</span><span class="s1">'at'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
  <span class="c1"># ...</span>
  <span class="k">else</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">payloads</span><span class="p">.</span><span class="nf">first</span><span class="p">[</span><span class="s1">'queue'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
    <span class="n">now</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span>
    <span class="n">to_push</span> <span class="o">=</span> <span class="n">payloads</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">entry</span><span class="o">|</span>
      <span class="n">entry</span><span class="p">[</span><span class="s1">'enqueued_at'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span> <span class="o">=</span> <span class="n">now</span>
      <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">dump_json</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="n">conn</span><span class="p">.</span><span class="nf">sadd</span><span class="p">(</span><span class="s1">'queues'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>
    <span class="n">conn</span><span class="p">.</span><span class="nf">lpush</span><span class="p">(</span><span class="s2">"queue:</span><span class="si">#{</span><span class="n">q</span><span class="si">}</span><span class="s2">"</span><span class="p">,</span> <span class="n">to_push</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>除了设置当前任务的入队时间 <code class="highlighter-rouge">enqueued_at</code> 之外，Sidekiq 将队列加入到一个大队列 <code class="highlighter-rouge">queues</code> 的集合中，并且将负载直接推到 <code class="highlighter-rouge">"queue:#{q}"</code> 数组中等待消费者的拉取，我们稍微梳理一下两种安排异步队列方法的调用过程：</p>

<p><img src="https://img.draveness.me/2017-08-28-Async-Schedule.jpg-1000width" alt="Async-Schedule" /></p>

<h3 id="redis-中的存储">Redis 中的存储</h3>

<p>无论是立即执行还是需要安排的异步任务都会进入 Redis 的队列中，但是它们之间还是有一些区别的，<code class="highlighter-rouge">Worker.perform_in/at</code> 会将任务以 <code class="highlighter-rouge">[at, args]</code> 的形式加入到 <code class="highlighter-rouge">schedules</code> 有序集中，而
<code class="highlighter-rouge">Worker.perform_async</code> 将负载加入到指定的队列，并向整个 Sidekiq 的队列集合 <code class="highlighter-rouge">queues</code> 中添加该队列。</p>

<p><img src="https://img.draveness.me/2017-08-28-Perform-async-in-Redis.jpg-1000width" alt="Perform-async-in-Redis" /></p>

<p>所有的 <code class="highlighter-rouge">payload</code> 中都包含了一个异步任务需要执行的全部信息，包括该任务的执行的队列 <code class="highlighter-rouge">queue</code>、异步队列的类 <code class="highlighter-rouge">class</code>、参数 <code class="highlighter-rouge">args</code> 以及 <code class="highlighter-rouge">sidekiq_options</code> 中的全部参数。</p>

<p><img src="https://img.draveness.me/2017-08-28-Job-in-Redis.jpg-1000width" alt="Job-in-Redis" /></p>

<p>除了上述参数，一个异步任务还包含诸如 <code class="highlighter-rouge">created_at</code>、<code class="highlighter-rouge">enqueued_at</code> 等信息，也有一个通过 <code class="highlighter-rouge">SecureRandom.hex(12)</code> 生成的任务唯一标识符 <code class="highlighter-rouge">jid</code>。</p>

<h2 id="sidekiq-的启动过程">Sidekiq 的启动过程</h2>

<p>作者对于 Sidekiq 印象最深刻的就是它在命令行启动的时候输出的一个字符画，我们能在 <code class="highlighter-rouge">cli.rb</code> 的 <code class="highlighter-rouge">Cli.banner</code> 方法中找到这个字符画：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>         m,
         `$b
    .ss,  $$:         .,d$
    `$$P,d$P'    .,md$P"'
     ,$$$$$bmmd$$$P^'
   .d$$$$$$$$$$P'
   $$^' `"^$$$'       ____  _     _      _    _
   $:     ,$$:       / ___|(_) __| | ___| | _(_) __ _
   `b     :$$        \___ \| |/ _` |/ _ \ |/ / |/ _` |
          $$:         ___) | | (_| |  __/   &lt;| | (_| |
          $$         |____/|_|\__,_|\___|_|\_\_|\__, |
        .d$$                                       |_|
</code></pre></div></div>

<p>这一节也将介绍 Sidekiq 的启动过程，在 <code class="highlighter-rouge">bin</code> 文件夹中的 sidekiq 文件包含的内容就是在命令行执行 <code class="highlighter-rouge">sidekiq</code> 时执行的代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">begin</span>
  <span class="n">cli</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="o">::</span><span class="no">CLI</span><span class="p">.</span><span class="nf">instance</span>
  <span class="n">cli</span><span class="p">.</span><span class="nf">parse</span>
  <span class="n">cli</span><span class="p">.</span><span class="nf">run</span>
<span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这里的代码就是创建了一个 <code class="highlighter-rouge">CLI</code> 对象，执行 <code class="highlighter-rouge">CLI#parse</code> 方法对参数进行解析，最后调用 <code class="highlighter-rouge">CLI#run</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run</span>
  <span class="n">print_banner</span>

  <span class="n">self_read</span><span class="p">,</span> <span class="n">self_write</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">pipe</span>
  <span class="c1"># ...</span>

  <span class="n">launcher</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Launcher</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
  <span class="k">begin</span>
    <span class="n">launcher</span><span class="p">.</span><span class="nf">run</span>
    <span class="k">while</span> <span class="n">readable_io</span> <span class="o">=</span> <span class="no">IO</span><span class="p">.</span><span class="nf">select</span><span class="p">([</span><span class="n">self_read</span><span class="p">])</span>
      <span class="n">signal</span> <span class="o">=</span> <span class="n">readable_io</span><span class="p">.</span><span class="nf">first</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nf">gets</span><span class="p">.</span><span class="nf">strip</span>
      <span class="n">handle_signal</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="no">Interrupt</span>
    <span class="n">launcher</span><span class="p">.</span><span class="nf">stop</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="从-launcher-到-manager">从 Launcher 到 Manager</h3>

<p><code class="highlighter-rouge">CLI#run</code> 在执行最开始就会打印 banner，也就是我们在每次启动 Sidekiq 时看到的字符画，而在之后会执行 <code class="highlighter-rouge">Launcher#run</code> 运行用于处理异步任务的 <code class="highlighter-rouge">Processor</code> 等对象。</p>

<p><img src="https://img.draveness.me/2017-08-28-Launcher-Poller-Manager-Processors.jpg-1000width" alt="Launcher-Poller-Manager-Processors" /></p>

<p>每一个 <code class="highlighter-rouge">Launcher</code> 都会启动一个 <code class="highlighter-rouge">Manager</code> 对象和一个 <code class="highlighter-rouge">Poller</code>，其中 <code class="highlighter-rouge">Manager</code> 同时管理了多个 <code class="highlighter-rouge">Processor</code> 对象，这些不同的类之间有着如上图所示的关系。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run</span>
  <span class="vi">@thread</span> <span class="o">=</span> <span class="n">safe_thread</span><span class="p">(</span><span class="s2">"heartbeat"</span><span class="p">,</span> <span class="o">&amp;</span><span class="nb">method</span><span class="p">(</span><span class="ss">:start_heartbeat</span><span class="p">))</span>
  <span class="vi">@poller</span><span class="p">.</span><span class="nf">start</span>
  <span class="vi">@manager</span><span class="p">.</span><span class="nf">start</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Manager</code> 会在初始化时根据传入的 <code class="highlighter-rouge">concurrency</code> 的值创建对应数量的 <code class="highlighter-rouge">Processor</code>，默认的并行数量为 25；当执行 <code class="highlighter-rouge">Manager#start</code> 时，就会启动对应数量的<strong>线程</strong>和处理器开始对任务进行处理：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Manager</span>
  <span class="k">def</span> <span class="nf">start</span>
    <span class="vi">@workers</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
      <span class="n">x</span><span class="p">.</span><span class="nf">start</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Processor</span>
  <span class="k">def</span> <span class="nf">start</span>
    <span class="vi">@thread</span> <span class="o">||=</span> <span class="n">safe_thread</span><span class="p">(</span><span class="s2">"processor"</span><span class="p">,</span> <span class="o">&amp;</span><span class="nb">method</span><span class="p">(</span><span class="ss">:run</span><span class="p">))</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>从 <code class="highlighter-rouge">Launcher</code> 的启动到现在只是一个调用 <code class="highlighter-rouge">initialize</code> 和 <code class="highlighter-rouge">start</code> 方法的过程，再加上 Sidekiq 源代码非常简单，所以阅读起没有丝毫的难度，也就不做太多的解释了。</p>

<h3 id="并行模型">并行模型</h3>

<p>当处理器开始执行 <code class="highlighter-rouge">Processor#run</code> 方法时，就开始对所有的任务进行处理了；从总体来看，Sidekiq 使用了多线程的模型对任务进行处理，每一个 <code class="highlighter-rouge">Processor</code> 都是使用了 <code class="highlighter-rouge">safe_thread</code> 方法在一个新的线程里面运行的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">safe_thread</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="no">Thread</span><span class="p">.</span><span class="nf">new</span> <span class="k">do</span>
    <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">[</span><span class="s1">'sidekiq_label'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span> <span class="o">=</span> <span class="nb">name</span>
    <span class="n">watchdog</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在使用 Sidekiq 时，我们也会在不同的机器上开启多个 Sidekiq Worker，也就是说 Sidekiq 可以以多进程、多线程的方式运行，同时处理大量的异步任务。</p>

<p><img src="https://img.draveness.me/2017-08-28-Sidekiq-Multi-Processes.jpg-1000width" alt="Sidekiq-Multi-Processes" /></p>

<p>到目前为止，我们已经分析了异步任务的入队以及 Sidekiq Worker 的启动过程了，接下来即将分析 Sidekiq 对异步任务的处理过程。</p>

<h3 id="主题的订阅">『主题』的订阅</h3>

<p>作为一个 Sidekiq Worker 进程，它在启动时就会决定选择订阅哪些『主题』去执行，比如当我们使用下面的命令时：</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> sidekiq <span class="nt">-q</span> critical,2 <span class="nt">-q</span> default
</code></pre></div></div>

<p><code class="highlighter-rouge">CLI#parse</code> 方法会对传入的 <code class="highlighter-rouge">-q</code> 参数进行解析，但是当执行 <code class="highlighter-rouge">sidekiq</code> 命令却没有传入队列参数时，Sidekiq 只会订阅 <code class="highlighter-rouge">default</code> 队列中的任务：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="no">ARGV</span><span class="p">)</span>
  <span class="c1"># ...</span>
  <span class="n">validate!</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">validate!</span>
  <span class="n">options</span><span class="p">[</span><span class="ss">:queues</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s1">'default'</span> <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="ss">:queues</span><span class="p">].</span><span class="nf">empty?</span>
<span class="k">end</span>
</code></pre></div></div>

<p>同时，默认情况下的队列的优先级都为 <code class="highlighter-rouge">1</code>，高优先级的队列在当前的任务中可以得到更多的执行机会，实现的方法是通过增加同一个 <code class="highlighter-rouge">queues</code> 集合中高优先级队列的数量，我们可以在 <code class="highlighter-rouge">CLI#parse_queue</code> 中找到实现这一功能的代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">parse_queue</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kp">nil</span><span class="p">)</span>
  <span class="p">[</span><span class="n">weight</span><span class="p">.</span><span class="nf">to_i</span><span class="p">,</span> <span class="mi">1</span><span class="p">].</span><span class="nf">max</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
    <span class="p">(</span><span class="n">opts</span><span class="p">[</span><span class="ss">:queues</span><span class="p">]</span> <span class="o">||=</span> <span class="p">[])</span> <span class="o">&lt;&lt;</span> <span class="n">q</span>
  <span class="k">end</span>
  <span class="n">opts</span><span class="p">[</span><span class="ss">:strict</span><span class="p">]</span> <span class="o">=</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">weight</span><span class="p">.</span><span class="nf">to_i</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="k">end</span>
</code></pre></div></div>

<p>到这里，其实我们就完成了设置过程中 Sidekiq Worker 『主题』订阅的功能了，我们将在后面 <a href="#执行任务">执行任务</a> 的部分具体介绍 Sidekiq 是如何使用这些参数的。</p>

<h2 id="异步任务的处理">异步任务的处理</h2>

<p>从异步任务的入队一节中，我们可以清楚地看到使用 <code class="highlighter-rouge">#perform_async</code> 和 <code class="highlighter-rouge">#perform_in</code> 两种方法创建的数据结构 <code class="highlighter-rouge">payload</code> 最终以不同的方式进入了 Redis 中，所以在这里我们将异步任务的处理分为定时任务和『立即』任务两个部分，分别对它们不同的处理方式进行分析。</p>

<h3 id="定时任务">定时任务</h3>

<p>Sidekiq 使用 <code class="highlighter-rouge">Scheduled::Poller</code> 对 Redis 中 <code class="highlighter-rouge">schedules</code> 有序集合中的负载进行处理，其中包括 <code class="highlighter-rouge">retry</code> 和 <code class="highlighter-rouge">schedule</code> 两个有序集合中的内容。</p>

<p><img src="https://img.draveness.me/2017-08-28-Redis-Sorted-Set.jpg-1000width" alt="Redis-Sorted-Set" /></p>

<p>在 <code class="highlighter-rouge">Poller</code> 被 <code class="highlighter-rouge">Scheduled::Poller</code> 启动时会调用 <code class="highlighter-rouge">#start</code> 方法开始对上述两个有序集合轮训，<code class="highlighter-rouge">retry</code> 中包含了所有重试的任务，而 <code class="highlighter-rouge">schedule</code> 就是被安排到指定时间执行的定时任务了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">start</span>
  <span class="vi">@thread</span> <span class="o">||=</span> <span class="n">safe_thread</span><span class="p">(</span><span class="s2">"scheduler"</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">initial_wait</span>
    <span class="k">while</span> <span class="o">!</span><span class="vi">@done</span>
      <span class="n">enqueue</span>
      <span class="n">wait</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Scheduled::Poller#start</code> 方法内部执行了一个 <code class="highlighter-rouge">while</code> 循环，在循环内部也只包含入队和等待两个操作，用于入队的方法最终调用了 <code class="highlighter-rouge">Scheduled::Poll::Enq#enqueue_jobs</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">enqueue_jobs</span><span class="p">(</span><span class="n">now</span><span class="o">=</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span><span class="p">.</span><span class="nf">to_s</span><span class="p">,</span> <span class="n">sorted_sets</span><span class="o">=</span><span class="no">SETS</span><span class="p">)</span>
  <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">redis</span> <span class="k">do</span> <span class="o">|</span><span class="n">conn</span><span class="o">|</span>
    <span class="n">sorted_sets</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">sorted_set</span><span class="o">|</span>
      <span class="k">while</span> <span class="n">job</span> <span class="o">=</span> <span class="n">conn</span><span class="p">.</span><span class="nf">zrangebyscore</span><span class="p">(</span><span class="n">sorted_set</span><span class="p">,</span> <span class="s1">'-inf'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">,</span> <span class="n">now</span><span class="p">,</span> <span class="ss">:limit</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]).</span><span class="nf">first</span> <span class="k">do</span>
        <span class="k">if</span> <span class="n">conn</span><span class="p">.</span><span class="nf">zrem</span><span class="p">(</span><span class="n">sorted_set</span><span class="p">,</span> <span class="n">job</span><span class="p">)</span>
          <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Client</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="no">Sidekiq</span><span class="p">.</span><span class="nf">load_json</span><span class="p">(</span><span class="n">job</span><span class="p">))</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>传入的 <code class="highlighter-rouge">SETS</code> 其实就是 <code class="highlighter-rouge">retry</code> 和 <code class="highlighter-rouge">schedule</code> 构成的数组，在上述方法中，Sidekiq 通过一个 <code class="highlighter-rouge">Redis#zrangebyscore</code> 和 <code class="highlighter-rouge">Redis#zrem</code> 将集合中小于当前时间的任务全部加到立即任务中，最终调用是在前面已经提到过的 <code class="highlighter-rouge">Client#push</code> 方法将任务推到指定的队列中。</p>

<p><img src="https://img.draveness.me/2017-08-28-Redis-Sidekiq-Poller.jpg-1000width" alt="Redis-Sidekiq-Poller" /></p>

<p>由于 <code class="highlighter-rouge">Scheduled::Poller</code> 并不是不停地对 Redis 中的数据进行处理的，因为当前进程一直都在执行 <code class="highlighter-rouge">Poller#enqueue</code> 其实是一个非常低效的方式，所以 Sidekiq 会在每次执行 <code class="highlighter-rouge">Poller#enqueue</code> 之后，执行 <code class="highlighter-rouge">Poller#wait</code> 方法，随机等待一段时间：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">wait</span>
  <span class="vi">@sleeper</span><span class="p">.</span><span class="nf">pop</span><span class="p">(</span><span class="n">random_poll_interval</span><span class="p">)</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">random_poll_interval</span>
  <span class="n">poll_interval_average</span> <span class="o">*</span> <span class="nb">rand</span> <span class="o">+</span> <span class="n">poll_interval_average</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">/</span> <span class="mi">2</span>
<span class="k">end</span>
</code></pre></div></div>

<p>随机等待时间的范围在 <code class="highlighter-rouge">[0.5 * poll_interval_average, 1.5 * poll_interval_average]</code> 之间；通过随机的方式，Sidekiq 可以避免在多个线程处理任务时，短时间内 Redis 接受大量的请求发生延迟等问题，能够保证从长期来看 Redis 接受的请求数是平均的；同时因为 <code class="highlighter-rouge">Scheduled::Poller</code> 使用了 <code class="highlighter-rouge">#enqueue</code> 加 <code class="highlighter-rouge">#wait</code> 对 Redis 中的数据进行消费，所以没有办法保证任务会在指定的时间点执行，<strong>执行的时间一定比安排的时间要晚</strong>，这也是我们在使用 Sidekiq 时需要注意的。</p>

<blockquote>
  <p>随机等待的时间其实不止与 <code class="highlighter-rouge">poll_interval_average</code> 有关，在默认情况下，它是当前进程数的 15 倍，在有 30 个 Sidekiq 线程时，每个线程会每隔 225 ~ 675s 的时间请求一次。</p>
</blockquote>

<h3 id="执行任务">执行任务</h3>

<p>定时任务是由 <code class="highlighter-rouge">Scheduled::Poller</code> 进行处理的，将其中需要执行的异步任务加入到指定的队列中，而这些任务最终都会在 <code class="highlighter-rouge">Processor#run</code> 真正被执行：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">run</span>
  <span class="k">begin</span>
    <span class="k">while</span> <span class="o">!</span><span class="vi">@done</span>
      <span class="n">process_one</span>
    <span class="k">end</span>
    <span class="vi">@mgr</span><span class="p">.</span><span class="nf">processor_stopped</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
  <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">ex</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当处理结束或者发生异常时会调用 <code class="highlighter-rouge">Manager#processor_stopped</code> 或者 <code class="highlighter-rouge">Manager#processor_died</code> 方法对 <code class="highlighter-rouge">Processor</code> 进行处理；在处理任务时其实也分为两个部分，也就是 <code class="highlighter-rouge">#fetch</code> 和 <code class="highlighter-rouge">#process</code> 两个方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">process_one</span>
  <span class="vi">@job</span> <span class="o">=</span> <span class="n">fetch</span>
  <span class="n">process</span><span class="p">(</span><span class="vi">@job</span><span class="p">)</span> <span class="k">if</span> <span class="vi">@job</span>
  <span class="vi">@job</span> <span class="o">=</span> <span class="kp">nil</span>
<span class="k">end</span>
</code></pre></div></div>

<p>我们先来看一下整个方法的调用栈，任务的获取从 <code class="highlighter-rouge">Processor#process_one</code> 一路调用下来，直到 <code class="highlighter-rouge">BasicFetch#retrive_work</code> 返回了 <code class="highlighter-rouge">UnitOfWork</code> 对象，返回的对象会经过分发最后执行对应类的 <code class="highlighter-rouge">#perform</code> 传入参数真正运行该任务：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Processor#process_one
├── Processor#fetch
│   └── Processor#get_one
│       └── BasicFetch#retrive_work
│           ├── Redis#brpop
│           └── UnitOfWork#new
└── Processor#process
    ├── Processor#dispatch
    ├── Processor#execute_job
    └── Worker#perform
</code></pre></div></div>

<p>对于任务的获取，我们需要关注的就是 <code class="highlighter-rouge">BasicFetch#retrive_work</code> 方法，他会从 Redis 中相应队列的有序数组中 <code class="highlighter-rouge">Redis#brpop</code> 出一个任务，然后封装成 <code class="highlighter-rouge">UnitOfWork</code> 对象后返回。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">retrieve_work</span>
  <span class="n">work</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">redis</span> <span class="p">{</span> <span class="o">|</span><span class="n">conn</span><span class="o">|</span> <span class="n">conn</span><span class="p">.</span><span class="nf">brpop</span><span class="p">(</span><span class="o">*</span><span class="n">queues_cmd</span><span class="p">)</span> <span class="p">}</span>
  <span class="no">UnitOfWork</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="o">*</span><span class="n">work</span><span class="p">)</span> <span class="k">if</span> <span class="n">work</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">#queues_cmd</code> 这个实例方法其实就用到了在主题的订阅一节中的 <code class="highlighter-rouge">queues</code> 参数，该参数会在 <code class="highlighter-rouge">Processor</code> 初始化是创建一个 <code class="highlighter-rouge">BasicFetch</code> 策略对象，最终在 <code class="highlighter-rouge">BasicFetch#queues_cmd</code> 方法调用时返回一个类似下面的数组：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">queue</span><span class="ss">:high</span>
<span class="n">queue</span><span class="ss">:high</span>
<span class="n">queue</span><span class="ss">:high</span>
<span class="n">queue</span><span class="ss">:low</span>
<span class="n">queue</span><span class="ss">:low</span>
<span class="n">queue</span><span class="ss">:default</span>
</code></pre></div></div>

<p>这样就可以实现了队列的优先级这一个功能了，返回的 <code class="highlighter-rouge">UnitOfWork</code> 其实是一个通过 <code class="highlighter-rouge">Struct.new</code> 创建的结构体，它会在 <code class="highlighter-rouge">Processor#process</code> 方法中作为资源被处理：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">work</span><span class="p">)</span>
  <span class="n">jobstr</span> <span class="o">=</span> <span class="n">work</span><span class="p">.</span><span class="nf">job</span>
  <span class="n">queue</span> <span class="o">=</span> <span class="n">work</span><span class="p">.</span><span class="nf">queue_name</span>

  <span class="k">begin</span>
    <span class="c1"># ...</span>

    <span class="n">job_hash</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">load_json</span><span class="p">(</span><span class="n">jobstr</span><span class="p">)</span>
    <span class="n">dispatch</span><span class="p">(</span><span class="n">job_hash</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">worker</span><span class="o">|</span>
      <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">server_middleware</span><span class="p">.</span><span class="nf">invoke</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">job_hash</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="k">do</span>
        <span class="n">execute_job</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">cloned</span><span class="p">(</span><span class="n">job_hash</span><span class="p">[</span><span class="s1">'args'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]))</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">ex</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>该方法对任务的执行其实总共有四个步骤：</p>

<ol>
  <li>将 Redis 中存储的字符串加载为 JSON；</li>
  <li>执行 <code class="highlighter-rouge">Processor#dispatch</code> 方法并在内部提供方法重试等功能，同时也实例化一个 <code class="highlighter-rouge">Sidekiq::Worker</code> 对象；</li>
  <li>依次执行服务端的中间件，可能会对参数进行更新；</li>
  <li>调用 <code class="highlighter-rouge">Processor#execute_job</code> 方法执行任务；</li>
</ol>

<p>而最后调用的时用于执行任务的方法 <code class="highlighter-rouge">Processor#execute_job</code>，它的实现也是到目前为止最为简单的方法之一了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">execute_job</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">cloned_args</span><span class="p">)</span>
  <span class="n">worker</span><span class="p">.</span><span class="nf">perform</span><span class="p">(</span><span class="o">*</span><span class="n">cloned_args</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>该方法在<strong>线程</strong>中执行了客户端创建的 <code class="highlighter-rouge">Worker</code> 类的实例方法 <code class="highlighter-rouge">#perform</code> 并传入了经过两侧中间件处理后的参数。</p>

<h3 id="小结">小结</h3>

<p>到目前为止，Sidekiq Worker 对任务的消费过程就是圆满的了，从客户端创建一个拥有 <code class="highlighter-rouge">#perform</code> 方法的 <code class="highlighter-rouge">Worker</code> 到消费者去执行该方法形成了一个闭环，完成了对任务的调度。</p>

<p><img src="https://img.draveness.me/2017-08-28-Client-Redis-Sidekiq-Worker.jpg-1000width" alt="Client-Redis-Sidekiq-Worker" /></p>

<p>Sidekiq 是一个非常轻量级的任务调度系统，它使用 Redis 作为整个系统的消息队列，在两侧分别建立了生产者和消费者的模块，不过除了这几个比较重要的模块，Sidekiq 中还有一些功能是我们无法忽略的，比如中间件、兼容 ActiveJob 甚至是测试的实现，都是我们需要去了解的；接下来，我们将介绍和分析主干之外的『分叉』功能。</p>

<h2 id="中间件">中间件</h2>

<p>中间件模块是 Sidekiq 为我们在整个任务的处理流程提供的两个钩子，一个是在客户端的钩子，另一个在 Sidekiq Worker 中。</p>

<p><img src="https://img.draveness.me/2017-08-28-Middlewares-Client-Redis-Sidekiq-Worker.jpg-1000width" alt="Middlewares-Client-Redis-Sidekiq-Worker" /></p>

<p>中间件的使用其实非常简单，我们默认所有的中间件都会拥有一个实例方法 <code class="highlighter-rouge">#call</code> 并接受 <code class="highlighter-rouge">worker</code>、<code class="highlighter-rouge">job</code> 和 <code class="highlighter-rouge">queue</code> 三个参数，在使用时也只需要直接调用 <code class="highlighter-rouge">Chain#add</code> 方法将其加入数组就可以了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AcmeCo</span><span class="o">::</span><span class="no">MyMiddleware</span>
  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># config/initializers/sidekiq.rb</span>
<span class="no">Sidekiq</span><span class="p">.</span><span class="nf">configure_server</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">server_middleware</span> <span class="k">do</span> <span class="o">|</span><span class="n">chain</span><span class="o">|</span>
    <span class="n">chain</span><span class="p">.</span><span class="nf">add</span> <span class="no">AcmeCo</span><span class="o">::</span><span class="no">MyMiddleware</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Sidekiq 将中间件分为了客户端和服务端两个部分，这两个部分的中间件其实并不是严格意义上的在执行之前，由于执行时间点的不同，导致它们有不同的功能：</p>

<ul>
  <li>服务端中间件是『包围』了任务执行过程的，我们可以在中间件中使用 <code class="highlighter-rouge">begin</code>、<code class="highlighter-rouge">rescue</code> 语句，这样当任务出现问题时，我们就可以拿到异常了；</li>
  <li>客户端中间件在任务即将被推入 Redis 之前运行，它能够阻止任务进入 Redis 并且允许我们在任务入队前对其进行修改和停止；</li>
</ul>

<p>当我们对 Sidekiq 中间的使用都有一定的了解时，就可以开始分析中间件的实现了。</p>

<h3 id="实现">实现</h3>

<p>无论是异步任务真正进入队列之前，还是在客户端处理，跟任务有关的信息都会先通过一个预处理流程，客户端和服务端两个中间件的链式调用都使用 <code class="highlighter-rouge">Middleware::Chain</code> 中的类进行处理的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Chain</span>
  <span class="kp">include</span> <span class="no">Enumerable</span>
  <span class="nb">attr_reader</span> <span class="ss">:entries</span>

  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="vi">@entries</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">yield</span> <span class="nb">self</span> <span class="k">if</span> <span class="nb">block_given?</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="n">klass</span><span class="p">);</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">prepend</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">insert_before</span><span class="p">(</span><span class="n">oldklass</span><span class="p">,</span> <span class="n">newklass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span> <span class="k">end</span>
  <span class="k">def</span> <span class="nf">insert_after</span><span class="p">(</span><span class="n">oldklass</span><span class="p">,</span> <span class="n">newklass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">);</span> <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>每一个 <code class="highlighter-rouge">Middleware::Chain</code> 中都包含一系列的 <code class="highlighter-rouge">Entry</code>，其中存储了中间件的相关信息，无论是客户端还是服务端都会在执行之前对每一个异步任务的参数执行 <code class="highlighter-rouge">invoke</code> 方法调用 <code class="highlighter-rouge">Middleware::Chain</code> 对象中的所有中间件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">invoke</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">chain</span> <span class="o">=</span> <span class="n">retrieve</span><span class="p">.</span><span class="nf">dup</span>
  <span class="n">traverse_chain</span> <span class="o">=</span> <span class="nb">lambda</span> <span class="k">do</span>
    <span class="k">if</span> <span class="n">chain</span><span class="p">.</span><span class="nf">empty?</span>
      <span class="k">yield</span>
    <span class="k">else</span>
      <span class="n">chain</span><span class="p">.</span><span class="nf">shift</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">traverse_chain</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="n">traverse_chain</span><span class="p">.</span><span class="nf">call</span>
<span class="k">end</span>

</code></pre></div></div>

<p><code class="highlighter-rouge">Chain#invoke</code> 会对其持有的每一个中间件都执行 <code class="highlighter-rouge">#call</code> 方法，中间件都可以对异步任务的参数进行改变或者进行一些记录日志等操作，最后执行传入的 block 并返回结果。</p>

<p><img src="https://img.draveness.me/2017-08-28-Sidekiq-Middlewares.jpg-1000width" alt="Sidekiq-Middlewares" /></p>

<p>当异步队列入队时，就会执行 <code class="highlighter-rouge">Client#process_single</code> 方法调用 Sidekiq 载入中的全部中间件最后返回新的 <code class="highlighter-rouge">item</code> 对象：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">process_single</span><span class="p">(</span><span class="n">worker_class</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
  <span class="n">queue</span> <span class="o">=</span> <span class="n">item</span><span class="p">[</span><span class="s1">'queue'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
  <span class="n">middleware</span><span class="p">.</span><span class="nf">invoke</span><span class="p">(</span><span class="n">worker_class</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="vi">@redis_pool</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">item</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>每一个 Sidekiq Worker 在处理中间件时也基本遵循相同的逻辑，如 <code class="highlighter-rouge">#process</code> 方法先先执行各种中间件，最后再运行 block 中的内容。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">work</span><span class="p">)</span>
  <span class="n">jobstr</span> <span class="o">=</span> <span class="n">work</span><span class="p">.</span><span class="nf">job</span>
  <span class="n">queue</span> <span class="o">=</span> <span class="n">work</span><span class="p">.</span><span class="nf">queue_name</span>

  <span class="k">begin</span>
    <span class="c1"># ...</span>

    <span class="n">job_hash</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">load_json</span><span class="p">(</span><span class="n">jobstr</span><span class="p">)</span>
    <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">server_middleware</span><span class="p">.</span><span class="nf">invoke</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">job_hash</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">execute_job</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">cloned</span><span class="p">(</span><span class="n">job_hash</span><span class="p">[</span><span class="s1">'args'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]))</span>
    <span class="k">end</span>
  <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">ex</span>
    <span class="c1"># ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">#execute_job</code> 方法执行期间，由于异步任务可能抛出异常，在这时，我们注册的中间件就可以根据情况对异常进行捕获并选择是否对异常进行处理或者抛给上层了。</p>

<h2 id="任务的重试">任务的重试</h2>

<p>Sidekiq 中任务的重试是由 <code class="highlighter-rouge">JobRetry</code> 负责的，<code class="highlighter-rouge">Prcessor</code> 中的 <code class="highlighter-rouge">#dispatch</code> 方法中调用了 <code class="highlighter-rouge">JobRetry#global</code> 方法捕获在异步任务执行过程中发生的错误：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="n">job_hash</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span>
  <span class="n">pristine</span> <span class="o">=</span> <span class="n">cloned</span><span class="p">(</span><span class="n">job_hash</span><span class="p">)</span>

  <span class="c1"># ...</span>
  <span class="vi">@retrier</span><span class="p">.</span><span class="nf">global</span><span class="p">(</span><span class="n">pristine</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">klass</span>  <span class="o">=</span> <span class="n">constantize</span><span class="p">(</span><span class="n">job_hash</span><span class="p">[</span><span class="s1">'class'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">])</span>
    <span class="n">worker</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">new</span>
    <span class="n">worker</span><span class="p">.</span><span class="nf">jid</span> <span class="o">=</span> <span class="n">job_hash</span><span class="p">[</span><span class="s1">'jid'</span><span class="p">.</span><span class="nf">freeze</span><span class="p">]</span>
    <span class="vi">@retrier</span><span class="p">.</span><span class="nf">local</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">pristine</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span> <span class="k">do</span>
      <span class="k">yield</span> <span class="n">worker</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>任务的执行过程分别调用了两个 <code class="highlighter-rouge">JobRetry</code> 的方法 <code class="highlighter-rouge">#global</code> 和 <code class="highlighter-rouge">#local</code>，这两个方法在实现上差不多，都将执行异步任务的 block 包在了一个 <code class="highlighter-rouge">begin</code>、<code class="highlighter-rouge">rescue</code> 中，选择在合适的时间重试：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">local</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span>
  <span class="k">yield</span>
<span class="c1"># ...</span>
<span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
  <span class="k">raise</span> <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Shutdown</span> <span class="k">if</span> <span class="n">exception_caused_by_shutdown?</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">msg</span><span class="p">[</span><span class="s1">'retry'</span><span class="p">]</span> <span class="o">==</span> <span class="kp">nil</span>
    <span class="n">msg</span><span class="p">[</span><span class="s1">'retry'</span><span class="p">]</span> <span class="o">=</span> <span class="n">worker</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">get_sidekiq_options</span><span class="p">[</span><span class="s1">'retry'</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">raise</span> <span class="n">e</span> <span class="k">unless</span> <span class="n">msg</span><span class="p">[</span><span class="s1">'retry'</span><span class="p">]</span>
  <span class="n">attempt_retry</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
  <span class="k">raise</span> <span class="no">Skip</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果我们在定义 <code class="highlighter-rouge">Worker</code> 时就禁用了重试，那么在这里就会直接抛出上层的异常，否则就会进入 <code class="highlighter-rouge">#attempt_retry</code> 方法安排任务进行重试：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">attempt_retry</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">queue</span><span class="p">,</span> <span class="n">exception</span><span class="p">)</span>
  <span class="n">max_retry_attempts</span> <span class="o">=</span> <span class="n">retry_attempts_from</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="s1">'retry'</span><span class="p">],</span> <span class="vi">@max_retries</span><span class="p">)</span>

  <span class="n">msg</span><span class="p">[</span><span class="s1">'queue'</span><span class="p">]</span> <span class="o">=</span> <span class="k">if</span> <span class="n">msg</span><span class="p">[</span><span class="s1">'retry_queue'</span><span class="p">]</span>
                   <span class="n">msg</span><span class="p">[</span><span class="s1">'retry_queue'</span><span class="p">]</span>
                 <span class="k">else</span>
                   <span class="n">queue</span>
                 <span class="k">end</span>

  <span class="n">count</span> <span class="o">=</span> <span class="k">if</span> <span class="n">msg</span><span class="p">[</span><span class="s1">'retry_count'</span><span class="p">]</span>
            <span class="n">msg</span><span class="p">[</span><span class="s1">'retried_at'</span><span class="p">]</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span>
            <span class="n">msg</span><span class="p">[</span><span class="s1">'retry_count'</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
          <span class="k">else</span>
            <span class="n">msg</span><span class="p">[</span><span class="s1">'failed_at'</span><span class="p">]</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span>
            <span class="n">msg</span><span class="p">[</span><span class="s1">'retry_count'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
          <span class="k">end</span>

  <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">max_retry_attempts</span>
    <span class="n">delay</span> <span class="o">=</span> <span class="n">delay_for</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">exception</span><span class="p">)</span>
    <span class="n">retry_at</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">to_f</span> <span class="o">+</span> <span class="n">delay</span>
    <span class="n">payload</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">dump_json</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">redis</span> <span class="k">do</span> <span class="o">|</span><span class="n">conn</span><span class="o">|</span>
      <span class="n">conn</span><span class="p">.</span><span class="nf">zadd</span><span class="p">(</span><span class="s1">'retry'</span><span class="p">,</span> <span class="n">retry_at</span><span class="p">.</span><span class="nf">to_s</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">else</span>
    <span class="n">retries_exhausted</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">exception</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在上面其实我们提到过，<code class="highlighter-rouge">Poller</code> 每次会从两个有序集合 <code class="highlighter-rouge">retry</code> 和 <code class="highlighter-rouge">schedule</code> 中查找到时的任务加入到对应的队列中，在 <code class="highlighter-rouge">#attempt_retry</code> 方法中，就可以找到看到 <code class="highlighter-rouge">retry</code> 队列中的元素是如何加入的了。</p>

<p>当任务的重试次数超过了限定的重试次数之后，就会执行 <code class="highlighter-rouge">#retries_exhausted</code> 以及 <code class="highlighter-rouge"># send_to_morgue</code> 这一方法，将任务的负载加入 <code class="highlighter-rouge">DeadSet</code> 对象中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">send_to_morgue</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="n">payload</span> <span class="o">=</span> <span class="no">Sidekiq</span><span class="p">.</span><span class="nf">dump_json</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="no">DeadSet</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">kill</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这样整个任务的重试过程就结束了，Sidekiq 使用 <code class="highlighter-rouge">begin</code>、<code class="highlighter-rouge">rescue</code> 捕获整个流程中出现的异常，并根据传入的 <code class="highlighter-rouge">retry_count</code> 参数进行重试，调度过程还是非常简洁也非常容易理解的。</p>

<h2 id="总结">总结</h2>

<p>作为一个 Ruby 社区中广泛被使用的异步任务处理的依赖，它的实现是很简单的并且其源代码非常易于阅读，整体的架构也非常清晰。</p>

<p><img src="https://img.draveness.me/2017-08-28-Middlewares-Client-Redis-Sidekiq-Worker.jpg-1000width" alt="Middlewares-Client-Redis-Sidekiq-Worker" /></p>

<p>使用键值的内存数据库 Redis 作为客户端和 Worker 之间的桥梁，Redis 的使用简化了 Sidekiq 的很多逻辑，同时对中间件的支持也使其有着良好的扩展性，不过正其实现简单，所以例如任务取消以及定时任务这种比较常见的功能其本身都没有实现，有的是 Sidekiq 本身设计问题导致的，有的需要另外的插件，不过在绝大多数情况下，Sidekiq 都能完全满足我们的需要，解决绝大多数的问题。</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="https://github.com/mperham/sidekiq">Sidekiq</a></li>
  <li><a href="https://ruby-china.org/topics/31470">Sidekiq 任务调度流程分析</a></li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>
