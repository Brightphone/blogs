<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>Redis 和 I/O 多路复用</title>
    <meta name="description" content="A beautiful narrative written with the world's most elegant publishing platform. The story begins here." />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/blogs/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/blogs/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/blogs/assets/css/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="/blogs//redis-io-multiplexing" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/blogs/page2/" />

    <meta property="og:site_name" content="Brightness" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Redis 和 I/O 多路复用" />
    <meta property="og:description" content="A beautiful narrative written with the world's most elegant publishing platform. The story begins here." />
    <meta property="og:url" content="/blogs//redis-io-multiplexing" />
    <meta property="og:image" content="/blogs/assets/images/cover1.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Redis 和 I/O 多路复用" />
    <meta name="twitter:description" content="A beautiful narrative written with the world's most elegant publishing platform. The story begins here." />
    <meta name="twitter:url" content="/blogs//redis-io-multiplexing" />
    <meta name="twitter:image:src" content="/blogs/assets/images/cover1.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "Brightness",
    "name": "Redis 和 I/O 多路复用",
    "url": "/blogs//redis-io-multiplexing",
    "image": "/blogs/assets/images/cover1.jpg",
    "description": "A beautiful narrative written with the world's most elegant publishing platform. The story begins here."
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="Brightness" href="/blogs/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/blogs/">Home</a></li>
        <li class="nav-about " role="presentation"><a href="/blogs/about">About</a></li>
        <li class="nav-fables " role="presentation"><a href="/blogs/tag/fables">Fables</a></li>
        <li class="nav-speeches " role="presentation"><a href="/blogs/tag/speeches">Speeches</a></li>
        <li class="nav-fiction " role="presentation"><a href="/blogs/tag/fiction">Fiction</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/casper">Casper</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/edgar">Edgar</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/abraham">Abraham</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/martin">Martin</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/lewis">Lewis</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/blogs/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        
        
    </nav>
</header>

<main class="content" role="main">

    <article class="">

        <header class="post-header">
            <h1 class="post-title">Redis 和 I/O 多路复用</h1>
            <section class="post-meta">
            <!-- <a href='/blogs/'></a> -->

            
                
            
                
            
                
            
                
            
                
            
            <time class="post-date" datetime="2016-11-26">26 Nov 2016</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/blogs/tag/redis'>Redis</a>,
                    
                
                    
                       <a href='/blogs/tag/server'>Server</a>,
                    
                
                    
                       <a href='/blogs/tag/database'>Database</a>,
                    
                
                    
                       <a href='/blogs/tag/nosql'>Nosql</a>
                    
                
                
            </section>
        </header>

        <section class="post-content">

            <p>最近在看 UNIX 网络编程并研究了一下 Redis 的实现，感觉 Redis 的源代码十分适合阅读和分析，其中 I/O 多路复用（mutiplexing）部分的实现非常干净和优雅，在这里想对这部分的内容进行简单的整理。</p>

<h2 id="几种-io-模型">几种 I/O 模型</h2>

<p>为什么 Redis 中要使用 I/O 多路复用这种技术呢？</p>

<p>首先，Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 <strong>I/O 多路复用</strong>就是为了解决这个问题而出现的。</p>

<h3 id="blocking-io">Blocking I/O</h3>

<p>先来看一下传统的阻塞 I/O 模型到底是如何工作的：当使用 <code class="highlighter-rouge">read</code> 或者 <code class="highlighter-rouge">write</code> 对某一个<strong>文件描述符（File Descriptor 以下简称 FD)</strong>进行读写时，如果当前 FD 不可读或不可写，整个 Redis 服务就不会对其它的操作作出响应，导致整个服务不可用。</p>

<p>这也就是传统意义上的，也就是我们在编程中使用最多的阻塞模型：</p>

<p><img src="https://img.draveness.me/2016-11-26-blocking-io.png-1000width" alt="blocking-io" /></p>

<p>阻塞模型虽然开发中非常常见也非常易于理解，但是由于它会影响其他 FD 对应的服务，所以在需要处理多个客户端任务的时候，往往都不会使用阻塞模型。</p>

<h3 id="io-多路复用">I/O 多路复用</h3>

<blockquote>
  <p>虽然还有很多其它的 I/O 模型，但是在这里都不会具体介绍。</p>
</blockquote>

<p>阻塞式的 I/O 模型并不能满足这里的需求，我们需要一种效率更高的 I/O 模型来支撑 Redis 的多个客户（redis-cli），这里涉及的就是 I/O 多路复用模型了：</p>

<p><img src="https://img.draveness.me/2016-11-26-I:O-Multiplexing-Model.png-1000width" alt="I:O-Multiplexing-Mode" /></p>

<p>在 I/O 多路复用模型中，最重要的函数调用就是 <code class="highlighter-rouge">select</code>，该方法的能够同时监控多个文件描述符的可读可写情况，当其中的某些文件描述符可读或者可写时，<code class="highlighter-rouge">select</code> 方法就会返回可读以及可写的文件描述符个数。</p>

<blockquote>
  <p>关于 <code class="highlighter-rouge">select</code> 的具体使用方法，在网络上资料很多，这里就不过多展开介绍了；</p>

  <p>与此同时也有其它的 I/O 多路复用函数 <code class="highlighter-rouge">epoll/kqueue/evport</code>，它们相比 <code class="highlighter-rouge">select</code> 性能更优秀，同时也能支撑更多的服务。</p>
</blockquote>

<h2 id="reactor-设计模式">Reactor 设计模式</h2>

<p>Redis 服务采用 Reactor 的方式来实现文件事件处理器（每一个网络连接其实都对应一个文件描述符）</p>

<p><img src="https://img.draveness.me/2016-11-26-redis-reactor-pattern.png-1000width" alt="redis-reactor-pattern" /></p>

<p>文件事件处理器使用 I/O 多路复用模块同时监听多个 FD，当 <code class="highlighter-rouge">accept</code>、<code class="highlighter-rouge">read</code>、<code class="highlighter-rouge">write</code> 和 <code class="highlighter-rouge">close</code> 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器。</p>

<p>虽然整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，提高了网络通信模型的性能，同时也可以保证整个 Redis 服务实现的简单。</p>

<h2 id="io-多路复用模块">I/O 多路复用模块</h2>

<p>I/O 多路复用模块封装了底层的 <code class="highlighter-rouge">select</code>、<code class="highlighter-rouge">epoll</code>、<code class="highlighter-rouge">avport</code> 以及 <code class="highlighter-rouge">kqueue</code> 这些 I/O 多路复用函数，为上层提供了相同的接口。</p>

<p><img src="https://img.draveness.me/2016-11-26-ae-module.jpg-1000width" alt="ae-module" /></p>

<p>在这里我们简单介绍 Redis 是如何包装 <code class="highlighter-rouge">select</code> 和 <code class="highlighter-rouge">epoll</code> 的，简要了解该模块的功能，整个 I/O 多路复用模块抹平了不同平台上 I/O 多路复用函数的差异性，提供了相同的接口：</p>

<ul>
  <li><code class="highlighter-rouge">static int  aeApiCreate(aeEventLoop *eventLoop)</code></li>
  <li><code class="highlighter-rouge">static int  aeApiResize(aeEventLoop *eventLoop, int setsize)</code></li>
  <li><code class="highlighter-rouge">static void aeApiFree(aeEventLoop *eventLoop)</code></li>
  <li><code class="highlighter-rouge">static int  aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask)</code></li>
  <li><code class="highlighter-rouge">static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) </code></li>
  <li><code class="highlighter-rouge">static int  aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp)</code></li>
</ul>

<p>同时，因为各个函数所需要的参数不同，我们在每一个子模块内部通过一个 <code class="highlighter-rouge">aeApiState</code> 来存储需要的上下文信息：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// select
</span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">aeApiState</span> <span class="p">{</span>
    <span class="n">fd_set</span> <span class="n">rfds</span><span class="p">,</span> <span class="n">wfds</span><span class="p">;</span>
    <span class="n">fd_set</span> <span class="n">_rfds</span><span class="p">,</span> <span class="n">_wfds</span><span class="p">;</span>
<span class="p">}</span> <span class="n">aeApiState</span><span class="p">;</span>

<span class="c1">// epoll
</span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">aeApiState</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">epfd</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">events</span><span class="p">;</span>
<span class="p">}</span> <span class="n">aeApiState</span><span class="p">;</span>
</code></pre></div></div>

<p>这些上下文信息会存储在 <code class="highlighter-rouge">eventLoop</code> 的 <code class="highlighter-rouge">void *state</code> 中，不会暴露到上层，只在当前子模块中使用。</p>

<h3 id="封装-select-函数">封装 select 函数</h3>

<blockquote>
  <p><code class="highlighter-rouge">select</code> 可以监控 FD 的可读、可写以及出现错误的情况。</p>
</blockquote>

<p>在介绍 I/O 多路复用模块如何对 <code class="highlighter-rouge">select</code> 函数封装之前，先来看一下 <code class="highlighter-rouge">select</code> 函数使用的大致流程：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="cm">/* file descriptor */</span>

<span class="n">fd_set</span> <span class="n">rfds</span><span class="p">;</span>
<span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rfds</span><span class="p">);</span>
<span class="n">FD_SET</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rfds</span><span class="p">)</span>

<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">select</span><span class="p">(</span><span class="n">fd</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rfds</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FD_ISSET</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rfds</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* file descriptor `fd` becomes readable */</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ol>
  <li>初始化一个可读的 <code class="highlighter-rouge">fd_set</code> 集合，保存需要监控可读性的 FD；</li>
  <li>使用 <code class="highlighter-rouge">FD_SET</code> 将 <code class="highlighter-rouge">fd</code> 加入 <code class="highlighter-rouge">rfds</code>；</li>
  <li>调用 <code class="highlighter-rouge">select</code> 方法监控 <code class="highlighter-rouge">rfds</code> 中的 FD 是否可读；</li>
  <li>当 <code class="highlighter-rouge">select</code> 返回时，检查 FD 的状态并完成对应的操作。</li>
</ol>

<p>而在 Redis 的 <code class="highlighter-rouge">ae_select</code> 文件中代码的组织顺序也是差不多的，首先在 <code class="highlighter-rouge">aeApiCreate</code> 函数中初始化 <code class="highlighter-rouge">rfds</code> 和 <code class="highlighter-rouge">wfds</code>：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">aeApiCreate</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">aeApiState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">aeApiState</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rfds</span><span class="p">);</span>
    <span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">wfds</span><span class="p">);</span>
    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">apidata</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>而 <code class="highlighter-rouge">aeApiAddEvent</code> 和 <code class="highlighter-rouge">aeApiDelEvent</code> 会通过 <code class="highlighter-rouge">FD_SET</code> 和 <code class="highlighter-rouge">FD_CLR</code> 修改 <code class="highlighter-rouge">fd_set</code> 中对应 FD 的标志位：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">aeApiAddEvent</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">aeApiState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">apidata</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_READABLE</span><span class="p">)</span> <span class="n">FD_SET</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rfds</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_WRITABLE</span><span class="p">)</span> <span class="n">FD_SET</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">wfds</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>整个 <code class="highlighter-rouge">ae_select</code> 子模块中最重要的函数就是 <code class="highlighter-rouge">aeApiPoll</code>，它是实际调用 <code class="highlighter-rouge">select</code> 函数的部分，其作用就是在 I/O 多路复用函数返回时，将对应的 FD 加入 <code class="highlighter-rouge">aeEventLoop</code> 的 <code class="highlighter-rouge">fired</code> 数组中，并返回事件的个数：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">aeApiPoll</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">tvp</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">aeApiState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">apidata</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">numevents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">_rfds</span><span class="p">,</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">rfds</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">fd_set</span><span class="p">));</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">_wfds</span><span class="p">,</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">wfds</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">fd_set</span><span class="p">));</span>

    <span class="n">retval</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">maxfd</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">_rfds</span><span class="p">,</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">_wfds</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">tvp</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">maxfd</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">aeFileEvent</span> <span class="o">*</span><span class="n">fe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">==</span> <span class="n">AE_NONE</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_READABLE</span> <span class="o">&amp;&amp;</span> <span class="n">FD_ISSET</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">_rfds</span><span class="p">))</span>
                <span class="n">mask</span> <span class="o">|=</span> <span class="n">AE_READABLE</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_WRITABLE</span> <span class="o">&amp;&amp;</span> <span class="n">FD_ISSET</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">_wfds</span><span class="p">))</span>
                <span class="n">mask</span> <span class="o">|=</span> <span class="n">AE_WRITABLE</span><span class="p">;</span>
            <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">numevents</span><span class="p">].</span><span class="n">fd</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
            <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">numevents</span><span class="p">].</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
            <span class="n">numevents</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">numevents</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="封装-epoll-函数">封装 epoll 函数</h3>

<p>Redis 对 <code class="highlighter-rouge">epoll</code> 的封装其实也是类似的，使用 <code class="highlighter-rouge">epoll_create</code> 创建 <code class="highlighter-rouge">epoll</code> 中使用的 <code class="highlighter-rouge">epfd</code>：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">aeApiCreate</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">aeApiState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">aeApiState</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">epoll_event</span><span class="p">)</span><span class="o">*</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">setsize</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">zfree</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">state</span><span class="o">-&gt;</span><span class="n">epfd</span> <span class="o">=</span> <span class="n">epoll_create</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span> <span class="cm">/* 1024 is just a hint for the kernel */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">epfd</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">zfree</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">);</span>
        <span class="n">zfree</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">apidata</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">aeApiAddEvent</code> 中使用 <code class="highlighter-rouge">epoll_ctl</code> 向 <code class="highlighter-rouge">epfd</code> 中添加需要监控的 FD 以及监听的事件：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">aeApiAddEvent</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">aeApiState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">apidata</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">epoll_event</span> <span class="n">ee</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="cm">/* avoid valgrind warning */</span>
    <span class="cm">/* If the fd was already monitored for some event, we need a MOD
     * operation. Otherwise we need an ADD operation. */</span>
    <span class="kt">int</span> <span class="n">op</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">fd</span><span class="p">].</span><span class="n">mask</span> <span class="o">==</span> <span class="n">AE_NONE</span> <span class="o">?</span>
            <span class="n">EPOLL_CTL_ADD</span> <span class="o">:</span> <span class="n">EPOLL_CTL_MOD</span><span class="p">;</span>

    <span class="n">ee</span><span class="p">.</span><span class="n">events</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">mask</span> <span class="o">|=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">fd</span><span class="p">].</span><span class="n">mask</span><span class="p">;</span> <span class="cm">/* Merge old events */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_READABLE</span><span class="p">)</span> <span class="n">ee</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">EPOLLIN</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_WRITABLE</span><span class="p">)</span> <span class="n">ee</span><span class="p">.</span><span class="n">events</span> <span class="o">|=</span> <span class="n">EPOLLOUT</span><span class="p">;</span>
    <span class="n">ee</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">epoll_ctl</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">epfd</span><span class="p">,</span><span class="n">op</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="o">&amp;</span><span class="n">ee</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>由于 <code class="highlighter-rouge">epoll</code> 相比 <code class="highlighter-rouge">select</code> 机制略有不同，在 <code class="highlighter-rouge">epoll_wait</code> 函数返回时并不需要遍历所有的 FD 查看读写情况；在 <code class="highlighter-rouge">epoll_wait</code> 函数返回时会提供一个 <code class="highlighter-rouge">epoll_event</code> 数组：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">union</span> <span class="n">epoll_data</span> <span class="p">{</span>
    <span class="kt">void</span>    <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
    <span class="kt">int</span>      <span class="n">fd</span><span class="p">;</span> <span class="cm">/* 文件描述符 */</span>
    <span class="kt">uint32_t</span> <span class="n">u32</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">u64</span><span class="p">;</span>
<span class="p">}</span> <span class="n">epoll_data_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">epoll_event</span> <span class="p">{</span>
    <span class="kt">uint32_t</span>     <span class="n">events</span><span class="p">;</span> <span class="cm">/* Epoll 事件 */</span>
    <span class="n">epoll_data_t</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<blockquote>
  <p>其中保存了发生的 <code class="highlighter-rouge">epoll</code> 事件（<code class="highlighter-rouge">EPOLLIN</code>、<code class="highlighter-rouge">EPOLLOUT</code>、<code class="highlighter-rouge">EPOLLERR</code> 和 <code class="highlighter-rouge">EPOLLHUP</code>）以及发生该事件的 FD。</p>
</blockquote>

<p><code class="highlighter-rouge">aeApiPoll</code> 函数只需要将 <code class="highlighter-rouge">epoll_event</code> 数组中存储的信息加入 <code class="highlighter-rouge">eventLoop</code> 的 <code class="highlighter-rouge">fired</code> 数组中，将信息传递给上层模块：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">aeApiPoll</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">tvp</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">aeApiState</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">apidata</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">numevents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">retval</span> <span class="o">=</span> <span class="n">epoll_wait</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">epfd</span><span class="p">,</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">,</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">setsize</span><span class="p">,</span>
            <span class="n">tvp</span> <span class="o">?</span> <span class="p">(</span><span class="n">tvp</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="o">*</span><span class="mi">1000</span> <span class="o">+</span> <span class="n">tvp</span><span class="o">-&gt;</span><span class="n">tv_usec</span><span class="o">/</span><span class="mi">1000</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

        <span class="n">numevents</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numevents</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">struct</span> <span class="n">epoll_event</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">events</span><span class="o">+</span><span class="n">j</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLIN</span><span class="p">)</span> <span class="n">mask</span> <span class="o">|=</span> <span class="n">AE_READABLE</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLOUT</span><span class="p">)</span> <span class="n">mask</span> <span class="o">|=</span> <span class="n">AE_WRITABLE</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLERR</span><span class="p">)</span> <span class="n">mask</span> <span class="o">|=</span> <span class="n">AE_WRITABLE</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">&amp;</span> <span class="n">EPOLLHUP</span><span class="p">)</span> <span class="n">mask</span> <span class="o">|=</span> <span class="n">AE_WRITABLE</span><span class="p">;</span>
            <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">fd</span> <span class="o">=</span> <span class="n">e</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">fd</span><span class="p">;</span>
            <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">numevents</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="子模块的选择">子模块的选择</h3>

<p>因为 Redis 需要在多个平台上运行，同时为了最大化执行的效率与性能，所以会根据编译平台的不同选择不同的 I/O 多路复用函数作为子模块，提供给上层统一的接口；在 Redis 中，我们通过宏定义的使用，合理的选择不同的子模块：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifdef HAVE_EVPORT
#include "ae_evport.c"
#else
</span>    <span class="cp">#ifdef HAVE_EPOLL
</span>    <span class="cp">#include "ae_epoll.c"
</span>    <span class="cp">#else
</span>        <span class="cp">#ifdef HAVE_KQUEUE
</span>        <span class="cp">#include "ae_kqueue.c"
</span>        <span class="cp">#else
</span>        <span class="cp">#include "ae_select.c"
</span>        <span class="cp">#endif
</span>    <span class="cp">#endif
#endif
</span></code></pre></div></div>

<p>因为 <code class="highlighter-rouge">select</code> 函数是作为 POSIX 标准中的系统调用，在不同版本的操作系统上都会实现，所以将其作为保底方案：</p>

<p><img src="https://img.draveness.me/2016-11-26-redis-choose-io-function.jpg-1000width" alt="redis-choose-io-function" /></p>

<p>Redis 会优先选择时间复杂度为 $O(1)$ 的 I/O 多路复用函数作为底层实现，包括 Solaries 10 中的 <code class="highlighter-rouge">evport</code>、Linux 中的 <code class="highlighter-rouge">epoll</code> 和 macOS/FreeBSD 中的 <code class="highlighter-rouge">kqueue</code>，上述的这些函数都使用了内核内部的结构，并且能够服务几十万的文件描述符。</p>

<p>但是如果当前编译环境没有上述函数，就会选择 <code class="highlighter-rouge">select</code> 作为备选方案，由于其在使用时会扫描全部监听的描述符，所以其时间复杂度较差 $O(n)$，并且只能同时服务 1024 个文件描述符，所以一般并不会以 <code class="highlighter-rouge">select</code> 作为第一方案使用。</p>

<h2 id="总结">总结</h2>

<p>Redis 对于 I/O 多路复用模块的设计非常简洁，通过宏保证了 I/O 多路复用模块在不同平台上都有着优异的性能，将不同的 I/O 多路复用函数封装成相同的 API 提供给上层使用。</p>

<p>整个模块使 Redis 能以单进程运行的同时服务成千上万个文件描述符，避免了由于多进程应用的引入导致代码实现复杂度的提升，减少了出错的可能性。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="http://man7.org/linux/man-pages/man2/select.2.html">Select-Man-Pages</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Reactor_pattern">Reactor-Pattern</a></li>
  <li><a href="https://people.eecs.berkeley.edu/~sangjin/2012/12/21/epoll-vs-kqueue.html">epoll vs kqueue</a></li>
</ul>

<h2 id="其它">其它</h2>

<blockquote>

  <p>Source: http://draveness.me/redis-io-multiplexing</p>
</blockquote>


        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
            
                
            
                
            
                
            
                
            

            <!-- Add Disqus Comments -->
            

        </footer>

    </article>

</main>
<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story no-cover" href="/blogs/redis-eventloop">
            <section class="post">
                <h2>Redis 中的事件循环</h2>
                <p>在目前的很多服务中，由于需要持续接受客户端或者用户的输入，所以需要一个事件循环来等待并处理外部事件，这篇文章主要会介绍 Redis 中的事件循环是如何处理事件的。 在文章中，我们会先从 Redis 的实现中分析事件是如何被处理的，然后用更具象化的方式了解服务中的不同模块是如何交流的。 ## aeEventLoop 在分析具体代码之前，先了解一下在事件处理中处于核心部分的 `aeEventLoop` 到底是什么： ![reids-eventloop](https://img.draveness.me/2016-12-09-reids-eventloop.png-1000width) `aeEventLoop` 在 Redis...</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev no-cover" href="/blogs/preload">
            <section class="post">
                <h2>预加载与智能预加载（iOS）</h2>
                <p>前两次的分享分别介绍了 ASDK 对于渲染的优化以及 ASDK 中使用的另一种布局模型；这两个新机制的引入分别解决了 iOS 在主线程渲染视图以及 Auto Layout 的性能问题，而这一次讨论的主要内容是 ASDK 如何预先请求服务器数据，达到看似无限滚动列表的效果的。 这篇文章是 ASDK 系列中的最后一篇，文章会介绍...</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/blogs/">Brightness</a> &copy; 2018</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-69281367-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/blogs/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/blogs/assets/js/index.js"></script>

</body>
</html>
