<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>如何从 MongoDB 迁移到 MySQL</title>
    <meta name="description" content="A beautiful narrative written with the world's most elegant publishing platform. The story begins here." />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/blogs/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/blogs/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/blogs/assets/css/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="/blogs//mongodb-to-mysql" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/blogs/page2/" />

    <meta property="og:site_name" content="Brightness" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="如何从 MongoDB 迁移到 MySQL" />
    <meta property="og:description" content="A beautiful narrative written with the world's most elegant publishing platform. The story begins here." />
    <meta property="og:url" content="/blogs//mongodb-to-mysql" />
    <meta property="og:image" content="/blogs/assets/images/cover1.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="如何从 MongoDB 迁移到 MySQL" />
    <meta name="twitter:description" content="A beautiful narrative written with the world's most elegant publishing platform. The story begins here." />
    <meta name="twitter:url" content="/blogs//mongodb-to-mysql" />
    <meta name="twitter:image:src" content="/blogs/assets/images/cover1.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "Brightness",
    "name": "如何从 MongoDB 迁移到 MySQL",
    "url": "/blogs//mongodb-to-mysql",
    "image": "/blogs/assets/images/cover1.jpg",
    "description": "A beautiful narrative written with the world's most elegant publishing platform. The story begins here."
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="Brightness" href="/blogs/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/blogs/">Home</a></li>
        <li class="nav-about " role="presentation"><a href="/blogs/about">About</a></li>
        <li class="nav-fables " role="presentation"><a href="/blogs/tag/fables">Fables</a></li>
        <li class="nav-speeches " role="presentation"><a href="/blogs/tag/speeches">Speeches</a></li>
        <li class="nav-fiction " role="presentation"><a href="/blogs/tag/fiction">Fiction</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/casper">Casper</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/edgar">Edgar</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/abraham">Abraham</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/martin">Martin</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/lewis">Lewis</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/blogs/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        
        
    </nav>
</header>

<main class="content" role="main">

    <article class="">

        <header class="post-header">
            <h1 class="post-title">如何从 MongoDB 迁移到 MySQL</h1>
            <section class="post-meta">
            <!-- <a href='/blogs/'></a> -->

            
                
            
                
            
                
            
                
            
                
            
            <time class="post-date" datetime="2017-10-10">10 Oct 2017</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/blogs/tag/database'>Database</a>,
                    
                
                    
                       <a href='/blogs/tag/mongodb'>Mongodb</a>,
                    
                
                    
                       <a href='/blogs/tag/mysql'>Mysql</a>,
                    
                
                    
                       <a href='/blogs/tag/rails'>Rails</a>,
                    
                
                    
                       <a href='/blogs/tag/ruby'>Ruby</a>,
                    
                
                    
                       <a href='/blogs/tag/server'>Server</a>
                    
                
                
            </section>
        </header>

        <section class="post-content">

            <p>最近的一个多月时间其实都在做数据库的迁移工作，我目前在开发的项目其实在上古时代是使用 MySQL 作为主要数据库的，后来由于一些业务上的原因从 MySQL 迁移到了 MongoDB，使用了几个月的时间后，由于数据库服务非常不稳定，再加上无人看管，同时 MongoDB 本身就是无 Schema 的数据库，最后导致数据库的脏数据问题非常严重。目前团队的成员没有较为丰富的 Rails 开发经验，所以还是希望使用 ActiveRecord 加上 Migration 的方式对数据进行一些强限制，保证数据库中数据的合法。</p>

<p><img src="https://img.draveness.me/2017-10-10-mysql-and-mongodb.png" alt="mysql-and-mongodb" /></p>

<p>文中会介绍作者在迁移数据库的过程中遇到的一些问题，并为各位读者提供需要<strong>停机</strong>迁移数据库的可行方案，如果需要不停机迁移数据库还是需要别的方案来解决，在这里提供的方案用于百万数据量的 MongoDB，预计的停机时间在两小时左右，如果数据量在千万级别以上，过长的停机时间可能是无法接受的，应该设计不停机的迁移方案；无论如何，作者希望这篇文章能够给想要做数据库迁移的开发者带来一些思路，少走一些坑。</p>

<h2 id="从关系到文档">从关系到文档</h2>

<p>虽然这篇文章的重点是从 MongoDB 迁移到 MySQL，但是作者还是想简单提一下从 MySQL 到 MongoDB 的迁移，如果我们仅仅是将 MySQL 中的全部数据导入到 MongoDB 中其实是一间比较简单的事情，其中最重要的原因就是 <strong>MySQL 支持的数据类型是 MongoDB 的子集</strong>：</p>

<p><img src="https://img.draveness.me/2017-10-10-mongodb-mysql-datatype-relation.png" alt="mongodb-mysql-datatype-relation" /></p>

<p>在迁移的过程中可以将 MySQL 中的全部数据以 csv 的格式导出，然后再将所有 csv 格式的数据使用 <code class="highlighter-rouge">mongoimport</code> 全部导入到 MongoDB 中：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>mysqldump <span class="nt">-u</span>&lt;username&gt; <span class="nt">-p</span>&lt;password&gt; <span class="se">\</span>
    <span class="nt">-T</span> &lt;output_directory&gt; <span class="se">\</span>
    <span class="nt">--fields-terminated-by</span> <span class="s1">','</span> <span class="se">\</span>
    <span class="nt">--fields-enclosed-by</span> <span class="s1">'\"'</span> <span class="se">\</span>
    <span class="nt">--fields-escaped-by</span> <span class="s1">'\'</span> <span class="se">\</span>
    <span class="nt">--no-create-info</span> &lt;database_name&gt;

<span class="nv">$ </span>mongoimport <span class="nt">--db</span> &lt;database_name&gt; <span class="nt">--collection</span> &lt;collection_name&gt; <span class="se">\</span>
    <span class="nt">--type</span> csv <span class="se">\</span>
    <span class="nt">--file</span> &lt;data.csv&gt; <span class="se">\</span>
    <span class="nt">--headerline</span>
</code></pre></div></div>

<p>虽然整个过程看起来只需要两个命令非常简单，但是等到你真要去做的时候你会遇到非常多的问题，作者没有过从 MySQL 或者其他关系型数据库迁移到 MongoDB 的经验，但是 Google 上相关的资料特别多，所以这总是一个有无数前人踩过坑的问题，而前人的经验也能够帮助我们节省很多时间。</p>

<p><img src="https://img.draveness.me/2017-10-24-mysql-to-mongodb.png" alt="mysql-to-mongodb" /></p>

<blockquote>
  <p>使用 csv 的方式导出数据在绝大多数的情况都不会出现问题，但是如果数据库中的某些文档中存储的是富文本，那么虽然在导出数据时不会出现问题，最终导入时可能出现一些比较奇怪的错误。</p>
</blockquote>

<h2 id="从文档到关系">从文档到关系</h2>

<p>相比于从 MySQL 到 MongoDB 的迁移，反向的迁移就麻烦了不止一倍，这主要是因为 MongoDB 中的很多数据类型和集合之间的关系在 MySQL 中都并不存在，比如嵌入式的数据结构、数组和哈希等集合类型、多对多关系的实现，很多的问题都不是仅仅能通过数据上的迁移解决的，我们需要在对数据进行迁移之前先对部分数据结构进行重构，本文中的后半部分会介绍需要处理的数据结构和逻辑。</p>

<p><img src="https://img.draveness.me/2017-10-10-mongodb-mysql-problems-to-be-solved.png" alt="mongodb-mysql-problems-to-be-solved" /></p>

<p>当我们准备将数据库彻底迁移到 MySQL 之前，需要做一些准备工作，将最后迁移所需要的工作尽可能地减少，保证停机的时间不会太长，准备工作的目标就是尽量消灭工程中复杂的数据结构。</p>

<h3 id="数据的预处理">数据的预处理</h3>

<p>在进行迁移之前要做很多准备工作，第一件事情是要把所有嵌入的数据结构改成非嵌入式的数据结构：</p>

<p><img src="https://img.draveness.me/2017-10-10-embedded-reference-documents.png" alt="embedded-reference-documents" /></p>

<p>也就是把所有 <code class="highlighter-rouge">embeds_many</code> 和 <code class="highlighter-rouge">embeds_one</code> 的关系都改成 <code class="highlighter-rouge">has_many</code> 和 <code class="highlighter-rouge">has_one</code>，同时将 <code class="highlighter-rouge">embedded_in</code> 都替换成 <code class="highlighter-rouge">belongs_to</code>，同时我们需要将工程中对应的测试都改成这种引用的关系，然而只改变代码中的关系并没有真正改变 MongoDB 中的数据。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">embeds_many_to_has_many</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
  <span class="n">child_key_name</span> <span class="o">=</span> <span class="n">child</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">underscore</span><span class="p">.</span><span class="nf">pluralize</span>
  <span class="n">parent</span><span class="p">.</span><span class="nf">collection</span><span class="p">.</span><span class="nf">find</span><span class="p">({}).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">parent_document</span><span class="o">|</span>
    <span class="k">next</span> <span class="k">unless</span> <span class="n">parent_document</span><span class="p">[</span><span class="n">child_key_name</span><span class="p">]</span>
    <span class="n">parent_document</span><span class="p">[</span><span class="n">child_key_name</span><span class="p">].</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">child_document</span><span class="o">|</span>
      <span class="n">new_child</span> <span class="o">=</span> <span class="n">child_document</span><span class="p">.</span><span class="nf">merge</span> <span class="s2">"</span><span class="si">#{</span><span class="n">parent</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">underscore</span><span class="si">}</span><span class="s2">_id"</span><span class="p">:</span> <span class="n">parent_document</span><span class="p">[</span><span class="s1">'_id'</span><span class="p">]</span>
      <span class="n">child</span><span class="p">.</span><span class="nf">collection</span><span class="p">.</span><span class="nf">insert_one</span> <span class="n">new_child</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="n">parent</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">unset</span><span class="p">(</span><span class="n">child_key_name</span><span class="p">.</span><span class="nf">to_sym</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">embeds_many_to_has_many</span><span class="p">(</span><span class="no">Person</span><span class="p">,</span> <span class="no">Address</span><span class="p">)</span>
</code></pre></div></div>

<p>我们可以使用上述的代码将关系为嵌入的模型都转换成引用，拍平所有复杂的数据关系，这段代码的运行时间与嵌入关系中的两个模型的数量有关，需要注意的是，MongoDB 中嵌入模型的数据可能因为某些原因出现相同的 <code class="highlighter-rouge">_id</code> 在插入时会发生冲突导致崩溃，你可以对 <code class="highlighter-rouge">insert_one</code> 使用 <code class="highlighter-rouge">resuce</code> 来保证这段代码的运行不会因为上述原因而停止。</p>

<p><img src="https://img.draveness.me/2017-10-10-embedded-to-reference.png" alt="embedded-to-reference" /></p>

<p>通过这段代码我们就可以轻松将原有的嵌入关系全部展开变成引用的关系，将嵌入的关系变成引用除了做这两个改变之外，不需要做其他的事情，无论是数据的查询还是模型的创建都不需要改变代码的实现，不过记得为子模型中父模型的外键<strong>添加索引</strong>，否则会导致父模型在获取自己持有的全部子模型时造成<strong>全表扫描</strong>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Comment</span>
  <span class="kp">include</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Document</span>
  <span class="n">index</span> <span class="ss">post_id: </span><span class="mi">1</span>
  <span class="n">belongs_to</span> <span class="ss">:post</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在处理了 MongoDB 中独有的嵌入式关系之后，我们就需要解决一些复杂的集合类型了，比如数组和哈希，如果我们使用 MySQL5.7 或者 PostgreSQL 的话，其实并不需要对他们进行处理，因为最新版本的 MySQL 和 PostgreSQL 已经提供了对 JSON 的支持，不过作者还是将项目中的数组和哈希都变成了常见的数据结构。</p>

<p>在这个可选的过程中，其实并没有什么标准答案，我们可以根据需要将不同的数据转换成不同的数据结构：</p>

<p><img src="https://img.draveness.me/2017-10-10-array-to-string-or-relation.png" alt="array-to-string-or-relation" /></p>

<p>比如，将数组变成字符串或者一对多关系，将哈希变成当前文档的键值对等等，如何处理这些集合数据其实都要看我们的业务逻辑，在改变这些字段的同时尽量为上层提供一个与原来直接 <code class="highlighter-rouge">.tags</code> 或者 <code class="highlighter-rouge">.categories</code> 结果相同的 API：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Post</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="nf">tag_titles</span>
    <span class="n">tags</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:title</span><span class="p">)</span>
  <span class="k">end</span>
  
  <span class="k">def</span> <span class="nf">split_categories</span>
    <span class="n">categories</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">','</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这一步其实也是可选的，上述代码只是为了减少其他地方的修改负担，当然如果你想使用 MySQL5.7 或者 PostgreSQL 数据库对 JSON 的支持也没有什么太大的问题，只是在查询集合字段时有一些不方便。</p>

<h3 id="mongoid-的小兄弟们">Mongoid 的『小兄弟』们</h3>

<p>在使用 Mongoid 进行开发期间难免会用到一些相关插件，比如 <a href="https://github.com/thetron/mongoid-enum">mongoid-enum</a>、<a href="https://github.com/mongoid/mongoid-slug">mongoid-slug</a> 和 <a href="https://github.com/mongoid/mongoid-history">mongoid-history</a> 等，这些插件的实现与 ActiveRecord 中具有相同功能的插件在实现上有很大的不同。</p>

<p>对于有些插件，比如 mongoid-slug 只是在引入插件的模型的文档中插入了 <code class="highlighter-rouge">_slugs</code> 字段，我们只需要在进行数据迁移忽略这些添加的字段并将所有的 <code class="highlighter-rouge">#slug</code> 方法改成 <code class="highlighter-rouge">#id</code>，不需要在预处理的过程中做其它的改变。而枚举的实现在 Mongoid 的插件和 ActiveRecord 中就截然不同了：</p>

<p><img src="https://img.draveness.me/2017-10-10-mongodb-mysql-enum.png" alt="mongodb-mysql-enu" /></p>

<p>mongoid-enum 使用字符串和 <code class="highlighter-rouge">_status</code> 来保存枚举类型的字段，而 ActiveRecord 使用整数和 <code class="highlighter-rouge">status</code> 表示枚举类型，两者在底层数据结构的存储上有一些不同，我们会在之后的迁移脚本中解决这个问题。</p>

<p><img src="https://img.draveness.me/2017-10-10-mongoid-activerecord-enum.png" alt="mongoid-activerecord-enum" /></p>

<p>如果在项目中使用了很多 Mongoid 的插件，由于其实现不同，我们也只能根据不同的插件的具体实现来决定如何对其进行迁移，如果使用了一些支持特殊功能的插件可能很难在 ActiveRecord 中找到对应的支持，在迁移时可以考虑暂时将部分不重要的功能移除。</p>

<h3 id="主键与-uuid">主键与 UUID</h3>

<p>我们希望从 MongoDB 迁移到 MySQL 的另一个重要原因就是 MongoDB 每一个文档的主键实在是太过冗长，一个 32 字节的 <code class="highlighter-rouge">_id</code> 无法给我们提供特别多的信息，只能增加我们的阅读障碍，再加上项目中并没有部署 MongoDB 集群，所以没能享受到用默认的 UUID 生成机制带来的好处。</p>

<p><img src="https://img.draveness.me/2017-10-10-mongodb-mysql-id.png" alt="mongodb-mysql-id" /></p>

<p>我们不仅没有享受到 UUID 带来的优点，它还在迁移 MySQL 的过程中为我们带来了很大的麻烦，一方面是因为 ActiveRecord 的默认主键是整数，不支持 32 字节长度的 UUID，如果我们想要不改变 MongoDB 的 UUID，直接迁移到 MySQL 中使用其实也没有什么问题，只是我们要将默认的整数类型的主键变成字符串类型，同时要使用一个 UUID 生成器来保证所有的主键都是根据时间递增的并且不会冲突。</p>

<p>如果准备使用 UUID 加生成器的方式，其实会省去很多迁移的时间，不过看起来确实不是特别的优雅，如何选择还是要权衡和评估，但是如果我们选择了使用 <code class="highlighter-rouge">integer</code> 类型的自增主键时，就需要做很多额外的工作了，首先是为所有的表添加 <code class="highlighter-rouge">uuid</code> 字段，同时为所有的外键例如 <code class="highlighter-rouge">post_id</code> 创建对应的 <code class="highlighter-rouge">post_uuid</code> 字段，通过 <code class="highlighter-rouge">uuid</code> 将两者关联起来：</p>

<p><img src="https://img.draveness.me/2017-10-10-mysql-before-migrations.png" alt="mysql-before-migrations" /></p>

<p>在数据的迁移过程中，我们会将原有的 <code class="highlighter-rouge">_id</code> 映射到 <code class="highlighter-rouge">uuid</code> 中，<code class="highlighter-rouge">post_id</code> 映射到 <code class="highlighter-rouge">post_uuid</code> 上，我们通过保持 <code class="highlighter-rouge">uuid</code> 和 <code class="highlighter-rouge">post_uuid</code> 之间的关系保证模型之间的关系没有丢失，在迁移数据的过程中 <code class="highlighter-rouge">id</code> 和 <code class="highlighter-rouge">post_id</code> 是完全不存在任何联系的。</p>

<p>当我们按照 <code class="highlighter-rouge">_id</code> 的顺序遍历整个文档，将文档中的数据被插入到表中时，MySQL 会为所有的数据行自动生成的递增的主键 <code class="highlighter-rouge">id</code>，而 <code class="highlighter-rouge">post_id</code> 在这时都为空。</p>

<p><img src="https://img.draveness.me/2017-10-10-mysql-after-migrations.png" alt="mysql-after-migrations" /></p>

<p>在全部的数据都被插入到 MySQL 之后，我们通过 <code class="highlighter-rouge">#find_by_uuid</code> 查询的方式将 <code class="highlighter-rouge">uuid</code> 和 <code class="highlighter-rouge">post_uuid</code> 中的关系迁移到 <code class="highlighter-rouge">id</code> 和 <code class="highlighter-rouge">post_id</code> 中，并将与 <code class="highlighter-rouge">uuid</code> 相关的字段全部删除，这样我们能够保证模型之间的关系不会消失，并且数据行的相对位置与迁移前完全一致。</p>

<h3 id="代码的迁移">代码的迁移</h3>

<p>Mongoid 在使用时都是通过 <code class="highlighter-rouge">include</code> 将相关方法加载到当前模型中的，而 ActiveRecord 是通过继承 <code class="highlighter-rouge">ActiveRecord::Base</code> 的方式使用的，完成了对数据的预处理，我们就可以对现有模型层的代码进行修改了。</p>

<p>首先当然是更改模型的『父类』，把所有的 <code class="highlighter-rouge">Mongoid::Document</code> 都改成 <code class="highlighter-rouge">ActiveRecord::Base</code>，然后创建类对应的 Migration 迁移文件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># app/models/post.rb</span>
<span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">validate_presence_of</span> <span class="ss">:title</span><span class="p">,</span> <span class="ss">:content</span>
<span class="k">end</span>

<span class="c1"># db/migrate/20170908075625_create_posts.rb</span>
<span class="k">class</span> <span class="nc">CreatePosts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span><span class="p">[</span><span class="mf">5.1</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:posts</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:title</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">text</span> <span class="ss">:content</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:uuid</span><span class="p">,</span> <span class="ss">null: </span><span class="kp">false</span>

      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span> <span class="ss">null: </span><span class="kp">false</span>
    <span class="k">end</span>
    
    <span class="n">add_index</span> <span class="ss">:posts</span><span class="p">,</span> <span class="ss">:uuid</span><span class="p">,</span> <span class="ss">unique: </span><span class="kp">true</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<blockquote>
  <p>注意：要为每一张表添加类型为字符串的 <code class="highlighter-rouge">uuid</code> 字段，同时为 <code class="highlighter-rouge">uuid</code> 建立唯一索引，以加快通过 <code class="highlighter-rouge">uuid</code> 建立不同数据模型之间关系的速度。</p>
</blockquote>

<p>除了建立数据库的迁移文件并修改基类，我们还需要修改一些 <code class="highlighter-rouge">include</code> 的模块和 Mongoid 中独有的查询，比如使用 <code class="highlighter-rouge">gte</code> 或者 <code class="highlighter-rouge">lte</code> 的日期查询和使用正则进行模式匹配的查询，这些查询在 ActiveRecord 中的使用方式与 Mongoid 中完全不同，我们需要通过手写 SQL 来解决这些问题。</p>

<p><img src="https://img.draveness.me/2017-10-10-mongoid-to-activerecord-model-and-query.png" alt="mongoid-to-activerecord-model-and-query" /></p>

<p>除此之外，我们也需要处理一些复杂的模型关系，比如 Mongoid 中的 <code class="highlighter-rouge">inverse_of</code> 在 ActiveRecord 中叫做  <code class="highlighter-rouge">foreign_key</code> 等等，这些修改其实都并不复杂，只是如果想要将这部分的代码全部处理掉，就需要对业务逻辑进行详细地测试以保证不会有遗留的问题，这也就对我们项目的测试覆盖率有着比较高的要求了，不过我相信绝大多数的 Rails 工程都有着非常好的测试覆盖率，能够保证这一部分代码和逻辑能够顺利迁移，但是如果项目中完全没有测试或者测试覆盖率很低，就只能人肉进行测试或者自求多福了，或者<strong>就别做迁移了，多写点测试再考虑这些重构的事情吧</strong>。</p>

<h3 id="数据的迁移">数据的迁移</h3>

<p>为每一个模型创建对应的迁移文件并建表其实一个不得不做的体力活，虽然有一些工作我们没法省略，但是我们可以考虑使用自动化的方式为所有的模型添加 <code class="highlighter-rouge">uuid</code> 字段和索引，同时也为类似 <code class="highlighter-rouge">post_id</code> 的字段添加相应的 <code class="highlighter-rouge">post_uuid</code> 列：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AddUuidColumns</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span><span class="p">[</span><span class="mf">5.1</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">eager_load!</span>
    <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">descendants</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">klass</span><span class="o">|</span>
      <span class="c1"># add `uuid` column and create unique index on `uuid`.</span>
      <span class="n">add_column</span> <span class="n">klass</span><span class="p">.</span><span class="nf">table_name</span><span class="p">,</span> <span class="ss">:uuid</span><span class="p">,</span> <span class="ss">:string</span><span class="p">,</span> <span class="ss">unique: </span><span class="kp">true</span>
      <span class="n">add_index</span> <span class="n">klass</span><span class="p">.</span><span class="nf">table_name</span><span class="p">,</span> <span class="ss">unique: </span><span class="kp">true</span>
      
      <span class="c1"># add `xxx_uuid` columns, ex: `post_uuid`, `comment_uuid` and etc.</span>
      <span class="n">uuids</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">attribute_names</span>
        <span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="kp">attr</span><span class="o">|</span> <span class="kp">attr</span><span class="p">.</span><span class="nf">include?</span> <span class="s1">'_id'</span> <span class="p">}</span>
        <span class="p">.</span><span class="nf">map</span>    <span class="p">{</span> <span class="o">|</span><span class="kp">attr</span><span class="o">|</span> <span class="kp">attr</span><span class="p">.</span><span class="nf">gsub</span> <span class="s1">'_id'</span><span class="p">,</span> <span class="s1">'_uuid'</span> <span class="p">}</span>
      <span class="k">next</span> <span class="k">unless</span> <span class="n">uuids</span><span class="p">.</span><span class="nf">present?</span>
      <span class="n">uuids</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">uuid</span><span class="o">|</span>
        <span class="n">add_column</span> <span class="n">klass</span><span class="p">.</span><span class="nf">table_name</span><span class="p">,</span> <span class="n">uuid</span><span class="p">,</span> <span class="ss">:string</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在添加 <code class="highlighter-rouge">uuid</code> 列并建立好索引之后，我们就可以开始对数据库进行迁移了，如果我们决定在迁移的过程中改变原有数据的主键，那么我们会将迁移分成两个步骤，数据的迁移和关系的重建，前者仅指将 MongoDB 中的所有数据全部迁移到 MySQL 中对应的表中，并将所有的 <code class="highlighter-rouge">_id</code> 转换成 <code class="highlighter-rouge">uuid</code>、<code class="highlighter-rouge">xx_id</code> 转换成 <code class="highlighter-rouge">xx_uuid</code>，而后者就是前面提到的：通过 <code class="highlighter-rouge">uuid</code> 和 <code class="highlighter-rouge">xx_uuid</code> 的关联重新建立模型之间的关系并在最后删除所有的 <code class="highlighter-rouge">uuid</code> 字段。</p>

<p>我们可以使用如下的代码对数据进行迁移，这段代码从 MongoDB 中遍历某个集合 Collection 中的全部数据，然后将文档作为参数传入 block，然后再分别通过 <code class="highlighter-rouge">DatabaseTransformer#delete_obsolete_columns</code> 和 <code class="highlighter-rouge">DatabaseTransformer#update_rename_columns</code> 方法删除部分已有的列、更新一些数据列最后将所有的 <code class="highlighter-rouge">id</code> 列都变成 <code class="highlighter-rouge">uuid</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">DatabaseTransformer</span>
  <span class="k">def</span> <span class="nf">import</span><span class="p">(</span><span class="n">collection_name</span><span class="p">,</span> <span class="o">*</span><span class="n">obsolete_columns</span><span class="p">,</span> <span class="o">**</span><span class="n">rename_columns</span><span class="p">)</span>
    <span class="n">collection</span> <span class="o">=</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Clients</span><span class="p">.</span><span class="nf">default</span><span class="p">.</span><span class="nf">collections</span><span class="p">.</span><span class="nf">select</span> <span class="k">do</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span>
      <span class="n">c</span><span class="p">.</span><span class="nf">namespace</span> <span class="o">==</span> <span class="s2">"</span><span class="si">#{</span><span class="n">database</span><span class="si">}</span><span class="s2">.</span><span class="si">#{</span><span class="n">collection_name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">pluralize</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span><span class="p">.</span><span class="nf">first</span>

    <span class="k">unless</span> <span class="n">collection</span><span class="p">.</span><span class="nf">present?</span>
      <span class="no">STDOUT</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="n">collection_name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">yellow</span><span class="si">}</span><span class="s2">: skipped"</span>
      <span class="no">STDOUT</span><span class="p">.</span><span class="nf">puts</span>
      <span class="k">return</span>
    <span class="k">end</span>

    <span class="n">constant</span> <span class="o">=</span> <span class="n">collection_name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">singularize</span><span class="p">.</span><span class="nf">camelcase</span><span class="p">.</span><span class="nf">constantize</span>
    <span class="n">reset_callbacks</span> <span class="n">constant</span>

    <span class="no">DatabaseTransformer</span><span class="p">.</span><span class="nf">profiling</span> <span class="k">do</span>
      <span class="n">collection_count</span> <span class="o">=</span> <span class="n">collection</span><span class="p">.</span><span class="nf">find</span><span class="p">.</span><span class="nf">count</span>
      <span class="n">collection</span><span class="p">.</span><span class="nf">find</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">document</span><span class="p">,</span> <span class="n">index</span><span class="o">|</span>
        <span class="n">document</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">document</span> <span class="k">if</span> <span class="nb">block_given?</span>
        <span class="n">delete_obsolete_columns</span> <span class="n">document</span><span class="p">,</span> <span class="n">obsolete_columns</span>
        <span class="n">update_rename_columns</span> <span class="n">document</span><span class="p">,</span> <span class="n">rename_columns</span>
        <span class="n">update_id_columns</span> <span class="n">document</span>

        <span class="n">insert_record</span> <span class="n">constant</span><span class="p">,</span> <span class="n">document</span>
        <span class="no">STDOUT</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="n">index</span><span class="si">}</span><span class="s2">/</span><span class="si">#{</span><span class="n">collection_count</span><span class="si">}</span><span class="se">\n</span><span class="s2">"</span> <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">).</span><span class="nf">zero?</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当完成了对文档的各种操作之后，该方法会直接调用 <code class="highlighter-rouge">DatabaseTransformer#insert_record</code> 将数据插入 MySQL 对应的表中；我们可以直接使用如下的代码将某个 Collection 中的全部文档迁移到 MySQL 中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">transformer</span> <span class="o">=</span> <span class="no">DatabaseTransformer</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'draven_production'</span>
<span class="n">transformer</span><span class="p">.</span><span class="nf">import</span> <span class="ss">:post</span><span class="p">,</span> <span class="ss">:_slugs</span><span class="p">,</span> <span class="ss">name: :title</span><span class="p">,</span> <span class="ss">_status: :status</span>
</code></pre></div></div>

<p>上述代码会在迁移时将集合每一个文档的 <code class="highlighter-rouge">_slugs</code> 字段全部忽略，同时将 <code class="highlighter-rouge">name</code> 重命名成 <code class="highlighter-rouge">title</code>、<code class="highlighter-rouge">_status</code> 重命名成 <code class="highlighter-rouge">status</code>，虽然作为枚举类型的字段 mongoid-enum 和 ActiveRecord 的枚举类型完全不同，但是在这里可以直接插入也没有什么问题，ActiveRecord 的模型在创建时会自己处理字符串和整数之间的转换：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">insert_record</span><span class="p">(</span><span class="n">constant</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
  <span class="n">model</span> <span class="o">=</span> <span class="n">constant</span><span class="p">.</span><span class="nf">new</span> <span class="n">params</span>
  <span class="n">model</span><span class="p">.</span><span class="nf">save!</span> <span class="ss">validate: </span><span class="kp">false</span>
<span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">exception</span>
  <span class="no">STDERR</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"Import Error: </span><span class="si">#{</span><span class="n">exception</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">raise</span> <span class="n">exception</span>
<span class="k">end</span>
</code></pre></div></div>

<p>为了加快数据的插入速度，同时避免所有由于插入操作带来的副作用，我们会在数据迁移期间重置所有的回调：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">reset_callbacks</span><span class="p">(</span><span class="n">constant</span><span class="p">)</span>
  <span class="sx">%i(create save update)</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">callback</span><span class="o">|</span>
    <span class="n">constant</span><span class="p">.</span><span class="nf">reset_callbacks</span> <span class="n">callback</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这段代码的作用仅在这个脚本运行的过程中才会生效，不会对工程中的其他地方造成任何的影响；同时，该脚本会在每 1000 个模型插入成功后向标准输出打印当前进度，帮助我们快速发现问题和预估迁移的时间。</p>

<blockquote>
  <p>你可以在 <a href="https://gist.github.com/Draveness/10476fe67a10128a37ba27a4c6967d07">database_transformer.rb</a> 找到完整的数据迁移代码。</p>
</blockquote>

<p>将所有的数据全部插入到 MySQL 的表之后，模型之间还没有任何显式的关系，我们还需要将通过 <code class="highlighter-rouge">uuid</code> 连接的模型转换成使用 <code class="highlighter-rouge">id</code> 的方式，对象之间的关系才能通过点语法直接访问，关系的建立其实非常简单，我们获得当前类所有结尾为 <code class="highlighter-rouge">_uuid</code> 的属性，然后遍历所有的数据行，根据 <code class="highlighter-rouge">uuid</code> 的值和 <code class="highlighter-rouge">post_uuid</code> 属性中的 “post” 部分获取到表名，最终得到对应的关联模型，在这里我们也处理了类似多态的特殊情况：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">RelationBuilder</span>
  <span class="k">def</span> <span class="nf">build_relations</span><span class="p">(</span><span class="n">class_name</span><span class="p">,</span> <span class="n">polymorphic_associations</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">rename_associations</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="n">uuids</span> <span class="o">=</span> <span class="n">class_name</span><span class="p">.</span><span class="nf">attribute_names</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="nb">name</span><span class="p">.</span><span class="nf">end_with?</span> <span class="s1">'_uuid'</span> <span class="p">}</span>

    <span class="k">unless</span> <span class="n">uuids</span><span class="p">.</span><span class="nf">present?</span>
      <span class="no">STDOUT</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="n">class_name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">yellow</span><span class="si">}</span><span class="s2">: skipped"</span>
      <span class="no">STDOUT</span><span class="p">.</span><span class="nf">puts</span>
      <span class="k">return</span>
    <span class="k">end</span>

    <span class="n">reset_callbacks</span> <span class="n">class_name</span>

    <span class="no">RelationBuilder</span><span class="p">.</span><span class="nf">profiling</span> <span class="k">do</span>
      <span class="n">models_count</span> <span class="o">=</span> <span class="n">class_name</span><span class="p">.</span><span class="nf">count</span>
      <span class="n">class_name</span><span class="p">.</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="n">model</span><span class="p">,</span> <span class="n">index</span><span class="o">|</span>
        <span class="n">update_params</span> <span class="o">=</span> <span class="n">uuids</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">uuid</span><span class="o">|</span>
          <span class="n">original_association_name</span> <span class="o">=</span> <span class="n">uuid</span><span class="p">[</span><span class="mi">0</span><span class="o">...-</span><span class="mi">5</span><span class="p">]</span>

          <span class="n">association_model</span> <span class="o">=</span> <span class="n">association_model</span><span class="p">(</span>
            <span class="n">original_association_name</span><span class="p">,</span>
            <span class="n">model</span><span class="p">[</span><span class="n">uuid</span><span class="p">],</span>
            <span class="n">polymorphic_associations</span><span class="p">,</span>
            <span class="n">rename_associations</span>
          <span class="p">)</span>

          <span class="p">[</span><span class="n">original_association_name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">,</span> <span class="n">association_model</span><span class="p">]</span>
        <span class="k">end</span><span class="p">.</span><span class="nf">compact</span>

        <span class="k">begin</span>
          <span class="no">Hash</span><span class="p">[</span><span class="n">update_params</span><span class="p">].</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span>
            <span class="n">model</span><span class="p">.</span><span class="nf">send</span> <span class="s2">"</span><span class="si">#{</span><span class="n">key</span><span class="si">}</span><span class="s2">="</span><span class="p">,</span> <span class="n">value</span>
          <span class="k">end</span>
          <span class="n">model</span><span class="p">.</span><span class="nf">save!</span> <span class="ss">validate: </span><span class="kp">false</span>
        <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">e</span>
          <span class="no">STDERR</span><span class="p">.</span><span class="nf">puts</span> <span class="n">e</span>
          <span class="k">raise</span> <span class="n">e</span>
        <span class="k">end</span>

        <span class="no">STDOUT</span><span class="p">.</span><span class="nf">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="n">index</span><span class="si">}</span><span class="s2">/</span><span class="si">#{</span><span class="n">models_count</span><span class="si">}</span><span class="se">\n</span><span class="s2">"</span> <span class="k">if</span> <span class="p">(</span><span class="n">counter</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">).</span><span class="nf">zero?</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在查找到对应的数据行之后就非常简单了，我们调用对应的 <code class="highlighter-rouge">post=</code> 等方法更新外键最后直接将外键的值保存到数据库中，与数据的迁移过程一样，我们在这段代码的执行过程中也会打印出当前的进度。</p>

<p>在初始化 <code class="highlighter-rouge">RelationBuilder</code> 时，如果我们传入了 <code class="highlighter-rouge">constants</code>，那么在调用 <code class="highlighter-rouge">RelationBuilder#build!</code> 时就会重建其中的全部关系，但是如果没有传入就会默认加载 ActiveRecord 中所有的子类，并去掉其中包含 <code class="highlighter-rouge">::</code> 的模型，也就是 ActiveRecord 中使用 <code class="highlighter-rouge">has_and_belongs_to_many</code> 创建的中间类，我们会在下一节中介绍如何单独处理多对多关系：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="nb">constants</span> <span class="o">=</span> <span class="p">[])</span>
  <span class="k">if</span> <span class="nb">constants</span><span class="p">.</span><span class="nf">present?</span>
    <span class="vi">@constants</span> <span class="o">=</span> <span class="nb">constants</span>
  <span class="k">else</span>
    <span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">eager_load!</span>
    <span class="vi">@constants</span> <span class="o">=</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">descendants</span>
        <span class="p">.</span><span class="nf">reject</span> <span class="p">{</span> <span class="o">|</span><span class="n">constant</span><span class="o">|</span> <span class="n">constant</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="s1">'::'</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<blockquote>
  <p>跟关系重建相关的代码可以在 <a href="https://gist.github.com/Draveness/c0798fb1272f483a176fa67741a3f1ee">relation_builder.rb</a> 找到完整的用于关系迁移的代码。</p>
</blockquote>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">builder</span> <span class="o">=</span> <span class="no">RelationBuilder</span><span class="p">.</span><span class="nf">new</span><span class="p">([</span><span class="no">Post</span><span class="p">,</span> <span class="no">Comment</span><span class="p">])</span>
<span class="n">builder</span><span class="p">.</span><span class="nf">build!</span>
</code></pre></div></div>

<p>通过这数据迁移和关系重建两个步骤就已经可以解决绝大部分的数据迁移问题了，但是由于 MongoDB 和 ActiveRecord 中对于多对多关系的处理比较特殊，所以我们需要单独进行解决，如果所有的迁移问题到这里都已经解决了，那么我们就可以使用下面的迁移文件将数据库中与 <code class="highlighter-rouge">uuid</code> 有关的全部列都删除了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">RemoveAllUuidColumns</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span><span class="p">[</span><span class="mf">5.1</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">eager_load!</span>
    <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">descendants</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">klass</span><span class="o">|</span>
      <span class="n">attrs</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">attribute_names</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="n">n</span><span class="o">|</span> <span class="n">n</span><span class="p">.</span><span class="nf">include?</span> <span class="s1">'uuid'</span> <span class="p">}</span>
      <span class="k">next</span> <span class="k">unless</span> <span class="n">attrs</span><span class="p">.</span><span class="nf">present?</span>
      <span class="n">remove_columns</span> <span class="n">klass</span><span class="p">.</span><span class="nf">table_name</span><span class="p">,</span> <span class="o">*</span><span class="n">attrs</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>到这里位置整个迁移的过程就基本完成了，接下来就是跟整个迁移过程中有关的其他事项，例如：对多对关系、测试的重要性等话题。</p>

<h3 id="多对多关系的处理">多对多关系的处理</h3>

<p>多对多关系在数据的迁移过程中其实稍微有一些复杂，在 Mongoid 中使用 <code class="highlighter-rouge">has_and_belongs_to_many</code> 会在相关的文档下添加一个 <code class="highlighter-rouge">tag_ids</code> 或者 <code class="highlighter-rouge">post_ids</code> 数组：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># The post document.</span>
<span class="p">{</span>
  <span class="s2">"_id"</span> <span class="p">:</span> <span class="no">ObjectId</span><span class="p">(</span><span class="s2">"4d3ed089fb60ab534684b7e9"</span><span class="p">),</span>
  <span class="s2">"tag_ids"</span> <span class="p">:</span> <span class="p">[</span>
    <span class="no">ObjectId</span><span class="p">(</span><span class="s2">"4d3ed089fb60ab534684b7f2"</span><span class="p">),</span> 
    <span class="no">ObjectId</span><span class="p">(</span><span class="s2">"4d3ed089fb60ab53468831f1"</span><span class="p">)</span>
  <span class="p">],</span>
  <span class="s2">"title"</span><span class="p">:</span> <span class="s2">"xxx"</span><span class="p">,</span>
  <span class="s2">"content"</span><span class="p">:</span> <span class="s2">"xxx"</span>
<span class="p">}</span>
</code></pre></div></div>

<p>而 ActiveRecord 中会建立一张单独的表，表的名称是两张表名按照字母表顺序的拼接，如果是 <code class="highlighter-rouge">Post</code> 和 <code class="highlighter-rouge">Tag</code>，对应的多对多表就是 <code class="highlighter-rouge">posts_tags</code>，除了创建多对多表，<code class="highlighter-rouge">has_and_belongs_to_many</code> 还会创建两个 <code class="highlighter-rouge">ActiveRecord::Base</code> 的子类 <code class="highlighter-rouge">Tag::HABTM_Posts</code> 和 <code class="highlighter-rouge">Post::HABTM_Tags</code>，我们可以使用下面的代码简单实验一下：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'active_record'</span>

<span class="k">class</span> <span class="nc">Tag</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">;</span> <span class="k">end</span>
<span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:tags</span>
<span class="k">end</span>
<span class="k">class</span> <span class="nc">Tag</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:posts</span>
<span class="k">end</span>
<span class="nb">puts</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">descendants</span>
<span class="c1"># =&gt; [Tag, Post, Post::HABTM_Tags, Tag::HABTM_Posts]</span>
</code></pre></div></div>

<p>上述代码打印出了两个 <code class="highlighter-rouge">has_and_belongs_to_many</code> 生成的类 <code class="highlighter-rouge">Tag::HABTM_Posts</code> 和 <code class="highlighter-rouge">Post::HABTM_Tags</code>，它们有着完全相同的表 <code class="highlighter-rouge">posts_tags</code>，处理多对多关系时，我们只需要在使用 <code class="highlighter-rouge">DatabaseTransformer</code> 导入表中的所有的数据之后，再通过遍历 <code class="highlighter-rouge">posts_tags</code> 表中的数据更新多对多的关系表就可以了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PostsTag</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">;</span> <span class="k">end</span>

<span class="c1"># migrate data from mongodb to mysql.</span>
<span class="n">transformer</span> <span class="o">=</span> <span class="no">DatabaseTransformer</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'draven_production'</span>
<span class="n">transformer</span><span class="p">.</span><span class="nf">import</span> <span class="ss">:posts_tags</span>

<span class="c1"># establish association between posts and tags.</span>
<span class="no">PostsTag</span><span class="p">.</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">model</span><span class="o">|</span>
  <span class="n">post</span> <span class="o">=</span> <span class="no">Post</span><span class="p">.</span><span class="nf">find_by_uuid</span> <span class="n">model</span><span class="p">.</span><span class="nf">post_uuid</span>
  <span class="n">tag</span> <span class="o">=</span> <span class="no">Tag</span><span class="p">.</span><span class="nf">find_by_uuid</span> <span class="n">model</span><span class="p">.</span><span class="nf">tag_uuid</span>
  <span class="k">next</span> <span class="k">unless</span> <span class="n">post</span><span class="p">.</span><span class="nf">present?</span> <span class="o">&amp;&amp;</span> <span class="n">tag</span><span class="p">.</span><span class="nf">present?</span>
  <span class="n">model</span><span class="p">.</span><span class="nf">update_columns</span> <span class="ss">post_id: </span><span class="n">post</span><span class="p">.</span><span class="nf">id</span><span class="p">,</span> <span class="ss">tag_id: </span><span class="n">tag</span><span class="p">.</span><span class="nf">id</span>
<span class="k">end</span>
</code></pre></div></div>

<p>所有使用 <code class="highlighter-rouge">has_and_belongs_to_many</code> 的多对多关系都需要通过上述代码进行迁移，这一步需要在删除数据库中的所有 <code class="highlighter-rouge">uuid</code> 字段之前完成。</p>

<h3 id="测试的重要性">测试的重要性</h3>

<p>在真正对线上的服务进行停机迁移之前，我们其实需要对数据库已有的数据进行部分和全量测试，在部分测试阶段，我们可以在本地准备一个数据量为生产环境数据量 1/10 或者 1/100 的 MongoDB 数据库，通过在本地模拟 MongoDB 和 MySQL 的环境进行预迁移，确保我们能够尽快地发现迁移脚本中的错误。</p>

<p><img src="https://img.draveness.me/2017-10-10-mongodb-pre-migration.png" alt="mongodb-pre-migration" /></p>

<p>准备测试数据库的办法是通过关系删除一些主要模型的数据行，在删除时可以通过 MongoDB 中的 <code class="highlighter-rouge">dependent: :destroy</code> 删除相关的模型，这样可以尽可能的保证数据的一致性和完整性，但是在对线上数据库进行迁移之前，我们依然需要对 MongoDB 中的全部数据进行全量的迁移测试，这样可以发现一些更加隐蔽的问题，保证真正上线时可以出现更少的状况。</p>

<p>数据库的迁移其实也属于重构，在进行 MongoDB 的数据库迁移之前一定要保证项目有着完善的测试体系和测试用例，这样才能让我们在项目重构之后，确定不会出现我们难以预料的问题，整个项目才是可控的，如果工程中没有足够的测试甚至没有测试，那么就不要再说重构这件事情了 – <strong>单元测试是重构的基础</strong>。</p>

<h2 id="总结">总结</h2>

<p>如何从 MongoDB 迁移到 MySQL 其实是一个工程问题，我们需要在整个过程中不断寻找可能出错的问题，将一个比较复杂的任务进行拆分，在真正做迁移之前尽可能地减少迁移对服务可用性以及稳定性带来的影响。</p>

<p><img src="https://img.draveness.me/2017-10-10-mysql-and-mongodb-work-together.png" alt="mysql-and-mongodb-work-together" /></p>

<p>除此之外，MongoDB 和 MySQL 之间的选择也不一定是非此即彼，我们将项目中的大部分数据都迁移到了 MySQL 中，但是将一部分用于计算和分析的数据留在了 MongoDB，这样就可以保证 MongoDB 宕机之后仍然不会影响项目的主要任务，同时，MySQL 的备份和恢复速度也会因为数据库变小而非常迅速。</p>

<p>最后一点，测试真的很重要，如果没有测试，没有人能够做到在<strong>修改大量的业务代码的过程中不丢失任何的业务逻辑</strong>，甚至如果没有测试，很多业务逻辑可能在开发的那一天就已经丢失了。</p>

<p>如果对文章的内容有疑问或者有 MongoDB 迁移相关的问题，可以在评论中留言。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://www.quora.com/How-do-I-migrate-data-from-a-MongoDB-to-MySQL-database-Can-it-be-done-in-a-real-time-scenario-What-are-the-pros-and-cons-for-each-migration-Which-one-do-you-advice-What-is-your-experience-Any-reference-DB-expert-who-can-do-it">How do I migrate data from a MongoDB to MySQL database? · Quora</a></li>
</ul>


        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
            
                
            
                
            
                
            
                
            

            <!-- Add Disqus Comments -->
            

        </footer>

    </article>

</main>
<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story no-cover" href="/blogs/activerecord">
            <section class="post">
                <h2>全面理解 ActiveRecord</h2>
                <p>最近事情并不是特别多，看了一些数据库相关的书籍，最后想到自己并不了解每天都在用的 ActiveRecord，对于它是如何创建模型、建立关系、执行 SQL 查询以及完成数据库迁移的，作者一直都有着自己的猜测，但是真正到源代码中去寻找答案一直都是没有做过的。 ![activerecord-architecture](https://img.draveness.me/2017-10-21-activerecord-architecture.png) 我们可以将 ActiveRecord 理解为一个不同 SQL 数据库的 Wrapper，同时为上层提供一种简洁、优雅的 API 或者说 DSL，能够极大得减轻开发者的负担并提升工作效率。 文章分四个部分介绍了...</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev no-cover" href="/blogs/database-concurrency-control">
            <section class="post">
                <h2>浅谈数据库并发控制 - 锁和 MVCC</h2>
                <p>在学习几年编程之后，你会发现所有的问题都没有简单、快捷的解决方案，很多问题都需要权衡和妥协，而本文介绍的就是数据库在并发性能和可串行化之间做的权衡和妥协 - 并发控制机制。 如果数据库中的所有事务都是串行执行的，那么它非常容易成为整个应用的性能瓶颈，虽然说没法水平扩展的节点在最后都会成为瓶颈，但是串行执行事务的数据库会加速这一过程；而并发（Concurrency）使一切事情的发生都有了可能，它能够解决一定的性能问题，但是它会带来更多诡异的错误。 引入了并发事务之后，如果不对事务的执行进行控制就会出现各种各样的问题，你可能没有享受到并发带来的性能提升就已经被各种奇怪的问题折磨的欲仙欲死了。 概述 如何控制并发是数据库领域中非常重要的问题之一，不过到今天为止事务并发的控制已经有了很多成熟的解决方案，而这些方案的原理就是这篇文章想要介绍的内容，文章中会介绍最为常见的三种并发控制机制： 分别是悲观并发控制、乐观并发控制和多版本并发控制，其中悲观并发控制其实是最常见的并发控制机制，也就是锁；而乐观并发控制其实也有另一个名字：乐观锁，乐观锁其实并不是一种真实存在的锁，我们会在文章后面的部分中具体介绍；最后就是多版本并发控制（MVCC）了，与前两者对立的命名不同，MVCC 可以与前两者中的任意一种机制结合使用，以提高数据库的读性能。 既然这篇文章介绍了不同的并发控制机制，那么一定会涉及到不同事务的并发，我们会通过示意图的方式分析各种机制是如何工作的。 悲观并发控制 控制不同的事务对同一份数据的获取是保证数据库的一致性的最根本方法，如果我们能够让事务在同一时间对同一资源有着独占的能力，那么就可以保证操作同一资源的不同事务不会相互影响。 最简单的、应用最广的方法就是使用锁来解决，当事务需要对资源进行操作时需要先获得资源对应的锁，保证其他事务不会访问该资源后，在对资源进行各种操作；在悲观并发控制中，数据库程序对于数据被修改持悲观的态度，在数据处理的过程中都会被锁定，以此来解决竞争的问题。 读写锁 为了最大化数据库事务的并发能力，数据库中的锁被设计为两种模式，分别是共享锁和互斥锁。当一个事务获得共享锁之后，它只可以进行读操作，所以共享锁也叫读锁；而当一个事务获得一行数据的互斥锁时，就可以对该行数据进行读和写操作，所以互斥锁也叫写锁。...</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/blogs/">Brightness</a> &copy; 2018</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-69281367-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/blogs/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/blogs/assets/js/index.js"></script>

</body>
</html>
