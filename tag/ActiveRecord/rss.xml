<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>brightphone.github.io/blogs/</title>
   
   <link></link>
   <description>A beautiful narrative written with the world's most elegant publishing platform. The story begins here.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>全面理解 ActiveRecord</title>
	  <link>/blogs//activerecord</link>
	  <author></author>
	  <pubDate>2017-10-21T00:00:00+00:00</pubDate>
	  <guid>/blogs//activerecord</guid>
	  <description><![CDATA[
	     <p>最近事情并不是特别多，看了一些数据库相关的书籍，最后想到自己并不了解每天都在用的 ActiveRecord，对于它是如何创建模型、建立关系、执行 SQL 查询以及完成数据库迁移的，作者一直都有着自己的猜测，但是真正到源代码中去寻找答案一直都是没有做过的。</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-architecture.png" alt="activerecord-architecture" /></p>

<p>我们可以将 ActiveRecord 理解为一个不同 SQL 数据库的 Wrapper，同时为上层提供一种简洁、优雅的 API 或者说 DSL，能够极大得减轻开发者的负担并提升工作效率。</p>

<p>文章分四个部分介绍了 ActiveRecord 中的重要内容，模型的创建过程、Scope 和查询的实现、模型关系的实现以及最后的 Migrations 任务的实现和执行过程，各个模块之间没有太多的关联，由于文章内容比较多，如果读者只对某一部分的内容感兴趣，可以只挑选一部分进行阅读。</p>

<h2 id="模型的创建过程">模型的创建过程</h2>

<p>在这篇文章中，我们会先分析阅读 ActiveRecord 是如何创建模型并将数据插入到数据库中的，由于 ActiveRecord 的源码变更非常迅速，这里使用的 ActiveRecord 版本是 v5.1.4，如果希望重现文中对方法的追踪过程可以 checkout 到 v5.1.4 的标签上并使用如下所示的命令安装指定版本的 ActiveRecord：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gem install activerecord <span class="nt">-v</span> <span class="s1">'5.1.4'</span>
</code></pre></div></div>

<h3 id="引入-activerecord">引入 ActiveRecord</h3>

<p>在正式开始使用 <a href="https://github.com/pry/pry">pry</a> 对方法进行追踪之前，我们需要现在 pry 中 <code class="highlighter-rouge">require</code> 对应的 gem，并且创建一个用于追踪的模型类：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="nb">require</span> <span class="s1">'active_record'</span>
<span class="o">=&gt;</span> <span class="kp">true</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">;</span> <span class="k">end</span>
<span class="o">=&gt;</span> <span class="kp">nil</span>
</code></pre></div></div>

<p>这个步骤非常的简单，这里也不多说什么了，只是创建了一个继承自 <code class="highlighter-rouge">ActiveRecord::Base</code> 的类 <code class="highlighter-rouge">Post</code>，虽然我们并没有在数据库中创建对应的表结构，不过目前来说已经够用了。</p>

<h3 id="从-postcreate-开始">从 Post.create 开始</h3>

<p>使用过 ActiveRecord 的人都知道，当我们使用 <code class="highlighter-rouge">Post.create</code> 方法的时候就会在数据库中创建一条数据记录，所以在这里我们就将该方法作为入口一探究竟：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="no">Post</span><span class="p">.</span><span class="nf">create</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">persistence</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">29</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Persistence</span><span class="o">::</span><span class="no">ClassMethods</span>

<span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="n">attributes</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">attributes</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Array</span><span class="p">)</span>
    <span class="n">attributes</span><span class="p">.</span><span class="nf">collect</span> <span class="p">{</span> <span class="o">|</span><span class="kp">attr</span><span class="o">|</span> <span class="n">create</span><span class="p">(</span><span class="kp">attr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">else</span>
    <span class="n">object</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">attributes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
    <span class="n">object</span><span class="p">.</span><span class="nf">save</span>
    <span class="n">object</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<blockquote>
  <p><code class="highlighter-rouge">$</code> 是 pry 为我们提供的用于查看方法源代码的工具，这篇文章中会省略 <code class="highlighter-rouge">$</code> 方法的一部分输出，还可能会对方法做一些简化减少理解方法实现时的干扰。</p>
</blockquote>

<p>通过 pry 的输出，我们可以在 ActiveRecord 的 <code class="highlighter-rouge">lib/active_record/persistence.rb</code> 文件中找到 <code class="highlighter-rouge">ActiveRecord::Base.create</code> 方法的实现，如果传入的参数是一个 <code class="highlighter-rouge">Hash</code>，该方法会先后执行 <code class="highlighter-rouge">ActiveRecord::Base.new</code> 和 <code class="highlighter-rouge">ActiveRecord::Base#save!</code> 创建一个新的对象并保存。</p>

<h4 id="使用-pry-追踪-save">使用 pry 追踪 #save!</h4>

<p><code class="highlighter-rouge">ActiveRecord::Base.new</code> 在大多数情况下都会调用父类的 <code class="highlighter-rouge">#initialize</code> 方法初始化实例，所以没有什么好说的，而 <code class="highlighter-rouge">ActiveRecord::Base#save!</code> 方法就做了很多事情：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="c1">#save!</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">suppressor</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">45</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Suppressor</span>

<span class="k">def</span> <span class="nf">save!</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="c1"># :nodoc:</span>
  <span class="no">SuppressorRegistry</span><span class="p">.</span><span class="nf">suppressed</span><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">name</span><span class="p">]</span> <span class="p">?</span> <span class="kp">true</span> <span class="p">:</span> <span class="k">super</span>
<span class="k">end</span>
</code></pre></div></div>

<p>首先是使用 <code class="highlighter-rouge">SuppressorRegistry</code> 来判断是否需要对当前的存取请求进行抑制，然后执行 <code class="highlighter-rouge">super</code> 方法，由于从上述代码中没有办法知道这里的 <code class="highlighter-rouge">super</code> 到底是什么，所以我们就需要通过 <code class="highlighter-rouge">.ancestors</code> 方法看看 <code class="highlighter-rouge">ActiveRecord::Base</code> 到底有哪些父类了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">ancestors</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">,</span>
 <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Suppressor</span><span class="p">,</span>
 <span class="o">...</span>
 <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Persistence</span><span class="p">,</span>
 <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Core</span><span class="p">,</span>
 <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">ToJsonWithActiveSupportEncoder</span><span class="p">,</span>
 <span class="no">Object</span><span class="p">,</span>
 <span class="o">...</span>
 <span class="no">Kernel</span><span class="p">,</span>
 <span class="no">BasicObject</span><span class="p">]</span>

<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">ancestors</span><span class="p">.</span><span class="nf">count</span>
<span class="o">=&gt;</span> <span class="mi">65</span>
</code></pre></div></div>

<p>使用 <code class="highlighter-rouge">.ancestors</code> 方法，你就可以看到整个方法调用链上包含 64 个父类，在这时简单的使用 pry 就已经不能帮助我们理解方法的调用过程了，因为 pry 没法查看当前的方法在父类中是否存在，我们需要从工程中分析哪些类的 <code class="highlighter-rouge">#save!</code> 方法在整个过程中被执行了并根据上述列表排出它们执行的顺序；经过分析，我们得到如下的结果：</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-base-save.png" alt="activerecord-base-save" /></p>

<p>从 <code class="highlighter-rouge">ActiveRecord::Suppressor</code> 到 <code class="highlighter-rouge">ActiveRecord::Persistence</code> 一共有五个 module 实现了 <code class="highlighter-rouge">#save!</code> 方法，上面我们已经知道了 <code class="highlighter-rouge">ActiveRecord::Suppressor#save!</code> 模块提供了对保存的抑制功能，接下来将依次看后四个方法都在保存模型的过程中做了什么。</p>

<h4 id="事务的执行">事务的执行</h4>

<p>从名字就可以看出 <code class="highlighter-rouge">ActiveRecord::Transactions</code> 主要是为数据库事务提供支持，并在数据库事务的不同阶段执行不同的回调，这个 module 中的 <code class="highlighter-rouge">#save!</code> 方法仅在 <code class="highlighter-rouge">#with_transaction_returning_status</code> 的 block 中执行了 <code class="highlighter-rouge">super</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">ActiveRecord</span>
  <span class="k">module</span> <span class="nn">Transactions</span>
    <span class="k">def</span> <span class="nf">save!</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="c1">#:nodoc:</span>
      <span class="n">with_transaction_returning_status</span> <span class="p">{</span> <span class="k">super</span> <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">#with_transaction_returning_status</code> 方法会运行外部传入的 block 通过 <code class="highlighter-rouge">super</code> 执行父类的 <code class="highlighter-rouge">#save!</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">with_transaction_returning_status</span>
  <span class="n">status</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">transaction</span> <span class="k">do</span>
    <span class="n">add_to_transaction</span>
    <span class="k">begin</span>
      <span class="n">status</span> <span class="o">=</span> <span class="k">yield</span>
    <span class="k">rescue</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Rollback</span>
      <span class="n">clear_transaction_record_state</span>
      <span class="n">status</span> <span class="o">=</span> <span class="kp">nil</span>
    <span class="k">end</span>

    <span class="k">raise</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Rollback</span> <span class="k">unless</span> <span class="n">status</span>
  <span class="k">end</span>
  <span class="n">status</span>
<span class="k">ensure</span>
  <span class="k">if</span> <span class="vi">@transaction_state</span> <span class="o">&amp;&amp;</span> <span class="vi">@transaction_state</span><span class="p">.</span><span class="nf">committed?</span>
    <span class="n">clear_transaction_record_state</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>通过上述方法，我们将所有的 SQL 请求都包装在了一个 <code class="highlighter-rouge">.transaction</code> 中，开启一个新的数据库事务并在其中执行请求，在这里统一处理一些跟事务回滚以及异常相关的逻辑，同时 <code class="highlighter-rouge">ActiveRecord::Transactions</code> 又能为当前的模型添加一些回调的支持：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">ActiveRecord</span>
  <span class="k">module</span> <span class="nn">Transactions</span>
    <span class="n">included</span> <span class="k">do</span>
      <span class="n">define_callbacks</span> <span class="ss">:commit</span><span class="p">,</span> <span class="ss">:rollback</span><span class="p">,</span>
                       <span class="ss">:before_commit</span><span class="p">,</span>
                       <span class="ss">:before_commit_without_transaction_enrollment</span><span class="p">,</span>
                       <span class="ss">:commit_without_transaction_enrollment</span><span class="p">,</span>
                       <span class="ss">:rollback_without_transaction_enrollment</span><span class="p">,</span>
                       <span class="ss">scope: </span><span class="p">[</span><span class="ss">:kind</span><span class="p">,</span> <span class="ss">:name</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>开发者就能够在模型中根据需要注册回调用来监听各种数据库事务相关的事件，绝大多数的事务最终都会在 <code class="highlighter-rouge">ActiveRecord::ConnectionAdapters::Transaction#within_new_transaction</code> 方法中执行：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">within_new_transaction</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="vi">@connection</span><span class="p">.</span><span class="nf">lock</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
    <span class="k">begin</span>
      <span class="n">transaction</span> <span class="o">=</span> <span class="n">begin_transaction</span> <span class="n">options</span>
      <span class="k">yield</span>
    <span class="k">rescue</span> <span class="no">Exception</span> <span class="o">=&gt;</span> <span class="n">error</span>
      <span class="k">if</span> <span class="n">transaction</span>
        <span class="n">rollback_transaction</span>
        <span class="n">after_failure_actions</span><span class="p">(</span><span class="n">transaction</span><span class="p">,</span> <span class="n">error</span><span class="p">)</span>
      <span class="k">end</span>
      <span class="k">raise</span>
    <span class="k">ensure</span>
      <span class="k">unless</span> <span class="n">error</span>
        <span class="k">if</span> <span class="no">Thread</span><span class="p">.</span><span class="nf">current</span><span class="p">.</span><span class="nf">status</span> <span class="o">==</span> <span class="s2">"aborting"</span>
          <span class="n">rollback_transaction</span> <span class="k">if</span> <span class="n">transaction</span>
        <span class="k">else</span>
          <span class="k">begin</span>
            <span class="n">commit_transaction</span>
          <span class="k">rescue</span> <span class="no">Exception</span>
            <span class="n">rollback_transaction</span><span class="p">(</span><span class="n">transaction</span><span class="p">)</span> <span class="k">unless</span> <span class="n">transaction</span><span class="p">.</span><span class="nf">state</span><span class="p">.</span><span class="nf">completed?</span>
            <span class="k">raise</span>
          <span class="k">end</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法虽然看起来非常复杂，但是方法的逻辑还是还是非常清晰的，如果事务没有抛出任何的异常，就可以将上述代码简化成以下的几行代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">within_new_transaction</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="vi">@connection</span><span class="p">.</span><span class="nf">lock</span><span class="p">.</span><span class="nf">synchronize</span> <span class="k">do</span>
      <span class="n">begin_transaction</span> <span class="n">options</span>
      <span class="k">yield</span>
      <span class="n">commit_transaction</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>我们可以看到，经过一系列的方法调用最后会在数据库中执行 <code class="highlighter-rouge">BEGIN</code>、SQL 语句和 <code class="highlighter-rouge">COMMIT</code> 来完成数据的持久化。</p>

<h4 id="追踪属性的重置">追踪属性的重置</h4>

<p>当 <code class="highlighter-rouge">ActiveRecord::Transactions#save!</code> 通过 <code class="highlighter-rouge">super</code> 将方法抛给上层之后，就由 <code class="highlighter-rouge">ActiveRecord::AttributesMethod::Dirty</code> 来处理了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">save!</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
  <span class="k">super</span><span class="p">.</span><span class="nf">tap</span> <span class="k">do</span>
    <span class="n">changes_applied</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果 <code class="highlighter-rouge">#save!</code> 最终执行成功，在这个阶段会将所有模型改变的标记全部清除，对包括 <code class="highlighter-rouge">@changed_attributes</code>、<code class="highlighter-rouge">@mutation_tracker</code> 在内的实例变量全部重置，为追踪下一次模型的修改做准备。</p>

<h4 id="字段的验证">字段的验证</h4>

<p>沿着整个继承链往下走，下一个被执行的模块就是 <code class="highlighter-rouge">ActiveRecord::Validations</code> 了，正如这么模块名字所暗示的，我们在这里会对模型中的字段进行验证：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">save!</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="n">perform_validations</span><span class="p">(</span><span class="n">options</span><span class="p">)</span> <span class="p">?</span> <span class="k">super</span> <span class="p">:</span> <span class="n">raise_validation_error</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述代码使用 <code class="highlighter-rouge">#perform_validations</code> 方法验证模型中的全部字段，以此来保证所有的字段都符合我们的预期：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">perform_validations</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="n">options</span><span class="p">[</span><span class="ss">:validate</span><span class="p">]</span> <span class="o">==</span> <span class="kp">false</span> <span class="o">||</span> <span class="n">valid?</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="ss">:context</span><span class="p">])</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个方法中我们可以看到如果在调用 <code class="highlighter-rouge">save!</code> 方法时，传入了 <code class="highlighter-rouge">validate: false</code> 所有的验证就都会被跳过，我们通过 <code class="highlighter-rouge">#valid?</code> 来判断当前的模型是否合法，而这个方法的执行过程其实也包含两个过程：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">ActiveRecord</span>
  <span class="k">module</span> <span class="nn">Validations</span>
    <span class="k">def</span> <span class="nf">valid?</span><span class="p">(</span><span class="n">context</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
      <span class="n">context</span> <span class="o">||=</span> <span class="n">default_validation_context</span>
      <span class="n">output</span> <span class="o">=</span> <span class="k">super</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
      <span class="n">errors</span><span class="p">.</span><span class="nf">empty?</span> <span class="o">&amp;&amp;</span> <span class="n">output</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">ActiveModel</span>
  <span class="k">module</span> <span class="nn">Validations</span>
    <span class="k">def</span> <span class="nf">valid?</span><span class="p">(</span><span class="n">context</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
      <span class="n">current_context</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="nf">validation_context</span> <span class="o">=</span> <span class="n">validation_context</span><span class="p">,</span> <span class="n">context</span>
      <span class="n">errors</span><span class="p">.</span><span class="nf">clear</span>
      <span class="n">run_validations!</span>
    <span class="k">ensure</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">validation_context</span> <span class="o">=</span> <span class="n">current_context</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>由于 <code class="highlighter-rouge">ActiveModel::Validations</code> 是 <code class="highlighter-rouge">ActiveRecord::Validations</code> 的『父类』，所以在 <code class="highlighter-rouge">ActiveRecord::Validations</code> 执行 <code class="highlighter-rouge">#valid?</code> 方法时，最终会执行父类 <code class="highlighter-rouge">#run_validations</code> 运行全部的验证回调。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">ActiveModel</span>
  <span class="k">module</span> <span class="nn">Validations</span>
    <span class="k">def</span> <span class="nf">run_validations!</span>
      <span class="n">_run_validate_callbacks</span>
      <span class="n">errors</span><span class="p">.</span><span class="nf">empty?</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>通过上述方法的实现，我们可以发现验证是否成功其实并不是通过我们在 <code class="highlighter-rouge">validate</code> 中传入一个返回 <code class="highlighter-rouge">true/false</code> 的方法决定的，而是要向当前模型的 <code class="highlighter-rouge">errors</code> 中添加更多的错误：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Invoice</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">validate</span> <span class="ss">:active_customer</span>
 
  <span class="k">def</span> <span class="nf">active_customer</span>
    <span class="n">errors</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="ss">:customer_id</span><span class="p">,</span> <span class="s2">"is not active"</span><span class="p">)</span> <span class="k">unless</span> <span class="n">customer</span><span class="p">.</span><span class="nf">active?</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个过程中执行的另一个方法 <code class="highlighter-rouge">#_run_validate_callbacks</code> 其实是通过 <code class="highlighter-rouge">ActiveSupport::Callbacks</code> 提供的 <code class="highlighter-rouge">#define_callbacks</code> 方法动态生成的，所以我们没有办法在工程中搜索到：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">define_callbacks</span><span class="p">(</span><span class="o">*</span><span class="n">names</span><span class="p">)</span>
  <span class="n">options</span> <span class="o">=</span> <span class="n">names</span><span class="p">.</span><span class="nf">extract_options!</span>

  <span class="n">names</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
    <span class="nb">name</span> <span class="o">=</span> <span class="nb">name</span><span class="p">.</span><span class="nf">to_sym</span>
    <span class="n">set_callbacks</span> <span class="nb">name</span><span class="p">,</span> <span class="no">CallbackChain</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="nb">module_eval</span> <span class="o">&lt;&lt;-</span><span class="no">RUBY</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
      def _run_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">_callbacks(&amp;block)
        run_callbacks </span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="sh">, &amp;block
      end

      def self._</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">_callbacks
        get_callbacks(</span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="sh">)
      end

      def self._</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">_callbacks=(value)
        set_callbacks(</span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="sh">, value)
      end

      def _</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">_callbacks
        __callbacks[</span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="sh">]
      end
</span><span class="no">    RUBY</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这篇文章中，我们只需要知道该 <code class="highlighter-rouge">#save!</code> 在合适的时机运行了正确的回调就可以了，在后面的文章（可能）中会详细介绍整个 callbacks 的具体执行流程。</p>

<h4 id="数据的持久化">数据的持久化</h4>

<p><code class="highlighter-rouge">#save!</code> 的调用栈最顶端就是 <code class="highlighter-rouge">ActiveRecord::Persistence#save!</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">save!</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">create_or_update</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="o">||</span> <span class="k">raise</span><span class="p">(</span><span class="no">RecordNotSaved</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"Failed to save the record"</span><span class="p">,</span> <span class="nb">self</span><span class="p">))</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">create_or_update</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">_raise_readonly_record_error</span> <span class="k">if</span> <span class="n">readonly?</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">new_record?</span> <span class="p">?</span> <span class="n">_create_record</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="p">:</span> <span class="n">_update_record</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">!=</span> <span class="kp">false</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个方法中，我们执行了 <code class="highlighter-rouge">#create_or_update</code> 以及 <code class="highlighter-rouge">#_create_record</code> 两个方法来创建模型：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">_create_record</span><span class="p">(</span><span class="n">attribute_names</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">attribute_names</span><span class="p">)</span>
  <span class="n">attributes_values</span> <span class="o">=</span> <span class="n">arel_attributes_with_values_for_create</span><span class="p">(</span><span class="n">attribute_names</span><span class="p">)</span>
  <span class="n">new_id</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">insert</span> <span class="n">attributes_values</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">id</span> <span class="o">||=</span> <span class="n">new_id</span> <span class="k">if</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">primary_key</span>
  <span class="vi">@new_record</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="k">yield</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="k">if</span> <span class="nb">block_given?</span>
  <span class="nb">id</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个私有方法中开始执行数据的插入操作了，首先是通过 <code class="highlighter-rouge">ActiveRecord::AttributeMethods#arel_attributes_with_values_for_create</code> 方法获取一个用于插入数据的字典，其中包括了数据库中的表字段和对应的待插入值。</p>

<p><img src="https://img.draveness.me/2017-10-21-database-statement-insert.png" alt="database-statement-insert" /></p>

<p>而下面的 <code class="highlighter-rouge">.insert</code> 方法就会将这个字典转换成 SQL 语句，经过上图所示的调用栈最终到不同的数据库中执行语句并返回最新的主键。</p>

<h3 id="小结">小结</h3>

<p>从整个模型的创建过程中，我们可以看到 ActiveRecord 对于不同功能的组织非常优雅，每一个方法都非常简短并且易于阅读，通过对应的方法名和模块名我们就能够明确的知道这个东西是干什么的，对于同一个方法的不同执行逻辑也分散了不同的模块中，最终使用 module 加上 include 的方式组织起来，如果要对某个方法添加一些新的逻辑也可以通过增加更多的 module 达到目的。</p>

<p>通过对源代码的阅读，我们可以看到对于 ActiveRecord 来说，<code class="highlighter-rouge">#create</code> 和 <code class="highlighter-rouge">#save!</code> 方法的执行路径其实是差不多的，只是在细节上有一些不同之处。</p>

<p><img src="https://img.draveness.me/2017-10-21-actual-callstack-for-activerecord-base-save.png" alt="actual-callstack-for-activerecord-base-save" /></p>

<p>虽然模型或者说数据行的创建过程最终会从子类一路执行到父类的 <code class="highlighter-rouge">#save!</code> 方法，但是逻辑的<strong>处理顺序</strong>并不是按照从子类到父类执行的，我们可以通过上图了解不同模块的真正执行过程。</p>

<h2 id="scope-和查询的实现">Scope 和查询的实现</h2>

<p>除了模型的插入、创建和迁移模块，ActiveRecord 中还有另一个非常重要的模块，也就是 Scope 和查询；为什么同时介绍这两个看起来毫不相干的内容呢？这是因为 Scope 和查询是完全分不开的一个整体，在 ActiveRecord 的实现中，两者有着非常紧密的联系。</p>

<h3 id="activerecordrelation">ActiveRecord::Relation</h3>

<p>对 ActiveRecord 稍有了解的人都知道，在使用 ActiveRecord 进行查询时，所有的查询方法其实都会返回一个 <code class="highlighter-rouge">#{Model}::ActiveRecord_Relation</code> 类的对象，比如 <code class="highlighter-rouge">User.all</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">class</span>
<span class="o">=&gt;</span> <span class="no">User</span><span class="o">::</span><span class="no">ActiveRecord_Relation</span>
</code></pre></div></div>

<p>在这里使用 pry 来可以帮助我们快速理解整个过程到底都发生了什么事情：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">scoping</span><span class="o">/</span><span class="n">named</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">24</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Scoping</span><span class="o">::</span><span class="no">Named</span><span class="o">::</span><span class="no">ClassMethods</span>

<span class="k">def</span> <span class="nf">all</span>
  <span class="k">if</span> <span class="n">current_scope</span>
    <span class="n">current_scope</span><span class="p">.</span><span class="nf">clone</span>
  <span class="k">else</span>
    <span class="n">default_scoped</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">#all</code> 方法中的注释中也写着它会返回一个 <code class="highlighter-rouge">ActiveRecord::Relation</code> 对象，它其实可以理解为 ActiveRecord 查询体系中的单位元，它的调用并不改变当前查询；而如果我们使用 pry 去看其他的方法例如 <code class="highlighter-rouge">User.where</code> 的时候：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="no">User</span><span class="p">.</span><span class="nf">where</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">querying</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">10</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Querying</span>

<span class="n">delegate</span> <span class="ss">:select</span><span class="p">,</span> <span class="ss">:group</span><span class="p">,</span> <span class="ss">:order</span><span class="p">,</span> <span class="ss">:except</span><span class="p">,</span> <span class="ss">:reorder</span><span class="p">,</span> <span class="ss">:limit</span><span class="p">,</span> <span class="ss">:offset</span><span class="p">,</span> <span class="ss">:joins</span><span class="p">,</span> <span class="ss">:left_joins</span><span class="p">,</span> <span class="ss">:left_outer_joins</span><span class="p">,</span> <span class="ss">:or</span><span class="p">,</span>
         <span class="ss">:where</span><span class="p">,</span> <span class="ss">:rewhere</span><span class="p">,</span> <span class="ss">:preload</span><span class="p">,</span> <span class="ss">:eager_load</span><span class="p">,</span> <span class="ss">:includes</span><span class="p">,</span> <span class="ss">:from</span><span class="p">,</span> <span class="ss">:lock</span><span class="p">,</span> <span class="ss">:readonly</span><span class="p">,</span> <span class="ss">:extending</span><span class="p">,</span>
         <span class="ss">:having</span><span class="p">,</span> <span class="ss">:create_with</span><span class="p">,</span> <span class="ss">:distinct</span><span class="p">,</span> <span class="ss">:references</span><span class="p">,</span> <span class="ss">:none</span><span class="p">,</span> <span class="ss">:unscope</span><span class="p">,</span> <span class="ss">:merge</span><span class="p">,</span> <span class="ss">to: :all</span>
</code></pre></div></div>

<p>从这里我们可以看出，真正实现为 <code class="highlighter-rouge">User</code> 类方法的只有 <code class="highlighter-rouge">.all</code>，其他的方法都会代理给 <code class="highlighter-rouge">all</code> 方法，在 <code class="highlighter-rouge">.all</code> 方法返回的对象上执行：</p>

<p><img src="https://img.draveness.me/2017-10-21-active-record-relation-delegation.png" alt="active-record-relation-delegation" /></p>

<p>所有直接在类上调用的方法都会先执行 <code class="highlighter-rouge">#all</code>，也就是说下面的几种写法是完全相同的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">User</span>    <span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">name: </span><span class="s1">'draven'</span><span class="p">)</span>
<span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">name: </span><span class="s1">'draven'</span><span class="p">)</span>
<span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">name: </span><span class="s1">'draven'</span><span class="p">).</span><span class="nf">all</span>
</code></pre></div></div>

<p>当我们了解了 <code class="highlighter-rouge">.where == .all + #where</code> 就可以再一次使用 pry 来查找真正被 ActiveRecord 实现的 <code class="highlighter-rouge">#where</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">where</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">relation</span><span class="o">/</span><span class="n">query_methods</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">599</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">QueryMethods</span>

<span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="n">opts</span> <span class="o">=</span> <span class="ss">:chain</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">)</span>
  <span class="k">if</span> <span class="ss">:chain</span> <span class="o">==</span> <span class="n">opts</span>
    <span class="no">WhereChain</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">spawn</span><span class="p">)</span>
  <span class="k">elsif</span> <span class="n">opts</span><span class="p">.</span><span class="nf">blank?</span>
    <span class="nb">self</span>
  <span class="k">else</span>
    <span class="n">spawn</span><span class="p">.</span><span class="nf">where!</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在分析查询的过程中，我们会选择几个常见的方法作为入口，尽可能得覆盖较多的查询相关的代码，增加我们对 ActiveRecord 的理解和认识。</p>

<h3 id="从-userall-开始">从 User.all 开始</h3>

<p>再来看一下上面看到的 <code class="highlighter-rouge">ActiveRecord::Relation.all</code> 方法，无论是 <code class="highlighter-rouge">#current_scope</code> 还是 <code class="highlighter-rouge">#default_scoped</code> 其实返回的都是当前的 <code class="highlighter-rouge">ActiveRecord</code> 对象：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">all</span>
  <span class="k">if</span> <span class="n">current_scope</span>
    <span class="n">current_scope</span><span class="p">.</span><span class="nf">clone</span>
  <span class="k">else</span>
    <span class="n">default_scoped</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="current_scope-和-default_scope">current_scope 和 default_scope</h4>

<p>如果当前没有 <code class="highlighter-rouge">#current_scope</code> 那么，就会调用 <code class="highlighter-rouge">#default_scoped</code> 返回响应的结果，否则就会 clone 当前对象并返回，可以简单举一个例子证明这里的猜测：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">current_scope</span>
<span class="o">=&gt;</span> <span class="kp">nil</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">current_scope</span>
  <span class="no">User</span> <span class="no">Load</span> <span class="p">(</span><span class="mf">0.1</span><span class="n">ms</span><span class="p">)</span>  <span class="no">SELECT</span> <span class="s2">"users"</span><span class="p">.</span><span class="nf">*</span> <span class="no">FROM</span> <span class="s2">"users"</span>
<span class="o">=&gt;</span> <span class="p">[]</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">current_scope</span><span class="p">.</span><span class="nf">class</span>
<span class="o">=&gt;</span> <span class="no">User</span><span class="o">::</span><span class="no">ActiveRecord_Relation</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">.current_scope</code> 是存储在位于线程变量的 <code class="highlighter-rouge">ScopeRegistry</code> 中，它其实就是当前的查询语句的上下文，存储着这一次链式调用造成的全部副作用：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">current_scope</span><span class="p">(</span><span class="n">skip_inherited_scope</span> <span class="o">=</span> <span class="kp">false</span><span class="p">)</span>
  <span class="no">ScopeRegistry</span><span class="p">.</span><span class="nf">value_for</span><span class="p">(</span><span class="ss">:current_scope</span><span class="p">,</span> <span class="nb">self</span><span class="p">,</span> <span class="n">skip_inherited_scope</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>而 <code class="highlighter-rouge">.default_scoped</code> 就是在当前查询链刚开始时执行的第一个方法，因为在执行第一个查询方法之前 <code class="highlighter-rouge">.current_scope</code> 一定为空：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">default_scoped</span><span class="p">(</span><span class="n">scope</span> <span class="o">=</span> <span class="n">relation</span><span class="p">)</span>
  <span class="n">build_default_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span> <span class="o">||</span> <span class="n">scope</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">build_default_scope</span><span class="p">(</span><span class="n">base_rel</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="k">return</span> <span class="k">if</span> <span class="n">abstract_class?</span>

  <span class="k">if</span> <span class="n">default_scopes</span><span class="p">.</span><span class="nf">any?</span>
    <span class="n">base_rel</span> <span class="o">||=</span> <span class="n">relation</span>
    <span class="n">evaluate_default_scope</span> <span class="k">do</span>
      <span class="n">default_scopes</span><span class="p">.</span><span class="nf">inject</span><span class="p">(</span><span class="n">base_rel</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">default_scope</span><span class="p">,</span> <span class="n">scope</span><span class="o">|</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:to_proc</span><span class="p">)</span> <span class="p">?</span> <span class="n">scope</span> <span class="p">:</span> <span class="n">scope</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="ss">:call</span><span class="p">)</span>
        <span class="n">default_scope</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">base_rel</span><span class="p">.</span><span class="nf">instance_exec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scope</span><span class="p">))</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当我们在 Rails 的模型层中使用 <code class="highlighter-rouge">.default_scope</code> 定义一些默认的上下文时，所有的 block 都换被转换成 <code class="highlighter-rouge">Proc</code> 对象最终添加到 <code class="highlighter-rouge">default_scopes</code> 数组中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">default_scope</span><span class="p">(</span><span class="n">scope</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span> <span class="c1"># :doc:</span>
  <span class="n">scope</span> <span class="o">=</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="k">if</span> <span class="nb">block_given?</span>
  <span class="c1"># ...</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">default_scopes</span> <span class="o">+=</span> <span class="p">[</span><span class="n">scope</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上面提到的 <code class="highlighter-rouge">.build_default_scope</code> 方法其实只是在 <code class="highlighter-rouge">default_scopes</code> 数组不为空时，将当前的 <code class="highlighter-rouge">Relation</code> 对象和数组中的全部 scope 一一 <code class="highlighter-rouge">#merge</code> 并返回一个新的 <code class="highlighter-rouge">Relation</code> 对象。</p>

<h4 id="activerecordrelation-对象">ActiveRecord::Relation 对象</h4>

<p><code class="highlighter-rouge">.default_scoped</code> 方法的参数 <code class="highlighter-rouge">scope</code> 其实就有一个默认值 <code class="highlighter-rouge">#relation</code>，这个默认值其实就是一个 <code class="highlighter-rouge">Relation</code> 类的实例：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">relation</span>
  <span class="n">relation</span> <span class="o">=</span> <span class="no">Relation</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">arel_table</span><span class="p">,</span> <span class="n">predicate_builder</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">finder_needs_type_condition?</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ignore_default_scope?</span>
    <span class="n">relation</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">type_condition</span><span class="p">).</span><span class="nf">create_with</span><span class="p">(</span><span class="n">inheritance_column</span><span class="p">.</span><span class="nf">to_s</span> <span class="o">=&gt;</span> <span class="n">sti_name</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="n">relation</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Relation.create</code> 对象的创建过程其实比较复杂，我们只需要知道经过 ActiveRecord 一系列的疯狂操作，最终会将几个参数传入 <code class="highlighter-rouge">.new</code> 方法初始化一个 <code class="highlighter-rouge">ActiveRecord::Relation</code> 实例：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Relation</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">klass</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">predicate_builder</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="p">{})</span>
    <span class="vi">@klass</span>  <span class="o">=</span> <span class="n">klass</span>
    <span class="vi">@table</span>  <span class="o">=</span> <span class="n">table</span>
    <span class="vi">@values</span> <span class="o">=</span> <span class="n">values</span>
    <span class="vi">@offsets</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="vi">@loaded</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="vi">@predicate_builder</span> <span class="o">=</span> <span class="n">predicate_builder</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当执行的是 <code class="highlighter-rouge">#all</code>、<code class="highlighter-rouge">.all</code> 或者绝大多数查询方法时，都会直接将这个初始化的对象返回来接受随后的链式调用。</p>

<h3 id="where-方法">where 方法</h3>

<p>相比于 <code class="highlighter-rouge">#all</code>、<code class="highlighter-rouge">#where</code> 查询的实现就复杂多了，不像 <code class="highlighter-rouge">#all</code> 会返回一个默认的 <code class="highlighter-rouge">Relation</code> 对象，<code class="highlighter-rouge">#where</code> 由 <code class="highlighter-rouge">WhereClause</code> 以及 <code class="highlighter-rouge">WhereClauseFactory</code> 等类共同处理；在 <code class="highlighter-rouge">#where</code> 的最正常的执行路径中，它会执行 <code class="highlighter-rouge">#where!</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="n">opts</span> <span class="o">=</span> <span class="ss">:chain</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">)</span>
  <span class="k">if</span> <span class="ss">:chain</span> <span class="o">==</span> <span class="n">opts</span>
    <span class="no">WhereChain</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">spawn</span><span class="p">)</span>
  <span class="k">elsif</span> <span class="n">opts</span><span class="p">.</span><span class="nf">blank?</span>
    <span class="nb">self</span>
  <span class="k">else</span>
    <span class="n">spawn</span><span class="p">.</span><span class="nf">where!</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">where!</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span><span class="p">)</span>
  <span class="n">opts</span> <span class="o">=</span> <span class="n">sanitize_forbidden_attributes</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
  <span class="n">references!</span><span class="p">(</span><span class="no">PredicateBuilder</span><span class="p">.</span><span class="nf">references</span><span class="p">(</span><span class="n">opts</span><span class="p">))</span> <span class="k">if</span> <span class="no">Hash</span> <span class="o">===</span> <span class="n">opts</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">where_clause</span> <span class="o">+=</span> <span class="n">where_clause_factory</span><span class="p">.</span><span class="nf">build</span><span class="p">(</span><span class="n">opts</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span>
  <span class="nb">self</span>
<span class="k">end</span>
</code></pre></div></div>

<blockquote>
  <p><code class="highlighter-rouge">#spawn</code> 其实就是对当前的 <code class="highlighter-rouge">Relation</code> 对象进行 <code class="highlighter-rouge">#clone</code>。</p>
</blockquote>

<p>查询方法 <code class="highlighter-rouge">#where!</code> 中的四行代码只有一行代码是我们需要关注的，该方法调用 <code class="highlighter-rouge">WhereClauseFactory#build</code> 生成一条 where 查询并存储到当前对象的 <code class="highlighter-rouge">where_clause</code> 中，在这个过程中并不会生成 SQL，而是会生成一个 <code class="highlighter-rouge">WhereClause</code> 对象，其中存储着 SQL 节点树：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">name: </span><span class="s1">'draven'</span><span class="p">).</span><span class="nf">where_clause</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;ActiveRecord::Relation::WhereClause:0x007fe5a10bf2c8</span>
 <span class="vi">@binds</span><span class="o">=</span>
  <span class="p">[</span><span class="c1">#&lt;ActiveRecord::Relation::QueryAttribute:0x007fe5a10bf4f8</span>
    <span class="vi">@name</span><span class="o">=</span><span class="s2">"name"</span><span class="p">,</span>
    <span class="vi">@original_attribute</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span>
    <span class="vi">@type</span><span class="o">=</span><span class="c1">#&lt;ActiveModel::Type::String:0x007fe59d33f2e0 @limit=nil, @precision=nil, @scale=nil&gt;,</span>
    <span class="vi">@value_before_type_cast</span><span class="o">=</span><span class="s2">"draven"</span><span class="o">&gt;</span><span class="p">],</span>
 <span class="vi">@predicates</span><span class="o">=</span>
  <span class="p">[</span><span class="c1">#&lt;Arel::Nodes::Equality:0x007fe5a10bf368</span>
    <span class="vi">@left</span><span class="o">=</span>
     <span class="c1">#&lt;struct Arel::Attributes::Attribute</span>
      <span class="n">relation</span><span class="o">=</span>
       <span class="c1">#&lt;Arel::Table:0x007fe59cc87830</span>
        <span class="vi">@name</span><span class="o">=</span><span class="s2">"users"</span><span class="p">,</span>
        <span class="vi">@table_alias</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span>
        <span class="vi">@type_caster</span><span class="o">=</span>
         <span class="c1">#&lt;ActiveRecord::TypeCaster::Map:0x007fe59cc87bf0</span>
          <span class="vi">@types</span><span class="o">=</span>
           <span class="no">User</span><span class="p">(</span><span class="ss">id: </span><span class="n">integer</span><span class="p">,</span> <span class="ss">avatar: </span><span class="n">string</span><span class="p">,</span> <span class="ss">nickname: </span><span class="n">string</span><span class="p">,</span> <span class="ss">wechat: </span><span class="n">string</span><span class="p">,</span> <span class="ss">name: </span><span class="n">string</span><span class="p">,</span> <span class="ss">gender: </span><span class="n">integer</span><span class="p">,</span> <span class="ss">school: </span><span class="n">string</span><span class="p">,</span> <span class="ss">grade: </span><span class="n">string</span><span class="p">,</span> <span class="ss">major: </span><span class="n">string</span><span class="p">,</span> <span class="ss">completed: </span><span class="n">boolean</span><span class="p">,</span> <span class="ss">created_at: </span><span class="n">datetime</span><span class="p">,</span> <span class="ss">updated_at: </span><span class="n">datetime</span><span class="p">,</span> <span class="ss">mobile: </span><span class="n">string</span><span class="p">,</span> <span class="ss">admin: </span><span class="n">boolean</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">,</span>
      <span class="nb">name</span><span class="o">=</span><span class="s2">"name"</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="vi">@right</span><span class="o">=</span><span class="c1">#&lt;Arel::Nodes::BindParam:0x007fe5a10bf520&gt;&gt;]&gt;</span>
</code></pre></div></div>

<blockquote>
  <p><a href="https://github.com/rails/arel">Arel</a> 是一个 Ruby 的 SQL 抽象语法树的管理器，ActiveRecord 查询的过程都是惰性的，在真正进入数据库查询之前，查询条件都是以语法树的形式存储的。</p>
</blockquote>

<p>在这里不像展开介绍 SQL 语法树的生成过程，因为过程比较复杂，详细分析也没有太大的意义。</p>

<h3 id="order-方法">order 方法</h3>

<p>除了 <code class="highlighter-rouge">#where</code> 方法之外，在这里还想简单介绍一下另外一个常用的方法 <code class="highlighter-rouge">#order</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">order</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">check_if_method_has_arguments!</span><span class="p">(</span><span class="ss">:order</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
  <span class="n">spawn</span><span class="p">.</span><span class="nf">order!</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">order!</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">preprocess_order_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">order_values</span> <span class="o">+=</span> <span class="n">args</span>
  <span class="nb">self</span>
<span class="k">end</span>
</code></pre></div></div>

<p>该方法的调用栈与 <code class="highlighter-rouge">#where</code> 非常相似，在调用栈中都会执行另一个带有 <code class="highlighter-rouge">!</code> 的方法，也都会向自己持有的某个『属性』追加一些参数，参数的处理也有点复杂，在这里简单看一看就好：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">preprocess_order_args</span><span class="p">(</span><span class="n">order_args</span><span class="p">)</span>
  <span class="n">order_args</span><span class="p">.</span><span class="nf">map!</span> <span class="k">do</span> <span class="o">|</span><span class="n">arg</span><span class="o">|</span>
    <span class="n">klass</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="ss">:sanitize_sql_for_order</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">order_args</span><span class="p">.</span><span class="nf">flatten!</span>
  <span class="n">validate_order_args</span><span class="p">(</span><span class="n">order_args</span><span class="p">)</span>

  <span class="n">references</span> <span class="o">=</span> <span class="n">order_args</span><span class="p">.</span><span class="nf">grep</span><span class="p">(</span><span class="no">String</span><span class="p">)</span>
  <span class="n">references</span><span class="p">.</span><span class="nf">map!</span> <span class="p">{</span> <span class="o">|</span><span class="n">arg</span><span class="o">|</span> <span class="n">arg</span> <span class="o">=~</span> <span class="sr">/^([a-zA-Z]\w*)\.(\w+)/</span> <span class="o">&amp;&amp;</span> <span class="vg">$1</span> <span class="p">}.</span><span class="nf">compact!</span>
  <span class="n">references!</span><span class="p">(</span><span class="n">references</span><span class="p">)</span> <span class="k">if</span> <span class="n">references</span><span class="p">.</span><span class="nf">any?</span>

  <span class="c1"># if a symbol is given we prepend the quoted table name</span>
  <span class="n">order_args</span><span class="p">.</span><span class="nf">map!</span> <span class="k">do</span> <span class="o">|</span><span class="n">arg</span><span class="o">|</span>
    <span class="k">case</span> <span class="n">arg</span>
    <span class="k">when</span> <span class="no">Symbol</span>
      <span class="n">arel_attribute</span><span class="p">(</span><span class="n">arg</span><span class="p">).</span><span class="nf">asc</span>
    <span class="k">when</span> <span class="no">Hash</span>
      <span class="n">arg</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">field</span><span class="p">,</span> <span class="n">dir</span><span class="o">|</span>
        <span class="k">case</span> <span class="n">field</span>
        <span class="k">when</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Nodes</span><span class="o">::</span><span class="no">SqlLiteral</span>
          <span class="n">field</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">dir</span><span class="p">.</span><span class="nf">downcase</span><span class="p">)</span>
        <span class="k">else</span>
          <span class="n">arel_attribute</span><span class="p">(</span><span class="n">field</span><span class="p">).</span><span class="nf">send</span><span class="p">(</span><span class="n">dir</span><span class="p">.</span><span class="nf">downcase</span><span class="p">)</span>
        <span class="k">end</span>
      <span class="p">}</span>
    <span class="k">else</span>
      <span class="n">arg</span>
    <span class="k">end</span>
  <span class="k">end</span><span class="p">.</span><span class="nf">flatten!</span>
<span class="k">end</span>
</code></pre></div></div>

<p>同样的，<code class="highlighter-rouge">#order</code> 方法的使用也会向 <code class="highlighter-rouge">order_values</code> 数组中添加对应的语法元素：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">name: :desc</span><span class="p">).</span><span class="nf">order_values</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="c1">#&lt;Arel::Nodes::Descending:0x007fe59ce4f190</span>
  <span class="vi">@expr</span><span class="o">=</span>
   <span class="c1">#&lt;struct Arel::Attributes::Attribute</span>
    <span class="n">relation</span><span class="o">=</span>
     <span class="c1">#&lt;Arel::Table:0x007fe59cc87830</span>
      <span class="vi">@name</span><span class="o">=</span><span class="s2">"users"</span><span class="p">,</span>
      <span class="vi">@table_alias</span><span class="o">=</span><span class="kp">nil</span><span class="p">,</span>
      <span class="vi">@type_caster</span><span class="o">=</span>
       <span class="c1">#&lt;ActiveRecord::TypeCaster::Map:0x007fe59cc87bf0</span>
        <span class="vi">@types</span><span class="o">=</span>
         <span class="no">User</span><span class="p">(</span><span class="ss">id: </span><span class="n">integer</span><span class="p">,</span> <span class="ss">avatar: </span><span class="n">string</span><span class="p">,</span> <span class="ss">nickname: </span><span class="n">string</span><span class="p">,</span> <span class="ss">wechat: </span><span class="n">string</span><span class="p">,</span> <span class="ss">name: </span><span class="n">string</span><span class="p">,</span> <span class="ss">gender: </span><span class="n">integer</span><span class="p">,</span> <span class="ss">school: </span><span class="n">string</span><span class="p">,</span> <span class="ss">grade: </span><span class="n">string</span><span class="p">,</span> <span class="ss">major: </span><span class="n">string</span><span class="p">,</span> <span class="ss">completed: </span><span class="n">boolean</span><span class="p">,</span> <span class="ss">created_at: </span><span class="n">datetime</span><span class="p">,</span> <span class="ss">updated_at: </span><span class="n">datetime</span><span class="p">,</span> <span class="ss">mobile: </span><span class="n">string</span><span class="p">,</span> <span class="ss">admin: </span><span class="n">boolean</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="nb">name</span><span class="o">=</span><span class="ss">:name</span><span class="o">&gt;&gt;</span><span class="p">]</span>
</code></pre></div></div>

<p>在这个方法的返回值中，我们也能看到与 Arel 相关的各种节点，可以大致理解上述语法树的作用。</p>

<h3 id="语法树的存储">语法树的存储</h3>

<p>无论是 <code class="highlighter-rouge">#where</code> 还是 <code class="highlighter-rouge">#order</code> 方法，它们其实都会向当前的 <code class="highlighter-rouge">Relation</code> 对象中追加相应的语法树节点，而除了上述的两个方法之外 <code class="highlighter-rouge">#from</code>、<code class="highlighter-rouge">#distinct</code>、<code class="highlighter-rouge">#lock</code>、<code class="highlighter-rouge">#limit</code> 等等，几乎所有的查询方法都会改变 <code class="highlighter-rouge">Relation</code> 中的某个值，然而所有的值其实都是通过 <code class="highlighter-rouge">@values</code> 这个实例变量存储的：</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-relation-value-methods.png" alt="activerecord-relation-value-methods" /></p>

<p><code class="highlighter-rouge">@values</code> 中存储的值分为三类，<code class="highlighter-rouge">SINGLE_VALUE</code>、<code class="highlighter-rouge">MULTI_VALUE</code> 和 <code class="highlighter-rouge">CLAUSE</code>，这三类属性会按照下面的规则存储在 <code class="highlighter-rouge">@values</code> 中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Relation</span><span class="o">::</span><span class="no">VALUE_METHODS</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span>
  <span class="n">method_name</span> <span class="o">=</span> <span class="p">\</span>
    <span class="k">case</span> <span class="nb">name</span>
    <span class="k">when</span> <span class="o">*</span><span class="no">Relation</span><span class="o">::</span><span class="no">MULTI_VALUE_METHODS</span> <span class="k">then</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">_values"</span>
    <span class="k">when</span> <span class="o">*</span><span class="no">Relation</span><span class="o">::</span><span class="no">SINGLE_VALUE_METHODS</span> <span class="k">then</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">_value"</span>
    <span class="k">when</span> <span class="o">*</span><span class="no">Relation</span><span class="o">::</span><span class="no">CLAUSE_METHODS</span> <span class="k">then</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">_clause"</span>
    <span class="k">end</span>
  <span class="nb">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
    def </span><span class="si">#{</span><span class="n">method_name</span><span class="si">}</span><span class="sh">                   # def includes_values
      get_value(</span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="sh">)         #   get_value(:includes)
    end                                  # end

    def </span><span class="si">#{</span><span class="n">method_name</span><span class="si">}</span><span class="sh">=(value)           # def includes_values=(value)
      set_value(</span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="sh">, value)  #   set_value(:includes, value)
    end                                  # end
</span><span class="no">  CODE</span>
<span class="k">end</span>
</code></pre></div></div>

<p>各种不同的值在最后都会按照一定的命名规则，存储在这个 <code class="highlighter-rouge">@values</code> 字典中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="vi">@values</span><span class="p">[</span><span class="nb">name</span><span class="p">]</span> <span class="o">||</span> <span class="n">default_value_for</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
  <span class="n">assert_mutability!</span>
  <span class="vi">@values</span><span class="p">[</span><span class="nb">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果我们直接在一个查询链中访问 <code class="highlighter-rouge">#values</code> 方法可以获得其中存储的所有查询条件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">name: </span><span class="s1">'draven'</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="ss">name: :desc</span><span class="p">).</span><span class="nf">values</span>
<span class="o">=&gt;</span> <span class="p">{</span><span class="ss">:references</span><span class="o">=&gt;</span><span class="p">[],</span>
 <span class="ss">:where</span><span class="o">=&gt;</span>
  <span class="c1">#&lt;ActiveRecord::Relation::WhereClause:0x007fe59d14d860&gt;,</span>
 <span class="ss">:order</span><span class="o">=&gt;</span>
  <span class="p">[</span><span class="c1">#&lt;Arel::Nodes::Descending:0x007fe59d14cd98&gt;]}</span>
</code></pre></div></div>

<p>很多 ActiveRecord 的使用者其实在使用的过程中都感觉在各种链式方法调用时没有改变任何事情，所有的方法都可以任意组合进行链式调用，其实每一个方法的调用都会对 <code class="highlighter-rouge">@values</code> 中存储的信息进行了修改，只是 ActiveRecord 很好地将它隐藏了幕后，让我们没有感知到它的存在。</p>

<h3 id="scope-方法">scope 方法</h3>

<p>相比于 <code class="highlighter-rouge">.default_scope</code> 这个类方法只是改变了当前模型中的 <code class="highlighter-rouge">default_scopes</code> 数组，另一个方法 <code class="highlighter-rouge">.scope</code> 会为当前类定义一个新的类方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">scoping</span><span class="o">/</span><span class="n">named</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">155</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Scoping</span><span class="o">::</span><span class="no">Named</span><span class="o">::</span><span class="no">ClassMethods</span>

<span class="k">def</span> <span class="nf">scope</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">extension</span> <span class="o">=</span> <span class="no">Module</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="k">if</span> <span class="n">block</span>

  <span class="k">if</span> <span class="n">body</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:to_proc</span><span class="p">)</span>
    <span class="n">singleton_class</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="ss">:define_method</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span> <span class="k">do</span> <span class="o">|*</span><span class="n">args</span><span class="o">|</span>
      <span class="n">scope</span> <span class="o">=</span> <span class="n">all</span><span class="p">.</span><span class="nf">scoping</span> <span class="p">{</span> <span class="n">instance_exec</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">body</span><span class="p">)</span> <span class="p">}</span>
      <span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span><span class="p">.</span><span class="nf">extending</span><span class="p">(</span><span class="n">extension</span><span class="p">)</span> <span class="k">if</span> <span class="n">extension</span>
      <span class="n">scope</span> <span class="o">||</span> <span class="n">all</span>
    <span class="k">end</span>
  <span class="k">else</span>
    <span class="n">singleton_class</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="ss">:define_method</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span> <span class="k">do</span> <span class="o">|*</span><span class="n">args</span><span class="o">|</span>
      <span class="n">scope</span> <span class="o">=</span> <span class="n">all</span><span class="p">.</span><span class="nf">scoping</span> <span class="p">{</span> <span class="n">body</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="p">}</span>
      <span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span><span class="p">.</span><span class="nf">extending</span><span class="p">(</span><span class="n">extension</span><span class="p">)</span> <span class="k">if</span> <span class="n">extension</span>
      <span class="n">scope</span> <span class="o">||</span> <span class="n">all</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法会直接在当前类的单类上通过 <code class="highlighter-rouge">define_methods</code> 为当前类定义类方法，定义的方法会在上面提到的 <code class="highlighter-rouge">.all</code> 的返回结果上执行 <code class="highlighter-rouge">#scoping</code>，存储当前执行的上下文，执行传入的 block，再恢复 <code class="highlighter-rouge">current_scope</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">scoping</span>
  <span class="n">previous</span><span class="p">,</span> <span class="n">klass</span><span class="p">.</span><span class="nf">current_scope</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">current_scope</span><span class="p">(</span><span class="kp">true</span><span class="p">),</span> <span class="nb">self</span>
  <span class="k">yield</span>
<span class="k">ensure</span>
  <span class="n">klass</span><span class="p">.</span><span class="nf">current_scope</span> <span class="o">=</span> <span class="n">previous</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这里其实有一个可能很多人从来没用过的特性，就是在 <code class="highlighter-rouge">.scope</code> 方法中传入一个 block：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span>
  <span class="n">scope</span> <span class="ss">:male</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span> <span class="ss">gender: :male</span> <span class="p">}</span> <span class="k">do</span>
    <span class="k">def</span> <span class="nf">twenty</span>
      <span class="n">where</span> <span class="ss">age: </span><span class="mi">20</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">male</span><span class="p">.</span><span class="nf">twenty</span>
<span class="c1">#=&gt; &lt;#User:0x007f98f3d61c38&gt;</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">twenty</span>
<span class="c1">#=&gt; NoMethodError: undefined method `twenty' for #&lt;Class:0x007f98f5c7b2b8&gt;</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">User</span><span class="p">.</span><span class="nf">female</span><span class="p">.</span><span class="nf">twenty</span>
<span class="c1">#=&gt; NoMethodError: undefined method `twenty' for #&lt;User::ActiveRecord_Relation:0x007f98f5d950e0&gt;</span>
</code></pre></div></div>

<p>这个传入的 block 只会在当前 <code class="highlighter-rouge">Relation</code> 对象的单类上添加方法，如果我们想定义一些不想在其他作用域使用的方法就可以使用这种方式：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">extending</span><span class="p">(</span><span class="o">*</span><span class="n">modules</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">modules</span><span class="p">.</span><span class="nf">any?</span> <span class="o">||</span> <span class="n">block</span>
    <span class="n">spawn</span><span class="p">.</span><span class="nf">extending!</span><span class="p">(</span><span class="o">*</span><span class="n">modules</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="k">else</span>
    <span class="nb">self</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">extending!</span><span class="p">(</span><span class="o">*</span><span class="n">modules</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">modules</span> <span class="o">&lt;&lt;</span> <span class="no">Module</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="k">if</span> <span class="n">block</span>
  <span class="n">modules</span><span class="p">.</span><span class="nf">flatten!</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">extending_values</span> <span class="o">+=</span> <span class="n">modules</span>
  <span class="kp">extend</span><span class="p">(</span><span class="o">*</span><span class="n">extending_values</span><span class="p">)</span> <span class="k">if</span> <span class="n">extending_values</span><span class="p">.</span><span class="nf">any?</span>
  <span class="nb">self</span>
<span class="k">end</span>
</code></pre></div></div>

<p>而 <code class="highlighter-rouge">extending</code> 方法的实现确实与我们预期的一样，创建了新的 <code class="highlighter-rouge">Module</code> 对象之后，直接使用 <code class="highlighter-rouge">#extend</code> 将其中的方法挂载当前对象的单类上。</p>

<h3 id="小结-1">小结</h3>

<p>到这里为止，我们对 ActiveRecord 中查询的分析就已经比较全面了，从最终要的 <code class="highlighter-rouge">Relation</code> 对象，到常见的 <code class="highlighter-rouge">#all</code>、<code class="highlighter-rouge">#where</code> 和 <code class="highlighter-rouge">#order</code> 方法，到 ActiveRecord 对语法树的存储，如何与 Arel 进行协作，在最后我们也介绍了 <code class="highlighter-rouge">.scope</code> 方法的工作原理，对于其它方法或者功能的实现其实也都大同小异，在这里就不展开细谈了。</p>

<h2 id="模型的关系">模型的关系</h2>

<p>作为一个关系型数据库的 ORM，ActiveRecord 一定要提供对模型之间关系的支持，它为模型之间的关系建立提供了四个类方法 <code class="highlighter-rouge">has_many</code>、<code class="highlighter-rouge">has_one</code>、<code class="highlighter-rouge">belongs_to</code> 和 <code class="highlighter-rouge">has_and_belongs_to_many</code>，在文章的这一部分，我们会从上面几个方法中选择一部分介绍 ActiveRecord 是如何建立模型之间的关系的。</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-associations.png" alt="activerecord-associations" /></p>

<h3 id="association-和继承链">Association 和继承链</h3>

<p>首先来看 <code class="highlighter-rouge">.has_many</code> 方法是如何实现的，我们可以通过 pry 直接找到该方法的源代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="no">User</span><span class="p">.</span><span class="nf">has_many</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">associations</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">1401</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Associations</span><span class="o">::</span><span class="no">ClassMethods</span>

<span class="k">def</span> <span class="nf">has_many</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">scope</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{},</span> <span class="o">&amp;</span><span class="n">extension</span><span class="p">)</span>
  <span class="n">reflection</span> <span class="o">=</span> <span class="no">Builder</span><span class="o">::</span><span class="no">HasMany</span><span class="p">.</span><span class="nf">build</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extension</span><span class="p">)</span>
  <span class="no">Reflection</span><span class="p">.</span><span class="nf">add_reflection</span> <span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">reflection</span>
<span class="k">end</span>
</code></pre></div></div>

<p>整个 <code class="highlighter-rouge">.has_many</code> 方法的实现也只有两行代码，总共涉及两个类 <code class="highlighter-rouge">Builder::HasMany</code> 和 <code class="highlighter-rouge">Reflection</code>，其中前者用于创建新的 <code class="highlighter-rouge">HasMany</code> 关系，后者负责将关系添加到当前类中。</p>

<p><code class="highlighter-rouge">HasMany</code> 类的实现其实非常简单，但是它从父类和整个继承链中继承了很多方法：</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-hasmany-ancestors.png" alt="activerecord-hasmany-ancestors" /></p>

<p>我们暂时先忘记 <code class="highlighter-rouge">.has_many</code> 方法的实现，先来看一下这里涉及的两个非常重要的类都是如何工作的，首先是 <code class="highlighter-rouge">Association</code> 以及它的子类；在 ActiveRecord 的实现中，我们其实能够找到四种关系的 Builder，它们有着非常清晰简单的继承关系：</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-ancestor-builders.png" alt="activerecord-ancestor-builders" /></p>

<p>在这里定义的 <code class="highlighter-rouge">.build</code> 方法其实实现也很清晰，它通过调用当前抽象类 <code class="highlighter-rouge">Association</code> 或者子类的响应方法完成一些建立关系必要的工作：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">build</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">extension</span> <span class="o">=</span> <span class="n">define_extensions</span> <span class="n">model</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span>
  <span class="n">reflection</span> <span class="o">=</span> <span class="n">create_reflection</span> <span class="n">model</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">extension</span>
  <span class="n">define_accessors</span> <span class="n">model</span><span class="p">,</span> <span class="n">reflection</span>
  <span class="n">define_callbacks</span> <span class="n">model</span><span class="p">,</span> <span class="n">reflection</span>
  <span class="n">define_validations</span> <span class="n">model</span><span class="p">,</span> <span class="n">reflection</span>
  <span class="n">reflection</span>
<span class="k">end</span>
</code></pre></div></div>

<p>其中包括创建用于操作、查询和管理当前关系扩展 Module 的 <code class="highlighter-rouge">.define_extensions</code> 方法，同时也会使用 <code class="highlighter-rouge">.create_reflection</code> 创建一个用于检查 ActiveRecord 类的关系的 <code class="highlighter-rouge">Reflection</code> 对象，我们会在下一节中展开介绍，在创建了 <code class="highlighter-rouge">Reflection</code> 后，我们会根据传入的模型和 <code class="highlighter-rouge">Reflection</code> 对象为当前的类，例如 <code class="highlighter-rouge">User</code> 定义属性存取方法、回调以及验证:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_accessors</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">reflection</span><span class="p">)</span>
  <span class="n">mixin</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="nf">generated_association_methods</span>
  <span class="nb">name</span> <span class="o">=</span> <span class="n">reflection</span><span class="p">.</span><span class="nf">name</span>
  <span class="n">define_readers</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
  <span class="n">define_writers</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_readers</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
  <span class="n">mixin</span><span class="p">.</span><span class="nf">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
    def </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">(*args)
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).reader(*args)
    end
</span><span class="no">  CODE</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_writers</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
  <span class="n">mixin</span><span class="p">.</span><span class="nf">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
    def </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">=(value)
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).writer(value)
    end
</span><span class="no">  CODE</span>
<span class="k">end</span>
</code></pre></div></div>

<p>存取方法还是通过 Ruby 的元编程能力定义的，在这里通过 <code class="highlighter-rouge">.class_eval</code> 方法非常轻松地就能在当前的模型中定义方法，关于回调和验证的定义在这里就不在展开介绍了。</p>

<h3 id="reflection-和继承链">Reflection 和继承链</h3>

<p><code class="highlighter-rouge">Reflection</code> 启用了检查 ActiveRecord 类和对象的关系和聚合的功能，它能够在 Builder 中使用为 ActiveRecord 中的类创建对应属性和方法。</p>

<p>与 <code class="highlighter-rouge">Association</code> 一样，ActiveRecord 中的不同关系也有不同的 <code class="highlighter-rouge">Reflection</code>，根据不同的关系和不同的配置，ActiveRecord 中建立了一套 Reflection 的继承体系与数据库中的不同关系一一对应：</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-reflections.png" alt="activerecord-reflections" /></p>

<p>当我们在上面使用 <code class="highlighter-rouge">.has_many</code> 方法时，会通过 <code class="highlighter-rouge">.create_reflection</code> 创建一个 <code class="highlighter-rouge">HasManyReflection</code> 对象：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">create_reflection</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">extension</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">scope</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Hash</span><span class="p">)</span>
    <span class="n">options</span> <span class="o">=</span> <span class="n">scope</span>
    <span class="n">scope</span>   <span class="o">=</span> <span class="kp">nil</span>
  <span class="k">end</span>

  <span class="n">validate_options</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
  <span class="n">scope</span> <span class="o">=</span> <span class="n">build_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="n">extension</span><span class="p">)</span>
  <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Reflection</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="n">macro</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">model</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Reflection#create</code> 方法是一个工厂方法，它会根据传入的 <code class="highlighter-rouge">macro</code> 和 <code class="highlighter-rouge">options</code> 中的值选择合适的类实例化：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">create</span><span class="p">(</span><span class="n">macro</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">ar</span><span class="p">)</span>
  <span class="n">klass</span> <span class="o">=</span> <span class="p">\</span>
    <span class="k">case</span> <span class="n">macro</span>
    <span class="k">when</span> <span class="ss">:composed_of</span>
      <span class="no">AggregateReflection</span>
    <span class="k">when</span> <span class="ss">:has_many</span>
      <span class="no">HasManyReflection</span>
    <span class="k">when</span> <span class="ss">:has_one</span>
      <span class="no">HasOneReflection</span>
    <span class="k">when</span> <span class="ss">:belongs_to</span>
      <span class="no">BelongsToReflection</span>
    <span class="k">else</span>
      <span class="k">raise</span> <span class="s2">"Unsupported Macro: </span><span class="si">#{</span><span class="n">macro</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>

  <span class="n">reflection</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">ar</span><span class="p">)</span>
  <span class="n">options</span><span class="p">[</span><span class="ss">:through</span><span class="p">]</span> <span class="p">?</span> <span class="no">ThroughReflection</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">reflection</span><span class="p">)</span> <span class="p">:</span> <span class="n">reflection</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这个创建的 <code class="highlighter-rouge">Reflection</code> 在很多时候都有非常重要的作用，在创建存储方法、回调和验证时，都需要将这个对象作为参数传入提供一定的支持，起到了数据源和提供 Helper 方法的作用。</p>

<p>在整个定义方法、属性以及回调的工作完成之后，会将当前的对象以 <code class="highlighter-rouge">name</code> 作为键存储到自己持有的一个 <code class="highlighter-rouge">_reflections</code> 字典中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># class_attribute :_reflections, instance_writer: false</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">add_reflection</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">reflection</span><span class="p">)</span>
  <span class="n">ar</span><span class="p">.</span><span class="nf">clear_reflections_cache</span>
  <span class="n">ar</span><span class="p">.</span><span class="nf">_reflections</span> <span class="o">=</span> <span class="n">ar</span><span class="p">.</span><span class="nf">_reflections</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span> <span class="o">=&gt;</span> <span class="n">reflection</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这个字典中存储着所有在当前类中使用 <code class="highlighter-rouge">has_many</code>、<code class="highlighter-rouge">has_one</code>、<code class="highlighter-rouge">belongs_to</code> 等方法定义的关系对应的映射。</p>

<h3 id="一对多关系">一对多关系</h3>

<p>一对多关系的这一节会分别介绍两个极其重要的方法 <code class="highlighter-rouge">.has_many</code> 和 <code class="highlighter-rouge">.belongs_to</code> 的实现；在这里，会先通过 <code class="highlighter-rouge">.has_many</code> 关系了解它是如何通过覆写父类方法定制自己的特性的，之后会通过 <code class="highlighter-rouge">.belongs_to</code> 研究 getter/setter 方法的调用栈。</p>

<p><img src="https://img.draveness.me/2017-10-21-one-to-many-association.png" alt="one-to-many-association" /></p>

<p>一对多关系在数据库的模型之间非常常见，而这两个方法在 ActiveRecord 也经常成对出现。</p>

<h4 id="has_many">has_many</h4>

<p>当我们对构建关系模块的两大支柱都已经有所了解之后，再来看这几个常用的方法就没有太多的难度了，首先来看一下一对多关系中的『多』是怎么实现的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">has_many</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">scope</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{},</span> <span class="o">&amp;</span><span class="n">extension</span><span class="p">)</span>
  <span class="n">reflection</span> <span class="o">=</span> <span class="no">Builder</span><span class="o">::</span><span class="no">HasMany</span><span class="p">.</span><span class="nf">build</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extension</span><span class="p">)</span>
  <span class="no">Reflection</span><span class="p">.</span><span class="nf">add_reflection</span> <span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">reflection</span>
<span class="k">end</span>
</code></pre></div></div>

<p>由于已经对 <code class="highlighter-rouge">Reflection.add_reflection</code> 方法的实现有所了解，所以这里直接看 <code class="highlighter-rouge">.has_many</code> 调用的 <code class="highlighter-rouge">Builder::HasMany.build</code> 方法的实现就可以知道这个类方法究竟做了什么，：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">build</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="n">extension</span> <span class="o">=</span> <span class="n">define_extensions</span> <span class="n">model</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span>
  <span class="n">reflection</span> <span class="o">=</span> <span class="n">create_reflection</span> <span class="n">model</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">extension</span>
  <span class="n">define_accessors</span> <span class="n">model</span><span class="p">,</span> <span class="n">reflection</span>
  <span class="n">define_callbacks</span> <span class="n">model</span><span class="p">,</span> <span class="n">reflection</span>
  <span class="n">define_validations</span> <span class="n">model</span><span class="p">,</span> <span class="n">reflection</span>
  <span class="n">reflection</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这里执行的 <code class="highlighter-rouge">.build</code> 方法与抽象类中的方法实现完全相同，子类并没有覆盖父类实现的方法，我们来找一下 <code class="highlighter-rouge">.define_accessors</code>、<code class="highlighter-rouge">.define_callbacks</code> 和 <code class="highlighter-rouge">.define_validations</code> 三个方法在 has_many 关系中都做了什么。</p>

<p><code class="highlighter-rouge">HasMany</code> 作为 has_many 关系的 Builder 类，其本身并没有实现太多的方法，只是对一些关系选项有一些自己独有的声明：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">ActiveRecord::Associations::Builder</span>
  <span class="k">class</span> <span class="nc">HasMany</span> <span class="o">&lt;</span> <span class="no">CollectionAssociation</span>
    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">macro</span>
      <span class="ss">:has_many</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">valid_options</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
      <span class="k">super</span> <span class="o">+</span> <span class="p">[</span><span class="ss">:primary_key</span><span class="p">,</span> <span class="ss">:dependent</span><span class="p">,</span> <span class="ss">:as</span><span class="p">,</span> <span class="ss">:through</span><span class="p">,</span> <span class="ss">:source</span><span class="p">,</span> <span class="ss">:source_type</span><span class="p">,</span> <span class="ss">:inverse_of</span><span class="p">,</span> <span class="ss">:counter_cache</span><span class="p">,</span> <span class="ss">:join_table</span><span class="p">,</span> <span class="ss">:foreign_type</span><span class="p">,</span> <span class="ss">:index_errors</span><span class="p">]</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">valid_dependent_options</span>
      <span class="p">[</span><span class="ss">:destroy</span><span class="p">,</span> <span class="ss">:delete_all</span><span class="p">,</span> <span class="ss">:nullify</span><span class="p">,</span> <span class="ss">:restrict_with_error</span><span class="p">,</span> <span class="ss">:restrict_with_exception</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>由于本身 has_many 关系中的读写方法都是对集合的操作，所以首先覆写了 <code class="highlighter-rouge">.define_writers</code> 和 <code class="highlighter-rouge">.define_readers</code> 两个方法生成了另外一组操作 id 的 getter/setter 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_readers</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
  <span class="k">super</span>

  <span class="n">mixin</span><span class="p">.</span><span class="nf">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
    def </span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">singularize</span><span class="si">}</span><span class="sh">_ids
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).ids_reader
    end
</span><span class="no">  CODE</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_writers</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
  <span class="k">super</span>

  <span class="n">mixin</span><span class="p">.</span><span class="nf">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
    def </span><span class="si">#{</span><span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">singularize</span><span class="si">}</span><span class="sh">_ids=(ids)
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).ids_writer(ids)
    end
</span><span class="no">  CODE</span>
<span class="k">end</span>
</code></pre></div></div>

<p>has_many 关系在 <code class="highlighter-rouge">CollectionAssociation</code> 和 <code class="highlighter-rouge">HasManyAssociation</code> 中实现的几个方法 <code class="highlighter-rouge">#reader</code>、<code class="highlighter-rouge">#writer</code>、<code class="highlighter-rouge">#ids_reader</code> 和 <code class="highlighter-rouge">#ids_writer</code> 其实还是比较复杂的，在这里就跳过不谈了。</p>

<p>而 <code class="highlighter-rouge">.define_callbacks</code> 和 <code class="highlighter-rouge">.define_extensions</code> 其实都大同小异，在作者看来没有什么值得讲的，has_many 中最重要的部分还是读写方法的实现过程，不过由于篇幅所限这里就不多说了。</p>

<h4 id="belongs_to">belongs_to</h4>

<p>在一对多关系中，经常与 has_many 对应的关系 belongs_to 其实实现和调用栈也几乎完全相同：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">belongs_to</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">scope</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="n">reflection</span> <span class="o">=</span> <span class="no">Builder</span><span class="o">::</span><span class="no">BelongsTo</span><span class="p">.</span><span class="nf">build</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
  <span class="no">Reflection</span><span class="p">.</span><span class="nf">add_reflection</span> <span class="nb">self</span><span class="p">,</span> <span class="nb">name</span><span class="p">,</span> <span class="n">reflection</span>
<span class="k">end</span>
</code></pre></div></div>

<p>但是与 has_many 比较大的不同是 <code class="highlighter-rouge">Builder::BelongsTo</code> 通过继承的父类定义了很多用于创建新关系的方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_accessors</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">reflection</span><span class="p">)</span>
  <span class="k">super</span>
  <span class="n">mixin</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="nf">generated_association_methods</span>
  <span class="nb">name</span> <span class="o">=</span> <span class="n">reflection</span><span class="p">.</span><span class="nf">name</span>
  <span class="n">define_constructors</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span> <span class="k">if</span> <span class="n">reflection</span><span class="p">.</span><span class="nf">constructable?</span>
  <span class="n">mixin</span><span class="p">.</span><span class="nf">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
    def reload_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).force_reload_reader
    end
</span><span class="no">  CODE</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">define_constructors</span><span class="p">(</span><span class="n">mixin</span><span class="p">,</span> <span class="nb">name</span><span class="p">)</span>
  <span class="n">mixin</span><span class="p">.</span><span class="nf">class_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
    def build_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">(*args, &amp;block)
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).build(*args, &amp;block)
    end
    def create_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">(*args, &amp;block)
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).create(*args, &amp;block)
    end
    def create_</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">!(*args, &amp;block)
      association(:</span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="sh">).create!(*args, &amp;block)
    end
</span><span class="no">  CODE</span>
<span class="k">end</span>
</code></pre></div></div>

<p>其他的部分虽然实现上也与 has_many 有着非常大的不同，但是原理基本上完全一致，不过在这里我们可以来看一下 belongs_to 关系创建的两个方法 <code class="highlighter-rouge">association</code> 和 <code class="highlighter-rouge">association=</code> 究竟是如何对数据库进行操作的。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Topic</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:subtopics</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Subtopic</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:topic</span>
<span class="k">end</span>
</code></pre></div></div>

<p>假设我们有着如上所示的两个模型，它们之间是一对多关系，我们以这对模型为例先来看一下 <code class="highlighter-rouge">association</code> 这个读方法的调用栈。</p>

<p><img src="https://img.draveness.me/2017-10-21-callstack-for-belongs-to-association-getter.png" alt="callstack-for-belongs-to-association-gette" /></p>

<p>通过我们对源代码和调用栈的阅读，我们可以发现其实如下的所有方法调用在大多数情况下是完全等价的，假设我们已经持有了一个 <code class="highlighter-rouge">Subtopic</code> 对象：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">subtopic</span> <span class="o">=</span> <span class="no">Subtopic</span><span class="p">.</span><span class="nf">first</span> <span class="c1">#=&gt; #&lt;Subtopic:0x007ff513f67768&gt;</span>

<span class="n">subtopic</span><span class="p">.</span><span class="nf">topic</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">reader</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">target</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">load_target</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">send</span><span class="p">(</span><span class="ss">:find_target</span><span class="p">)</span>
</code></pre></div></div>

<p>上述的五种方式都可以获得当前 <code class="highlighter-rouge">Subtopic</code> 对象的 belongs_to 关系对应的 <code class="highlighter-rouge">Topic</code> 数据行，而最后一个方法 <code class="highlighter-rouge">#find_target</code> 其实也就是真正创建、绑定到最后执行查询 SQL 的方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">find_target</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">associations</span><span class="o">/</span><span class="n">singular_association</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">38</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Associations</span><span class="o">::</span><span class="no">SingularAssociation</span>

<span class="k">def</span> <span class="nf">find_target</span>
  <span class="k">return</span> <span class="n">scope</span><span class="p">.</span><span class="nf">take</span> <span class="k">if</span> <span class="n">skip_statement_cache?</span>

  <span class="n">conn</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">connection</span>
  <span class="n">sc</span> <span class="o">=</span> <span class="n">reflection</span><span class="p">.</span><span class="nf">association_scope_cache</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">owner</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">StatementCache</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">params</span><span class="o">|</span>
      <span class="n">as</span> <span class="o">=</span> <span class="no">AssociationScope</span><span class="p">.</span><span class="nf">create</span> <span class="p">{</span> <span class="n">params</span><span class="p">.</span><span class="nf">bind</span> <span class="p">}</span>
      <span class="n">target_scope</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">as</span><span class="p">.</span><span class="nf">scope</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">conn</span><span class="p">)).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="k">end</span>

  <span class="n">binds</span> <span class="o">=</span> <span class="no">AssociationScope</span><span class="p">.</span><span class="nf">get_bind_values</span><span class="p">(</span><span class="n">owner</span><span class="p">,</span> <span class="n">reflection</span><span class="p">.</span><span class="nf">chain</span><span class="p">)</span>
  <span class="n">sc</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="n">binds</span><span class="p">,</span> <span class="n">klass</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">record</span><span class="o">|</span>
    <span class="n">set_inverse_instance</span> <span class="n">record</span>
  <span class="k">end</span><span class="p">.</span><span class="nf">first</span>
<span class="k">rescue</span> <span class="o">::</span><span class="no">RangeError</span>
  <span class="kp">nil</span>
<span class="k">end</span>
</code></pre></div></div>

<p>我们已经对 <code class="highlighter-rouge">association</code> 方法的实现有了非常清楚的认知了，下面再来过一下 <code class="highlighter-rouge">association=</code> 方法的实现，首先还是来看一下 setter 方法的调用栈：</p>

<p><img src="https://img.draveness.me/2017-10-21-callstack-for-belongs-to-association-setter.png" alt="callstack-for-belongs-to-association-sette" /></p>

<p>相比于 getter 的调用栈，setter 方法的调用栈都复杂了很多，在研究 setter 方法实现的过程中我们一定要记住这个方法并不会改变数据库中对应的数据行，只会改变当前对应的某个属性，经过对调用栈和源代码的分析，我们可以有以下的结论：假设现在有一个 <code class="highlighter-rouge">Subtopic</code> 对象和一个新的 <code class="highlighter-rouge">Topic</code> 实例，那么下面的一系列操作其实是完全相同的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">subtopic</span> <span class="o">=</span> <span class="no">Subtopic</span><span class="p">.</span><span class="nf">first</span> <span class="c1">#=&gt; #&lt;Subtopic:0x007ff513f67768&gt;</span>
<span class="n">new_topic</span> <span class="o">=</span> <span class="no">Topic</span><span class="p">.</span><span class="nf">first</span>   <span class="c1">#=&gt; #&lt;Topic:0x007ff514b24cb8&gt;</span>

<span class="n">subtopic</span><span class="p">.</span><span class="nf">topic</span> <span class="o">=</span> <span class="n">new_topic</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">topic_id</span> <span class="o">=</span> <span class="n">new_topic</span><span class="p">.</span><span class="nf">id</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">writer</span><span class="p">(</span><span class="n">new_topic</span><span class="p">)</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">replace</span><span class="p">(</span><span class="n">new_topic</span><span class="p">)</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">replace_keys</span><span class="p">(</span><span class="n">new_topic</span><span class="p">)</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">association</span><span class="p">(</span><span class="ss">:topic</span><span class="p">).</span><span class="nf">owner</span><span class="p">[</span><span class="ss">:topic_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_topic</span><span class="p">.</span><span class="nf">id</span>
<span class="n">subtopic</span><span class="p">[</span><span class="ss">:topic_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_topic</span><span class="p">.</span><span class="nf">id</span>
<span class="n">subtopic</span><span class="p">.</span><span class="nf">write_attribute</span><span class="p">(</span><span class="ss">:topic_id</span><span class="p">,</span> <span class="n">new_topic</span><span class="p">.</span><span class="nf">id</span><span class="p">)</span>
</code></pre></div></div>

<p>虽然这些方法最后返回的结果可能有所不同，但是它们最终都会将 <code class="highlighter-rouge">subtopic</code> 对象的 <code class="highlighter-rouge">topic_id</code> 属性更新成 <code class="highlighter-rouge">topic.id</code>，上面的方法中有简单的，也有复杂的，不过都能达到相同的目的；我相信如果读者亲手创建上述的关系并使用 pry 查看源代码一定会对 getter 和 setter 的执行过程有着非常清楚的认识。</p>

<h3 id="多对多关系-habtm">多对多关系 habtm</h3>

<p>无论是 has_many 还是 belongs_to 其实都是一个 ORM 原生需要支持的关系，但是 habtm(has_and_belongs_to_many) 却是 ActiveRecord 为我们提供的一个非常方便的语法糖，哪怕是并没有 <code class="highlighter-rouge">.has_and_belongs_to_many</code> 这个方法，我们也能通过 <code class="highlighter-rouge">.has_many</code> 实现多对多关系，得到与前者完全等价的效果，只是实现的过程稍微麻烦一些。</p>

<p>在这一小节中，我们想要了解 habtm 这个语法糖是如何工作的，它是如何将现有的关系组成更复杂的 habtm 的多对多关系的；想要了解它的工作原理，我们自然要分析它的源代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">has_and_belongs_to_many</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">scope</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extension</span><span class="p">)</span>
  <span class="n">builder</span> <span class="o">=</span> <span class="no">Builder</span><span class="o">::</span><span class="no">HasAndBelongsToMany</span><span class="p">.</span><span class="nf">new</span> <span class="nb">name</span><span class="p">,</span> <span class="nb">self</span><span class="p">,</span> <span class="n">options</span>
  <span class="n">join_model</span> <span class="o">=</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Deprecation</span><span class="p">.</span><span class="nf">silence</span> <span class="p">{</span> <span class="n">builder</span><span class="p">.</span><span class="nf">through_model</span> <span class="p">}</span>
  <span class="nb">const_set</span> <span class="n">join_model</span><span class="p">.</span><span class="nf">name</span><span class="p">,</span> <span class="n">join_model</span>
  <span class="n">private_constant</span> <span class="n">join_model</span><span class="p">.</span><span class="nf">name</span>

  <span class="n">habtm_reflection</span> <span class="o">=</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Reflection</span><span class="o">::</span><span class="no">HasAndBelongsToManyReflection</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="nb">self</span><span class="p">)</span>
  <span class="n">middle_reflection</span> <span class="o">=</span> <span class="n">builder</span><span class="p">.</span><span class="nf">middle_reflection</span> <span class="n">join_model</span>
  <span class="no">Builder</span><span class="o">::</span><span class="no">HasMany</span><span class="p">.</span><span class="nf">define_callbacks</span> <span class="nb">self</span><span class="p">,</span> <span class="n">middle_reflection</span>
  <span class="no">Reflection</span><span class="p">.</span><span class="nf">add_reflection</span> <span class="nb">self</span><span class="p">,</span> <span class="n">middle_reflection</span><span class="p">.</span><span class="nf">name</span><span class="p">,</span> <span class="n">middle_reflection</span>
  <span class="n">middle_reflection</span><span class="p">.</span><span class="nf">parent_reflection</span> <span class="o">=</span> <span class="n">habtm_reflection</span>

  <span class="c1"># ...</span>

  <span class="n">hm_options</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="n">hm_options</span><span class="p">[</span><span class="ss">:through</span><span class="p">]</span> <span class="o">=</span> <span class="n">middle_reflection</span><span class="p">.</span><span class="nf">name</span>
  <span class="n">hm_options</span><span class="p">[</span><span class="ss">:source</span><span class="p">]</span> <span class="o">=</span> <span class="n">join_model</span><span class="p">.</span><span class="nf">right_reflection</span><span class="p">.</span><span class="nf">name</span>

  <span class="c1"># ...</span>

  <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Deprecation</span><span class="p">.</span><span class="nf">silence</span> <span class="p">{</span> <span class="n">has_many</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">hm_options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extension</span> <span class="p">}</span>
  <span class="n">_reflections</span><span class="p">[</span><span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">].</span><span class="nf">parent_reflection</span> <span class="o">=</span> <span class="n">habtm_reflection</span>
<span class="k">end</span>
</code></pre></div></div>

<blockquote>
  <p>在这里，我们对该方法的源代码重新进行组织和排序，方法的作用与 v5.1.4 中的完全相同。</p>
</blockquote>

<p>上述方法在最开始先创建了一个 <code class="highlighter-rouge">HasAndBelongsToMany</code> 的 Builder 实例，然后在 block 中执行了这个 Builder 的 <code class="highlighter-rouge">#through_model</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">through_model</span>
  <span class="n">habtm</span> <span class="o">=</span> <span class="no">JoinTableResolver</span><span class="p">.</span><span class="nf">build</span> <span class="n">lhs_model</span><span class="p">,</span> <span class="n">association_name</span><span class="p">,</span> <span class="n">options</span>

  <span class="n">join_model</span> <span class="o">=</span> <span class="no">Class</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span><span class="p">;</span>
      <span class="nb">attr_accessor</span> <span class="ss">:left_model</span>
      <span class="nb">attr_accessor</span> <span class="ss">:name</span>
      <span class="nb">attr_accessor</span> <span class="ss">:table_name_resolver</span>
      <span class="nb">attr_accessor</span> <span class="ss">:left_reflection</span>
      <span class="nb">attr_accessor</span> <span class="ss">:right_reflection</span>
    <span class="k">end</span>

    <span class="c1"># ...</span>
  <span class="p">}</span>

  <span class="n">join_model</span><span class="p">.</span><span class="nf">name</span>                <span class="o">=</span> <span class="s2">"HABTM_</span><span class="si">#{</span><span class="n">association_name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">camelize</span><span class="si">}</span><span class="s2">"</span>
  <span class="n">join_model</span><span class="p">.</span><span class="nf">table_name_resolver</span> <span class="o">=</span> <span class="n">habtm</span>
  <span class="n">join_model</span><span class="p">.</span><span class="nf">left_model</span>          <span class="o">=</span> <span class="n">lhs_model</span>
  <span class="n">join_model</span><span class="p">.</span><span class="nf">add_left_association</span> <span class="ss">:left_side</span><span class="p">,</span> <span class="ss">anonymous_class: </span><span class="n">lhs_model</span>
  <span class="n">join_model</span><span class="p">.</span><span class="nf">add_right_association</span> <span class="n">association_name</span><span class="p">,</span> <span class="n">belongs_to_options</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
  <span class="n">join_model</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">#through_model</code> 方法会返回一个新的继承自 <code class="highlighter-rouge">ActiveRecord::Base</code> 的类，我们通过一下的例子来说明一下这里究竟做了什么，假设在我们的工程中定义了如下的两个类：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:tags</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Tag</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_and_belongs_to_many</span> <span class="ss">:posts</span>
<span class="k">end</span>
</code></pre></div></div>

<p>它们每个类都通过 <code class="highlighter-rouge">.has_and_belongs_to_many</code> 创建了一个 <code class="highlighter-rouge">join_model</code> 类，这两个类都是在当前类的命名空间下的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Post</span><span class="o">::</span><span class="no">HABTM_Posts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">;</span> <span class="k">end</span>
<span class="k">class</span> <span class="nc">Tags</span><span class="o">::</span><span class="no">HABTM_Posts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">;</span> <span class="k">end</span>
</code></pre></div></div>

<p>除了在当前类的命名空间下定义两个新的类之外，<code class="highlighter-rouge">#through_model</code> 方法还通过 <code class="highlighter-rouge">#add_left_association</code> 和 <code class="highlighter-rouge">#add_right_association</code> 为创建的私有类添加了两个 <code class="highlighter-rouge">.belongs_to</code> 方法的调用：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">join_model</span> <span class="o">=</span> <span class="no">Class</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1"># ...</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">add_left_association</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="n">belongs_to</span> <span class="nb">name</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">left_reflection</span> <span class="o">=</span> <span class="n">_reflect_on_association</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">add_right_association</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
    <span class="n">rhs_name</span> <span class="o">=</span> <span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">singularize</span><span class="p">.</span><span class="nf">to_sym</span>
    <span class="n">belongs_to</span> <span class="n">rhs_name</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">right_reflection</span> <span class="o">=</span> <span class="n">_reflect_on_association</span><span class="p">(</span><span class="n">rhs_name</span><span class="p">)</span>
  <span class="k">end</span>
<span class="p">}</span>
</code></pre></div></div>

<p>所以在这里，每一个 HABTM 类中都通过 <code class="highlighter-rouge">.belongs_to</code> 增加了两个对数据库表中对应列的映射：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Post</span><span class="o">::</span><span class="no">HABTM_Posts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:post_id</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span>
  <span class="n">belongs_to</span> <span class="ss">:tag_id</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Tags</span><span class="o">::</span><span class="no">HABTM_Posts</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:tag_id</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span>
  <span class="n">belongs_to</span> <span class="ss">:post_id</span><span class="p">,</span> <span class="ss">required: </span><span class="kp">false</span>
<span class="k">end</span>
</code></pre></div></div>

<p>看到这里，你可能会认为既然有两个模型，那么应该会有两张表分别对应这两个模型，但是实际情况却不是这样。</p>

<p><img src="https://img.draveness.me/2017-10-21-habtm-association-table-name.png" alt="habtm-association-table-name" /></p>

<p>ActiveRecord 通过覆写这两个类的 <code class="highlighter-rouge">.table_name</code> 方法，使用一个 <code class="highlighter-rouge">JoinTableResolver</code> 来解决不同的模型拥有相同的数据库表的问题：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Migration</span>
  <span class="k">module</span> <span class="nn">JoinTable</span>
    <span class="k">def</span> <span class="nf">join_table_name</span><span class="p">(</span><span class="n">table_1</span><span class="p">,</span> <span class="n">table_2</span><span class="p">)</span>
      <span class="no">ModelSchema</span><span class="p">.</span><span class="nf">derive_join_table_name</span><span class="p">(</span><span class="n">table_1</span><span class="p">,</span> <span class="n">table_2</span><span class="p">).</span><span class="nf">to_sym</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">module</span> <span class="nn">ModelSchema</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">derive_join_table_name</span><span class="p">(</span><span class="n">first_table</span><span class="p">,</span> <span class="n">second_table</span><span class="p">)</span> 
    <span class="p">[</span><span class="n">first_table</span><span class="p">.</span><span class="nf">to_s</span><span class="p">,</span> <span class="n">second_table</span><span class="p">.</span><span class="nf">to_s</span><span class="p">].</span><span class="nf">sort</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s2">"</span><span class="se">\0</span><span class="s2">"</span><span class="p">).</span><span class="nf">gsub</span><span class="p">(</span><span class="sr">/^(.*_)(.+)\0\1(.+)/</span><span class="p">,</span> <span class="s1">'\1\2_\3'</span><span class="p">).</span><span class="nf">tr</span><span class="p">(</span><span class="s2">"</span><span class="se">\0</span><span class="s2">"</span><span class="p">,</span> <span class="s2">"_"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在默认的 <code class="highlighter-rouge">join_table</code> 规则中，两张表会按照字母顺序排序，最后通过 <code class="highlighter-rouge">_</code> 连接到一起，但是如果两张表有着完全相同的前缀，比如 music_artists 和 music_records 两张表，它们连接的结果就是 music_artists_records，公共的前缀会被删除，这种情况经常发生在包含命名空间的模型中，例如：<code class="highlighter-rouge">Music::Artist</code>。</p>

<p>当我们已经通过多对多关系的 Builder 创建了一个中间模型之后，就会建立两个 <code class="highlighter-rouge">Reflection</code> 对象：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">habtm_reflection</span> <span class="o">=</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Reflection</span><span class="o">::</span><span class="no">HasAndBelongsToManyReflection</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="nb">self</span><span class="p">)</span>
<span class="n">middle_reflection</span> <span class="o">=</span> <span class="n">builder</span><span class="p">.</span><span class="nf">middle_reflection</span> <span class="n">join_model</span>
<span class="no">Builder</span><span class="o">::</span><span class="no">HasMany</span><span class="p">.</span><span class="nf">define_callbacks</span> <span class="nb">self</span><span class="p">,</span> <span class="n">middle_reflection</span>
<span class="no">Reflection</span><span class="p">.</span><span class="nf">add_reflection</span> <span class="nb">self</span><span class="p">,</span> <span class="n">middle_reflection</span><span class="p">.</span><span class="nf">name</span><span class="p">,</span> <span class="n">middle_reflection</span>
<span class="n">middle_reflection</span><span class="p">.</span><span class="nf">parent_reflection</span> <span class="o">=</span> <span class="n">habtm_reflection</span>
</code></pre></div></div>

<p>其中一个对象是 <code class="highlighter-rouge">HasAndBelongsToManyReflection</code> 实例，表示当前的多对多关系，另一个对象是 <code class="highlighter-rouge">#middle_reflection</code> 方法返回的 <code class="highlighter-rouge">HasMany</code>，表示当前的类与 <code class="highlighter-rouge">join_model</code> 之间有一个一对多关系，这个关系是隐式的，不过我们可以通过下面的代码来『理解』它：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># has_and_belongs_to_many :posts</span>
  <span class="c1"># =</span>
  <span class="n">has_many</span> <span class="ss">:posts_tag</span>
  <span class="c1"># + </span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述的代码构成了整个多对多关系的一部分，而另一部分由下面的代码来处理，当模型持有了一个跟中间模型相关的一对多关系之后，就会创建另一个以中间模型为桥梁 has_many 关系：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hm_options</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">hm_options</span><span class="p">[</span><span class="ss">:through</span><span class="p">]</span> <span class="o">=</span> <span class="n">middle_reflection</span><span class="p">.</span><span class="nf">name</span>
<span class="n">hm_options</span><span class="p">[</span><span class="ss">:source</span><span class="p">]</span> <span class="o">=</span> <span class="n">join_model</span><span class="p">.</span><span class="nf">right_reflection</span><span class="p">.</span><span class="nf">name</span>

<span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Deprecation</span><span class="p">.</span><span class="nf">silence</span> <span class="p">{</span> <span class="n">has_many</span> <span class="nb">name</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">hm_options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extension</span> <span class="p">}</span>
</code></pre></div></div>

<p>这里还是使用 <code class="highlighter-rouge">Post</code> 和 <code class="highlighter-rouge">Tag</code> 这两个模型之间的关系举例子，通过上述代码，我们会在两个类中分别建立如下的关系：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># has_many :posts_tag</span>
  <span class="n">has_many</span> <span class="ss">:tags</span><span class="p">,</span> <span class="ss">through: :posts_tag</span><span class="p">,</span> <span class="ss">source: :tag</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Tag</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># has_many :tags_post</span>
  <span class="n">has_many</span> <span class="ss">:post</span><span class="p">,</span> <span class="ss">through: :tags_post</span><span class="p">,</span> <span class="ss">source: :post</span>
<span class="k">end</span>
</code></pre></div></div>

<p>通过两个隐式的 has_many 关系，两个显示的 has_many 就能够通过 <code class="highlighter-rouge">through</code> 和 <code class="highlighter-rouge">source</code> 间接找到自己对应的多个数据行，而从开发者的角度来看，整个工程中只使用了一行代码 <code class="highlighter-rouge">has_and_belongs_to_many :models</code>，其他的工作完全都是隐式的。</p>

<p><img src="https://img.draveness.me/2017-10-21-many-to-many-associations.png" alt="many-to-many-associations" /></p>

<p>由于关系型数据库其实并没有物理上的多对多关系，只有在逻辑上才能实现多对多，所以对于每一个模型来说，它实现的都是一对多关系；只有从整体来看，通过 <code class="highlighter-rouge">PostsTags</code> 第三张表的引入，我们实现的才是从 <code class="highlighter-rouge">Post</code> 到 <code class="highlighter-rouge">Tag</code> 之间的多对多关系。</p>

<h3 id="小结-2">小结</h3>

<p>ActiveRecord 对关系的支持其实非常全面，从最常见的一对一、一对多关系，再到多对多关系，都有着非常优雅、简洁的实现，虽然这一小节中没能全面的介绍所有关系的实现，但是对整个模块中重要类和整体架构的介绍已经非常具体了；不得不感叹 ActiveRecord 对多对多关系方法 <code class="highlighter-rouge">has_and_belongs_to_many</code> 的实现非常整洁，我们在分析其实现时也非常顺畅。</p>

<h2 id="migrations-任务和执行过程">Migrations 任务和执行过程</h2>

<p>Migrations（迁移）是 ActiveRecord 提供的一种用于更改数据库 Schema 的方式，它提供了可以直接操作数据库的 DSL，这样我们就不需要自己去手写所有的 SQL 来更新数据库中的表结构了。</p>

<p><img src="https://img.draveness.me/2017-10-21-activerecord-migrations.png" alt="activerecord-migrations" /></p>

<p>每一个 Migration 都具有一个唯一的时间戳，每次进行迁移时都会在现有的数据库中执行当前 Migration 文件的 DSL 更新数据库 Schema 得到新的数据库版本。而想要理解 Migrations 是如何工作的，就需要知道 <code class="highlighter-rouge">#create_table</code>、<code class="highlighter-rouge">#add_column</code> 等 DSL 是怎么实现的。</p>

<h3 id="migration51">Migration[5.1]</h3>

<p>我在使用 ActiveRecord 提供的数据库迁移的时候一直都特别好奇 <code class="highlighter-rouge">Migration[5.1]</code> 后面跟着的这个 <code class="highlighter-rouge">[5.1]</code> 是个什么工作原理，看了源代码之后我才知道：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Migration</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">[]</span><span class="p">(</span><span class="n">version</span><span class="p">)</span>
    <span class="no">Compatibility</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">version</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">.[]</code> 是 <code class="highlighter-rouge">ActiveRecord::Migration</code> 的类方法，它通过执行 <code class="highlighter-rouge">Compatibility.find</code> 来判断当前的代码中使用的数据库迁移版本是否与 gem 中的版本兼容：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Current</span> <span class="o">&lt;</span> <span class="no">Migration</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">compatibility.rb</code> 在兼容性方面做了很多事情，保证 ActiveRecord 中的迁移都是可以向前兼容的，在这里也就不准备介绍太多了。</p>

<h3 id="从-rake-dbmigrate-开始">从 rake db:migrate 开始</h3>

<p>作者在阅读迁移部分的源代码时最开始以 <code class="highlighter-rouge">Migration</code> 类作为入口，结果发现这并不是一个好的选择，最终也没能找到定义 DSL 的位置，所以重新选择了 <code class="highlighter-rouge">rake db:migrate</code> 作为入口分析迁移的实现；通过对工程目录的分析，很快就能发现 ActiveRecord 中所有的 rake 命令都位于 <code class="highlighter-rouge">lib/railties/database.rake</code> 文件中，在文件中也能找到 <code class="highlighter-rouge">db:migrate</code> 对应的 rake 任务：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">db_namespace</span> <span class="o">=</span> <span class="n">namespace</span> <span class="ss">:db</span> <span class="k">do</span>
  <span class="n">desc</span> <span class="s2">"Migrate the database (options: VERSION=x, VERBOSE=false, SCOPE=blog)."</span>
  <span class="n">task</span> <span class="ss">migrate: </span><span class="p">[</span><span class="ss">:environment</span><span class="p">,</span> <span class="ss">:load_config</span><span class="p">]</span> <span class="k">do</span>
    <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Tasks</span><span class="o">::</span><span class="no">DatabaseTasks</span><span class="p">.</span><span class="nf">migrate</span>
    <span class="n">db_namespace</span><span class="p">[</span><span class="s2">"_dump"</span><span class="p">].</span><span class="nf">invoke</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述代码中的 <code class="highlighter-rouge">DatabaseTasks</code> 类就包含在 <code class="highlighter-rouge">lib/active_record/tasks</code> 目录中的 <code class="highlighter-rouge">database_tasks.rb</code> 文件里：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">tasks</span><span class="o">/</span>
<span class="err">├──</span> <span class="n">database_tasks</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">├──</span> <span class="n">mysql_database_tasks</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">├──</span> <span class="n">postgresql_database_tasks</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">└──</span> <span class="n">sqlite_database_tasks</span><span class="p">.</span><span class="nf">rb</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">#migrate</code> 方法就是 <code class="highlighter-rouge">DatabaseTasks</code> 的一个实例方法，同时 ActiveRecord 通过 <code class="highlighter-rouge">extend self</code> 将 <code class="highlighter-rouge">#migrate</code> 方法添加到了当前类的单类上，成为了当前类的类方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Tasks</span>
  <span class="k">module</span> <span class="nn">DatabaseTasks</span>
    <span class="kp">extend</span> <span class="nb">self</span>
    
    <span class="k">def</span> <span class="nf">migrate</span>
      <span class="k">raise</span> <span class="s2">"Empty VERSION provided"</span> <span class="k">if</span> <span class="no">ENV</span><span class="p">[</span><span class="s2">"VERSION"</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="no">ENV</span><span class="p">[</span><span class="s2">"VERSION"</span><span class="p">].</span><span class="nf">empty?</span>

      <span class="n">version</span> <span class="o">=</span> <span class="no">ENV</span><span class="p">[</span><span class="s2">"VERSION"</span><span class="p">]</span> <span class="p">?</span> <span class="no">ENV</span><span class="p">[</span><span class="s2">"VERSION"</span><span class="p">].</span><span class="nf">to_i</span> <span class="p">:</span> <span class="kp">nil</span>
      <span class="n">scope</span> <span class="o">=</span> <span class="no">ENV</span><span class="p">[</span><span class="s2">"SCOPE"</span><span class="p">]</span>
      <span class="no">Migrator</span><span class="p">.</span><span class="nf">migrate</span><span class="p">(</span><span class="n">migrations_paths</span><span class="p">,</span> <span class="n">version</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">migration</span><span class="o">|</span>
        <span class="n">scope</span><span class="p">.</span><span class="nf">blank?</span> <span class="o">||</span> <span class="n">scope</span> <span class="o">==</span> <span class="n">migration</span><span class="p">.</span><span class="nf">scope</span>
      <span class="k">end</span>
      <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span><span class="p">.</span><span class="nf">clear_cache!</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="迁移器migrator">『迁移器』Migrator</h4>

<p>迁移任务中主要使用了 <code class="highlighter-rouge">Migrator.migrate</code> 方法，通过传入迁移文件的路径和期望的迁移版本对数据库进行迁移：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Migrator</span><span class="c1">#:nodoc:</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
    <span class="k">def</span> <span class="nf">migrate</span><span class="p">(</span><span class="n">migrations_paths</span><span class="p">,</span> <span class="n">target_version</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
      <span class="k">case</span>
      <span class="k">when</span> <span class="n">target_version</span><span class="p">.</span><span class="nf">nil?</span>
        <span class="n">up</span><span class="p">(</span><span class="n">migrations_paths</span><span class="p">,</span> <span class="n">target_version</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
      <span class="k">when</span> <span class="n">current_version</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">target_version</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">[]</span>
      <span class="k">when</span> <span class="n">current_version</span> <span class="o">&gt;</span> <span class="n">target_version</span>
        <span class="n">down</span><span class="p">(</span><span class="n">migrations_paths</span><span class="p">,</span> <span class="n">target_version</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
      <span class="k">else</span>
        <span class="n">up</span><span class="p">(</span><span class="n">migrations_paths</span><span class="p">,</span> <span class="n">target_version</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在默认情况下，显然我们是不会传入目标的数据库版本的，也就是 <code class="highlighter-rouge">target_version.nil? == true</code>，这时会执行 <code class="highlighter-rouge">.up</code> 方法，对数据库向『上』迁移：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">up</span><span class="p">(</span><span class="n">migrations_paths</span><span class="p">,</span> <span class="n">target_version</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="n">migrations</span> <span class="o">=</span> <span class="n">migrations</span><span class="p">(</span><span class="n">migrations_paths</span><span class="p">)</span>
  <span class="n">migrations</span><span class="p">.</span><span class="nf">select!</span> <span class="p">{</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="k">yield</span> <span class="n">m</span> <span class="p">}</span> <span class="k">if</span> <span class="nb">block_given?</span>

  <span class="n">new</span><span class="p">(</span><span class="ss">:up</span><span class="p">,</span> <span class="n">migrations</span><span class="p">,</span> <span class="n">target_version</span><span class="p">).</span><span class="nf">migrate</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="方法调用栈">方法调用栈</h4>

<p>通过 <code class="highlighter-rouge">.new</code> 方法 ActiveRecord 初始化了一个新的 <code class="highlighter-rouge">Migrator</code> 实例，然后执行了 <code class="highlighter-rouge">Migrator#migrate</code>，在整个迁移执行的过程中，我们有以下的方法调用栈：</p>

<p><img src="https://img.draveness.me/2017-10-21-rake-db-migrate.png" alt="rake-db-migrate" /></p>

<p>在整个迁移过程的调用栈中，我们会关注以下的四个部分，首先是 <code class="highlighter-rouge">Migrator#migrate_without_lock</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">migrate_without_lock</span>
  <span class="k">if</span> <span class="n">invalid_target?</span>
    <span class="k">raise</span> <span class="no">UnknownMigrationVersionError</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vi">@target_version</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">runnable</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">migration</span><span class="o">|</span>
    <span class="n">execute_migration_in_transaction</span><span class="p">(</span><span class="n">migration</span><span class="p">,</span> <span class="vi">@direction</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">record_environment</span>
  <span class="n">result</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这个方法其实并没有那么重要，但是这里调用了 <code class="highlighter-rouge">Migrator#runnable</code> 方法，这个无参的方法返回了所有需要运行的 <code class="highlighter-rouge">Migration</code> 文件，<code class="highlighter-rouge">Migrator#runnable</code> 是如何选择需要迁移的文件是作者比较想要了解的，也是作者认为比较重要的地方：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">runnable</span>
  <span class="n">runnable</span> <span class="o">=</span> <span class="n">migrations</span><span class="p">[</span><span class="n">start</span><span class="o">..</span><span class="n">finish</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">up?</span>
    <span class="n">runnable</span><span class="p">.</span><span class="nf">reject</span> <span class="p">{</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">ran?</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">else</span>
    <span class="n">runnable</span><span class="p">.</span><span class="nf">pop</span> <span class="k">if</span> <span class="n">target</span>
    <span class="n">runnable</span><span class="p">.</span><span class="nf">find_all</span> <span class="p">{</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">ran?</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">ran?</span><span class="p">(</span><span class="n">migration</span><span class="p">)</span>
  <span class="n">migrated</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="n">migration</span><span class="p">.</span><span class="nf">version</span><span class="p">.</span><span class="nf">to_i</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>通过对这个方法的阅读的分析，我们可以看到，如果迁移模式是 <code class="highlighter-rouge">:up</code>，那么就会选择所有未迁移的文件，也就是说在这时<strong>迁移文件的选择与创建的顺序是无关的</strong>。</p>

<h4 id="迁移的执行">迁移的执行</h4>

<p>当我们通过 <code class="highlighter-rouge">#runnable</code> 获得了整个待运行的迁移文件数组之后，就可以遍历所有的文件一次执行 <code class="highlighter-rouge">Migrator#execute_migrate_in_transaction</code> 方法了，在调用栈的最后会执行 <code class="highlighter-rouge">Migration#exec_migration</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">exec_migration</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span>
  <span class="vi">@connection</span> <span class="o">=</span> <span class="n">conn</span>
  <span class="k">if</span> <span class="nb">respond_to?</span><span class="p">(</span><span class="ss">:change</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="ss">:down</span>
      <span class="n">revert</span> <span class="p">{</span> <span class="n">change</span> <span class="p">}</span>
    <span class="k">else</span>
      <span class="n">change</span>
    <span class="k">end</span>
  <span class="k">else</span>
    <span class="nb">send</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">ensure</span>
  <span class="vi">@connection</span> <span class="o">=</span> <span class="kp">nil</span>
<span class="k">end</span>
</code></pre></div></div>

<p>到这里就能与我们平时在 <code class="highlighter-rouge">Migration</code> 中实现的 <code class="highlighter-rouge">#change</code>、<code class="highlighter-rouge">#up</code> 和 <code class="highlighter-rouge">#down</code> 连到一起，逻辑也走通了；上述代码的逻辑还是很清晰的，如果当前的 <code class="highlighter-rouge">Migratoin</code> 实现了 <code class="highlighter-rouge">#change</code> 方法就会根据 <code class="highlighter-rouge">direction</code> 选择执行 <code class="highlighter-rouge">#change</code> 还是 <code class="highlighter-rouge">#revert + #change</code>，否则就会按照迁移的方向执行对应的方法。</p>

<h3 id="migrations-的-dsl">Migrations 的 DSL</h3>

<p>在数据迁移的模块执行的 Migration 文件中包含的都是 ActiveRecord 提供的 DSL 语法，这部分语法包含两部分，一部分是 Schema 相关的 DSL <code class="highlighter-rouge">schema_statements.rb</code>，其中包括表格的创建和删除以及一些用于辅助 Schema 创建的 <code class="highlighter-rouge">#column_exists?</code> 等方法，另一部分是表定义相关的 DSL <code class="highlighter-rouge">schema_definitions.rb</code>，其中包括处理表结构的 <code class="highlighter-rouge">TableDefinition</code> 类和抽象代表一张数据库中表的 <code class="highlighter-rouge">Table</code> 类。</p>

<h4 id="抽象适配器">抽象适配器</h4>

<p>在整个 <code class="highlighter-rouge">connection_adapters</code> 的子模块中，绝大多数模块在三大 SQL 数据库，MySQL、PostgreSQL 和 sqlite3 中都有着各自的实现：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lib</span><span class="o">/</span><span class="n">active_record</span><span class="o">/</span><span class="n">connection_adapters</span>
<span class="err">├──</span> <span class="n">abstract</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">connection_pool</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">database_limits</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">database_statements</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">query_cache</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">quoting</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">savepoints</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_creation</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_definitions</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_dumper</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_statements</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">└──</span> <span class="n">transaction</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">├──</span> <span class="n">mysql</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">column</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">database_statements</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">explain_pretty_printer</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">quoting</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_creation</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_definitions</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_dumper</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">├──</span> <span class="n">schema_statements</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">│  </span> <span class="err">└──</span> <span class="n">type_metadata</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">├──</span> <span class="n">postgresql</span>
<span class="err">│  </span> <span class="err">└──</span> <span class="o">...</span>
<span class="err">├──</span> <span class="n">sqlite3</span>
<span class="err">│  </span> <span class="err">└──</span> <span class="o">...</span>
<span class="err">├──</span> <span class="n">abstract_adapter</span><span class="p">.</span><span class="nf">rb</span>
<span class="err">├──</span> <span class="o">...</span>
<span class="err">└──</span> <span class="n">sqlite3_adapter</span><span class="p">.</span><span class="nf">rb</span>
</code></pre></div></div>

<p>不过这三个数据库的所有子模块都继承自 <code class="highlighter-rouge">AbstractAdapter</code> 下面对应的子模块，以获得一些三者共用的能力，包括数据库、Schema 的声明与管理等功能。</p>

<p><img src="https://img.draveness.me/2017-10-21-abstract-adapter-and-much-more.png" alt="abstract-adapter-and-much-more" /></p>

<p>通过 <code class="highlighter-rouge">AbstractAdapter</code> 抽离出的公用功能，我们可以通过新的适配器随时适配其他的 SQL 数据库。</p>

<h4 id="schema-dsl">Schema DSL</h4>

<p>数据库的 Schema DSL 部分就包含我们经常使用的 <code class="highlighter-rouge">#create_table</code>、<code class="highlighter-rouge">#rename_table</code> 以及 <code class="highlighter-rouge">#add_column</code> 这些需要表名才能执行的方法，在这里以最常见的 <code class="highlighter-rouge">#create_table</code> 为例，简单分析一下这部分代码的实现：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">create_table</span><span class="p">(</span><span class="n">table_name</span><span class="p">,</span> <span class="ss">comment: </span><span class="kp">nil</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
  <span class="n">td</span> <span class="o">=</span> <span class="n">create_table_definition</span> <span class="n">table_name</span><span class="p">,</span> <span class="n">options</span><span class="p">[</span><span class="ss">:temporary</span><span class="p">],</span> <span class="n">options</span><span class="p">[</span><span class="ss">:options</span><span class="p">],</span> <span class="n">options</span><span class="p">[</span><span class="ss">:as</span><span class="p">],</span> <span class="ss">comment: </span><span class="n">comment</span>

  <span class="k">yield</span> <span class="n">td</span> <span class="k">if</span> <span class="nb">block_given?</span>

  <span class="n">execute</span> <span class="n">schema_creation</span><span class="p">.</span><span class="nf">accept</span> <span class="n">td</span>
<span class="k">end</span>
</code></pre></div></div>

<p>首先，在创建表时先通过 <code class="highlighter-rouge">#create_table_definition</code> 方法创建一个新的 <code class="highlighter-rouge">TableDefinition</code> 实例，然后将这个实例作为参数传入 block：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">create_table</span> <span class="ss">:users</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 block 对这个 <code class="highlighter-rouge">TableDefinition</code> 对象一顿操作后，会通过 <code class="highlighter-rouge">SchemaCreation#accept</code> 方法获得一个用于在数据库中，能够创建表的 SQL 语句：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">accept</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
  <span class="n">m</span> <span class="o">=</span> <span class="vi">@cache</span><span class="p">[</span><span class="n">o</span><span class="p">.</span><span class="nf">class</span><span class="p">]</span> <span class="o">||=</span> <span class="s2">"visit_</span><span class="si">#{</span><span class="n">o</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">name</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s1">'::'</span><span class="p">).</span><span class="nf">last</span><span class="si">}</span><span class="s2">"</span>
  <span class="nb">send</span> <span class="n">m</span><span class="p">,</span> <span class="n">o</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">visit_TableDefinition</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
  <span class="n">create_sql</span> <span class="o">=</span> <span class="s2">"CREATE</span><span class="si">#{</span><span class="s1">' TEMPORARY'</span> <span class="k">if</span> <span class="n">o</span><span class="p">.</span><span class="nf">temporary</span><span class="si">}</span><span class="s2"> TABLE </span><span class="si">#{</span><span class="n">quote_table_name</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="nf">name</span><span class="p">)</span><span class="si">}</span><span class="s2"> "</span>

  <span class="n">statements</span> <span class="o">=</span> <span class="n">o</span><span class="p">.</span><span class="nf">columns</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span> <span class="n">accept</span> <span class="n">c</span> <span class="p">}</span>
  <span class="n">statements</span> <span class="o">&lt;&lt;</span> <span class="n">accept</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="nf">primary_keys</span><span class="p">)</span> <span class="k">if</span> <span class="n">o</span><span class="p">.</span><span class="nf">primary_keys</span>

  <span class="n">create_sql</span> <span class="o">&lt;&lt;</span> <span class="s2">"(</span><span class="si">#{</span><span class="n">statements</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">', '</span><span class="p">)</span><span class="si">}</span><span class="s2">)"</span> <span class="k">if</span> <span class="n">statements</span><span class="p">.</span><span class="nf">present?</span>
  <span class="n">add_table_options!</span><span class="p">(</span><span class="n">create_sql</span><span class="p">,</span> <span class="n">table_options</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
  <span class="n">create_sql</span> <span class="o">&lt;&lt;</span> <span class="s2">" AS </span><span class="si">#{</span><span class="vi">@conn</span><span class="p">.</span><span class="nf">to_sql</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="nf">as</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span> <span class="k">if</span> <span class="n">o</span><span class="p">.</span><span class="nf">as</span>
  <span class="n">create_sql</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">SchemaCreation</code> 类就是一个接受各种各样的 <code class="highlighter-rouge">TableDefinition</code>、<code class="highlighter-rouge">PrimaryKeyDefinition</code> 对象返回 SQL 的一个工具，可以将 <code class="highlighter-rouge">SchemaCreation</code> 理解为一个表结构的解释器；最后的 <code class="highlighter-rouge">#execute</code> 会在数据库中执行 SQL 改变数据库中的表结构。</p>

<p>在 <code class="highlighter-rouge">SchemaStatements</code> 中定义的其它方法的实现也都是大同小异，比如 <code class="highlighter-rouge">#drop_table</code> 其实都是删除数据库中的某张表：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">drop_table</span><span class="p">(</span><span class="n">table_name</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="n">execute</span> <span class="s2">"DROP TABLE</span><span class="si">#{</span><span class="s1">' IF EXISTS'</span> <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="ss">:if_exists</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">quote_table_name</span><span class="p">(</span><span class="n">table_name</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="表定义-dsl">表定义 DSL</h4>

<p><code class="highlighter-rouge">SchemaStatements</code> 中定义的方法，参数大都包含 <code class="highlighter-rouge">table_name</code>，而另一个类 <code class="highlighter-rouge">TableDefinitions</code> 就包含了直接对表操作的 DSL：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">create_table</span> <span class="ss">:foo</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">t</span><span class="p">.</span><span class="nf">class</span>  <span class="c1"># =&gt; "ActiveRecord::ConnectionAdapters::TableDefinition"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>当我们在 <code class="highlighter-rouge">#create_table</code> 中使用例如 <code class="highlighter-rouge">#string</code>、<code class="highlighter-rouge">#integer</code> 等方法时，所有的方法都会通过元编程的魔法最终执行 <code class="highlighter-rouge">TableDefinition#column</code> 改变表的定义：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">ColumnMethods</span>
  <span class="p">[</span>
    <span class="ss">:bigint</span><span class="p">,</span>
    <span class="c1"># ...</span>
    <span class="ss">:integer</span><span class="p">,</span>
    <span class="ss">:string</span><span class="p">,</span>
    <span class="ss">:text</span><span class="p">,</span>
    <span class="ss">:time</span><span class="p">,</span>
    <span class="ss">:timestamp</span><span class="p">,</span>
    <span class="ss">:virtual</span><span class="p">,</span>
  <span class="p">].</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">column_type</span><span class="o">|</span>
    <span class="nb">module_eval</span> <span class="o">&lt;&lt;-</span><span class="no">CODE</span><span class="p">,</span> <span class="kp">__FILE__</span><span class="p">,</span> <span class="kp">__LINE__</span> <span class="o">+</span> <span class="mi">1</span><span class="sh">
      def </span><span class="si">#{</span><span class="n">column_type</span><span class="si">}</span><span class="sh">(*args, **options)
        args.each { |name| column(name, :</span><span class="si">#{</span><span class="n">column_type</span><span class="si">}</span><span class="sh">, options) }
      end
</span><span class="no">    CODE</span>
  <span class="k">end</span>
  <span class="kp">alias_method</span> <span class="ss">:numeric</span><span class="p">,</span> <span class="ss">:decimal</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">#column</code> 方法非常神奇，它从各处收集有关当前表的定义，最终为表中的每一个字段创建一个 <code class="highlighter-rouge">ColumnDefinition</code> 实例，并存储到自己持有的 <code class="highlighter-rouge">@columns_hash</code> 中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">column</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
  <span class="nb">name</span> <span class="o">=</span> <span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span>
  <span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">.</span><span class="nf">to_sym</span> <span class="k">if</span> <span class="n">type</span>
  <span class="n">options</span> <span class="o">=</span> <span class="n">options</span><span class="p">.</span><span class="nf">dup</span>

  <span class="n">index_options</span> <span class="o">=</span> <span class="n">options</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="ss">:index</span><span class="p">)</span>
  <span class="n">index</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">index_options</span><span class="p">.</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">Hash</span><span class="p">)</span> <span class="p">?</span> <span class="n">index_options</span> <span class="p">:</span> <span class="p">{})</span> <span class="k">if</span> <span class="n">index_options</span>
  <span class="vi">@columns_hash</span><span class="p">[</span><span class="nb">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_column_definition</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
  <span class="nb">self</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">new_column_definition</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>
  <span class="n">type</span> <span class="o">=</span> <span class="n">aliased_types</span><span class="p">(</span><span class="n">type</span><span class="p">.</span><span class="nf">to_s</span><span class="p">,</span> <span class="n">type</span><span class="p">)</span>
  <span class="n">options</span><span class="p">[</span><span class="ss">:primary_key</span><span class="p">]</span> <span class="o">||=</span> <span class="n">type</span> <span class="o">==</span> <span class="ss">:primary_key</span>
  <span class="n">options</span><span class="p">[</span><span class="ss">:null</span><span class="p">]</span> <span class="o">=</span> <span class="kp">false</span> <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="ss">:primary_key</span><span class="p">]</span>
  <span class="n">create_column_definition</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">create_column_definition</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
  <span class="no">ColumnDefinition</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>除了 <code class="highlighter-rouge">ColumnDefinition</code> 之外，在 ActiveRecord 中还存在 <code class="highlighter-rouge">PrimaryKeyDefinition</code>、<code class="highlighter-rouge">IndexDefinition</code> 等等类和结构体用于表示数据库中的某一种元素。</p>

<p>表结构在最后会被 <code class="highlighter-rouge">SchemaCreation</code> 类的 <code class="highlighter-rouge">#accept</code> 方法展开，最后在数据库中执行。</p>

<h3 id="小结-3">小结</h3>

<p>到这里整个 Migrations 部分的实现就已经阅读分析完了，整个『模块』包含两个部分，一部分是 rake 任务执行 DSL 代码的过程，另一部分是 DSL 的实现，两部分的结合最终构成了整个 Migrations 模块的全部内容。</p>

<p>ActiveRecord 对于 Migration 迁移机制的设计确实很好的解决数据库中的表结构不断变更的问题，同时因为所有的 Migration 文件都在版本控制中管理，我们也能够随时还原数据库中的表结构。</p>

<h2 id="总结">总结</h2>

<p>文章对 ActiveRecord 中涉及的很多问题都进行了分析和介绍，包括模型的创建、查询以及关系，还包括数据库表迁移的实现，本来想将文中的几个部分分开进行介绍，但是写着写着就懒得分开了，如果对文章的内容有疑问，请在博客下面的评论系统中留言。</p>

<blockquote>

</blockquote>


	  ]]></description>
	</item>


</channel>
</rss>
