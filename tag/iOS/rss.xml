<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>brightphone.github.io/blogs/</title>
   
   <link></link>
   <description>A beautiful narrative written with the world's most elegant publishing platform. The story begins here.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>StackOverflow 黑魔法系列 <2></title>
	  <link>/blogs//stackoverflow-hei-mo-fa-xi-lie-2</link>
	  <author></author>
	  <pubDate>2015-08-03T03:08:19+00:00</pubDate>
	  <guid>/blogs//stackoverflow-hei-mo-fa-xi-lie-2</guid>
	  <description><![CDATA[
	     <p>距离上一次的 StackOverflow 黑魔法系列的 post 已经很久了, 自己也很久没有写技术博客了, 虽然这次带来的又是一篇水文. 但是好久没有写了, 写写水文也好试试手.</p>

<h2 id="autoreleasepool">AutoReleasePool</h2>

<p>iOS 中的 run loop 等待一些事件的发生并且响应这些实践. 这个事件可能包括用户触摸屏幕等等.</p>

<p>处理每一个 iOS 中的事件时, 一个新的 autorelease pool 都会在开始时被创建, 然后在事件响应结束后被 <code class="highlighter-rouge">drain</code>. 从理论上来说, 自动释放池的嵌套可以使无数的, 但是你需要知道的最主要的自动释放池是 <strong>Event Loop</strong>.</p>

<p>下面是应用程序生命周期的图:</p>

<p><img src="/content/images/2015/08/nBjxr.jpg" alt="" /></p>

<p>可以用下面的代码来表示</p>

<pre><code class="language-objectivec">int UIApplicationMain(...) {
    while (!shouldQuitApplication) {
        Event *someEvent = // wait for next event;
        NSAutoreleasePool *myPool = [[NSAutoreleasePool alloc] init];
        // handle event
        [myPool release];
    }
}
</code></pre>

<p>在 iOS 中有三种事件的类型.</p>

<pre><code class="language-objectivec">UIEventTypeTouches,
UIEventTypeMotion,
UIEventTypeRemoteControl,
</code></pre>

<p>所以在每一次触摸, 运动和远程控制的事件结束之后, 自动释放池都会被排干.</p>

<p>链接: <a href="http://stackoverflow.com/questions/5766839/end-of-run-loop-autorelease-pool-recovery">End of run loop — autorelease pool recovery</a></p>

<h2 id="gcd-nsthread-和-nsoperationqueue-之间有什么区别">GCD, NSThread 和 NSOperationQueue 之间有什么区别?</h2>

<ol>
  <li>当你需要<strong>直接控制你所创建的线程</strong>时, 使用 <code class="highlighter-rouge">NSThread</code>. e.g.
    <ul>
      <li>当你需要对控制线程的优先级有细颗粒度的控制或者与其他直接消耗线程对象的子系统直接交互并且需要停留在同一页上时, 就需要使用 <code class="highlighter-rouge">NSThread</code> 但是这种情况是及其罕见的, 但是它们确实发生, 特别是在实时应用中.</li>
    </ul>
  </li>
  <li>当你的任务是简单的并行时, 使用 <code class="highlighter-rouge">GCD</code>. e.g.
    <ul>
      <li>你想要将一些工作简单的抛到后台去执行</li>
      <li>串行化的获取某些数据结构</li>
      <li>有一些可以使用 <code class="highlighter-rouge">dispatch_apply</code> 能够很好的串行化的 <code class="highlighter-rouge">for</code> 循环</li>
      <li>有一些数据源或者计时器, <code class="highlighter-rouge">GCD</code> 的 <code class="highlighter-rouge">API</code> 能够让你非常容易的使它们工作在后台</li>
    </ul>
  </li>
  <li>当你在处理 Cocoa API 层级并且有一些更复杂的操作需要并行时, 使用 <code class="highlighter-rouge">NSOperation</code>. <code class="highlighter-rouge">NSOperation</code> 允许子类化, 复杂的依赖图, 撤销并且支持一些其他更高层级的语法糖. <code class="highlighter-rouge">NSOperation</code> 是对 <code class="highlighter-rouge">GCD</code> 的封装, 所以它有点类似有多核, 多线程的能力的 <code class="highlighter-rouge">GCD</code>. 如果你直接在 POSIX 层级进行工作时, 你应该更希望使用 <code class="highlighter-rouge">GCD</code>.</li>
</ol>

<p>链接: <a href="http://stackoverflow.com/questions/12995344/which-is-the-best-of-gcd-nsthread-or-nsoperationqueue">Which is the best of GCD, NSThread or NSOperationQueue?</a></p>

<h2 id="nsoperation-与-grand-central-dispatch-对比">NSOperation 与 Grand Central Dispatch 对比</h2>

<p><code class="highlighter-rouge">GCD</code> 是一个底层级的以 C 语言为基础的 API, 可以用于以任务为基础的并行模型. <code class="highlighter-rouge">NSOperation</code> 和 <code class="highlighter-rouge">NSOperationQueue</code> 是 Objective-C 中用于完成相应工作的类. <code class="highlighter-rouge">NSOperation</code> 在 iOS 4 和 OS X 10.6 中被首次介绍, <code class="highlighter-rouge">NSOperationQueue</code> 和其它一些队列是使用 <code class="highlighter-rouge">GCD</code> 实现的.</p>

<p>从总体上来说, 你应该使用满足需要的最高层级的抽象. 这意味着你需要使用 <code class="highlighter-rouge">NSOperationQueue</code> 来代替 <code class="highlighter-rouge">GCD</code>, 除非你需要完成一些事情, 但是 <code class="highlighter-rouge">NSOperationQueue</code> 无法支持.</p>

<p>事实上, 有许多可以使用 <code class="highlighter-rouge">NSOperationQueue</code> 可以非常简单完成的工作, 但是使用 <code class="highlighter-rouge">GCD</code> 时需要很多的工作. 苹果公司借助 GCD 创建了拥有对象友好型的 API 的 <code class="highlighter-rouge">NSOperation</code>.</p>

<p>链接: <a href="http://stackoverflow.com/questions/10373331/nsoperation-vs-grand-central-dispatch">NSOperation vs Grand Central Dispatch</a></p>

<h2 id="uitableviewcell-子视图在被点击时消失">UITableViewCell 子视图在被点击时消失</h2>

<p>当 UITableViewCell 被点击时, 在 cell 的 <code class="highlighter-rouge">contentView</code> 上面的视图的颜色全部都会改变, 你可以通过子类化 <code class="highlighter-rouge">UIView</code> 来改变颜色或者使用 <code class="highlighter-rouge">UIImageView</code> 并使用 1x1 像素的拉伸图片来解决这个问题.</p>

<p>链接: <a href="http://stackoverflow.com/questions/6745919/uitableviewcell-subview-disappears-when-cell-is-selected">UITableViewCell subview disappears when cell is selected</a></p>

<h2 id="判断-iphone-上的晃动手势">判断 iPhone 上的晃动手势</h2>

<p>判断 iPhone 上面晃动手势的最简单办法是, 你需要有一些 UIView 来作为第一响应者来接收晃动实践. 这里有一写使用 UIView 获取晃动事件的代码.</p>

<pre><code class="language-objectivec">@implementation ShakingView

- (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event {
    if ( event.subtype == UIEventSubtypeMotionShake ){
        // Put in code here to handle shake
    }

    if ( [super respondsToSelector:@selector(motionEnded:withEvent:)] )
        [super motionEnded:motion withEvent:event];
}

- (BOOL)canBecomeFirstResponder {
    return YES;
}

@end
</code></pre>

<p>你可以通过子类化任意一个 <code class="highlighter-rouge">UIView</code> 并覆写这些方法完成对晃动手势的监听.</p>

<p>在视图控制器中, 你需要设置这个视图变成第一响应者:</p>

<pre><code class="language-objectivec">- (void) viewWillAppear:(BOOL)animated {
    [shakeView becomeFirstResponder];
    [super viewWillAppear:animated];
}
- (void) viewWillDisappear:(BOOL)animated {
    [shakeView resignFirstResponder];
    [super viewWillDisappear:animated];
}
</code></pre>

<p>如果有其他的视图变成了第一响应者, 那么在其他视图响应结束后, 恢复当前视图的第一响应者身份.</p>

<p>链接: <a href="http://stackoverflow.com/questions/150446/how-do-i-detect-when-someone-shakes-an-iphone">How do I detect when someone shakes an iPhone?</a></p>

	  ]]></description>
	</item>

	<item>
	  <title>MagicMove 在 iOS 中的实现</title>
	  <link>/blogs//swift-de-na-xie-keng</link>
	  <author></author>
	  <pubDate>2015-06-07T13:33:57+00:00</pubDate>
	  <guid>/blogs//swift-de-na-xie-keng</guid>
	  <description><![CDATA[
	     <p>最近由于去武汉参加 hackday, 十多天没有更新博客了. 今天就来说一说, 我在 hackday 上使用 swift 开发 App 遇到的哪些问题吧.</p>

<h2 id="神奇移动">神奇移动</h2>

<p>我曾经在很多的 App 中都实现了类似 Keynote 中的神奇移动的效果, 也就是指定当前帧和下一帧中的视图, 当 Keynote 从当前帧切换到下一帧时, 就会根据当前的这两帧中视图的位置添加动画, 达到神奇的效果.</p>

<p>而我在 iOS 开发中的实现其实有以下几个步骤.</p>

<ul>
  <li>使下一帧的视图控制器获取视图的引用, 以及视图的位置以便返回时使视图归位.</li>
  <li>push 或者 present 时, 在下一帧的视图控制器中重新绘制视图.</li>
  <li>将视图移动到目标位置.</li>
  <li>将视图移回原位置之后 pop 或者 dismiss</li>
</ul>

<p>当我在 Swift 中实现的时候却遇到了几个问题.</p>

<h2 id="值类型">值类型</h2>

<p>在 Swift 中类型分为值类型和引用类型两种, 值类型在传递和赋值时将进行复制, 引用类型就只会保留一个指向对象的引用, 就像 C 语言中的指针.</p>

<p>因为在这一次动画的实现中, 我需要实现多个视图的神奇移动效果, 所以我把 <code class="highlighter-rouge">[UIView]</code> 数组传到下一个视图中, 而在 Swift 中, 数组是值类型的, 在传递的过程中会自动 copy. 也就是说, 下一个视图中的 <code class="highlighter-rouge">[UIView]</code> 和当前视图中的 <code class="highlighter-rouge">[UIView]</code> 并没有什么太多的关系.</p>

<p>但是在 Swift 中传递单独的 <code class="highlighter-rouge">UIView</code> 的时候, 由于 UIView 等 Objective-C 对象都是<strong>引用类型</strong>的, 所以在传递的过程中都是传递的引用, 也就是指针. 所以在下一个视图改变 UIView 之后, 原视图也会发生对应的变化. 但是由于, 我不想改变原有的视图, 所以需要对视图进行深拷贝, 就是是调用 <code class="highlighter-rouge">copy()</code> 方法</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">copy</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="nf">copy</span><span class="p">()</span>
</code></pre></div></div>

<p>在调用 <code class="highlighter-rouge">copy()</code> 方法时需要实现 <code class="highlighter-rouge">copyWithZone</code> 方法以及 <code class="highlighter-rouge">NSCopying</code> 协议. 但是所有的 Objective-C 对象都是默认没有实现这个方法, 所以需要我们手动实现.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">copyWithZone</span><span class="p">(</span><span class="nv">zone</span><span class="p">:</span> <span class="kt">NSZone</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">AnyObject</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">copy</span> <span class="o">=</span> <span class="kt">CRMainCollectionViewCell</span><span class="p">(</span><span class="nv">frame</span><span class="p">:</span> <span class="k">self</span><span class="o">.</span><span class="n">frame</span><span class="p">)</span>
    <span class="n">copy</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">index</span>
    <span class="n">copy</span><span class="o">.</span><span class="n">avatarImageView</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">avatarImageView</span><span class="o">.</span><span class="n">image</span>
    <span class="n">copy</span><span class="o">.</span><span class="n">customizeImageView</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">customizeImageView</span><span class="o">.</span><span class="n">image</span>
    <span class="n">copy</span><span class="o">.</span><span class="n">nameLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">nameLabel</span><span class="o">.</span><span class="n">text</span>
    <span class="n">copy</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
    <span class="k">return</span> <span class="n">copy</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这就是我所实现的 <code class="highlighter-rouge">copyWithZone</code> 方法, 你可以视情况实现你的 <code class="highlighter-rouge">copyWithZone</code> 方法.</p>

	  ]]></description>
	</item>

	<item>
	  <title>链式语法与 Objective-C</title>
	  <link>/blogs//lian-shi-yu-fa-yu-objective-c</link>
	  <author></author>
	  <pubDate>2015-05-27T07:44:22+00:00</pubDate>
	  <guid>/blogs//lian-shi-yu-fa-yu-objective-c</guid>
	  <description><![CDATA[
	     <p>作为一个 Objective-C 语言的使用者已经有近两年的时间了. 在逐渐熟悉手中的工具, Objective-C 语言的同时, 我也开始从更高的角度来观察这一门语言.</p>

<p>虽然至今我也不敢说我精通 Objective-C 和 Cocoa Touch, 但是我对它们也有了一些自己的见解.</p>

<h2 id="objective-c">Objective-C</h2>

<p>Objective-C 语言的语法使得我感觉到这门语言是如此的<strong>优雅</strong>. 在别人看来啰嗦的 label, 其实更是为了增加语言的可读性, 使 Objective-C 更像一门自然语言而做出的努力.</p>

<p>大多数的方法都不需要去查看文档, 只凭借方法的签名就能获得这个方法的作用, 这点使我们 iOS 开发者在编码的过程中更容易的达到<strong>代码即注释</strong>.</p>

<pre><code class="language-objectivec">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>然而凡事都是有双面性, Objective-C 中一些重要框架的使用, 往往让人诟病.</p>

<h2 id="core-data">Core Data</h2>

<p>作为一名 iOS 开发者就会不可避免的接触到 Core Data 这个框架, 但是它的使用却一直被开发者吐槽, 主要是它的使用实在太过于复杂, 麻烦.</p>

<p>但是你有时却不得不使用它.</p>

<p>当然, 我在我所开发的应用中并没有过多的使用 Core Data, 而是使用了 levelDB 来代替, 这种 Key-Value 存储的数据库更适合于大部分的应用.</p>

<h2 id="autolayout">AutoLayout</h2>

<p>在 AutoLayout 刚刚出现的时候, 许多的开发者都觉得 AutoLayout 必将快速将原来 iOS 开发中使用 frame 布局转变到使用 constraint 布局.</p>

<p>但是知道真正使用的时候才发现原来 AutoLayout 的使用方法是如此的繁琐.</p>

<pre><code class="language-objectivec">[superview addConstraints:@[

    //view1 constraints
    [NSLayoutConstraint constraintWithItem:view1
                                 attribute:NSLayoutAttributeTop
                                 relatedBy:NSLayoutRelationEqual
                                    toItem:superview
                                 attribute:NSLayoutAttributeTop
                                multiplier:1.0
                                  constant:padding.top],

    [NSLayoutConstraint constraintWithItem:view1
                                 attribute:NSLayoutAttributeLeft
                                 relatedBy:NSLayoutRelationEqual
                                    toItem:superview
                                 attribute:NSLayoutAttributeLeft
                                multiplier:1.0
                                  constant:padding.left],

    [NSLayoutConstraint constraintWithItem:view1
                                 attribute:NSLayoutAttributeBottom
                                 relatedBy:NSLayoutRelationEqual
                                    toItem:superview
                                 attribute:NSLayoutAttributeBottom
                                multiplier:1.0
                                  constant:-padding.bottom],

    [NSLayoutConstraint constraintWithItem:view1
                                 attribute:NSLayoutAttributeRight
                                 relatedBy:NSLayoutRelationEqual
                                    toItem:superview
                                 attribute:NSLayoutAttributeRight
                                multiplier:1
                                  constant:-padding.right],

 ]];
</code></pre>

<p>使用这种方式来构建布局简直就是一种折磨, 这也是为什么在 AutoLayout 刚刚出现的时候, 并没有什么人去使用它. 反而, 真正使 AutoLayout 被开发者广泛使用的是另一个 DSL, 也就是大名鼎鼎的 <a href="https://github.com/SnapKit/Masonry">Masonry</a>.</p>

<p>它使用一种非常非常简洁的方式来实现自动布局.</p>

<pre><code class="language-objectivec">[view1 mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.equalTo(superview.mas_top).with.offset(padding.top); //with is an optional semantic filler
    make.left.equalTo(superview.mas_left).with.offset(padding.left);
    make.bottom.equalTo(superview.mas_bottom).with.offset(-padding.bottom);
    make.right.equalTo(superview.mas_right).with.offset(-padding.right);
}];
</code></pre>

<p>其中最关键的一点就是使用了<strong>链式语法</strong>.</p>

<pre><code class="language-objectivec">make.top.equalTo(superview.mas_top).with.offset(padding.top);
</code></pre>

<h2 id="animation">Animation</h2>

<p>在 Masonry 之后, 也就是前一段时间, 又有开发者为动画实现了同样简洁优雅的链式语法, 也就是 <a href="https://github.com/jhurray/JHChainableAnimations">JHChainableAnimations</a>.</p>

<p>在 JHChainableAnimations 作者的同意下, 我也同样将它移植到了 Swift 上 <a href="https://github.com/Draveness/DKChainableAnimationKit">DKChainableAnimationKit</a>.</p>

<p>这是使用 Objective-C 原有的方法实现的动画, 虽然它非常的易读, 并且符合 Objective-C 一贯的风格.</p>

<pre><code class="language-objectivec">[UIView animateWithDuration:1.0
                      delay:0.0
     usingSpringWithDamping:0.8
      initialSpringVelocity:1.0
                    options:0 animations:^{
                       CGPoint newPosition = self.myView.frame.origin;
                       newPosition.x += 50;
                       self.myView.frame.origin = newPosition;
} completion:^(BOOL finished) {
   [UIView animateWithDuration:0.5
                         delay:0.0
                       options:UIViewAnimationOptionCurveEaseIn
                    animations:^{
       self.myView.backgroundColor = [UIColor purpleColor];
   } completion:nil];
}];
</code></pre>

<p>但是这段代码与下面的<strong>链式语法</strong>比起来就显得冗长与罗嗦了.</p>

<pre><code class="language-objectivec">self.myView.moveX(50).spring.thenAfter(1.0).makeBackground([UIColor purpleColor]).easeIn.animate(0.5);
</code></pre>

<p>虽然有人说, 这是<strong>对属性的误用</strong>, 不过在我看来<strong>与它带来的便捷, 优雅与易读相比, 属性的误用又算什么呢</strong>?</p>

<p>链式的语法能够极大的改变原有 Objective-C Swift 的使用, 而在这两者的启发下, 我也开始了各种各样的尝试.</p>

<h2 id="uikit">UIKit</h2>

<p>首先, 我在 UIKit 中进行了尝试, 希望能对原有的语法进行改造. 使用链式语法取代原有的语法. 这也就有了 <a href="https://github.com/Draveness/ChainableKit">ChainableKit</a> 使用链式语法配置 UIKit 组件的第三方库.</p>

<pre><code class="language-objectivec">UIColor *red = [UIColor redColor];
UILabel.make
    .backgroundColor(red)
    .textAlignment(NSTextAlignmentCenter)
</code></pre>

<p>但是, 当这一框架刚刚诞生并且我尝试写出之后, 我却感到有些怪异, 这好像并不符合我们的直觉, 因为这些属性并没有顺序上的关系. 但是却不失为一种尝试.</p>

<p>不过, 它也确实能够极大的减少代码的行数, <strong>将配置 UILabel 的全部代码聚合在一起</strong>.</p>

<h2 id="attributedstring">AttributedString</h2>

<p>由于 <a href="https://github.com/fazibear/colorize">colorize</a> 的启发, 我又在 AttributedString 中尝试使用链式语法来解决创建配置<strong>属性字符串</strong>的问题. <a href="https://github.com/Draveness/Typeset">Typeset</a></p>

<pre><code class="language-objectivec">@"Hello".typeset.match(@"He").red.string;
</code></pre>

<h2 id="总结">总结</h2>

<p>这就是我对链式语法在 Objective-C 中使用的总结和体会. 虽然并没有得出什么重要的结论, 不过我还是相信<strong>简洁与优雅的方法最终总会被开发者采纳</strong>.</p>

	  ]]></description>
	</item>

	<item>
	  <title>DKNightVersion 的实现 --- 如何为 iOS 应用添加夜间模式</title>
	  <link>/blogs//dknightversion-de-shi-xian-wei-ios-ying-yong-tian-jia-ye-jian-mo-shi</link>
	  <author></author>
	  <pubDate>2015-05-09T07:13:35+00:00</pubDate>
	  <guid>/blogs//dknightversion-de-shi-xian-wei-ios-ying-yong-tian-jia-ye-jian-mo-shi</guid>
	  <description><![CDATA[
	     <p><strong>最新: <a href="http://draveness.me/night">成熟的夜间模式解决方案</a></strong></p>

<p><strong>注意: 这篇文章已经过时了, 最新版本的 2.3.0 实现已经更改了.</strong></p>

<p>在很多重阅读或者需要在夜间观看的软件其实都会把夜间模式当做一个 App 所需要具备的特性. 而如何在不改变原有的架构, 甚至不改变原有的代码的基础上, 就能为应用优雅地添加夜间模式就成为一个在很多应用开发的过程中不得不面对的一个问题.</p>

<p>就是以上事情的驱动, 使我思考如何才能使用一种优雅并且简洁的方法解决这一问题.</p>

<p>而 <a href="https://github.com/Draveness/DKNightVersion">DKNightVersion</a> 就是我带来的解决方案.</p>

<p>到目前为止, 这个框架的大部分的工作都已经完成了, 或许它现在不够完善, 不过我会持续地维护这个框架, 帮助饱受实现夜间模式之苦的工程师们解决这个<del>坑的一逼的</del>需求.</p>

<h2 id="实现">实现</h2>

<p>现在我也终于有时间来<del>水一水</del>写一篇博客来说一下这个框架是如何实现夜间模式的, 它都有哪些特性.</p>

<p>在很长的一段时间我都在想如何才能在不覆写 <code class="highlighter-rouge">UIKit</code> 控件的基础上, 为 iOS App 添加夜间模式. 而 <code class="highlighter-rouge">objc/runtime</code> 为我带来了不覆写 <code class="highlighter-rouge">UIKit</code> 就能实现这一目的的希望.</p>

<h3 id="为-uikit-控件添加-nightcolor-属性">为 UIKit 控件添加 <code class="highlighter-rouge">nightColor</code> 属性</h3>

<p>因为我们并不会子类化 UIKit 控件, 然后使用 <code class="highlighter-rouge"><span class="k">@property</span></code> 为它的子类添加属性. 而是使用 Objective-C 中神奇的分类(Category) 和 <code class="highlighter-rouge">objc/runtime</code>, 为 UI 系列的控件添加属性.</p>

<p>使用 <code class="highlighter-rouge">objc/runtime</code> 为分类添加属性相信很多人都知道而且经常在开发中使用了. 如果不了解的话, 可以看<a href="http://nshipster.com/associated-objects/">这里</a>.</p>

<p>DKNightVersion 为大多数常用的 <code class="highlighter-rouge">color</code> 比如说: <code class="highlighter-rouge">backgroundColor</code> <code class="highlighter-rouge">tintColor</code> 都添加了以 <code class="highlighter-rouge">night</code> 开头的夜间模式下的颜色, <code class="highlighter-rouge">nightBackgroundColor</code> <code class="highlighter-rouge">nightTintColor</code>.</p>

<pre><code class="language-objectivec">- (UIColor *)nightBackgroundColor {
    return objc_getAssociatedObject(self, &amp;nightBackgroundColorKey) ? :self.backgroundColor);
}

- (void)setNightBackgroundColor:(UIColor *)nightBackgroundColor {
    objc_setAssociatedObject(self, &amp;nightBackgroundColorKey, nightBackgroundColor, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
</code></pre>

<p>我们创建这个属性以保存夜间模式下的颜色, 这样当应用的主题切换到夜间模式时, 将 <code class="highlighter-rouge">nightColor</code> 属性存储的颜色赋值给对应的 <code class="highlighter-rouge">color</code>, 但是这会有一个问题. 当应用重新切换回正常模式时, 我们失去了原有正常模式的 <code class="highlighter-rouge">color</code>.</p>

<h3 id="添加-normalcolor-存储颜色">添加 <code class="highlighter-rouge">normalColor</code> 存储颜色</h3>

<p>为了解决这一问题, 我们为 UIKit 控件添加了另一个属性 <code class="highlighter-rouge">normalColor</code> 来保存正常模式下的颜色.</p>

<pre><code class="language-objectivec">- (UIColor *)normalBackgroundColor {
    return objc_getAssociatedObject(self, &amp;normalBackgroundColorKey);
}

- (void)setNormalBackgroundColor:(UIColor *)normalBackgroundColor {
    objc_setAssociatedObject(self, &amp;normalBackgroundColorKey, normalBackgroundColor, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}
</code></pre>

<p>但是保存这个颜色的时机是非常重要的, 在最开始的时候, 我的选择是直接覆写 <code class="highlighter-rouge">setter</code> 方法, 在保存颜色之前存储 <code class="highlighter-rouge">normalColor</code>.</p>

<pre><code class="language-objectivec">- (void)setBackgroundColor:(UIColor *)backgroundColor {
    self.normalBackgroundColor = backgroundColor;
    _backgroundColor = backgroundColor;
}
</code></pre>

<p>然而这种看似可以运行的 <code class="highlighter-rouge">setter</code> 其实会导致视图不会被着色, 设置 <code class="highlighter-rouge">color</code> 包括正常的颜色都不会有任何的反应, 反而视图的背景颜色一片漆黑.</p>

<p>由于上面这种方法行不通, 我想换一种方法使用观察者模式来存储 <code class="highlighter-rouge">normalColor</code>, 将实例自己注册为 <code class="highlighter-rouge">color</code> 属性的观察者, 当 <code class="highlighter-rouge">color</code> 属性变化时, 通知 UIKit 控件本身, 然后, 把属性存到 <code class="highlighter-rouge">normalColor</code> 属性中.</p>

<p>然而在什么时候将自己注册为观察者这一问题, 又使我放弃了这一解决方案. 最终选择<a href="http://nshipster.com/method-swizzling/">方法调剂</a>来解决原有 <code class="highlighter-rouge">color</code> 的存储问题.</p>

<p>使用方法调剂为原有属性的 <code class="highlighter-rouge">setter</code> 方法添加钩子, 在方法调用之前, 将属性存储起来, 用于切换回 <code class="highlighter-rouge">normal</code> 模式时, 为属性赋值.</p>

<p>这是要与 <code class="highlighter-rouge">setter</code> 调剂的钩子方法:</p>

<pre><code class="language-objectivec">- (void)hook_setBackgroundColor:(UIColor*)backgroundColor {
    if ([DKNightVersionManager currentThemeVersion] == DKThemeVersionNormal) {
        [self setNormalBackgroundColor:backgroundColor];
    }
    [self hook_setBackgroundColor:backgroundColor];
}
</code></pre>

<p>如果当前是 <code class="highlighter-rouge">normal</code> 模式, 就会存储 <code class="highlighter-rouge">color</code>, 如果不是就会直接赋值, 如果你看不懂为什么这里好像会造成无限递归, 请看<a href="http://nshipster.com/method-swizzling/">这里</a>, 详细的解释了方法调剂是如何使用的.</p>

<h3 id="dknightversionmanager-实现-color-切换">DKNightVersionManager 实现 <code class="highlighter-rouge">color</code> 切换</h3>

<p>我们已经为 UIKit 控件添加了 <code class="highlighter-rouge">normalColor</code> 和 <code class="highlighter-rouge">nightColor</code>, 接下来我们需要实现 <code class="highlighter-rouge">color</code> 在这两者之间的切换, 而这 <code class="highlighter-rouge">DKNightVersionManager</code> 就是为了处理模式切换的类.</p>

<p>通过为 <code class="highlighter-rouge">DKNightVersionManager</code> 创建一个单例来处理 <code class="highlighter-rouge">模式转换</code>, <code class="highlighter-rouge">使用默认颜色</code>, <code class="highlighter-rouge">动画时间</code> 等操作.</p>

<p>当调用 <code class="highlighter-rouge">DKNightVersionManager</code> 的类方法 <code class="highlighter-rouge">nightFalling</code> 或者 <code class="highlighter-rouge">dawnComing</code> 时, 我们首先会获取全局的 <code class="highlighter-rouge">UIWindow</code>, 然后通过递归调用 <code class="highlighter-rouge">changeColor</code> 方法, 使能够响应 <code class="highlighter-rouge">changeColor</code> 方法的视图改变颜色.</p>

<pre><code class="language-objectivec">- (void)changeColor:(id &lt;DKNightVersionChangeColorProtocol&gt;)object {
    if ([object respondsToSelector:@selector(changeColor)]) {
        [object changeColor];
    }
    if ([object respondsToSelector:@selector(subviews)]) {
        if (![object subviews]) {
            // Basic case, do nothing.
            return;
        } else {
            for (id subview in [object subviews]) {
                // recursice darken all the subviews of current view.
                [self changeColor:subview];
                if ([subview respondsToSelector:@selector(changeColor)]) {
                    [subview changeColor];
                }
            }
        }
    }
}
</code></pre>

<p>因为我在这个类中并没有引入 <code class="highlighter-rouge">category</code>, 编译器不知道 <code class="highlighter-rouge">id</code> 类型具有这两个方法. 所以我声明了一个协议, 使 <code class="highlighter-rouge">changeColor</code> 中的方法来满足两个方法 <code class="highlighter-rouge">changeColor</code> 和 <code class="highlighter-rouge">subViews</code>. 不让编译器提示错误.</p>

<pre><code class="language-objectivec">@protocol DKNightVersionChangeColorProtocol &lt;NSObject&gt;

- (void)changeColor;
- (NSArray *)subviews;

@end
</code></pre>

<p>然后让所有的 UIKit 控件遵循这个协议就可以了, 当然我们也可以不显式的遵循这个协议, 只要它能够响应这两个方法也是可以的.</p>

<h3 id="实现默认颜色">实现默认颜色</h3>

<p>我们要在 DKNightVersion 实现默认的夜间模式配色, 以便减少开发者的工作量.</p>

<p>但是因为我们对每种 <code class="highlighter-rouge">color</code> 只在父类中实现一次, 这样使得子类能够继承父类的实现, 但是同样<strong>不想让 UIKit 系子类继承父类的默认颜色</strong>.</p>

<pre><code class="language-objectivec">- (UIColor *)defaultNightBackgroundColor {
    BOOL notUIKitSubclass = [self isKindOfClass:[UIView class]] &amp;&amp; ![NSStringFromClass(self.class) hasPrefix:@"UI"];
    if ([self isMemberOfClass:[UIView class]] || notUIKitSubclass) {
        return UIColorFromRGB(0x343434);
    } else {
        UIColor *resultColor = self.normalBackgroundColor ?: [UIColor clearColor];
        return resultColor;
    }
}
</code></pre>

<p>通过使用 <code class="highlighter-rouge">isMemberOfClass:</code> 方法来判断<strong>实例是不是当前类的实例, 而不是该类子类的实例.</strong> 然后才会返回默认的颜色. 但是非 UIKit 中的子类是可以继承这个特性的, 所以使用这段代码来判断该实例是否是非 UIKit 的子类:</p>

<pre><code class="language-objectivec">[self isKindOfClass:[UIView class]] &amp;&amp; ![NSStringFromClass(self.class) hasPrefix:@"UI"]
</code></pre>

<p>我们通过 <code class="highlighter-rouge">NSStringFromClass(self.class) hasPrefix:@"UI"</code> 巧妙地达到这一目的.</p>

<h4 id="使用-erb-生成-objective-c-代码">使用 <code class="highlighter-rouge">erb</code> 生成 Objective-C 代码</h4>

<p>这个框架大多数的工作都是重复的, 但是我并不想为每一个类重复编写近乎相同的代码, 这样的代码十分不易阅读和维护, 所以使用了 <code class="highlighter-rouge">erb</code> 文件, 来为生成的 Objective-C 代码提供模板, 只将元数据进行解析然后传入每一个模板, 动态生成所有的代码, 再通过另一个脚本将所有的文件加入目录中.</p>

<hr />

<p><a href="https://github.com/Draveness/DKNightVersion">DKNightVersion</a> 的实现并不复杂. 它不仅使用了 <code class="highlighter-rouge">erb</code> 和 Ruby 脚本来减少了大量的工作量, 而且使用了 <code class="highlighter-rouge">objc/runtime</code> 的特性来魔改 UIKit 组件, 达到为 iOS 应用添加夜间模式的效果.</p>

<iframe src="https://ghbtns.com/github-btn.html?user=Draveness&amp;repo=DKNightVersion&amp;type=star&amp;count=true&amp;size=large" frameborder="0" scrolling="0" width="160px" height="30px"></iframe>

	  ]]></description>
	</item>

	<item>
	  <title>使用代码为 Xcode 工程添加文件</title>
	  <link>/blogs//bei-xcodeproj-keng-de-zhe-ji-tian</link>
	  <author></author>
	  <pubDate>2015-05-06T12:48:25+00:00</pubDate>
	  <guid>/blogs//bei-xcodeproj-keng-de-zhe-ji-tian</guid>
	  <description><![CDATA[
	     <p>这几天在持续更新 <a href="https://github.com/Draveness/DKNightVersion">DKNightVersion</a> 这个仓库, 我对这个框架投入了很多的时间和精力.</p>

<p>我还是希望把这个框架的方方面面都做好的, 为框架的使用者提供最好的用户体验, 将开发者的使用成本和使用难度降到最低, 提升开发者的使用体验.</p>

<p>但是在我维护这个框架的过程中还是感觉到如何平衡框架的可扩展性和易用性实在是太难了. 为了减少开发者工作量以达到减少错误的目的, 我在这最近几乎每天 8 小时以上的与 xcodeproj 这个文件打交道, 把原来所需的工作尽可能的降低, 从原来的:</p>

<ol>
  <li>ruby generator.rb</li>
  <li>拖拽 UIKit 文件到工作区的指定位置</li>
  <li>选择指定的 Target</li>
</ol>

<p>到现在的一个命令:</p>

<ol>
  <li>rake</li>
</ol>

<p>我也付出了很大的努力, 虽然这个过程看起来非常的简单, 只是<strong>将原来的拖拽改变为使用代码来操作</strong>而已. 但是在实际的操作中, 还是<strong>极其麻烦</strong>的.</p>

<p>麻烦到什么程度呢? 在我每次觉得我要觉得我要成功的时候, 总是会遇到这样那样奇怪的错误或者错误给予我致命一击, 让一切努力都从零开始, 而这种情况在这几天处理这个问题的过程中遇到了 5,6 次.</p>

<p>我很多次都是想过要放弃实现这个功能, 不过到最后, 我还是完成了.</p>

<blockquote>
  <p>很大一部分原因是无法容忍作品中的不完美, 如果我没有想到它, 可能不会去做, 但是既然我想到了这个减少工作量的办法, 而且已经有先例(Cocoapods)完成了, 那么我也一定要实现这个功能.</p>
</blockquote>

<p>而到现在, 我觉得需要写一篇博客记录一下这个过程, 既能够为后人带来一些启发也能少走一些弯路.</p>

<h2 id="xcode-做了什么">Xcode 做了什么</h2>

<p>因为 DKNightVersion 使用了 Ruby 脚本来生成 Objective-C 代码, 而在代码生成之后, 文件虽然会出现在你文件夹之中, 但是并不会直接添加到你的工程文件中, 也就是<strong>编译器不知道你需要这些文件</strong>.</p>

<p>我们一般都是通过拖拽来把这些文件添加到工程中合适的位置, 让编译器 Xcode 知道: <strong>我需要这些文件, 帮我”编译”它们</strong>. 这就是你在拖拽的过程中, Xcode 实际上做的事情.</p>

<p>在拖拽的过程中, 它实际上就是改变了一个神奇的文件 <code class="highlighter-rouge">pbxproj</code>, 这个文件在你的 <code class="highlighter-rouge">xcodeproj</code> <strong>目录</strong>中, 你需要右键点击 <code class="highlighter-rouge">xcodeproj</code> 文件</p>

<p><img src="/content/images/2015/05/E471A4A7-223C-4958-8A02-82CE1B7A6AF6.png" alt="" /></p>

<p>然后会出现这样的菜单, 选中显示包内容</p>

<p><img src="/content/images/2015/05/47DDA965-DBB2-45A8-B8C1-1A0DC5EDE4AE.png" alt="" /></p>

<p>然后你就会看到一个 <code class="highlighter-rouge">project.pbxproj</code> 文件, 而你对文件进行的操作, <strong>添加和删除</strong>实际上都是对这个文件的修改.</p>

<p>如果你长期使用命令行, 你就会非常自然的发现 <code class="highlighter-rouge">*.xcodeproj</code> <code class="highlighter-rouge">*.xcodeworkspace</code> 实际上都是文件夹, 但是后者并不是我们今天所要关心的问题.</p>

<p><img src="/content/images/2015/05/AA8E09AC-864A-46D6-A794-6D2547858CA8.png" alt="" /></p>

<p>我是怎么知道的呢, 我通过反复的尝试, 再删除一些文件的 <code class="highlighter-rouge">refernece</code>(没有将文件移到垃圾桶), 然后使用 <code class="highlighter-rouge">git diff</code> 查看所做的修改, 就会发现其他的文件并没有被修改, <strong>唯一被修改的就是这个 <code class="highlighter-rouge">project.pbxproj</code> 文件</strong>.</p>

<ul>
  <li>在我们进行文件的<strong>增加和删除(不包括修改)</strong>的过程中, 实际上就是对 <code class="highlighter-rouge">project.pbxproj</code> 的修改.</li>
</ul>

<h1 id="向-xcode-工程中添加或删除文件">向 Xcode 工程中添加或删除文件</h1>

<p>如何在非 GUI 中完成对 Xcode 工程文件的操作呢? 我总共进行了三种不同的尝试.</p>

<h2 id="手搓">手搓</h2>

<p>作为一个<del>闲的蛋疼</del>专业的工程师, 我的第一想法是, 这需求肯定很多, 干脆造一个轮子好了, 于是我打开了 <code class="highlighter-rouge">project.pbxproj</code> 文件. 立刻被里面的数据所淹没了.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* Begin PBXBuildFile section */
		0DFDC45E10D450EE9CA10394 /* UITableViewCell+BackgroundColor.h in Headers */ = {isa = PBXBuildFile; fileRef = A9EE3067770E740BB65F5B9D /* UITableViewCell+BackgroundColor.h */; };
		186AC5221AF855410095ED95 /* DKNightVersionManagerTest.m in Sources */ = {isa = PBXBuildFile; fileRef = 186AC5211AF855410095ED95 /* DKNightVersionManagerTest.m */; };
		18D2288D1AF8BA4F00872BF1 /* UINavigationBar+Animation.m in Sources */ = {isa = PBXBuildFile; fileRef = 18D2288C1AF8BA4F00872BF1 /* UINavigationBar+Animation.m */; };
</code></pre></div></div>

<p>七百多行的文件, 我在这里只选取了三行. 因为这个文件中的<strong>数据</strong>实在是太多了. 你会看到每一行的前面大概都是一个 <strong>24 位的 16 进制数字</strong> 然后就是一个文件名 <code class="highlighter-rouge">UITableViewCell+BackgroundColor.h</code> 在最后有一个 <code class="highlighter-rouge">isa</code> 和一个 <code class="highlighter-rouge">fileRef</code>.</p>

<p>在大概浏览了一下这个文件的全部内容之后, 我对于手搓这个 script 有了一个初步的想法, 第一步就是生成这个 <strong>24 位的 16 进制数字</strong>. 当然我希望知道苹果是如何生成这一 16 进制数字的.</p>

<p>(<strong>注: 我实在无法对这个文件中的任何一部分进行详尽的解释, 不过之后我会介绍几个重要的相关概念</strong>)</p>

<p>然而我没有找到相关的资料, 而我自己也没有这个能力来推导出这个神奇的数字是如何生成的.</p>

<h2 id="使用-xcodeproj">使用 <code class="highlighter-rouge">Xcodeproj</code></h2>

<p><a href="https://github.com/CocoaPods/Xcodeproj">Xcodeproj</a> 是一个使用 Ruby 来创建和修改 Xcode 工程文件的工具. 我找到它的原因是 Cocoapods 也通过 Ruby 代码向 Xcode 工程中添加文件, 所以我在 Cocoapods 中找到了这一组件.</p>

<p>在最开始尝试使用这个工具的时候, 发现它的文档是<strong>极其</strong>糟糕. 根本无法直接在文档找到<strong>向 Xcode 工程中添加文件的方法</strong>, 这一简单的需求并没有明确的写在文档中, 这令我十分的不理解.</p>

<p>这个组件的主要功能不就是向工程中添加文件么? 为什么没有写在文档中, 而我所做的就是不断的阅读这个组件的源代码, 尝试理解 <code class="highlighter-rouge">project.pbxproj</code> 中的东西到底都是什么. 而在这期间, 有几个非常重要的问题需要我们理解.</p>

<ul>
  <li>Target</li>
  <li>Group</li>
  <li>FileRef</li>
</ul>

<h4 id="target">Target</h4>

<p><code class="highlighter-rouge">Target</code> 到底是什么, 我在以前的 iOS 开发的工作中并没有仔细地考虑这一个问题, 直到我遇到这一<strong>需求</strong>时, 我在尝试理解这背后的意义.</p>

<blockquote>
  <p>A target specifies a product to build and contains the instructions for building the product from a set of files in a project or workspace. A target defines a single product; it organizes the inputs into the build system—the source files and instructions for processing those source files—required to build that product. Projects can contain one or more targets, each of which produces one product.</p>
</blockquote>

<p><a href="https://developer.apple.com/library/ios/featuredarticles/XcodeConcepts/Concept-Targets.html">Target</a> 指定了一个用于产品(product), 并且包含了从工程中的一些文件中构建产品的命令.</p>

<p>这些命令使用构建设置(build settings)和构建阶段(build phases)的方式来组织, 我们可以在 Xcode 编辑器中改变这些设置.</p>

<h4 id="group">Group</h4>

<p>Group 这个概念和我们平时经常说的 folder 文件夹有很大的差别, 文件夹在我们的日常使用时是一直所接触到的, 而对于 Group, 如果你不使用 Xcode 来编程(不是很清楚别的 IDE 是否有这个功能)的话, 这个概念距离你太远了.</p>

<p>Group 其实是 Xcode 中用来组织文件的一种方式, <strong>它对文件系统没有任何影响</strong>, 无论你创建或者删除一个 Group, 都不会导致 folder 的增加或者移除. 当然如果在你删除时选择 Move to Trash 就是另外一说了.</p>

<p>在 Group 中的文件的关系, 不会与 folder 中的有什么冲突, 它只是 Xcode 为你提供的一种分离关注的方式而已. 但是, 我一般会在开发过程中将不同的模块分到不同的 Group 和 folder 中便于整理.</p>

<p>Group 之间的关系, 也是在 <code class="highlighter-rouge">project.pbxproj</code> 中定义的, 这个文件中包含了 Xcode 工程中所有 File 和 Group 的关系, 如果你大致浏览过这个文件的话, 你就会对我所说的有所了解.</p>

<p>Group 在我们的工程中就是黄色的文件夹, 而 Folder 是蓝色的文件夹(一般在 Xcode 工程中, 我们不会使用 Folder).</p>

<h4 id="fileref">FileRef</h4>

<p>FileRef 其实就是 File Reference 的缩写, 当你从 Xcode 中删除一个文件的时候, 它会弹出这样的提示框.</p>

<p><img src="/content/images/2015/05/77DF33A1-B29F-4294-8860-9D638A95333A.png" alt="" /></p>

<p>而其中的 <code class="highlighter-rouge">Remove Reference</code> 选项并不会将这个文件移除到垃圾桶, 而只是会将这个文件的引用从 Xcode 的工程文件中删除.</p>

<p>如果你曾经看过 <code class="highlighter-rouge">Build Phases</code> 中的内容, 你会发现</p>

<ul>
  <li>如果删除的是 <code class="highlighter-rouge">.h</code> 文件, 它会从 <code class="highlighter-rouge">Build Phases</code> 中的 <strong>Headers</strong> 部分删除</li>
  <li>如果删除的是 <code class="highlighter-rouge">.m</code> 文件, 它会从 <code class="highlighter-rouge">Build Phases</code> 中的 <strong>Compile Source</strong> 部分删除</li>
</ul>

<p>但是文件还是会在原来的地方, 因为 Xcode 中所加入到工程的只是文件的一个引用 — File Ref.</p>

<h3 id="添加文件">添加文件</h3>

<p>我们已经基本了解了阅读这一篇博客所需要的全部知识, 接下来, 我们就需要来分析一下向 Xcode 工程中添加文件所需要的几个步骤.</p>

<p>当我们生成一堆 Objective-C 代码时, 我们的第一步是要将这些文件拖入 Xcode 工程中, 这时 Xcode 会弹出视图询问你是创建 Groups 还是 Folder references, 并询问你要加入到哪个 Target 中.</p>

<p><img src="/content/images/2015/05/04217493-910E-4E6E-BF6E-B0CEE86D3CFB.png" alt="" /></p>

<ul>
  <li>当选择创建 Groups 时,  Xcode 就会把 .h 文件加入 Build Phases 中的 Header, 把 .m 文件加入 Compile Sources 中, 并创建一个黄色的文件夹.</li>
  <li>当选择创建 Folder references 时, Xcode 会把所有的文件加入 Build Phases 中的 Copy Bundles Resources, 不进行任何的编译, 然后创建一个蓝色的文件夹.</li>
</ul>

<p>我们现在就来使用代码来模拟将文件加入 Xcode 中, 选择 Create Groups 并且添加到指定 Target 的全过程.</p>

<p>在这里我们需要使用 Ruby 的开源框架 <a href="https://github.com/CocoaPods/Xcodeproj">xcodeproj</a> 这个框架是著名的开源框架 Cocoapods 的一个组件.</p>

<blockquote>
  <p>Create and modify Xcode projects from Ruby.</p>
</blockquote>

<h4 id="查找-xcodeproj-文件">查找 <code class="highlighter-rouge">*.xcodeproj</code> 文件</h4>

<p><a href="https://github.com/CocoaPods/Xcodeproj/blob/master/lib/xcodeproj/project.rb">lib/xcodeproj/project.rb</a></p>

<p>在使用 xcodeproj 时, 只需要<strong>查找 <code class="highlighter-rouge">*.xcodeproj</code> 文件</strong>而不是 <code class="highlighter-rouge">*.pbxproj</code>. 我们通过调用 <code class="highlighter-rouge">Project</code> 的类方法来打开文件.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">project</span> <span class="o">=</span> <span class="no">Xcodeproj</span><span class="o">::</span><span class="no">Project</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="获取-target">获取 Target</h4>

<p><a href="https://github.com/CocoaPods/Xcodeproj/blob/master/lib/xcodeproj/project.rb">lib/xcodeproj/project.rb</a></p>

<p>接下来要获取 Target, 模拟选择 <code class="highlighter-rouge">Add to targets</code> 这一操作, 在每一个 Project 中都有多个 Target.</p>

<p>一般在我们的项目中, 一般都有一个以 <code class="highlighter-rouge">项目名</code> 和一个以 <code class="highlighter-rouge">项目名+Test</code> 命名的 Target.</p>

<p>Tips:</p>

<ul>
  <li>在 Pod 项目中, 每一个 Pod 都会对应一个 Target, 然后会有一个 <code class="highlighter-rouge">Pods-项目名</code> Target.</li>
</ul>

<p><img src="/content/images/2015/05/1BF77D9B-8D05-4FFA-9A87-0DC73FF7EA52.png" alt="" /></p>

<p>而在这里我想要获得的就是以项目名命名的 Target, 一般都是 <code class="highlighter-rouge">targets</code> 数组中的第一个.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">target</span> <span class="o">=</span> <span class="n">project</span><span class="p">.</span><span class="nf">targets</span><span class="p">.</span><span class="nf">first</span>
</code></pre></div></div>

<h4 id="创建-group">创建 Group</h4>

<p><a href="https://github.com/CocoaPods/Xcodeproj/blob/master/lib/xcodeproj/project/object/group.rb">lib/xcodeproj/project/object/group.rb</a></p>

<p>在获取 Target 之后, 需要创建或者获取一个文件即将被添加进去的 <code class="highlighter-rouge">group</code>, 我一般使用 <code class="highlighter-rouge">find_subpath</code> 这个方法</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_subpath</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">should_create</span> <span class="o">=</span> <span class="kp">false</span><span class="p">)</span>
</code></pre></div></div>

<p>它能比较快捷的根据路径名寻找 <code class="highlighter-rouge">group</code>, 如果当前的 <code class="highlighter-rouge">group</code> 不存在, 它还会递归地创建(可选).</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">group</span> <span class="o">=</span> <span class="n">project</span><span class="p">.</span><span class="nf">main_group</span><span class="p">.</span><span class="nf">find_subpath</span><span class="p">(</span><span class="no">File</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">'DKNightVersion'</span><span class="p">,</span> <span class="s1">'Pod'</span><span class="p">,</span> <span class="s1">'Classes'</span><span class="p">,</span> <span class="s1">'UIKit'</span><span class="p">),</span> <span class="kp">true</span><span class="p">)</span>
</code></pre></div></div>

<p>因为这个方法是一个 <code class="highlighter-rouge">group</code> 的实例方法, 所以先通过 <code class="highlighter-rouge">main_group</code> 获取主 <code class="highlighter-rouge">group</code>, 然后再调用这个方法, 最后会返回指定的 <code class="highlighter-rouge">group</code>. 在工程中创建这样一种的结构.</p>

<p><img src="/content/images/2015/05/508108E0-0EF4-4A8B-8A80-5D2CA5208D58.png" alt="" /></p>

<p>在成功获取之后还<strong>需要把 <code class="highlighter-rouge">group</code> 的 <code class="highlighter-rouge">source_tree</code> 设置成 <code class="highlighter-rouge">'SOURCE_ROOT'</code></strong>, 这样在加入到 Build Phases 的时候, 它会从工程文件的根目录下开始寻找你所添加的文件, 不会出现一些非常奇怪的问题.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">group</span><span class="p">.</span><span class="nf">set_source_tree</span><span class="p">(</span><span class="s1">'SOURCE_ROOT'</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="向-group-中添加文件">向 <code class="highlighter-rouge">group</code> 中添加文件</h3>

<p><a href="https://github.com/CocoaPods/Xcodeproj/blob/master/lib/xcodeproj/project/object/group.rb">lib/xcodeproj/project/object/group.rb</a></p>

<p>我们在获取 <code class="highlighter-rouge">group</code> 之后就可以向其中添加文件了. 在这时使用 <code class="highlighter-rouge">new_reference</code> 方法, 为文件创建一个 <code class="highlighter-rouge">FileRef</code> 添加到 <code class="highlighter-rouge">group</code> 中.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">file_ref</span> <span class="o">=</span> <span class="n">group</span><span class="p">.</span><span class="nf">new_reference</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
</code></pre></div></div>

<p>这样这个文件就添加到了 <code class="highlighter-rouge">group</code> 中, 会出现在工程中的导航栏中.</p>

<p>但是这个文件并没有被添加到 <code class="highlighter-rouge">Build Phases</code> 中, 无论你是编译还是作为资源来使用, Xcode 都会提示你无法找到这个文件. 我们还需要把这个文件加入到 <code class="highlighter-rouge">Build Phases</code> 中.</p>

<h3 id="将文件加入-build-phases">将文件加入 <code class="highlighter-rouge">Build Phases</code></h3>

<p><a href="https://github.com/CocoaPods/Xcodeproj/blob/master/lib/xcodeproj/project/object/native_target.rb">lib/xcodeproj/project/object/native_target.rb</a></p>

<p>在前面获取到的 <code class="highlighter-rouge">Target</code> 在这一步就开始起了作用, 我们需要获取 <code class="highlighter-rouge">Target</code> 的 <code class="highlighter-rouge">Build Phase</code> 并将在上面添加的文件添加到 <code class="highlighter-rouge">Build Phase</code> 中.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">target</span><span class="p">.</span><span class="nf">add_file_references</span><span class="p">([</span><span class="n">file_ref</span><span class="p">])</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">add_file_references</code> 就负责把一组 <code class="highlighter-rouge">FileRef</code> 添加到对应的 <code class="highlighter-rouge">Build Phases</code> 中, <code class="highlighter-rouge">source_build_phase</code> <code class="highlighter-rouge">headers_build_phase</code> <code class="highlighter-rouge">resource_build_phase</code> <code class="highlighter-rouge">framework_build_phase</code> 在 GUI 中你可以找到这四者对应的 section.</p>

<p>而 <code class="highlighter-rouge">add_file_references</code> 方法自动为你把 <code class="highlighter-rouge">FileRef</code> 添加到合适的 phase 中.</p>

<p>但是从 <code class="highlighter-rouge">Build Phase</code> 中移除文件就需要手动获取这些 <code class="highlighter-rouge">*_build_phase</code> 然后从中调用 <code class="highlighter-rouge">remove_reference</code> 来删除文件或者资源.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">target</span><span class="p">.</span><span class="nf">source_build_phase</span><span class="p">.</span><span class="nf">remove_file_reference</span><span class="p">(</span><span class="n">file_ref</span><span class="p">)</span>
<span class="n">target</span><span class="p">.</span><span class="nf">headers_build_phase</span><span class="p">.</span><span class="nf">remove_file_refernece</span><span class="p">(</span><span class="n">file_ref</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="保存-project">保存 Project</h4>

<p>在最后, 我们只需要调用 <code class="highlighter-rouge">save</code> 方法来保存整个工程就好了.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">project</span><span class="p">.</span><span class="nf">save</span>
</code></pre></div></div>

<h2 id="总结">总结</h2>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">project</span> <span class="o">=</span> <span class="no">Xcodeproj</span><span class="o">::</span><span class="no">Project</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="n">target</span> <span class="o">=</span> <span class="n">project</span><span class="p">.</span><span class="nf">targets</span><span class="p">.</span><span class="nf">first</span>
<span class="n">group</span> <span class="o">=</span> <span class="n">project</span><span class="p">.</span><span class="nf">main_group</span><span class="p">.</span><span class="nf">find_subpath</span><span class="p">(</span><span class="no">File</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">'DKNightVersion'</span><span class="p">,</span> <span class="s1">'Pod'</span><span class="p">,</span> <span class="s1">'Classes'</span><span class="p">,</span> <span class="s1">'UIKit'</span><span class="p">),</span> <span class="kp">true</span><span class="p">)</span>
<span class="n">group</span><span class="p">.</span><span class="nf">set_source_tree</span><span class="p">(</span><span class="s1">'SOURCE_ROOT'</span><span class="p">)</span>
<span class="n">file_ref</span> <span class="o">=</span> <span class="n">group</span><span class="p">.</span><span class="nf">new_reference</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>
<span class="n">target</span><span class="p">.</span><span class="nf">add_file_references</span><span class="p">([</span><span class="n">file_ref</span><span class="p">])</span>
<span class="n">project</span><span class="p">.</span><span class="nf">save</span>
</code></pre></div></div>

<p>其实到现在为止, 我感觉到使用代码向 Xcodeproj 中添加文件是很简单的事情, 那是因为, 首先有 Xcodeproj 这样文档糟糕但是功能还是比较齐全的第三方框架, 而且这是我在几天不停地阅读源代码, 不停被坑, 一点一点尝试才摸索出来的结果, 都是泪啊…不想多说了…不过最后把这个问题解决之后, <del>自我感觉还是蛮好的</del>还是挺高兴的. 嗯, 就这样.</p>

	  ]]></description>
	</item>

	<item>
	  <title>StackOverflow 黑魔法系列 <1></title>
	  <link>/blogs//stackoverflow-hei-mo-fa-xi-lie-1</link>
	  <author></author>
	  <pubDate>2015-04-30T13:52:25+00:00</pubDate>
	  <guid>/blogs//stackoverflow-hei-mo-fa-xi-lie-1</guid>
	  <description><![CDATA[
	     <p>最近看到了很多关于 iOS 开发的黑魔法, 发现最终的链接都是来自与 <a href="http://stackoverflow.com/">stackoverflow</a>, 我感觉需要在 stackoverflow 上这个社区逛一逛, 找一些比较<del>屌~~神奇的黑魔法来分享一下, 也能够</del>多两篇水文~~提高一下自己的水平, 当然我会在每一条”咒语”的后面加上原文的链接.</p>

<h2 id="原子atomic和非原子nonatomic的区别是什么">原子(atomic)和非原子(nonatomic)的区别是什么?</h2>

<pre><code class="language-objectivec">@property(nonatomic, retain) UITextField *userName;
@property(atomic, retain) UITextField *userName;
@property(retain) UITextField *userName;
</code></pre>

<p>这三行代码中的后两行是相同的, 因为 <code class="highlighter-rouge">atomic</code> 是默认的行为. 在现在的 LLVM 的版本中, 使用 <code class="highlighter-rouge">atomic</code> 和 <code class="highlighter-rouge">nonatomic</code> 声明的属性在自动生成 <code class="highlighter-rouge">getter/setter</code> 方法时有所不同.</p>

<p>如果你是用了 <code class="highlighter-rouge">atomic</code>, 那么自动合成的 <code class="highlighter-rouge">getter/setter</code> 方法会确保值会正确从 <code class="highlighter-rouge">getter</code> 中返回, 或者能够正确的被 <code class="highlighter-rouge">setter</code> 所设置, 也就是加锁. 同一时间只能访问(包含 <code class="highlighter-rouge">getter/setter</code>)这个属性一次.</p>

<p>在 <code class="highlighter-rouge">nonatomic</code> 中, 就不会保证同一时间只有一个操作能够访问该属性了, 这也会加快属性的访问速度, 使得 <code class="highlighter-rouge">nonatomic</code> 比 <code class="highlighter-rouge">atomic</code> 快的多.</p>

<p>然而 <code class="highlighter-rouge">atomic</code> 并不能保证线程的安全, 如果在 <code class="highlighter-rouge">线程 A</code> 中调用 getter, 与此同时在 <code class="highlighter-rouge">线程 B</code> 和 <code class="highlighter-rouge">线程 C</code> 中调用 <code class="highlighter-rouge">setter</code>, 那么 <code class="highlighter-rouge">线程 A</code> 中可能获得 B/C 中某一个属性的值. 但是我们并不知道结果. 所以, <code class="highlighter-rouge">atomic</code> 虽然能在一定程度上确保 <code class="highlighter-rouge">getter/setter</code> 方法的正确调用但是并不能 100% 的确保线程的安全.</p>

<p>而确保线程安全和数据完整, 也是我们在使用多线程编程中的主要挑战, 它可以通过别的方法来解决.</p>

<p>链接: <a href="http://stackoverflow.com/questions/588866/whats-the-difference-between-the-atomic-and-nonatomic-attributes">What’s the difference between the atomic and nonatomic attributes?</a></p>

<hr />

<h2 id="如何使用-iphone-sdk-检查当前网络的状态">如何使用 iPhone SDK 检查当前网络的状态?</h2>

<p>检查当前网络的状态还是有多种方法的.</p>

<p>提问的人首先提了一个非常取巧也非常聪明的办法, 它直接使用了 <code class="highlighter-rouge">stringWithContentsOfURL:</code> 这个方法来访问 Google, 然后查看是否有 response 来判断网络的状态.</p>

<pre><code class="language-objectivec">- (BOOL) connectedToInternet {
  NSString *URLString = [NSString stringWithContentsOfURL:[NSURL URLWithString:@"http://www.google.com"]];
  return ( URLString != NULL ) ? YES : NO;
}
</code></pre>

<p>但是这段代码在天朝还是行不通啊, 我们并没有 Google 这个网站, 当然可以把 Google 改成随便什么别的网站来解决这个问题, 但是我们还是需要一种更加”靠谱”的解决方案.</p>

<p>第二种方法是使用第三方开源框架 <a href="https://github.com/tonymillion/Reachability">Reachability</a></p>

<p>在实现文件的中添加如下代码, 然后填写你想要测试连通性的 host:</p>

<pre><code class="language-objectivec">// Checks if we have an internet connection or not
    - (void)testInternetConnection {   
    // Allocate a reachability object
    Reachability* reach = [Reachability reachabilityWithHostname:@"www.google.com"];

    // Set the blocks
    reach.reachableBlock = ^(Reachability*reach) {
    // keep in mind this is called on a background thread
    // and if you are updating the UI it needs to happen
    // on the main thread, like this:

        dispatch_async(dispatch_get_main_queue(), ^{
            NSLog(@"REACHABLE!");
        });
    };

    reach.unreachableBlock = ^(Reachability*reach) {
        NSLog(@"UNREACHABLE!");
    };

    // Start the notifier, which will cause the reachability object to retain itself!
    [reach startNotifier];
}
</code></pre>

<p>链接: <a href="http://stackoverflow.com/questions/1083701/how-to-check-for-an-active-internet-connection-on-iphone-sdk">How to check for an active Internet Connection on iPhone SDK?</a></p>

<hr />

<h2 id="在-objective-c-的字符串中如何查询是否含有子字符串">在 Objective-C 的字符串中如何查询是否含有子字符串?</h2>

<p>在 iOS8 以前, 我们需要使用 <code class="highlighter-rouge">rangeOfString:</code> 方法来判断是否含有子字符串:</p>

<pre><code class="language-objectivec">NSString *string = @"hello bla bla";
if ([string rangeOfString:@"bla"].location == NSNotFound) {
   NSLog(@"string does not contain bla");
} else {
   NSLog(@"string contains bla!");
}
</code></pre>

<p>其中最关键的地方是 <code class="highlighter-rouge">rangeOfString:</code> 会返回一个 <code class="highlighter-rouge">NSRange</code> 的结构体, <code class="highlighter-rouge">{NSNotFound, 0}</code>, 所以我们要获取结构体中的 <code class="highlighter-rouge">location</code> 来判断是否存在该字符串, 详见<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSString_Class/index.html#//apple_ref/occ/instm/NSString/rangeOfString:">文档</a>.</p>

<p>而在 iOS8 之后, 苹果<del>大发慈悲地</del>为我们提供了更加友善的解决办法, 也就是 <code class="highlighter-rouge">containString:</code> 方法直接解决了这个问题.</p>

<pre><code class="language-objectivec">NSString *string = @"hello bla blah";
if ([string containsString:@"bla"]) {
   NSLog(@"string contains bla!");
} else {
   NSLog(@"string does not contain bla");
}
</code></pre>

<p>链接: <a href="http://stackoverflow.com/questions/2753956/how-do-i-check-if-a-string-contains-another-string-in-objective-c">How do I check if a string contains another string in Objective-C?</a></p>

<h2 id="当键盘出现时-如何使-uitextfield-向上移动">当键盘出现时, 如何使 <code class="highlighter-rouge">UITextField</code> 向上移动?</h2>

<p>在 iOS 开发中, 我们经常会遇到这样的问题, 键盘的出现会遮挡已有的文本框使得用户无法看到自己的输入. 这其实是一个比较麻烦的问题, 并不是一两行代码能够解决的. 在这个问题中, 需要注意两点:</p>

<ul>
  <li>如果你所要显示的内容并没有全部在 iPhone 屏幕中, 那么就需要添加一个 <code class="highlighter-rouge">UIScrollView</code>, 也就是说, 如果仅仅为了使得 <code class="highlighter-rouge">UITextField</code> 上移, 添加 <code class="highlighter-rouge">UIScrollView</code> 是得不偿失并且浪费的.</li>
  <li>解决这个问题最标准的办法就是, 在键盘出现的时候上移 <code class="highlighter-rouge">UITextField</code>, 在键盘消失的时候下移 <code class="highlighter-rouge">UITextField</code>.</li>
</ul>

<p>在这里我们要使用通知来解决这个问题, 首先我们要在 <code class="highlighter-rouge">viewWillAppear:</code> 和 <code class="highlighter-rouge">viewWillDisapear:</code> 中分别注册和移除通知.</p>

<pre><code class="language-objectivec">- (void)viewWillAppear:(BOOL)animated {
   [super viewWillAppear:animated];
   [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow) name:UIKeyboardWillShowNotification object:nil];
   [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillHide) name:UIKeyboardWillHideNotification object:nil];
}

- (void)viewWillDisappear:(BOOL)animated {
   [super viewWillDisappear:animated];
   [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardWillShowNotification object:nil];
   [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardWillHideNotification object:nil];
}
</code></pre>

<p>然后我们需要实现一个 <code class="highlighter-rouge">UITextField</code> 的代理方法 <code class="highlighter-rouge">textFieldDidBeginEditing:</code> 当 <code class="highlighter-rouge">UITextField</code> 开始编辑键盘准备响应的时候, 让 <code class="highlighter-rouge">UITextField</code> 向上弹出.</p>

<pre><code class="language-objectivec">- (void)textFieldDidBeginEditing:(UITextField *)sender {
   //move the main view, so that the keyboard does not hide it.
   if  (self.view.frame.origin.y &gt;= 0) {
       [self setViewMovedUp:YES];
   }
}
</code></pre>

<p>接下来实现当键盘弹出或隐藏发出通知所响应的两个方法, <code class="highlighter-rouge">keyboardWillShow</code> 和 <code class="highlighter-rouge">keyboardWillHide</code>.</p>

<pre><code class="language-objectivec">- (void)keyboardWillShow {
   // Animate the current view out of the way
   if (self.view.frame.origin.y &gt;= 0) {
       [self setViewMovedUp:YES];
   } else if (self.view.frame.origin.y &lt; 0) {
       [self setViewMovedUp:NO];
   }
}

- (void)keyboardWillHide {
   if (self.view.frame.origin.y &gt;= 0) {
       [self setViewMovedUp:YES];
   } else if (self.view.frame.origin.y &lt; 0) {
       [self setViewMovedUp:NO];
   }
}
</code></pre>

<p>在最后, 就来实现使 <code class="highlighter-rouge">UITextField</code> 移动的方法 <code class="highlighter-rouge">setViewMovedUp:</code> 了.</p>

<pre><code class="language-objectivec">#define kOFFSET_FOR_KEYBOARD 80.0

- (void)setViewMovedUp:(BOOL)movedUp {
   [UIView beginAnimations:nil context:NULL];
   [UIView setAnimationDuration:0.3]; // if you want to slide up the view

   CGRect rect = self.view.frame;
   if (movedUp) {
       // 1. move the view's origin up so that the text field that will be hidden come above the keyboard
       // 2. increase the size of the view so that the area behind the keyboard is covered up.
       rect.origin.y -= kOFFSET_FOR_KEYBOARD;
       rect.size.height += kOFFSET_FOR_KEYBOARD;
   } else {
       // revert back to the normal state.
       rect.origin.y += kOFFSET_FOR_KEYBOARD;
       rect.size.height -= kOFFSET_FOR_KEYBOARD;
   }
   self.view.frame = rect;

   [UIView commitAnimations];
}
</code></pre>

<p>这种重要的问题在苹果的<a href="https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/KeyboardManagement/KeyboardManagement.html#//apple_ref/doc/uid/TP40009542-CH5-SW7">官方文档</a>中也对应的实现方法.</p>

<p>链接: <a href="http://stackoverflow.com/questions/1126726/how-to-make-a-uitextfield-move-up-when-keyboard-is-present">How to make a UITextField move up when keyboard is present</a></p>

<hr />

<h2 id="如何在-uitableview-中禁止选择的高亮">如何在 <code class="highlighter-rouge">UITableView</code> 中禁止选择的高亮?</h2>

<pre><code class="language-objectivec">tableView.allowsSelection = NO;
</code></pre>

<p>链接: <a href="http://stackoverflow.com/questions/190908/how-can-i-disable-the-uitableview-selection-highlighting">How can I disable the UITableView selection highlighting?</a></p>

	  ]]></description>
	</item>

	<item>
	  <title>iOS 源代码分析----Masonry</title>
	  <link>/blogs//ios-yuan-dai-ma-fen-xi-masonry</link>
	  <author></author>
	  <pubDate>2015-04-27T08:40:22+00:00</pubDate>
	  <guid>/blogs//ios-yuan-dai-ma-fen-xi-masonry</guid>
	  <description><![CDATA[
	     <p><a href="https://github.com/SnapKit/Masonry">Masonry</a> 是 Objective-C 中用于自动布局的第三方框架, 我们一般使用它来代替冗长, 繁琐的 AutoLayout 代码.</p>

<p>Masonry 的使用还是很简洁的:</p>

<pre><code class="language-objectivec">[button mas_makeConstraints:^(MASConstraintMaker *make) {
	make.centerX.equalTo(self.view);
	make.top.equalTo(self.view).with.offset(40);
	make.width.equalTo(@185);
	make.height.equalTo(@38);
}];
</code></pre>

<h2 id="从-mas_makeconstraints-开始">从 mas_makeConstraints: 开始</h2>

<p>其中最常用的方法就是</p>

<pre><code class="language-objectivec">// View+MASAdditions.h

- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;
</code></pre>

<p>同样, 也有用于<strong>更新和重新构建</strong>约束的分类方法:</p>

<pre><code class="language-objectivec">// View+MASAdditions.h

- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;
- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block;
</code></pre>

<h2 id="constraint-maker-block">Constraint Maker Block</h2>

<p>我们以 <code class="highlighter-rouge">mas_makeConstraints:</code> 方法为入口来分析一下 Masonry 以及类似的框架(SnapKit)是如何工作的. <code class="highlighter-rouge">mas_makeConstraints:</code> 方法位于 <code class="highlighter-rouge">UIView</code> 的分类 <code class="highlighter-rouge">MASAdditions</code> 中.</p>

<blockquote>
  <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Provides constraint maker block and convience methods for creating MASViewAttribute which are view + NSLayoutAttribute pairs.
</code></pre></div>  </div>
</blockquote>

<p>这个分类为我们提供一种非常便捷的方法来配置 <code class="highlighter-rouge">MASConstraintMaker</code>, 并为视图添加 <code class="highlighter-rouge">mas_left</code> <code class="highlighter-rouge">mas_right</code> 等属性.</p>

<p>方法的实现如下:</p>

<pre><code class="language-objectivec">// View+MASAdditions.m

- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block {
    self.translatesAutoresizingMaskIntoConstraints = NO;
    MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];
    block(constraintMaker);
    return [constraintMaker install];
}
</code></pre>

<p>因为 Masonry 是封装的苹果的 AutoLayout 框架, 所以我们要在为视图添加约束前将 <code class="highlighter-rouge">translatesAutoresizingMaskIntoConstraints</code> 属性设置为 <code class="highlighter-rouge">NO</code>. 如果这个属性没有被正确设置, 那么视图的约束不会被成功添加.</p>

<p>在设置 <code class="highlighter-rouge">translatesAutoresizingMaskIntoConstraints</code> 属性之后,</p>

<ul>
  <li>我们会初始化一个 <code class="highlighter-rouge">MASConstraintMaker</code> 的实例.</li>
  <li>然后将 maker 传入 block 配置其属性.</li>
  <li>最后调用 maker 的 <code class="highlighter-rouge">install</code> 方法为视图添加约束.</li>
</ul>

<h2 id="masconstraintmaker">MASConstraintMaker</h2>

<p><code class="highlighter-rouge">MASConstraintMaker</code> 为我们提供了工厂方法来创建 <code class="highlighter-rouge">MASConstraint</code>. 所有的约束都会被收集直到它们最后调用 <code class="highlighter-rouge">install</code> 方法添加到视图上.</p>

<blockquote>
  <p>Provides factory methods for creating MASConstraints. Constraints are collected until they are ready to be installed</p>
</blockquote>

<p>在初始化 <code class="highlighter-rouge">MASConstraintMaker</code> 的实例时, 它会<strong>持有一个对应 view 的弱引用</strong>, 并初始化一个  <code class="highlighter-rouge">constraints</code> 的空可变数组用来之后配置属性时持有所有的约束.</p>

<pre><code class="language-objectivec">// MASConstraintMaker.m

- (id)initWithView:(MAS_VIEW *)view {
    self = [super init];
    if (!self) return nil;

    self.view = view;
    self.constraints = NSMutableArray.new;

    return self;
}
</code></pre>

<p>这里的 <code class="highlighter-rouge">MAS_VIEW</code> 是一个宏, 是 <code class="highlighter-rouge">UIView</code> 的 alias.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MASUtilities.h
</span>
<span class="cp">#define MAS_VIEW UIView
</span></code></pre></div></div>

<h2 id="setup-masconstraintmaker">Setup MASConstraintMaker</h2>

<p>在调用 <code class="highlighter-rouge">block(constraintMaker)</code> 时, 实际上是对 <code class="highlighter-rouge">constraintMaker</code> 的配置.</p>

<pre><code class="language-objectivec">make.centerX.equalTo(self.view);
make.top.equalTo(self.view).with.offset(40);
make.width.equalTo(@185);
make.height.equalTo(@38);
</code></pre>

<h3 id="makeleft">make.left</h3>

<p>访问 <code class="highlighter-rouge">make</code> 的 <code class="highlighter-rouge">left</code> <code class="highlighter-rouge">right</code> <code class="highlighter-rouge">top</code> <code class="highlighter-rouge">bottom</code>  等属性时, 会调用 <code class="highlighter-rouge">constraint:addConstraintWithLayoutAttribute:</code> 方法.</p>

<pre><code class="language-objectivec">// MASViewConstraint.m

- (MASConstraint *)left {
    return [self addConstraintWithLayoutAttribute:NSLayoutAttributeLeft];
}

- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {
    return [self constraint:nil addConstraintWithLayoutAttribute:layoutAttribute];
}

- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute {
    MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute];
    MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];
    if ([constraint isKindOfClass:MASViewConstraint.class]) { ... }
    if (!constraint) {
        newConstraint.delegate = self;
        [self.constraints addObject:newConstraint];
    }
    return newConstraint;
}
</code></pre>

<p>在调用链上最终会达到 <code class="highlighter-rouge">constraint:addConstraintWithLayoutAttribute:</code> 这一方法, 在这里省略了一些暂时不需要了解的问题. 因为在这个类中传入该方法的第一个参数一直为 <code class="highlighter-rouge">nil</code>, 所以这里省略的代码不会执行.</p>

<p>这部分代码会先以布局属性 <code class="highlighter-rouge">left</code> 和视图本身初始化一个 <code class="highlighter-rouge">MASViewAttribute</code> 的实例, 之后使用 <code class="highlighter-rouge">MASViewAttribute</code> 的实例初始化一个 <code class="highlighter-rouge">constraint</code> 并设置它的代理, 加入数组, 然后返回.</p>

<p>这些工作就是你在输入 <code class="highlighter-rouge">make.left</code> 进行的全部工作, 它会返回一个 <code class="highlighter-rouge">MASConstraint</code>, 用于之后的继续配置.</p>

<h3 id="makeleftequalto80">make.left.equalTo(@80)</h3>

<p>在 <code class="highlighter-rouge">make.left</code> 返回 <code class="highlighter-rouge">MASConstraint</code> 之后, 我们会继续在这个链式的语法中调用下一个方法来指定约束的关系.</p>

<pre><code class="language-objectivec">// MASConstraint.h

- (MASConstraint * (^)(id attr))equalTo;
- (MASConstraint * (^)(id attr))greaterThanOrEqualTo;
- (MASConstraint * (^)(id attr))lessThanOrEqualTo;
</code></pre>

<p>这三个方法是在 <code class="highlighter-rouge">MASViewConstraint</code> 的父类, <code class="highlighter-rouge">MASConstraint</code> 中定义的.</p>

<p><code class="highlighter-rouge">MASConstraint</code> 是一个抽象类, 其中有很多的方法都<strong>必须在子类中覆写</strong>的. Masonry 中有两个 <code class="highlighter-rouge">MASConstraint</code> 的子类, 分别是 <code class="highlighter-rouge">MASViewConstraint</code> 和 <code class="highlighter-rouge">MASCompositeConstraint</code>. 后者实际上是一些<strong>约束的集合</strong>. 这么设计的原因我们会在 post 的最后解释.</p>

<p>先来看一下这三个方法是怎么实现的:</p>

<pre><code class="language-objectivec">// MASConstraint.m

- (MASConstraint * (^)(id))equalTo {
    return ^id(id attribute) {
        return self.equalToWithRelation(attribute, NSLayoutRelationEqual);
    };
}
</code></pre>

<p>该方法会导致 <code class="highlighter-rouge">self.equalToWithRelation</code> 的执行, 而这个方法是定义在子类中的, 因为父类作为抽象类没有提供这个方法的具体实现.</p>

<pre><code class="language-objectivec">// MASConstraint.m

- (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation { MASMethodNotImplemented(); }
</code></pre>

<p><code class="highlighter-rouge">MASMethodNotImplemented</code> 也是一个宏定义, 用于在<strong>子类未继承这个方法</strong>或者<strong>直接使用这个类</strong>时抛出异常.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// MASConstraint.m
</span>
<span class="cp">#define MASMethodNotImplemented() \
    @throw [NSException exceptionWithName:NSInternalInconsistencyException \
                                   reason:[NSString stringWithFormat:@"You must override %@ in a subclass.", NSStringFromSelector(_cmd)] \
                                 userInfo:nil]
</span>
</code></pre></div></div>

<p>因为我们为 <code class="highlighter-rouge">equalTo</code> 提供了参数 <code class="highlighter-rouge">attribute</code> 和布局关系 <code class="highlighter-rouge">NSLayoutRelationEqual</code>, 这两个参数会传递到 <code class="highlighter-rouge">equalToWithRelation</code> 中, 设置 <code class="highlighter-rouge">constraint</code> 的布局关系和 <code class="highlighter-rouge">secondViewAttribute</code> 属性, 为即将 maker 的 <code class="highlighter-rouge">install</code> 做准备.</p>

<pre><code class="language-objectivec">// MASViewConstraint.m

- (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation {
    return ^id(id attribute, NSLayoutRelation relation) {
        if ([attribute isKindOfClass:NSArray.class]) { ... }
        else {
            ...
            self.layoutRelation = relation;
            self.secondViewAttribute = attribute;
            return self;
        }
    };
}
</code></pre>

<p>我们不得不提一下 <code class="highlighter-rouge">setSecondViewAttribute:</code> 方法, 它并不只是一个简单的 setter 方法, 它会根据你传入的值的种类赋值.</p>

<pre><code class="language-objectivec">// MASConstraintMaker.m

- (void)setSecondViewAttribute:(id)secondViewAttribute {
    if ([secondViewAttribute isKindOfClass:NSValue.class]) {
        [self setLayoutConstantWithValue:secondViewAttribute];
    } else if ([secondViewAttribute isKindOfClass:MAS_VIEW.class]) {
        _secondViewAttribute = [[MASViewAttribute alloc] initWithView:secondViewAttribute layoutAttribute:self.firstViewAttribute.layoutAttribute];
    } else if ([secondViewAttribute isKindOfClass:MASViewAttribute.class]) {
        _secondViewAttribute = secondViewAttribute;
    } else {
        NSAssert(NO, @"attempting to add unsupported attribute: %@", secondViewAttribute);
    }
}
</code></pre>

<p>第一种情况对应的就是:</p>

<pre><code class="language-objectivec">make.left.equalTo(@40);
</code></pre>

<p>传入 <code class="highlighter-rouge">NSValue</code> 的时, 会直接设置 <code class="highlighter-rouge">constraint</code> 的 <code class="highlighter-rouge">offset</code>, <code class="highlighter-rouge">centerOffset</code>, <code class="highlighter-rouge">sizeOffset</code>, 或者 <code class="highlighter-rouge">insets</code></p>

<p>第二种情况一般会直接传入一个视图:</p>

<pre><code class="language-objectivec">make.left.equalTo(view);
</code></pre>

<p>这时, 就会初始化一个 <code class="highlighter-rouge">layoutAttribute</code> 属性与 <code class="highlighter-rouge">firstViewArribute</code> 相同的 <code class="highlighter-rouge">MASViewAttribute</code>, 上面的代码就会使视图与 <code class="highlighter-rouge">view</code> 左对齐.</p>

<p>第三种情况会传入一个视图的 <code class="highlighter-rouge">MASViewAttribute</code>:</p>

<pre><code class="language-objectivec">make.left.equalTo(view.mas_right);
</code></pre>

<p>使用这种写法时, 一般是因为约束的方向不同. 这行代码会使视图的左侧与 <code class="highlighter-rouge">view</code> 的右侧对齐.</p>

<p>到这里我们就基本完成了对<strong>一个</strong>约束的配置, 接下来可以使用相同的语法完成对一个视图上所有约束进行配置, 然后进入了最后一个环节.</p>

<h2 id="install-masconstraintmaker">Install MASConstraintMaker</h2>

<p>我们会在 <code class="highlighter-rouge">mas_makeConstraints:</code> 方法的最后调用 <code class="highlighter-rouge">[constraintMaker install]</code> 方法来安装所有存储在 <code class="highlighter-rouge">self.constraints</code> 数组中的所有约束.</p>

<pre><code class="language-objectivec">// MASConstraintMaker.m

- (NSArray *)install {
    if (self.removeExisting) {
        NSArray *installedConstraints = [MASViewConstraint installedConstraintsForView:self.view];
        for (MASConstraint *constraint in installedConstraints) {
            [constraint uninstall];
        }
    }
    NSArray *constraints = self.constraints.copy;
    for (MASConstraint *constraint in constraints) {
        constraint.updateExisting = self.updateExisting;
        [constraint install];
    }
    [self.constraints removeAllObjects];
    return constraints;
}
</code></pre>

<p>在这个方法会先判断当前的视图的约束是否应该要被 <code class="highlighter-rouge">uninstall</code>, 如果我们在最开始调用 <code class="highlighter-rouge">mas_remakeConstraints:</code> 方法时, 视图中原来的约束就会全部被 <code class="highlighter-rouge">uninstall</code>.</p>

<p>然后就会遍历 <code class="highlighter-rouge">constraints</code> 数组, 发送 <code class="highlighter-rouge">install</code> 消息.</p>

<h3 id="masviewconstraint-install">MASViewConstraint install</h3>

<p>MASViewConstraint 的 <code class="highlighter-rouge">install</code> 方法就是最后为当前视图添加约束的最后的方法, 首先这个方法会先获取即将用于初始化 <code class="highlighter-rouge">NSLayoutConstraint</code> 的子类的几个属性.</p>

<pre><code class="language-objectivec">// MASViewConstraint.m

MAS_VIEW *firstLayoutItem = self.firstViewAttribute.view;
NSLayoutAttribute firstLayoutAttribute = self.firstViewAttribute.layoutAttribute;
MAS_VIEW *secondLayoutItem = self.secondViewAttribute.view;
NSLayoutAttribute secondLayoutAttribute = self.secondViewAttribute.layoutAttribute;
</code></pre>

<p>Masonry 之后会判断当前即将添加的约束是否是 size 类型的约束</p>

<pre><code class="language-objectivec">// MASViewConstraint.m

if (!self.firstViewAttribute.isSizeAttribute &amp;&amp; !self.secondViewAttribute) {
   secondLayoutItem = firstLayoutItem.superview;
   secondLayoutAttribute = firstLayoutAttribute;
}
</code></pre>

<p>如果不是 size 类型并且没有提供第二个 <code class="highlighter-rouge">viewAttribute</code>, (e.g. <code class="highlighter-rouge">make.left.equalTo(@10);</code>) 会自动将约束添加到 <code class="highlighter-rouge">superview</code> 上. 它等价于:</p>

<pre><code class="language-objectivec">make.left.equalTo(superView.mas_left).with.offset(10);
</code></pre>

<p>然后就会初始化 <code class="highlighter-rouge">NSLayoutConstraint</code> 的子类 <code class="highlighter-rouge">MASLayoutConstraint</code>:</p>

<pre><code class="language-objectivec">// MASViewConstraint.m

MASLayoutConstraint *layoutConstraint
   = [MASLayoutConstraint constraintWithItem:firstLayoutItem
                                   attribute:firstLayoutAttribute
                                   relatedBy:self.layoutRelation
                                      toItem:secondLayoutItem
                                   attribute:secondLayoutAttribute
                                  multiplier:self.layoutMultiplier
                                    constant:self.layoutConstant];
layoutConstraint.priority = self.layoutPriority;                                    
</code></pre>

<p>接下来它会寻找 <code class="highlighter-rouge">firstLayoutItem</code> 和 <code class="highlighter-rouge">secondLayoutItem</code> 两个视图的公共 <code class="highlighter-rouge">superview</code>, 相当于求两个数的最小公倍数.</p>

<pre><code class="language-objectivec">// View+MASAdditions.m

- (instancetype)mas_closestCommonSuperview:(MAS_VIEW *)view {
    MAS_VIEW *closestCommonSuperview = nil;

    MAS_VIEW *secondViewSuperview = view;
    while (!closestCommonSuperview &amp;&amp; secondViewSuperview) {
        MAS_VIEW *firstViewSuperview = self;
        while (!closestCommonSuperview &amp;&amp; firstViewSuperview) {
            if (secondViewSuperview == firstViewSuperview) {
                closestCommonSuperview = secondViewSuperview;
            }
            firstViewSuperview = firstViewSuperview.superview;
        }
        secondViewSuperview = secondViewSuperview.superview;
    }
    return closestCommonSuperview;
}
</code></pre>

<p>如果需要升级当前的约束就会获取原有的约束, 并替换为新的约束, 这样就不需要再次为 <code class="highlighter-rouge">view</code> 安装约束.</p>

<pre><code class="language-objectivec">// MASViewConstraint.m

MASLayoutConstraint *existingConstraint = nil;
if (self.updateExisting) {
   existingConstraint = [self layoutConstraintSimilarTo:layoutConstraint];
}
if (existingConstraint) {
   // just update the constant
   existingConstraint.constant = layoutConstraint.constant;
   self.layoutConstraint = existingConstraint;
} else {
   [self.installedView addConstraint:layoutConstraint];
   self.layoutConstraint = layoutConstraint;
}

[firstLayoutItem.mas_installedConstraints addObject:self];
</code></pre>

<p>如果原来的 <code class="highlighter-rouge">view</code> 中不存在可以升级的约束, 或者没有调用 <code class="highlighter-rouge">mas_updateConstraint:</code> 方法, 那么就会在上一步寻找到的 <code class="highlighter-rouge">installedView</code> 上面添加约束.</p>

<pre><code class="language-objectivec">[self.installedView addConstraint:layoutConstraint];
</code></pre>

<h2 id="其他问题">其他问题</h2>

<p>到现在为止整个 Masonry 为视图添加约束的过程就已经完成了, 然而我们还有一些待解决的其它问题.</p>

<h3 id="makeleftequalviewwithoffset30">make.left.equal(view).with.offset(30)</h3>

<p>我们在前面的讨论中已经讨论了这个链式语法的前半部分, 但是在使用中也会”延长”这个链式语句, 比如添加 <code class="highlighter-rouge">with</code> <code class="highlighter-rouge">offset</code>.</p>

<p>其实在 Masonry 中使用 <code class="highlighter-rouge">with</code> 并不是必须的, 它的作用仅仅是使代码更加的易读.</p>

<blockquote>
  <p>Optional semantic property which has no effect but improves the readability of constraint</p>
</blockquote>

<pre><code class="language-objectivec">// MASConstraint.m
- (MASConstraint *)with {
    return self;
}

- (MASConstraint *)and {
    return self;
}
</code></pre>

<p>与 <code class="highlighter-rouge">with</code> 有着相同作用的还有 <code class="highlighter-rouge">and</code>, 这两个方法都会直接返回 <code class="highlighter-rouge">MASConstraint</code>, 方法本身不做任何的修改.</p>

<p>而 <code class="highlighter-rouge">offset</code> 方法其实是修改 <code class="highlighter-rouge">layoutConstraint</code> 中的常量, 因为 <code class="highlighter-rouge">self.layoutConstant</code> 在初始化时会被设置为 0, 我们可以通过修改 <code class="highlighter-rouge">offset</code> 属性来改变它.</p>

<pre><code class="language-objectivec">// MASViewConstraint.m

- (void)setOffset:(CGFloat)offset {
    self.layoutConstant = offset;
}
</code></pre>

<h3 id="mascompositeconstraint">MASCompositeConstraint</h3>

<p><code class="highlighter-rouge">MASCompositeConstraint</code> 是一些 <code class="highlighter-rouge">MASConstraint</code> 的集合, 它能够提供一种更加便捷的方法同时为一个视图来添加多个约束.</p>

<blockquote>
  <p>A group of MASConstraint objects</p>
</blockquote>

<p>通过 <code class="highlighter-rouge">make</code> 直接调用 <code class="highlighter-rouge">edges</code> <code class="highlighter-rouge">size</code> <code class="highlighter-rouge">center</code> 时, 就会产生一个 <code class="highlighter-rouge">MASCompositeConstraint</code> 的实例, 而这个实例会初始化所有对应的单独的约束.</p>

<pre><code class="language-objectivec">// MASConstraintMaker.m

- (MASConstraint *)edges {
    return [self addConstraintWithAttributes:MASAttributeTop | MASAttributeLeft | MASAttributeRight | MASAttributeBottom];
}

- (MASConstraint *)size {
    return [self addConstraintWithAttributes:MASAttributeWidth | MASAttributeHeight];
}

- (MASConstraint *)center {
    return [self addConstraintWithAttributes:MASAttributeCenterX | MASAttributeCenterY];
}
</code></pre>

<p>这些属性都会调用 <code class="highlighter-rouge">addConstraintWithAttributes:</code> 方法, 生成多个属于 <code class="highlighter-rouge">MASCompositeConstraint</code> 的实例.</p>

<pre><code class="language-objectivec">// MASConstraintMaker.m

NSMutableArray *children = [NSMutableArray arrayWithCapacity:attributes.count];

for (MASViewAttribute *a in attributes) {
   [children addObject:[[MASViewConstraint alloc] initWithFirstViewAttribute:a]];
}

MASCompositeConstraint *constraint = [[MASCompositeConstraint alloc] initWithChildren:children];
constraint.delegate = self;
[self.constraints addObject:constraint];
return constraint;
</code></pre>

<h3 id="mas_equalto">mas_equalTo</h3>

<p>Masonry 中还有一个类似与 magic 的宏, 这个宏将 C 和 Objective-C 语言中的一些基本数据结构比如说 <code class="highlighter-rouge">double</code> <code class="highlighter-rouge">CGPoint</code> <code class="highlighter-rouge">CGSize</code> 这些值用 <code class="highlighter-rouge">NSValue</code> 进行包装.</p>

<p>这是一种非常简洁的使用方式, 如果你对这个非常感兴趣, 可以看一下 <code class="highlighter-rouge">MASUtilities.h</code> 中的源代码, 在这里就不对这个做出解释了.</p>

<h2 id="masonry-如何为视图添加约束面试回答">Masonry 如何为视图添加约束(面试回答)</h2>

<p>Masonry 与其它的第三方开源框架一样选择了使用分类的方式为 UIKit 添加一个方法 <code class="highlighter-rouge">mas_makeConstraint</code>, 这个方法接受了一个 block, 这个 block 有一个 <code class="highlighter-rouge">MASConstraintMaker</code> 类型的参数, 这个 maker 会持有一个<strong>约束的数组</strong>, 这里保存着所有将被加入到视图中的约束.</p>

<p>我们通过链式的语法配置 maker, 设置它的 <code class="highlighter-rouge">left</code> <code class="highlighter-rouge">right</code> 等属性, 比如说 <code class="highlighter-rouge">make.left.equalTo(view)</code>, 其实这个 <code class="highlighter-rouge">left</code> <code class="highlighter-rouge">equalTo</code> 还有像 <code class="highlighter-rouge">with</code> <code class="highlighter-rouge">offset</code> 之类的方法都会返回一个 <code class="highlighter-rouge">MASConstraint</code> 的实例, 所以在这里才可以用类似 Ruby 中链式的语法.</p>

<p>在配置结束后, 首先会调用 maker 的 <code class="highlighter-rouge">install</code> 方法, 而这个 maker 的 <code class="highlighter-rouge">install</code> 方法会遍历其持有的约束数组, 对其中的每一个约束发送 <code class="highlighter-rouge">install</code> 消息. 在这里就会使用到在上一步中配置的属性, 初始化 <code class="highlighter-rouge">NSLayoutConstraint</code> 的子类 <code class="highlighter-rouge">MASLayoutConstraint</code> 并添加到合适的视图上.</p>

<p>视图的选择会通过调用一个方法 <code class="highlighter-rouge">mas_closestCommonSuperview:</code> 来返回两个视图的<strong>最近公共父视图</strong>.</p>

<h2 id="总结">总结</h2>

<p>虽然 Masonry 这个框架中的代码并不是非常的多, 只有 1,2 万行的代码, 但是感觉这个项目阅读起来十分的困难, 没有 SDWebImage 清晰, 因为代码中类的属性非常的多, 而且有很多相似的属性会干扰我们对这个项目的阅读, 整个框架运用了大量的 block 语法进行回调.</p>

<p>虽然代码十分整洁不过我觉得却降低了可读性, 但是还是那句话, 把简洁留给别人复杂留给自己, 只要为开发者提供简洁的接口就可以了.</p>

	  ]]></description>
	</item>

	<item>
	  <title>关于一些 iOS 面试问题的解答</title>
	  <link>/blogs//guan-yu-xie-ios-wen-ti-de-jie-da</link>
	  <author></author>
	  <pubDate>2015-04-26T13:59:29+00:00</pubDate>
	  <guid>/blogs//guan-yu-xie-ios-wen-ti-de-jie-da</guid>
	  <description><![CDATA[
	     <p>这篇 post 主要是对知乎上 <a href="http://www.zhihu.com/question/19604641">iOS程序员的问题列表</a> 的回答, 也算是对自己已有的知识进行整理.</p>

<p>如果你对本篇 post 中的回答有所疑问, 可以在下面留言. 如果有问题, 我一定会修改的 :-)</p>

<h2 id="问题以及回答">问题以及回答</h2>

<h3 id="1-什么是-arc-arc-是为了解决什么问题而诞生的">1. 什么是 ARC? (ARC 是为了解决什么问题而诞生的?)</h3>

<p>ARC 是 Automatic Reference Counting 的缩写, 即自动引用计数. 这是苹果在 iOS5 中引入的内存管理机制. Objective-C 和 Swift 使用 ARC 追踪和管理应用的内存使用. 这一机制使得开发者无需键入 <code class="highlighter-rouge">retain</code> 和 <code class="highlighter-rouge">release</code>, 这不仅能够降低程序崩溃和内存泄露的风险, 而且可以减少开发者的工作量, 能够大幅度提升程序的<strong>流畅性</strong>和<strong>可预测性</strong>. 但是 ARC 不适用于 Core Foundation 框架中, 仍然需要手动管理内存.</p>

<hr />

<h3 id="2-以下-keywords-有什么区别-assign-vs-weak-__block-vs-__weak">2. 以下 keywords 有什么区别: <code class="highlighter-rouge">assign vs weak</code>, <code class="highlighter-rouge">__block vs __weak</code></h3>

<p><code class="highlighter-rouge">assign</code> 和 <code class="highlighter-rouge">weak</code> 是用于在声明属性时, 为属性指定内存管理的语义.</p>

<ul>
  <li><code class="highlighter-rouge">assign</code> 用于简单的赋值, 不改变属性的引用计数, 用于 Objective-C 中的 <code class="highlighter-rouge">NSInteger</code>, <code class="highlighter-rouge">CGFloat</code> 以及 C 语言中 <code class="highlighter-rouge">int</code>, <code class="highlighter-rouge">float</code>, <code class="highlighter-rouge">double</code> 等数据类型.</li>
  <li><code class="highlighter-rouge">weak</code> 用于对象类型,  由于 <code class="highlighter-rouge">weak</code> 同样不改变对象的引用计数且不持有对象实例, 当该对象废弃时, 该弱引用自动失效并且被赋值为 <code class="highlighter-rouge">nil</code>, 所以它可以用于避免两个强引用产生的<strong>循环引用</strong>导致内存无法释放的问题.</li>
</ul>

<p><code class="highlighter-rouge">__block</code> 和 <code class="highlighter-rouge">__weak</code> 之间的却是确实极大的, 不过它们都用于修饰变量.</p>

<ul>
  <li>前者用于指明当前声明的变量在被 block 捕获之后, 可以在 block 中改变变量的值. 因为在 block 声明的同时会截获该 block 所使用的全部自动变量的值, 而这些值只在 block 中<strong>只具有”使用权”而不具有”修改权”</strong>. 而 <code class="highlighter-rouge">__block</code> 说明符就为 block 提供了变量的修改权.</li>
  <li>后者是<strong>所有权修饰符</strong>, 什么是所有权修饰符? 这里涉及到另一个问题, 因为在 ARC 有效时, id 类型和对象类型同 C 语言中的其他类型不同, 必须附加所有权修饰符. 所有权修饰符一种有 4 种:
    <ul>
      <li>__strong</li>
      <li>__weak</li>
      <li>__unsafe_unretained</li>
      <li>__autorelease</li>
    </ul>
  </li>
  <li><code class="highlighter-rouge">__weak</code> 与 <code class="highlighter-rouge">weak</code> 的区别只在于, 前者用于变量的声明, 而后者用于属性的声明.</li>
</ul>

<hr />

<h3 id="3-__block-在-arc-和非-arc-下含义一样吗">3. <code class="highlighter-rouge">__block</code> 在 ARC 和非 ARC 下含义一样吗？</h3>

<p><code class="highlighter-rouge">__block</code> <strong>在 ARC 下捕获的变量会被 block retain</strong>, 这样可能导致循环引用, 所以必须要使用弱引用才能解决该问题. 而在非 ARC 下, 可以直接使用 <code class="highlighter-rouge">__block</code> 说明符修饰变量, 因为在非 ARC 下, block 不会 retain 捕获的变量.</p>

<hr />

<h3 id="4-使用-nonatomic-一定是线程安全的吗">4. 使用 <code class="highlighter-rouge">nonatomic</code> 一定是线程安全的吗？</h3>

<p><code class="highlighter-rouge">nonatomic</code> 的内存管理语义是<strong>非原子</strong>的, 非原子的操作本来就是线程不安全的, 而 <code class="highlighter-rouge">atomic</code> 的操作是原子的, 但是<strong>并不意味着它是线程安全的</strong>, 它会增加正确的几率, 能够更好的避免线程的错误, 但是它仍然是线程不安全的.</p>

<p>当使用 <code class="highlighter-rouge">nonatomic</code> 的时候, 属性的 setter 和 getter 操作是非原子的, 所以当多个线程同时对某一属性进行读和写的操作, 属性的最终结果是不能预测的.</p>

<p>当使用 <code class="highlighter-rouge">atomic</code> 时, 虽然对属性的读和写是原子的, 但是仍然可能出现线程错误: 当线程 A 进行写操作, 这时其他线程的读或写操作会因为该操作的进行而等待. 当 A 线程的写操作结束后, B 线程进行写操作, 然后当 A 线程进行读操作时, 却获得了在 B 线程中的值, 这就破坏了线程安全, 如果有线程 C 在 A 线程读操作前 release 了该属性, 那么还会导致程序崩溃. 所以仅仅使用 <code class="highlighter-rouge">atomic</code> 并不会使得线程安全, 我们还需要为线程添加 <code class="highlighter-rouge">lock</code> 来确保线程的安全.</p>

<p><code class="highlighter-rouge">atomic</code> 都不是一定线程安全的, <code class="highlighter-rouge">nonatomic</code> 就更不必多说了.</p>

<hr />

<h3 id="5-描述一个你遇到过的-retain-cycle-例子">5. <del>描述一个你遇到过的 retain cycle 例子.</del></h3>

<hr />

<h3 id="6--voidload-和--voidinitialize-有什么用处">6. <code class="highlighter-rouge">+ (void)load;</code> 和 <code class="highlighter-rouge">+ (void)initialize;</code> 有什么用处？</h3>

<p>当类对象被引入项目时, runtime 会向每一个类对象发送 <code class="highlighter-rouge">load</code> 消息. <code class="highlighter-rouge">load</code> 方法还是非常的神奇的, 因为它会在<strong>每一个类甚至分类</strong>被引入时仅调用一次, 调用的顺序是父类优先于子类, 子类优先于分类. 而且 <code class="highlighter-rouge">load</code> 方法不会被类自动继承, 每一个类中的 <code class="highlighter-rouge">load</code> 方法都不需要像 <code class="highlighter-rouge">viewDidLoad</code> 方法一样调用父类的方法. 由于 <code class="highlighter-rouge">load</code> 方法会在类被 <code class="highlighter-rouge">import</code> 时调用一次, 而这时往往是改变类的行为的最佳时机. 我在 <a href="https://github.com/Draveness/DKNightVersion">DKNightVersion</a> 中使用 <code class="highlighter-rouge">method swizlling</code> 来修改原有的方法时, 就是在分类 <code class="highlighter-rouge">load</code> 中实现的.</p>

<p><code class="highlighter-rouge">initialize</code> 方法和 <code class="highlighter-rouge">load</code> 方法有一些不同, 它虽然也会在整个 runtime 过程中调用一次, 但是它是在<strong>该类的第一个方法执行之前</strong>调用, 也就是说 <code class="highlighter-rouge">initialize</code> 的调用是<strong>惰性</strong>的, 它的实现也与我们在平时使用的惰性初始化属性时基本相同. 我在实际的项目中并没有遇到过必须使用这个方法的情况, 在该方法中主要做<strong>静态变量的设置</strong>并用于<strong>确保在实例初始化前某些条件必须满足</strong>.</p>

<hr />

<h3 id="7-为什么其他语言里叫函数调用-objective-c-中是给对象发送消息-谈下对-runtime-的理解">7. 为什么其他语言里叫函数调用, Objective-C 中是给对象发送消息 (谈下对 runtime 的理解)</h3>

<p>我们在其他语言中比如说: C, Python, Java, C++, Haskell … 中提到函数调用或者方法调用(面向对象). 函数调用是在编译期就已经决定了会调用哪个函数(方法), 编译器在编译期就能检查出函数的执行是否正确.</p>

<p>然而 Objective-C(ObjC) 是一门动态的语言, 整个 ObjC 语言都是尽可能的将所有的工作推迟到运行时才决定. 它基于 runtime 来工作, runtime 就是 ObjC 的灵魂, 其核心就是消息发送<code class="highlighter-rouge">objc_msgSend </code>.</p>

<blockquote>
  <p>What makes Objective-C truly powerful is its runtime.</p>
</blockquote>

<p>所有的消息都会在运行时才会确定, <code class="highlighter-rouge">[obj message]</code> 在运行时会被转化为 <code class="highlighter-rouge">objc_msgSend(id self, SEL cmd, ...)</code> 来执行, 它会在运行时从<strong>选择子表中寻找对应的选择子</strong>并将选择子与实现进行绑定. 而如果没有找到对应的实现, 就会进入类似黑魔法的消息转发流程. 调用 <code class="highlighter-rouge">+ (BOOL)resolveInstanceMethod:(SEL)aSelector</code> 方法, 我们可以在这个方法中<strong>为类动态地生成方法</strong>.</p>

<p>我们几乎可以使用 runtime 魔改 Objective-C 中的一切: <code class="highlighter-rouge">class</code> <code class="highlighter-rouge">property</code> <code class="highlighter-rouge">object</code> <code class="highlighter-rouge">ivar</code> <code class="highlighter-rouge">method</code> <code class="highlighter-rouge">protocol</code>, 而下面就是它的主要应用:</p>

<ul>
  <li>内省</li>
  <li>为分类动态的添加属性</li>
  <li>使用方法调剂修改原有的方法实现</li>
  <li>…</li>
</ul>

<hr />

<h3 id="8-什么是-method-swizzling">8. 什么是 Method Swizzling?</h3>

<p><code class="highlighter-rouge">method swizzling</code> 实际上就是一种在运行时动态修改原有方法实现的技术, 它实际上是基于 ObjC runtime 的特性, 而 <code class="highlighter-rouge">method swizzling</code> 的核心方法就是 <code class="highlighter-rouge">method_exchangeImplementations(SEL origin, SEL swizzle)</code>. 使用这个方法就可以在运行时动态地改变原有的方法实现, 在 <a href="https://github.com/Draveness/DKNightVersion/blob/master/Pod/Classes/UIKit/Auto/UILabel/UILabel%2BTextColor.m">DKNigtVersion</a>(为 iOS 应用添加夜间模式) 中能够看到大量 <code class="highlighter-rouge">method swizzling</code> 的使用, 方法的调用时机就是在上面提到的 <code class="highlighter-rouge">load</code> 方法中, 不在 <code class="highlighter-rouge">initialize</code> 方法中改变方法实现的原因是 <strong><code class="highlighter-rouge">initialize</code> 可能会被子类所继承并重新执行最终导致无限递归</strong>, 而 <code class="highlighter-rouge">load</code> 并不会被继承.</p>

<hr />

<h3 id="9-uiview-和-calayer-有什么关系">9. <code class="highlighter-rouge">UIView</code> 和 <code class="highlighter-rouge">CALayer</code> 有什么关系?</h3>

<p>看到这个问题不禁想到大一在网易面试时的经历, 当时的两位面试官就问了我这么一个问题, <code class="highlighter-rouge">UIView </code>和 <code class="highlighter-rouge">CALayer</code> 是什么关系, 为什么要这么设计? 我已经忘记了当时是怎么回答的. 隐约记得当时说每一个 <code class="highlighter-rouge">UIView</code> 都会对应一个 <code class="highlighter-rouge">CALayer</code> 至于为什么这样, 当时的我实在是太弱无法回答出来了.</p>

<p>每一个 <code class="highlighter-rouge">UIView</code> 的身后对应一个 <code class="highlighter-rouge">Core Animation</code> 框架中的 <code class="highlighter-rouge">CALayer</code>. 每一个 <code class="highlighter-rouge">UIView</code> 都是 ` CALayer` 的代理.</p>

<blockquote>
  <p>Many of the methods you call on UIView simply delegate to the layer</p>
</blockquote>

<p>在 iOS 上当你处理一个又一个的 <code class="highlighter-rouge">UIView</code> 时, 实际上是在操作 <code class="highlighter-rouge">CALayer</code>. 尽管有的时候你并不知道 (直接操作 <code class="highlighter-rouge">CALayer</code> 并不会对效率有着显著的提升).</p>

<p><code class="highlighter-rouge">UIView</code> 实际上就是对 <code class="highlighter-rouge">CALayer</code> 的轻量级的封装. <code class="highlighter-rouge">UIView</code> 继承自 <code class="highlighter-rouge">UIResponder</code>, 用来处理来自用户的事件; <code class="highlighter-rouge">CALayer</code> 继承自 <code class="highlighter-rouge">NSObject</code> 主要用于处理图层的渲染和动画. 这么设计有以下几个原因:</p>

<ul>
  <li>你可以通过操作 <code class="highlighter-rouge">UIView</code> 在一个更高的层级上处理与用户的交互, 触摸, 点击, 拖拽等事件, 这些都是在 <code class="highlighter-rouge">UIKit</code> 这个层级上完成的.</li>
  <li><code class="highlighter-rouge">UIView</code> 和 <code class="highlighter-rouge">NSView(AppKit)</code> 的实现极其不同, 而使用 <code class="highlighter-rouge">Core Animation</code> 可以实现底层代码地重用, 在 Mac 和 iOS 平台上都使用着近乎相同的 <code class="highlighter-rouge">Core Animation</code> 代码, 这样我们可以对这个层级进行抽象在两种平台上产生 <code class="highlighter-rouge">UIKit</code> 和 <code class="highlighter-rouge">AppKit</code> 用于不同平台的框架.</li>
</ul>

<p>使用 <code class="highlighter-rouge">CALayer</code> 的唯一原因大概是便于移植到不同的平台, 如果仅仅使用 <code class="highlighter-rouge">Core Animation</code> 层级进行开发, 处理用户的交互时间需要写更多的代码.</p>

<hr />

<h3 id="10-如何高性能的给-uiimageview-加个圆角-不准说-layercornerradius">10. 如何高性能的给 <code class="highlighter-rouge">UIImageView</code> 加个圆角? (不准说 <code class="highlighter-rouge">layer.cornerRadius</code>!)</h3>

<p>一般情况下给 UIImageView 或者说 UIKit 的控件添加圆角都是改变 <code class="highlighter-rouge">clipsToBounds</code> 和 <code class="highlighter-rouge">layer.cornerRadius</code>, 这样大约两行代码就可以解决这个问题. 但是, 这样使用这样的方法会<strong>强制 Core Animation 提前渲染屏幕的离屏绘制</strong>, 而离屏绘制就会为性能带来负面影响.</p>

<p>我们也可以使用另一种比较复杂的方式来为图片添加圆角, 这里就用到了贝塞尔曲线.</p>

<pre><code class="language-objectivec">UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
imageView.center = CGPointMake(200, 300);
UIImage *anotherImage = [UIImage imageNamed:@"image"];
UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 1.0);
[[UIBezierPath bezierPathWithRoundedRect:imageView.bounds
                           cornerRadius:50] addClip];
[anotherImage drawInRect:imageView.bounds];
imageView.image = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
[self.view addSubview:imageView];
</code></pre>

<p>在这里使用了贝塞尔曲线”切割”个这个图片, 给 <code class="highlighter-rouge">UIImageView</code> 添加了的圆角.</p>

<hr />

<h3 id="11-使用-drawrect-有什么影响">11. 使用 <code class="highlighter-rouge">drawRect:</code> 有什么影响?</h3>

<p>这个问题对于我来说确实有些难以回答, 我记得我在我人生的第一个 iOS 项目 SportJoin 中曾经使用这个方法来绘制图形, 但是具体怎么做的, 我已经忘记了.</p>

<p>这个方法的主要作用是根据传入的 <code class="highlighter-rouge">rect</code> 来绘制图像 <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/#//apple_ref/occ/instm/UIView/drawRect:">参见文档</a>. 这个方法的默认实现没有做任何事情, 我们<strong>可以</strong>在这个方法中使用 <code class="highlighter-rouge">Core Graphics</code> 和 <code class="highlighter-rouge">UIKit</code> 来绘制视图的内容.</p>

<p>这个方法的调用机制也是非常特别. 当你调用 <code class="highlighter-rouge">setNeedsDisplay</code> 方法时, UIKit 将会把当前图层标记为 dirty, 但<strong>还是会显示原来的内容</strong>, 直到下一次的视图渲染周期, 才会为标记为 dirty 的图层重新建立 Core Graphics 上下文, 然后将内存中的数据恢复出来, 再使用 CGContextRef 进行绘制.</p>

<hr />

<h3 id="12-asihttprequest-或者-sdwebimage-里面给-uiimageview-加载图片的逻辑是什么样的">12. ASIHttpRequest 或者 SDWebImage 里面给 UIImageView 加载图片的逻辑是什么样的?</h3>

<p>我曾经阅读过 SDWebImage 的源代码, 就在这里对如何给 UIImageView 加载图片做一个总结吧, SDWebImage 中为 UIView 提供了一个分类叫做 WebCache, 这个分类中有一个最常用的接口, <code class="highlighter-rouge">sd_setImageWithURL:placeholderImage:</code>, 这个分类同时提供了很多类似的方法, 这些方法最终会调用一个同时具有 <code class="highlighter-rouge">option</code> <code class="highlighter-rouge">progressBlock</code> <code class="highlighter-rouge">completionBlock</code> 的方法, 而在这个类最终被调用的方法首先会检查是否传入了 <code class="highlighter-rouge">placeholderImage</code> 以及对应的参数, 并设置 <code class="highlighter-rouge">placeholderImage</code>.</p>

<p>然后会获取 <code class="highlighter-rouge">SDWebImageManager</code> 中的单例调用一个 <code class="highlighter-rouge">downloadImageWithURL:...</code> 的方法来获取图片, 而这个 manager 获取图片的过程有大体上分为两部分, 它首先会在 <code class="highlighter-rouge">SDWebImageCache</code> 中寻找图片是否有对应的缓存, 它会以 url 作为数据的索引先在内存中寻找是否有对应的缓存, 如果缓存未命中就会在磁盘中利用 MD5 处理过的 key 来继续查询对应的数据, 如果找到了, 就会把磁盘中的缓存备份到内存中.</p>

<p>然而, 假设我们在内存和磁盘缓存中都没有命中, 那么 manager 就会调用它持有的一个 <code class="highlighter-rouge">SDWebImageDownloader</code> 对象的方法 <code class="highlighter-rouge">downloadImageWithURL:...</code> 来下载图片, 这个方法会在执行的过程中调用另一个方法 <code class="highlighter-rouge">addProgressCallback:andCompletedBlock:fotURL:createCallback:</code> 来存储下载过程中和下载完成的回调, 当回调块是第一次添加的时候, 方法会实例化一个 <code class="highlighter-rouge">NSMutableURLRequest</code> 和 <code class="highlighter-rouge">SDWebImageDownloaderOperation</code>, 并将后者加入 downloader 持有的下载队列开始图片的异步下载.</p>

<p>而在图片下载完成之后, 就会在主线程设置 image, 完成整个图像的异步下载和配置.</p>

<hr />

<h3 id="13-设计一个简单的图片内存缓存器-包含移除策略">13. 设计一个简单的图片内存缓存器 (包含移除策略)</h3>

<p>待我阅读完 path 开源的 <a href="https://github.com/path/FastImageCache">FastImageCache</a>的源代码就来回答.</p>

<hr />

<h3 id="14-讲讲你用instrument优化动画性能的经历">14. <del>讲讲你用Instrument优化动画性能的经历</del></h3>

<hr />

<h3 id="15-loadview-的作用是什么">15. <code class="highlighter-rouge">loadView</code> 的作用是什么?</h3>

<blockquote>
  <p>This method loads or creates a view and assigns it to the <code class="highlighter-rouge">view</code> property.</p>
</blockquote>

<p><code class="highlighter-rouge">loadView</code> 是 <code class="highlighter-rouge">UIViewController</code> 的实例方法, 我们永远不要直接调用这个方法 <code class="highlighter-rouge">[self loadView]</code>. 这在苹果的<a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/#//apple_ref/occ/instm/UIViewController/loadView">官方文档</a>中已经明确的写出了. <code class="highlighter-rouge">loadView</code> 会在获取视图控制器的 <code class="highlighter-rouge">view</code> 但是却得到 <code class="highlighter-rouge">nil</code> 时被调用.</p>

<p><code class="highlighter-rouge">loadView</code> 的具体实现会做下面两件事情中的一件:</p>

<ol>
  <li>
    <p>如果你的视图控制器关联了一个 storyboard, 那么它就会加载 storyboard 中的视图.</p>
  </li>
  <li>
    <p>如果试图控制器没有关联的 storyboard, 那么就会创建一个空的视图, 并分配给 <code class="highlighter-rouge">view</code> 属性</p>
  </li>
</ol>

<p>如果你需要覆写 <code class="highlighter-rouge">loadView</code> 方法:</p>

<ol>
  <li>你需要创建一个根视图.</li>
  <li>创建并初始化 <code class="highlighter-rouge">view</code> 的子视图, 调用 <code class="highlighter-rouge">addSubview:</code> 方法将它们添加到父视图上.</li>
  <li>如果你使用了自动布局, 提供足够的约束来保证视图的位置.</li>
  <li>将根视图分配给 <code class="highlighter-rouge">view</code> 属性.</li>
</ol>

<p>永远不要在这个方法中调用 <code class="highlighter-rouge">[super loadView]</code>.</p>

<hr />

<h3 id="16-viewwilllayoutsubviews-的作用是什么">16. <code class="highlighter-rouge">viewWillLayoutSubviews</code> 的作用是什么?</h3>

<p><code class="highlighter-rouge">viewWillLayoutSubviews</code> 方法会在视图的 bounds 改变时, 视图会调整子视图的位置, 我们可以在视图控制器中覆写这个方法在视图放置子视图前做出改变, 当屏幕的方向改变时, 这个方法会被调用.</p>

<hr />

<h3 id="17-gcd-里面有哪几种-queue-背后的线程模型是什么样的">17. GCD 里面有哪几种 Queue? 背后的线程模型是什么样的?</h3>

<p>GCD 中 Queue 的种类还要看我们怎么进行分类, 如果根据同一时间内处理的操作数分类的话, GCD 中的 Queue 分为两类</p>

<ol>
  <li>Serial Dispatch Queue</li>
  <li>Concurrent Dispatch Queue</li>
</ol>

<p>一类是串行派发队列, 它只使用一个线程, 会等待当前执行的操作结束后才会执行下一个操作, 它按照追加的顺序进行处理. 另一类是并行派发队列, 它同时使用多个线程, 如果当前的线程数足够, 那么就不会等待正在执行的操作, 使用多个线程同时执行多个处理.</p>

<p>另外的一种分类方式如下:</p>

<ol>
  <li>Main Dispatch Queue</li>
  <li>Global Dispatch Queue</li>
  <li>Custom Dispatch Queue</li>
</ol>

<p>主线程只有一个, 它是一个串行的进程. 所有追加到 Main Dispatch Queue 中的处理都会在 RunLoop 在执行. Global Dispatch Queue 是所有应用程序都能使用的并行派发队列, 它有 4 个执行优先级 High, Default, Low, Background. 当然我们也可以使用 <code class="highlighter-rouge">dispatch_queue_create</code> 创建派发队列.</p>

<hr />

<h3 id="18--core-data-或者-sqlite-的读写是分线程的吗-死锁如何解决">18.  Core Data 或者 sqlite 的读写是分线程的吗? 死锁如何解决?</h3>

<p>Core Data 和 sqlite 这两个我还真没深入用过, 我只在小的玩具应用上使用过 Core Data, 但是发现这货实在是太难用了, 我就果断放弃了, sqlite 我也用过, 每次输入 SQL 语句的时候我多想吐槽, 写一些简单的还好, 复杂的就直接 Orz 了. 所以我一般会使用 levelDB 对进行数据的持久存储.</p>

<p>数据库读取操作一般都是多线程的, 在对数据进行读取的时候, 我们要确保当前的状态不会被修改, 所以加锁, 防止由于线程竞争而出现的错误. 在 Core Data 中使用并行的最重要的规则是: <strong>每一个 <code class="highlighter-rouge">NSManagedObjectContext</code> 必须只从创建它的进程中访问</strong>.</p>

<hr />

<h3 id="19-http-的-post-和-get-有什么区别">19. http 的 POST 和 GET 有什么区别?</h3>

<p>根据 HTTP 协议的定义 GET 类型的请求是幂等的, 而 POST 请求是有副作用的, 也就是说 GET 用于获取一些资源, 而 POST 用于改变一些资源, 这可能会创建新的资源或更新已有的资源.</p>

<p>POST 请求比 GET 请求更加的安全, 因为你不会把信息添加到 URL 上的查询字符串上. 所以使用 GET 来收集密码或者一些敏感信息并不是什么好主意.</p>

<p>最后, POST 请求比 GET 请求也可以传输更多的信息.</p>

<hr />

<h3 id="20-什么是-binary-search-tree-它的时间复杂度是多少">20. 什么是 Binary search tree, 它的时间复杂度是多少?</h3>

<p>二叉搜索树是一棵以二叉树来组织的, 它搜索的时间复杂度 $O(h)$ 与树的高度成正比, 最坏的运行时间是 $\Theta(\lg n)$.</p>

<hr />

<h2 id="参考资料">参考资料</h2>
<ul>
  <li><a href="http://www.mgenware.com/blog/?p=1493">iOS: ARC和非ARC下使用Block属性的问题</a></li>
  <li><a href="http://stackoverflow.com/nquestions/12347236/which-is-threadsafe-atomic-or-non-atomic">Which is threadsafe atomic or non atomic?</a></li>
  <li><a href="http://stackoverflow.com/questions/13326435/nsobject-load-and-initialize-what-do-they-do">NSObject +load and +initialize - What do they do?</a></li>
  <li><a href="https://www.mikeash.com/pyblog/friday-qa-2009-05-22-objective-c-class-loading-and-initialization.html">Objective-C Class Loading and Initialization</a></li>
  <li><a href="http://stackoverflow.com/questions/6191480/objective-c-init-vs-initialize">Objective-C: init vs initialize</a></li>
  <li><a href="http://pilky.me/21/">Dynamic Tips &amp; Tricks With Objective-C
</a></li>
  <li><a href="http://nshipster.com/method-swizzling/">Method Swizzling</a></li>
  <li><a href="http://stackoverflow.com/questions/7826306/what-are-the-differences-between-a-uiview-and-a-calayer">What are the differences between a UIView and a CALayer?</a></li>
  <li><a href="http://raptureinvenice.com/ios-brownbag-view-vs-layers-including-clock-demo/">iOS Brownbag: View vs. Layers (including Clock Demo)</a></li>
  <li><a href="http://stackoverflow.com/questions/4735623/uilabel-layer-cornerradius-negatively-impacting-performance">UILabel layer cornerRadius negatively impacting performance</a></li>
  <li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/#//apple_ref/occ/instm/UIView/drawRect:">UIView Class Reference</a></li>
  <li><a href="http://objccn.io/issue-3-1/">绘制像素到屏幕上</a></li>
  <li><a href="http://stackoverflow.com/questions/8876212/proper-use-of-loadview-and-viewdidload-with-uiviewcontroller-without-nibs-xibs">Proper use of loadView and viewDidLoad with UIViewController without nibs/xibs</a></li>
  <li><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/#//apple_ref/occ/instm/UIViewController/loadView">UIViewController Class Reference</a></li>
  <li><a href="http://stackoverflow.com/questions/14662120/core-data-threads/14662206#14662206">Core Data &amp; Threads</a></li>
  <li><a href="http://stackoverflow.com/questions/10593735/making-core-data-thread-safe">Making Core Data Thread-safe</a></li>
  <li><a href="http://stackoverflow.com/questions/3477333/what-is-the-difference-between-post-and-get">What is the difference between POST and GET?</a></li>
  <li><a href="http://stackoverflow.com/questions/46585/when-do-you-use-post-and-when-do-you-use-get">When do you use POST and when do you use GET?</a></li>
  <li><a href="http://www.amazon.cn/Objective-C%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B-iOS%E4%B8%8EOS-X%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%9D%82%E6%9C%AC%E4%B8%80%E6%A0%91/dp/B00DE60G3S/ref=sr_1_1?ie=UTF8&amp;qid=1430229077&amp;sr=8-1&amp;keywords=objective-c%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B+ios%E4%B8%8Eos+x%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">Objective-C高级编程-iOS与OS-X多线程和内存管理</a></li>
</ul>

	  ]]></description>
	</item>


</channel>
</rss>
