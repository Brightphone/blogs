<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>谈谈 Rack 的协议与实现</title>
    <meta name="description" content="A beautiful narrative written with the world's most elegant publishing platform. The story begins here." />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/blogs/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/blogs/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/blogs/assets/css/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="/blogs//rack" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/blogs/page2/" />

    <meta property="og:site_name" content="Brightness" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="谈谈 Rack 的协议与实现" />
    <meta property="og:description" content="A beautiful narrative written with the world's most elegant publishing platform. The story begins here." />
    <meta property="og:url" content="/blogs//rack" />
    <meta property="og:image" content="/blogs/assets/images/cover1.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="谈谈 Rack 的协议与实现" />
    <meta name="twitter:description" content="A beautiful narrative written with the world's most elegant publishing platform. The story begins here." />
    <meta name="twitter:url" content="/blogs//rack" />
    <meta name="twitter:image:src" content="/blogs/assets/images/cover1.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "Brightness",
    "name": "谈谈 Rack 的协议与实现",
    "url": "/blogs//rack",
    "image": "/blogs/assets/images/cover1.jpg",
    "description": "A beautiful narrative written with the world's most elegant publishing platform. The story begins here."
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="Brightness" href="/blogs/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/blogs/">Home</a></li>
        <li class="nav-about " role="presentation"><a href="/blogs/about">About</a></li>
        <li class="nav-fables " role="presentation"><a href="/blogs/tag/fables">Fables</a></li>
        <li class="nav-speeches " role="presentation"><a href="/blogs/tag/speeches">Speeches</a></li>
        <li class="nav-fiction " role="presentation"><a href="/blogs/tag/fiction">Fiction</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/casper">Casper</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/edgar">Edgar</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/abraham">Abraham</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/martin">Martin</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/lewis">Lewis</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/blogs/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        
        
    </nav>
</header>

<main class="content" role="main">

    <article class="">

        <header class="post-header">
            <h1 class="post-title">谈谈 Rack 的协议与实现</h1>
            <section class="post-meta">
            <!-- <a href='/blogs/'></a> -->

            
                
            
                
            
                
            
                
            
                
            
            <time class="post-date" datetime="2017-10-29">29 Oct 2017</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/blogs/tag/Rack系列'>Rack系列</a>,
                    
                
                    
                       <a href='/blogs/tag/rack'>Rack</a>,
                    
                
                    
                       <a href='/blogs/tag/ruby'>Ruby</a>,
                    
                
                    
                       <a href='/blogs/tag/rails'>Rails</a>,
                    
                
                    
                       <a href='/blogs/tag/server'>Server</a>
                    
                
                
            </section>
        </header>

        <section class="post-content">

            <ul>
  <li><a href="https://draveness.me/rack">谈谈 Rack 协议与实现</a></li>
  <li><a href="https://draveness.me/rack-webrick">浅谈 WEBrick 的多线程模型</a></li>
  <li><a href="https://draveness.me/rack-thin">浅谈 Thin 的事件驱动模型</a></li>
  <li><a href="https://draveness.me/rack-unicorn">浅谈 Unicorn 的多进程模型</a></li>
  <li><a href="https://draveness.me/rack-puma">浅谈 Puma 的并发模型与实现</a></li>
  <li><a href="https://draveness.me/ruby-webserver">Ruby Web 服务器的并发模型与性能</a></li>
</ul>

<p>作为 Rails 开发者，基本上每天都与 Rails 的各种 API 以及数据库打交道，Rails 的世界虽然非常简洁，不过其内部的实现还是很复杂的，很多刚刚接触 Rails 的开发者可能都不知道 Rails 其实就是一个 <a href="https://github.com/rack/rack">Rack</a> 应用，在这一系列的文章中，我们会分别介绍 Rack 以及一些常见的遵循 Rack 协议的 webserver 的实现原理。</p>

<p><img src="https://img.draveness.me/2017-10-29-rack-logo.png" alt="rack-logo" /></p>

<p>不只是 Rails，几乎所有的 Ruby 的 Web 框架都是一个 Rack 的应用，除了 Web 框架之外，Rack 也支持相当多的 Web 服务器，可以说 Ruby 世界几乎一切与 Web 相关的服务都与 Rack 有关。</p>

<p><img src="https://img.draveness.me/2017-10-29-rack-and-web-servers-frameworks.png" alt="rack-and-web-servers-frameworks" /></p>

<p>所以如果想要了解 Rails 或者其他 Web 服务底层的实现，那么一定需要了解 Rack 是如何成为应用容器（webserver）和应用框架之间的桥梁的，本文中介绍的是 2.0.3 版本的 rack。</p>

<h2 id="rack-协议">Rack 协议</h2>

<p>在 Rack 的协议中，将 Rack 应用描述成一个可以响应 <code class="highlighter-rouge">call</code> 方法的 Ruby 对象，它仅接受来自外界的一个参数，也就是环境，然后返回一个只包含三个值的数组，按照顺序分别是状态码、HTTP Headers 以及响应请求的正文。</p>

<blockquote>
  <p>A Rack application is a Ruby object (not a class) that responds to call. It takes exactly one argument, the environment and returns an Array of exactly three values: The status, the headers, and the body.</p>
</blockquote>

<p><img src="https://img.draveness.me/2017-10-29-rack-protocol.png" alt="rack-protoco" /></p>

<p>Rack 在 webserver 和应用框架之间提供了一套最小的 API 接口，如果 webserver 都遵循 Rack 提供的这套规则，那么所有的框架都能通过协议任意地改变底层使用 webserver；所有的 webserver 只需要在 <code class="highlighter-rouge">Rack::Handler</code> 的模块中创建一个实现了 <code class="highlighter-rouge">.run</code> 方法的类就可以了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Rack</span>
  <span class="k">module</span> <span class="nn">Handler</span>
    <span class="k">class</span> <span class="nc">WEBrick</span> <span class="o">&lt;</span> <span class="o">::</span><span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServlet</span><span class="o">::</span><span class="no">AbstractServlet</span>
      <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">run</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{})</span>
        <span class="c1"># ..</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>这个类方法接受两个参数，分别是一个 Rack 应用对象和一个包含各种参数的 <code class="highlighter-rouge">options</code> 字典，其中可能包括自定义的 ip 地址和端口号以及各种配置，根据 Rack 协议，所有应用对象在接受到一个 <code class="highlighter-rouge">#call</code> 方法并且传入 <code class="highlighter-rouge">env</code> 时，都会返回一个三元组：</p>

<p><img src="https://img.draveness.me/2017-10-29-rack-app.png" alt="rack-app" /></p>

<p>最后的 <code class="highlighter-rouge">body</code> 响应体其实是一个由多个响应内容组成的数组，Rack 使用的 webserver 会将 <code class="highlighter-rouge">body</code> 中几个部分的连接到一起最后拼接成一个 HTTP 响应后返回。</p>

<h2 id="rack-的使用">Rack 的使用</h2>

<p>我们在大致了解 Rack 协议之后，其实可以从一段非常简单的代码入手来了解 Rack 是如何启动 webserver 来处理来自用户的请求的，我们可以在任意目录下创建如下所示的 config.ru 文件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># config.ru</span>

<span class="n">run</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">env</span><span class="o">|</span> <span class="p">[</span><span class="s1">'200'</span><span class="p">,</span> <span class="p">{</span><span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'text/html'</span><span class="p">},</span> <span class="p">[</span><span class="s1">'get rack\'d'</span><span class="p">]]</span> <span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>因为 <code class="highlighter-rouge">Proc</code> 对象也能够响应 <code class="highlighter-rouge">#call</code> 方法，所以上述的 Proc 对象也可以看做是一个 Rack 应用。</p>
</blockquote>

<p>接下来，我们在同一目录使用 <code class="highlighter-rouge">rackup</code> 命令在命令行中启动一个 webserver 进程：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>rackup config.ru
<span class="o">[</span>2017-10-26 22:59:26] INFO  WEBrick 1.3.1
<span class="o">[</span>2017-10-26 22:59:26] INFO  ruby 2.3.3 <span class="o">(</span>2016-11-21<span class="o">)</span> <span class="o">[</span>x86_64-darwin16]
<span class="o">[</span>2017-10-26 22:59:26] INFO  WEBrick::HTTPServer#start: <span class="nv">pid</span><span class="o">=</span>83546 <span class="nv">port</span><span class="o">=</span>9292
</code></pre></div></div>

<p>从命令的输出我们可以看到，使用 rackup 运行了一个 WEBrick 的进程，监听了 9292 端口，如果我们使用 curl 来访问对应的请求，就可以得到在 config.ru 文件中出现的 <code class="highlighter-rouge">'get rack\'d'</code> 文本：</p>

<blockquote>
  <p>在这篇文章中，作者都会使用开源的工具 <a href="https://github.com/jakubroztocil/httpie">httpie</a> 代替 curl 在命令行中发出 HTTP 请求，相比 curl 而言 httpie 能够提供与 HTTP 响应有关的更多信息。</p>
</blockquote>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">http</span> <span class="n">http</span><span class="ss">:/</span><span class="o">/</span><span class="n">localhost</span><span class="p">:</span><span class="mi">9292</span>
<span class="no">HTTP</span><span class="o">/</span><span class="mf">1.1</span> <span class="mi">200</span> <span class="no">OK</span>
<span class="no">Connection</span><span class="p">:</span> <span class="no">Keep</span><span class="o">-</span><span class="no">Alive</span>
<span class="no">Content</span><span class="o">-</span><span class="no">Type</span><span class="p">:</span> <span class="n">text</span><span class="o">/</span><span class="n">html</span>
<span class="no">Date</span><span class="p">:</span> <span class="no">Thu</span><span class="p">,</span> <span class="mi">26</span> <span class="no">Oct</span> <span class="mi">2017</span> <span class="mi">15</span><span class="p">:</span><span class="mo">07</span><span class="p">:</span><span class="mi">47</span> <span class="no">GMT</span>
<span class="no">Server</span><span class="p">:</span> <span class="no">WEBrick</span><span class="o">/</span><span class="mf">1.3</span><span class="o">.</span><span class="mi">1</span> <span class="p">(</span><span class="no">Ruby</span><span class="o">/</span><span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span><span class="o">/</span><span class="mi">2016</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">21</span><span class="p">)</span>
<span class="no">Transfer</span><span class="o">-</span><span class="no">Encoding</span><span class="p">:</span> <span class="n">chunked</span>

<span class="n">get</span> <span class="n">rack</span><span class="err">'</span><span class="n">d</span>
</code></pre></div></div>

<p>从上述请求返回的 HTTP 响应头中的信息，我们可以看到 WEBrick 确实按照 config.ru 文件中的代码对当前的 HTTP 请求进行了处理。</p>

<h3 id="中间件">中间件</h3>

<p>Rack 协议和中间件是 Rack 能达到今天地位不可或缺的两个功能或者说特性，Rack 协议规定了 webserver 和 Rack 应用之间应该如何通信，而 Rack 中间件能够在上层改变 HTTP 的响应或者请求，在不改变应用的基础上为 Rack 应用增加新的功能。</p>

<p>Rack 的中间件是一个实现了两个方法 <code class="highlighter-rouge">.initialize</code> 和 <code class="highlighter-rouge">#call</code> 的类，初始化方法会接受两个参数，分别是 <code class="highlighter-rouge">app</code> 和 <code class="highlighter-rouge">options</code> 字典，而 <code class="highlighter-rouge">#call</code> 方法接受一个参数也就是 HTTP 请求的环境参数 <code class="highlighter-rouge">env</code>，在这里我们创建了一个新的 Rack 中间件 <code class="highlighter-rouge">StatusLogger</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">StatusLogger</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{})</span>
    <span class="vi">@app</span> <span class="o">=</span> <span class="n">app</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">body</span> <span class="o">=</span> <span class="vi">@app</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="n">status</span>
    <span class="p">[</span><span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">body</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在所有的 <code class="highlighter-rouge">#call</code> 方法中都<strong>应该</strong>调用 <code class="highlighter-rouge">app.call</code> 让应用对 HTTP 请求进行处理并在方法结束时将所有的参数按照顺序返回。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">use</span> <span class="no">StatusLogger</span>
<span class="n">run</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">env</span><span class="o">|</span> <span class="p">[</span><span class="s1">'200'</span><span class="p">,</span> <span class="p">{</span><span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'text/html'</span><span class="p">},</span> <span class="p">[</span><span class="s1">'get rack\'d'</span><span class="p">]]</span> <span class="p">}</span>
</code></pre></div></div>

<p>如果需要使用某一个 Rack 中间件只需要在当前文件中使用 <code class="highlighter-rouge">use</code> 方法，在每次接收到来自用户的 HTTP 请求时都会打印出当前响应的状态码。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">rackup</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">19</span><span class="p">:</span><span class="mi">46</span><span class="p">:</span><span class="mi">40</span><span class="p">]</span> <span class="no">INFO</span>  <span class="no">WEBrick</span> <span class="mf">1.3</span><span class="o">.</span><span class="mi">1</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">19</span><span class="p">:</span><span class="mi">46</span><span class="p">:</span><span class="mi">40</span><span class="p">]</span> <span class="no">INFO</span>  <span class="n">ruby</span> <span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span> <span class="p">(</span><span class="mi">2016</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">21</span><span class="p">)</span> <span class="p">[</span><span class="n">x86_64</span><span class="o">-</span><span class="n">darwin16</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">19</span><span class="p">:</span><span class="mi">46</span><span class="p">:</span><span class="mi">40</span><span class="p">]</span> <span class="no">INFO</span>  <span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServer</span><span class="c1">#start: pid=5274 port=9292</span>
<span class="mi">200</span>
<span class="mf">127.0</span><span class="o">.</span><span class="mf">0.1</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">27</span><span class="o">/</span><span class="no">Oct</span><span class="o">/</span><span class="mi">2017</span><span class="p">:</span><span class="mi">19</span><span class="p">:</span><span class="mi">46</span><span class="p">:</span><span class="mi">53</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s2">"GET / HTTP/1.1"</span> <span class="mi">200</span> <span class="o">-</span> <span class="mf">0.0004</span>
</code></pre></div></div>

<p>除了直接通过 <code class="highlighter-rouge">use</code> 方法直接传入 <code class="highlighter-rouge">StatusLogger</code> 中间件之外，我们也可以在 <code class="highlighter-rouge">use</code> 中传入配置参数，所有的配置都会通过 <code class="highlighter-rouge">options</code> 最终初始化一个中间件的实例，比如，我们有以下的中间件 <code class="highlighter-rouge">BodyTransformer</code>：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BodyTransformer</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{})</span>
    <span class="vi">@app</span> <span class="o">=</span> <span class="n">app</span>
    <span class="vi">@count</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:count</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">body</span> <span class="o">=</span> <span class="vi">@app</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="n">env</span><span class="p">)</span>
    <span class="n">body</span> <span class="o">=</span> <span class="n">body</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">str</span><span class="o">|</span> <span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="o">...</span><span class="vi">@count</span><span class="p">].</span><span class="nf">upcase</span> <span class="o">+</span> <span class="n">str</span><span class="p">[</span><span class="vi">@count</span><span class="o">..-</span><span class="mi">1</span><span class="p">]</span> <span class="p">}</span>
    <span class="p">[</span><span class="n">status</span><span class="p">,</span> <span class="n">headers</span><span class="p">,</span> <span class="n">body</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述中间件会在每次调用时都将 Rack 应用返回的 <code class="highlighter-rouge">body</code> 中前 <code class="highlighter-rouge">count</code> 个字符变成大写的，我们可以在 config.ru 中添加一个新的中间件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">use</span> <span class="no">StatusLogger</span>
<span class="n">use</span> <span class="no">BodyTransformer</span><span class="p">,</span> <span class="ss">count: </span><span class="mi">3</span>
<span class="n">run</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">env</span><span class="o">|</span> <span class="p">[</span><span class="s1">'200'</span><span class="p">,</span> <span class="p">{</span><span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'text/html'</span><span class="p">},</span> <span class="p">[</span><span class="s1">'get rack\'d'</span><span class="p">]]</span> <span class="p">}</span>
</code></pre></div></div>

<p>当我们再次使用 http 命令请求相同的 URL 时，就会获得不同的结果，同时由于我们保留了 <code class="highlighter-rouge">StatusLogger</code>，所以在 console 中也会打印出当前响应的状态码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># session 1</span>
<span class="err">$</span> <span class="n">rackup</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">21</span><span class="p">:</span><span class="mo">04</span><span class="p">:</span><span class="mo">05</span><span class="p">]</span> <span class="no">INFO</span>  <span class="no">WEBrick</span> <span class="mf">1.3</span><span class="o">.</span><span class="mi">1</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">21</span><span class="p">:</span><span class="mo">04</span><span class="p">:</span><span class="mo">05</span><span class="p">]</span> <span class="no">INFO</span>  <span class="n">ruby</span> <span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span> <span class="p">(</span><span class="mi">2016</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">21</span><span class="p">)</span> <span class="p">[</span><span class="n">x86_64</span><span class="o">-</span><span class="n">darwin16</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">21</span><span class="p">:</span><span class="mo">04</span><span class="p">:</span><span class="mo">05</span><span class="p">]</span> <span class="no">INFO</span>  <span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServer</span><span class="c1">#start: pid=7524 port=9292</span>
<span class="mi">200</span>
<span class="mf">127.0</span><span class="o">.</span><span class="mf">0.1</span> <span class="o">-</span> <span class="o">-</span> <span class="p">[</span><span class="mi">27</span><span class="o">/</span><span class="no">Oct</span><span class="o">/</span><span class="mi">2017</span><span class="p">:</span><span class="mi">21</span><span class="p">:</span><span class="mo">04</span><span class="p">:</span><span class="mi">19</span> <span class="o">+</span><span class="mi">0800</span><span class="p">]</span> <span class="s2">"GET / HTTP/1.1"</span> <span class="mi">200</span> <span class="o">-</span> <span class="mf">0.0005</span>

<span class="c1"># session 2</span>
<span class="err">$</span> <span class="n">http</span> <span class="n">http</span><span class="ss">:/</span><span class="o">/</span><span class="n">localhost</span><span class="p">:</span><span class="mi">9292</span>
<span class="no">HTTP</span><span class="o">/</span><span class="mf">1.1</span> <span class="mi">200</span> <span class="no">OK</span>
<span class="no">Connection</span><span class="p">:</span> <span class="no">Keep</span><span class="o">-</span><span class="no">Alive</span>
<span class="no">Content</span><span class="o">-</span><span class="no">Type</span><span class="p">:</span> <span class="n">text</span><span class="o">/</span><span class="n">html</span>
<span class="no">Date</span><span class="p">:</span> <span class="no">Fri</span><span class="p">,</span> <span class="mi">27</span> <span class="no">Oct</span> <span class="mi">2017</span> <span class="mi">13</span><span class="p">:</span><span class="mo">04</span><span class="p">:</span><span class="mi">19</span> <span class="no">GMT</span>
<span class="no">Server</span><span class="p">:</span> <span class="no">WEBrick</span><span class="o">/</span><span class="mf">1.3</span><span class="o">.</span><span class="mi">1</span> <span class="p">(</span><span class="no">Ruby</span><span class="o">/</span><span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span><span class="o">/</span><span class="mi">2016</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">21</span><span class="p">)</span>
<span class="no">Transfer</span><span class="o">-</span><span class="no">Encoding</span><span class="p">:</span> <span class="n">chunked</span>

<span class="no">GET</span> <span class="n">rack</span><span class="err">'</span><span class="n">d</span>
</code></pre></div></div>

<p>Rack 的中间件的使用其实非常简单，我们只需要定义符合要求的类，然后在合适的方法中返回合适的结果就可以了，在接下来的部分我们将介绍 Rack 以及中间件的实现原理。</p>

<h2 id="rack-的实现原理">Rack 的实现原理</h2>

<p>到这里，我们已经对 Rack 的使用有一些基本的了解了，包括如何使用 <code class="highlighter-rouge">rackup</code> 命令启动一个 webserver，也包括 Rack 的中间件如何使用，接下来我们就准备开始对 Rack 是如何实现上述功能进行分析了。</p>

<h3 id="rackup-命令">rackup 命令</h3>

<p>那么 <code class="highlighter-rouge">rackup</code> 到底是如何工作的呢，首先我们通过 <code class="highlighter-rouge">which</code> 命令来查找当前 <code class="highlighter-rouge">rackup</code> 的执行路径并打印出该文件的全部内容：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">which</span> <span class="n">rackup</span>
<span class="sr">/Users/</span><span class="n">draveness</span><span class="o">/</span><span class="p">.</span><span class="nf">rvm</span><span class="o">/</span><span class="n">gems</span><span class="o">/</span><span class="n">ruby</span><span class="o">-</span><span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">rackup</span>

<span class="err">$</span> <span class="n">cat</span> <span class="sr">/Users/</span><span class="n">draveness</span><span class="o">/</span><span class="p">.</span><span class="nf">rvm</span><span class="o">/</span><span class="n">gems</span><span class="o">/</span><span class="n">ruby</span><span class="o">-</span><span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">rackup</span>
<span class="c1">#!/usr/bin/env ruby_executable_hooks</span>
<span class="c1">#</span>
<span class="c1"># This file was generated by RubyGems.</span>
<span class="c1">#</span>
<span class="c1"># The application 'rack' is installed as part of a gem, and</span>
<span class="c1"># this file is here to facilitate running it.</span>
<span class="c1">#</span>

<span class="nb">require</span> <span class="s1">'rubygems'</span>

<span class="n">version</span> <span class="o">=</span> <span class="s2">"&gt;= 0.a"</span>

<span class="k">if</span> <span class="no">ARGV</span><span class="p">.</span><span class="nf">first</span>
  <span class="n">str</span> <span class="o">=</span> <span class="no">ARGV</span><span class="p">.</span><span class="nf">first</span>
  <span class="n">str</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="nf">dup</span><span class="p">.</span><span class="nf">force_encoding</span><span class="p">(</span><span class="s2">"BINARY"</span><span class="p">)</span> <span class="k">if</span> <span class="n">str</span><span class="p">.</span><span class="nf">respond_to?</span> <span class="ss">:force_encoding</span>
  <span class="k">if</span> <span class="n">str</span> <span class="o">=~</span> <span class="sr">/\A_(.*)_\z/</span> <span class="n">and</span> <span class="no">Gem</span><span class="o">::</span><span class="no">Version</span><span class="p">.</span><span class="nf">correct?</span><span class="p">(</span><span class="vg">$1</span><span class="p">)</span> <span class="k">then</span>
    <span class="n">version</span> <span class="o">=</span> <span class="vg">$1</span>
    <span class="no">ARGV</span><span class="p">.</span><span class="nf">shift</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="nb">load</span> <span class="no">Gem</span><span class="p">.</span><span class="nf">activate_bin_path</span><span class="p">(</span><span class="s1">'rack'</span><span class="p">,</span> <span class="s1">'rackup'</span><span class="p">,</span> <span class="n">version</span><span class="p">)</span>
</code></pre></div></div>

<p>从上述文件中的注释中可以看到当前文件是由 RubyGems 自动生成的，在文件的最后由一个 <code class="highlighter-rouge">load</code> 方法加载了某一个文件中的代码，我们可以在 pry 中尝试运行一下这个命令。</p>

<p>首先，通过 <code class="highlighter-rouge">gem list</code> 命令得到当前机器中所有 rack 的版本，然后进入 pry 执行 <code class="highlighter-rouge">.activate_bin_path</code> 命令：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">gem</span> <span class="n">list</span> <span class="s2">"^rack$"</span>

<span class="o">***</span> <span class="no">LOCAL</span> <span class="no">GEMS</span> <span class="o">***</span>

<span class="n">rack</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">.</span><span class="mi">3</span><span class="p">,</span> <span class="mf">2.0</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1.6</span><span class="o">.</span><span class="mi">8</span><span class="p">,</span> <span class="mf">1.2</span><span class="o">.</span><span class="mi">3</span><span class="p">)</span>

<span class="err">$</span> <span class="n">pry</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="no">Gem</span><span class="p">.</span><span class="nf">activate_bin_path</span><span class="p">(</span><span class="s1">'rack'</span><span class="p">,</span> <span class="s1">'rackup'</span><span class="p">,</span> <span class="s1">'2.0.3'</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="s2">"/Users/draveness/.rvm/gems/ruby-2.3.3/gems/rack-2.0.3/bin/rackup"</span>

<span class="err">$</span> <span class="n">cat</span> <span class="sr">/Users/</span><span class="n">draveness</span><span class="o">/</span><span class="p">.</span><span class="nf">rvm</span><span class="o">/</span><span class="n">gems</span><span class="o">/</span><span class="n">ruby</span><span class="o">-</span><span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span><span class="o">/</span><span class="n">gems</span><span class="o">/</span><span class="n">rack</span><span class="o">-</span><span class="mf">2.0</span><span class="o">.</span><span class="mi">3</span><span class="o">/</span><span class="n">bin</span><span class="o">/</span><span class="n">rackup</span>
<span class="c1">#!/usr/bin/env ruby</span>

<span class="nb">require</span> <span class="s2">"rack"</span>
<span class="no">Rack</span><span class="o">::</span><span class="no">Server</span><span class="p">.</span><span class="nf">start</span>
</code></pre></div></div>

<blockquote>
  <p><code class="highlighter-rouge">rackup</code> 命令定义在 rack 工程的 bin/rackup 文件中，在通过 rubygems 安装后会生成另一个加载该文件的可执行文建。</p>
</blockquote>

<p>在最后打印了该文件的内容，到这里我们就应该知道 <code class="highlighter-rouge">.activate_bin_path</code> 方法会查找对应 gem 当前生效的版本，并返回文件的路径；在这个可执行文件中，上述代码只是简单的 <code class="highlighter-rouge">require</code> 了一下 rack 方法，之后运行 <code class="highlighter-rouge">.start</code> 启动了一个 <code class="highlighter-rouge">Rack::Server</code>。</p>

<h3 id="server-的启动">Server 的启动</h3>

<p>从这里开始，我们就已经从 rackup 命令的执行进入了 rack 的源代码，可以直接使用 pry 找到 <code class="highlighter-rouge">.start</code> 方法所在的文件，从方法中可以看到当前类方法初始化了一个新的实例后，在新的对象上执行了 <code class="highlighter-rouge">#start</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">pry</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="nb">require</span> <span class="s1">'rack'</span>
<span class="o">=&gt;</span> <span class="kp">true</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="err">$</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span><span class="p">.</span><span class="nf">start</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">147</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Rack::Server&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">start</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="n">new</span><span class="p">(</span><span class="n">options</span><span class="p">).</span><span class="nf">start</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="初始化和配置">初始化和配置</h3>

<p>在 <code class="highlighter-rouge">Rack::Server</code> 启动的过程中初始化了一个新的对象，初始化的过程中其实也包含了整个服务器的配置过程：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">185</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Rack::Server&gt;</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">options</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
  <span class="vi">@ignore_options</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">if</span> <span class="n">options</span>
    <span class="vi">@use_default_options</span> <span class="o">=</span> <span class="kp">false</span>
    <span class="vi">@options</span> <span class="o">=</span> <span class="n">options</span>
    <span class="vi">@app</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="ss">:app</span><span class="p">]</span> <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="ss">:app</span><span class="p">]</span>
  <span class="k">else</span>
    <span class="n">argv</span> <span class="o">=</span> <span class="n">defined?</span><span class="p">(</span><span class="no">SPEC_ARGV</span><span class="p">)</span> <span class="p">?</span> <span class="no">SPEC_ARGV</span> <span class="p">:</span> <span class="no">ARGV</span>
    <span class="vi">@use_default_options</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="vi">@options</span> <span class="o">=</span> <span class="n">parse_options</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个 <code class="highlighter-rouge">Server</code> 对象的初始化器中，虽然可以通过 <code class="highlighter-rouge">options</code> 从外界传入参数，但是当前类中仍然存在这个 <code class="highlighter-rouge">#options</code> 和 <code class="highlighter-rouge">#default_options</code> 两个实例方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">199</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">options</span>
  <span class="n">merged_options</span> <span class="o">=</span> <span class="vi">@use_default_options</span> <span class="p">?</span> <span class="n">default_options</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="vi">@options</span><span class="p">)</span> <span class="p">:</span> <span class="vi">@options</span>
  <span class="n">merged_options</span><span class="p">.</span><span class="nf">reject</span> <span class="p">{</span> <span class="o">|</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="o">|</span> <span class="vi">@ignore_options</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>

<span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">204</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">default_options</span>
  <span class="n">environment</span>  <span class="o">=</span> <span class="no">ENV</span><span class="p">[</span><span class="s1">'RACK_ENV'</span><span class="p">]</span> <span class="o">||</span> <span class="s1">'development'</span>
  <span class="n">default_host</span> <span class="o">=</span> <span class="n">environment</span> <span class="o">==</span> <span class="s1">'development'</span> <span class="p">?</span> <span class="s1">'localhost'</span> <span class="p">:</span> <span class="s1">'0.0.0.0'</span>
  <span class="p">{</span>
    <span class="ss">:environment</span> <span class="o">=&gt;</span> <span class="n">environment</span><span class="p">,</span>
    <span class="ss">:pid</span>         <span class="o">=&gt;</span> <span class="kp">nil</span><span class="p">,</span>
    <span class="ss">:Port</span>        <span class="o">=&gt;</span> <span class="mi">9292</span><span class="p">,</span>
    <span class="ss">:Host</span>        <span class="o">=&gt;</span> <span class="n">default_host</span><span class="p">,</span>
    <span class="ss">:AccessLog</span>   <span class="o">=&gt;</span> <span class="p">[],</span>
    <span class="ss">:config</span>      <span class="o">=&gt;</span> <span class="s2">"config.ru"</span>
  <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述两个方法中处理了一些对象本身定义的一些参数，比如默认的端口号 9292 以及默认的 config 文件，config 文件也就是 <code class="highlighter-rouge">rackup</code> 命令接受的一个文件参数，文件中的内容就是用来配置一个 Rack 服务器的代码，在默认情况下为 config.ru，也就是如果文件名是 config.ru，我们不需要向 <code class="highlighter-rouge">rackup</code> 命令传任何参数，它会自动找当前目录的该文件：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">rackup</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">09</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mi">34</span><span class="p">]</span> <span class="no">INFO</span>  <span class="no">WEBrick</span> <span class="mf">1.3</span><span class="o">.</span><span class="mi">1</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">09</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mi">34</span><span class="p">]</span> <span class="no">INFO</span>  <span class="n">ruby</span> <span class="mf">2.3</span><span class="o">.</span><span class="mi">3</span> <span class="p">(</span><span class="mi">2016</span><span class="o">-</span><span class="mi">11</span><span class="o">-</span><span class="mi">21</span><span class="p">)</span> <span class="p">[</span><span class="n">x86_64</span><span class="o">-</span><span class="n">darwin16</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2017</span><span class="o">-</span><span class="mi">10</span><span class="o">-</span><span class="mi">27</span> <span class="mi">09</span><span class="p">:</span><span class="mo">00</span><span class="p">:</span><span class="mi">34</span><span class="p">]</span> <span class="no">INFO</span>  <span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServer</span><span class="c1">#start: pid=96302 port=9292</span>
</code></pre></div></div>

<p>访问相同的 URL 能得到完全一致的结果，在这里就不再次展示了，有兴趣的读者可以亲自尝试一下。</p>

<h3 id="包装应用">『包装』应用</h3>

<p>当我们执行了 <code class="highlighter-rouge">.initialize</code> 方法初始化了一个新的实例之后，接下来就会进入 <code class="highlighter-rouge">#start</code> 实例方法尝试启动一个 webserver 处理 config.ru 中定义的应用了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">258</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">start</span> <span class="o">&amp;</span><span class="n">blk</span>
  <span class="c1"># ...</span>

  <span class="n">wrapped_app</span>
  <span class="c1"># ..</span>

  <span class="n">server</span><span class="p">.</span><span class="nf">run</span> <span class="n">wrapped_app</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blk</span>
<span class="k">end</span>
</code></pre></div></div>

<p>我们已经从上述方法中删除了很多对于本文来说不重要的代码实现，所以上述方法中最重要的部分就是 <code class="highlighter-rouge">#wrapped_app</code> 方法，以及另一个 <code class="highlighter-rouge">#server</code> 方法，首先来看 <code class="highlighter-rouge">#wrapped_app</code> 方法的实现。</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">353</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">wrapped_app</span>
  <span class="vi">@wrapped_app</span> <span class="o">||=</span> <span class="n">build_app</span> <span class="n">app</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法有两部分组成，分别是 <code class="highlighter-rouge">#app</code> 和 <code class="highlighter-rouge">#build_app</code> 两个实例方法，其中 <code class="highlighter-rouge">#app</code> 方法的调用栈比较复杂：</p>

<p><img src="https://img.draveness.me/2017-10-29-server-app-call-stack.png" alt="server-app-call-stack" /></p>

<p>整个方法在最终会执行 <code class="highlighter-rouge">Builder.new_from_string</code> 通过 Ruby 中元编程中经常使用的 <code class="highlighter-rouge">eval</code> 方法，将输入文件中的全部内容与两端字符串拼接起来，并直接执行这段代码：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">builder</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">48</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">new_from_string</span><span class="p">(</span><span class="n">builder_script</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="s2">"(rackup)"</span><span class="p">)</span>
  <span class="nb">eval</span> <span class="s2">"Rack::Builder.new {</span><span class="se">\n</span><span class="s2">"</span> <span class="o">+</span> <span class="n">builder_script</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">}.to_app"</span><span class="p">,</span>
    <span class="no">TOPLEVEL_BINDING</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="mi">0</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在 <code class="highlighter-rouge">eval</code> 方法中执行代码的作用其实就是如下所示的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span>
  <span class="n">use</span> <span class="no">StatusLogger</span>
  <span class="n">use</span> <span class="no">BodyTransformer</span><span class="p">,</span> <span class="ss">count: </span><span class="mi">3</span>
  <span class="n">run</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">env</span><span class="o">|</span> <span class="p">[</span><span class="s1">'200'</span><span class="p">,</span> <span class="p">{</span><span class="s1">'Content-Type'</span> <span class="o">=&gt;</span> <span class="s1">'text/html'</span><span class="p">},</span> <span class="p">[</span><span class="s1">'get rack\'d'</span><span class="p">]]</span> <span class="p">}</span>
<span class="p">}.</span><span class="nf">to_app</span>
</code></pre></div></div>

<p>我们先暂时不管这段代码是如何执行的，我们只需要知道上述代码存储了所有的中间件以及 Proc 对象，最后通过 <code class="highlighter-rouge">#to_app</code> 方法返回一个 Rack 应用。</p>

<p>在这之后会使用 <code class="highlighter-rouge">#build_app</code> 方法将所有的中间件都包括在 Rack 应用周围，因为所有的中间件也都是一个响应 <code class="highlighter-rouge">#call</code> 方法，返回三元组的对象，其实也就是一个遵循协议的 App，唯一的区别就是中间件中会调用初始化时传入的 Rack App：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">343</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">build_app</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
  <span class="n">middleware</span><span class="p">[</span><span class="n">options</span><span class="p">[</span><span class="ss">:environment</span><span class="p">]].</span><span class="nf">reverse_each</span> <span class="k">do</span> <span class="o">|</span><span class="n">middleware</span><span class="o">|</span>
    <span class="n">middleware</span> <span class="o">=</span> <span class="n">middleware</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="k">if</span> <span class="n">middleware</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:call</span><span class="p">)</span>
    <span class="k">next</span> <span class="k">unless</span> <span class="n">middleware</span>
    <span class="n">klass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">middleware</span>
    <span class="n">app</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">app</span>
<span class="k">end</span>
</code></pre></div></div>

<p>经过上述方法，我们在一个 Rack 应用周围一层一层包装上了所有的中间件，最后调用的中间件在整个调用栈中的最外层，当包装后的应用接受来自外界的请求时，会按照如下的方式进行调用：</p>

<p><img src="https://img.draveness.me/2017-10-29-wrapped-app.png" alt="wrapped-app" /></p>

<p>所有的请求都会先经过中间件，每一个中间件都会在 <code class="highlighter-rouge">#call</code> 方法内部调用另一个中间件或者应用，在接收到应用的返回之后会分别对响应进行处理最后由最先定义的中间件返回。</p>

<h3 id="中间件的实现">中间件的实现</h3>

<p>在 Rack 中，中间件是由两部分的代码共同处理的，分别是 <code class="highlighter-rouge">Rack::Builder</code> 和 <code class="highlighter-rouge">Rack::Server</code> 两个类，前者包含所有的能够在 config.ru 文件中使用的 DSL 方法，当我们使用 <code class="highlighter-rouge">eval</code> 执行 config.ru 文件中的代码时，会先初始化一个 <code class="highlighter-rouge">Builder</code> 的实例，然后执行 <code class="highlighter-rouge">instance_eval</code> 运行代码块中的所有内容：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">builder</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">53</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span>

<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">default_app</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="vi">@use</span><span class="p">,</span> <span class="vi">@map</span><span class="p">,</span> <span class="vi">@run</span><span class="p">,</span> <span class="vi">@warmup</span> <span class="o">=</span> <span class="p">[],</span> <span class="kp">nil</span><span class="p">,</span> <span class="n">default_app</span><span class="p">,</span> <span class="kp">nil</span>
  <span class="nb">instance_eval</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="k">if</span> <span class="nb">block_given?</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这时，config.ru 文件中的代码就会在当前实例的环境下执行，文件中的 <code class="highlighter-rouge">#use</code> 和 <code class="highlighter-rouge">#run</code> 方法在调用时就会执行 <code class="highlighter-rouge">Builder</code> 的实例方法，我们可以先看一下 <code class="highlighter-rouge">#use</code> 方法是如何实现的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">builder</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">81</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span>

<span class="k">def</span> <span class="nf">use</span><span class="p">(</span><span class="n">middleware</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="vi">@use</span> <span class="o">&lt;&lt;</span> <span class="nb">proc</span> <span class="p">{</span> <span class="o">|</span><span class="n">app</span><span class="o">|</span> <span class="n">middleware</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法会将传入的参数组合成一个接受 <code class="highlighter-rouge">app</code> 作为入参的 <code class="highlighter-rouge">Proc</code> 对象，然后加入到 <code class="highlighter-rouge">@use</code> 数组中存储起来，在这里并没有发生任何其他的事情，另一个 <code class="highlighter-rouge">#run</code> 方法的实现其实就更简单了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">builder</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">103</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span>

<span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
  <span class="vi">@run</span> <span class="o">=</span> <span class="n">app</span>
<span class="k">end</span>
</code></pre></div></div>

<p>它只是将传入的 <code class="highlighter-rouge">app</code> 对象存储到持有的 <code class="highlighter-rouge">@run</code> 实例变量中，如果我们想要获取当前的 <code class="highlighter-rouge">Builder</code> 生成的应用，只需要通过 <code class="highlighter-rouge">#to_app</code> 方法：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">builder</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">144</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Builder</span>

<span class="k">def</span> <span class="nf">to_app</span>
  <span class="nb">fail</span> <span class="s2">"missing run or map statement"</span> <span class="k">unless</span> <span class="vi">@run</span>
  <span class="vi">@use</span><span class="p">.</span><span class="nf">reverse</span><span class="p">.</span><span class="nf">inject</span><span class="p">(</span><span class="vi">@run</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span><span class="n">e</span><span class="o">|</span> <span class="n">e</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>上述方法将所有传入 <code class="highlighter-rouge">#use</code> 和 <code class="highlighter-rouge">#run</code> 命令的应用和中间件进行了组合，通过 <code class="highlighter-rouge">#inject</code> 方法达到了如下所示的效果：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># config.ru</span>
<span class="n">use</span> <span class="no">MiddleWare1</span>
<span class="n">use</span> <span class="no">MiddleWare2</span>
<span class="n">run</span> <span class="no">RackApp</span>

<span class="c1"># equals to</span>
<span class="no">MiddleWare1</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">MiddleWare2</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">RackApp</span><span class="p">)))</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Builder</code> 类其实简单来看就做了这件事情，将一种非常难以阅读的代码，变成比较清晰可读的 DSL，最终返回了一个中间件（也可以说是应用）对象，虽然在 <code class="highlighter-rouge">Builder</code> 中也包含其他的 DSL 语法元素，但是在这里都没有介绍。</p>

<p>上一小节提到的 <code class="highlighter-rouge">#build_app</code> 方法其实也只是根据当前的环境选择合适的中间件继续包裹到这个链式的调用中：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">343</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">build_app</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
  <span class="n">middleware</span><span class="p">[</span><span class="n">options</span><span class="p">[</span><span class="ss">:environment</span><span class="p">]].</span><span class="nf">reverse_each</span> <span class="k">do</span> <span class="o">|</span><span class="n">middleware</span><span class="o">|</span>
    <span class="n">middleware</span> <span class="o">=</span> <span class="n">middleware</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="k">if</span> <span class="n">middleware</span><span class="p">.</span><span class="nf">respond_to?</span><span class="p">(</span><span class="ss">:call</span><span class="p">)</span>
    <span class="k">next</span> <span class="k">unless</span> <span class="n">middleware</span>
    <span class="n">klass</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">middleware</span>
    <span class="n">app</span> <span class="o">=</span> <span class="n">klass</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="n">app</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这里的 <code class="highlighter-rouge">#middleware</code> 方法可以被子类覆写，如果不覆写该方法会根据环境的不同选择不同的中间件数组包裹当前的应用：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">229</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Rack::Server&gt;</span>

<span class="k">def</span> <span class="nf">default_middleware_by_environment</span>
  <span class="n">m</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span><span class="o">|</span><span class="n">h</span><span class="p">,</span><span class="n">k</span><span class="o">|</span> <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]}</span>
  <span class="n">m</span><span class="p">[</span><span class="s2">"deployment"</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">ContentLength</span><span class="p">],</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">Chunked</span><span class="p">],</span>
    <span class="n">logging_middleware</span><span class="p">,</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">TempfileReaper</span><span class="p">]</span>
  <span class="p">]</span>
  <span class="n">m</span><span class="p">[</span><span class="s2">"development"</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">ContentLength</span><span class="p">],</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">Chunked</span><span class="p">],</span>
    <span class="n">logging_middleware</span><span class="p">,</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">ShowExceptions</span><span class="p">],</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">Lint</span><span class="p">],</span>
    <span class="p">[</span><span class="no">Rack</span><span class="o">::</span><span class="no">TempfileReaper</span><span class="p">]</span>
  <span class="p">]</span>
  <span class="n">m</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">.default_middleware_by_environment</code> 中就包含了不同环境下应该使用的中间件，<code class="highlighter-rouge">#build_app</code> 会视情况选择中间件加载。</p>

<h3 id="webserver-的选择">webserver 的选择</h3>

<p>在 <code class="highlighter-rouge">Server#start</code> 方法中，我们已经通过 <code class="highlighter-rouge">#wrapped_app</code> 方法将应用和中间件打包到了一起，然后分别执行 <code class="highlighter-rouge">#server</code> 和 <code class="highlighter-rouge">Server#run</code> 方法选择并运行 webserver，先来看 webserver 是如何选择的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">server</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">300</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Server</span>

<span class="k">def</span> <span class="nf">server</span>
  <span class="vi">@_server</span> <span class="o">||=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Handler</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="ss">:server</span><span class="p">])</span>
  <span class="k">unless</span> <span class="vi">@_server</span>
    <span class="vi">@_server</span> <span class="o">=</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Handler</span><span class="p">.</span><span class="nf">default</span>
  <span class="k">end</span>
  <span class="vi">@_server</span>
<span class="k">end</span>
</code></pre></div></div>

<p>如果我们在运行 <code class="highlighter-rouge">rackup</code> 命令时传入了 <code class="highlighter-rouge">server</code> 选项，例如 <code class="highlighter-rouge">rackup -s WEBrick</code>，就会直接使用传入的 webserver，否则就会使用默认的 Rack 处理器：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">handler</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">46</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Rack::Handler&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">default</span>
  <span class="c1"># Guess.</span>
  <span class="k">if</span> <span class="no">ENV</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="s2">"PHP_FCGI_CHILDREN"</span><span class="p">)</span>
    <span class="no">Rack</span><span class="o">::</span><span class="no">Handler</span><span class="o">::</span><span class="no">FastCGI</span>
  <span class="k">elsif</span> <span class="no">ENV</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="no">REQUEST_METHOD</span><span class="p">)</span>
    <span class="no">Rack</span><span class="o">::</span><span class="no">Handler</span><span class="o">::</span><span class="no">CGI</span>
  <span class="k">elsif</span> <span class="no">ENV</span><span class="p">.</span><span class="nf">include?</span><span class="p">(</span><span class="s2">"RACK_HANDLER"</span><span class="p">)</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="no">ENV</span><span class="p">[</span><span class="s2">"RACK_HANDLER"</span><span class="p">])</span>
  <span class="k">else</span>
    <span class="n">pick</span> <span class="p">[</span><span class="s1">'puma'</span><span class="p">,</span> <span class="s1">'thin'</span><span class="p">,</span> <span class="s1">'webrick'</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在这个方法中，调用 <code class="highlighter-rouge">.pick</code> 其实最终也会落到 <code class="highlighter-rouge">.get</code> 方法上，在 <code class="highlighter-rouge">.pick</code> 中我们通过遍历传入的数组<strong>尝试</strong>对其进行加载：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">handler</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">34</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Rack::Handler&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">pick</span><span class="p">(</span><span class="n">server_names</span><span class="p">)</span>
  <span class="n">server_names</span> <span class="o">=</span> <span class="no">Array</span><span class="p">(</span><span class="n">server_names</span><span class="p">)</span>
  <span class="n">server_names</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">server_name</span><span class="o">|</span>
    <span class="k">begin</span>
      <span class="k">return</span> <span class="n">get</span><span class="p">(</span><span class="n">server_name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">)</span>
    <span class="k">rescue</span> <span class="no">LoadError</span><span class="p">,</span> <span class="no">NameError</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">raise</span> <span class="no">LoadError</span><span class="p">,</span> <span class="s2">"Couldn't find handler for: </span><span class="si">#{</span><span class="n">server_names</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">', '</span><span class="p">)</span><span class="si">}</span><span class="s2">."</span>
<span class="k">end</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">.get</code> 方法是用于加载 webserver 对应处理器的方法，方法中会通过一定的命名规范从对应的文件目录下加载相应的常量：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">From</span><span class="p">:</span> <span class="n">lib</span><span class="o">/</span><span class="n">rack</span><span class="o">/</span><span class="n">handler</span><span class="p">.</span><span class="nf">rb</span> <span class="err">@</span> <span class="n">line</span> <span class="mi">11</span><span class="p">:</span>
<span class="no">Owner</span><span class="p">:</span> <span class="c1">#&lt;Class:Rack::Handler&gt;</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">get</span><span class="p">(</span><span class="n">server</span><span class="p">)</span>
  <span class="k">return</span> <span class="k">unless</span> <span class="n">server</span>
  <span class="n">server</span> <span class="o">=</span> <span class="n">server</span><span class="p">.</span><span class="nf">to_s</span>

  <span class="k">unless</span> <span class="vi">@handlers</span><span class="p">.</span><span class="nf">include?</span> <span class="n">server</span>
    <span class="n">load_error</span> <span class="o">=</span> <span class="n">try_require</span><span class="p">(</span><span class="s1">'rack/handler'</span><span class="p">,</span> <span class="n">server</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">if</span> <span class="n">klass</span> <span class="o">=</span> <span class="vi">@handlers</span><span class="p">[</span><span class="n">server</span><span class="p">]</span>
    <span class="n">klass</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s2">"::"</span><span class="p">).</span><span class="nf">inject</span><span class="p">(</span><span class="no">Object</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">o</span><span class="p">,</span> <span class="n">x</span><span class="o">|</span> <span class="n">o</span><span class="p">.</span><span class="nf">const_get</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">else</span>
    <span class="nb">const_get</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="kp">false</span><span class="p">)</span>
  <span class="k">end</span>

<span class="k">rescue</span> <span class="no">NameError</span> <span class="o">=&gt;</span> <span class="n">name_error</span>
  <span class="k">raise</span> <span class="n">load_error</span> <span class="o">||</span> <span class="n">name_error</span>
<span class="k">end</span>
</code></pre></div></div>

<p>一部分常量是预先定义在 handler.rb 文件中的，另一部分是由各个 webserver 的开发者自己定义或者遵循一定的命名规范加载的：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">register</span> <span class="s1">'cgi'</span><span class="p">,</span> <span class="s1">'Rack::Handler::CGI'</span>
<span class="n">register</span> <span class="s1">'fastcgi'</span><span class="p">,</span> <span class="s1">'Rack::Handler::FastCGI'</span>
<span class="n">register</span> <span class="s1">'webrick'</span><span class="p">,</span> <span class="s1">'Rack::Handler::WEBrick'</span>
<span class="n">register</span> <span class="s1">'lsws'</span><span class="p">,</span> <span class="s1">'Rack::Handler::LSWS'</span>
<span class="n">register</span> <span class="s1">'scgi'</span><span class="p">,</span> <span class="s1">'Rack::Handler::SCGI'</span>
<span class="n">register</span> <span class="s1">'thin'</span><span class="p">,</span> <span class="s1">'Rack::Handler::Thin'</span>
</code></pre></div></div>

<p>在默认的情况下，如果不在启动服务时指定服务器就会按照 puma、thin 和 webrick 的顺序依次尝试加载响应的处理器。</p>

<h3 id="webserver-的启动">webserver 的启动</h3>

<p>当 Rack 已经使用中间件对应用进行包装并且选择了对应的 webserver 之后，我们就可以将处理好的应用作为参数传入 <code class="highlighter-rouge">WEBrick.run</code> 方法了：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Rack</span>
  <span class="k">module</span> <span class="nn">Handler</span>
    <span class="k">class</span> <span class="nc">WEBrick</span> <span class="o">&lt;</span> <span class="o">::</span><span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServlet</span><span class="o">::</span><span class="no">AbstractServlet</span>
      <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">run</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{})</span>
        <span class="n">environment</span>  <span class="o">=</span> <span class="no">ENV</span><span class="p">[</span><span class="s1">'RACK_ENV'</span><span class="p">]</span> <span class="o">||</span> <span class="s1">'development'</span>
        <span class="n">default_host</span> <span class="o">=</span> <span class="n">environment</span> <span class="o">==</span> <span class="s1">'development'</span> <span class="p">?</span> <span class="s1">'localhost'</span> <span class="p">:</span> <span class="kp">nil</span>

        <span class="n">options</span><span class="p">[</span><span class="ss">:BindAddress</span><span class="p">]</span> <span class="o">=</span> <span class="n">options</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="ss">:Host</span><span class="p">)</span> <span class="o">||</span> <span class="n">default_host</span>
        <span class="n">options</span><span class="p">[</span><span class="ss">:Port</span><span class="p">]</span> <span class="o">||=</span> <span class="mi">8080</span>
        <span class="vi">@server</span> <span class="o">=</span> <span class="o">::</span><span class="no">WEBrick</span><span class="o">::</span><span class="no">HTTPServer</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
        <span class="vi">@server</span><span class="p">.</span><span class="nf">mount</span> <span class="s2">"/"</span><span class="p">,</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Handler</span><span class="o">::</span><span class="no">WEBrick</span><span class="p">,</span> <span class="n">app</span>
        <span class="k">yield</span> <span class="vi">@server</span>  <span class="k">if</span> <span class="nb">block_given?</span>
        <span class="vi">@server</span><span class="p">.</span><span class="nf">start</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>所有遵循 Rack 协议的 webserver 都会实现上述 <code class="highlighter-rouge">.run</code> 方法接受 <code class="highlighter-rouge">app</code>、<code class="highlighter-rouge">options</code> 和一个 block 作为参数运行一个进程来处理所有的来自用户的 HTTP 请求，在这里就是每个 webserver 自己需要解决的了，它其实并不属于 Rack 负责的部门，但是 Rack 实现了一些常见 webserver 的 handler，比如 CGI、Thin 和 WEBrick 等等，这些 handler 的实现原理都不会包含在这篇文章中。</p>

<h2 id="rails-和-rack">Rails 和 Rack</h2>

<p>在了解了 Rack 的实现之后，其实我们可以发现 Rails 应用就是一堆 Rake 中间件和一个 Rack 应用的集合，在任意的工程中我们执行 <code class="highlighter-rouge">rake middleware</code> 的命令都可以得到以下的输出：</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">rake</span> <span class="n">middleware</span>
<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Sendfile</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">Static</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">Executor</span>
<span class="n">use</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">Cache</span><span class="o">::</span><span class="no">Strategy</span><span class="o">::</span><span class="no">LocalCache</span><span class="o">::</span><span class="no">Middleware</span>
<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Runtime</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">RequestId</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">RemoteIp</span>
<span class="n">use</span> <span class="no">Rails</span><span class="o">::</span><span class="no">Rack</span><span class="o">::</span><span class="no">Logger</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">ShowExceptions</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">DebugExceptions</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">Reloader</span>
<span class="n">use</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">Callbacks</span>
<span class="n">use</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span><span class="o">::</span><span class="no">CheckPending</span>
<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">Head</span>
<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">ConditionalGet</span>
<span class="n">use</span> <span class="no">Rack</span><span class="o">::</span><span class="no">ETag</span>
<span class="n">run</span> <span class="no">ApplicationName</span><span class="o">::</span><span class="no">Application</span><span class="p">.</span><span class="nf">routes</span>
</code></pre></div></div>

<p>在这里包含了很多使用 <code class="highlighter-rouge">use</code> 加载的 Rack 中间件，当然在最后也包含一个 Rack 应用，也就是 <code class="highlighter-rouge">ApplicationName::Application.routes</code>，这个对象其实是一个 <code class="highlighter-rouge">RouteSet</code> 实例，也就是说在 Rails 中所有的请求在经过中间件之后都会先有一个路由表来处理，路由会根据一定的规则将请求交给其他控制器处理：</p>

<p><img src="https://img.draveness.me/2017-10-29-rails-application.png" alt="rails-application" /></p>

<p>除此之外，<code class="highlighter-rouge">rake middleware</code> 命令的输出也告诉我们 Rack 其实为我们提供了很多非常方便的中间件比如 <code class="highlighter-rouge">Rack::Sendfile</code> 等可以减少我们在开发一个 webserver 时需要处理的事情。</p>

<h2 id="总结">总结</h2>

<p>Rack 协议可以说占领了整个 Ruby 服务端的市场，无论是常见的服务器还是框架都遵循 Rack 协议进行了设计，而正因为 Rack 以及 Rack 协议的存在我们在使用 Rails 或者 Sinatra 开发 Web 应用时才可以对底层使用的 webserver 进行无缝的替换，在接下来的文章中会逐一介绍不同的 webserver 是如何对 HTTP 请求进行处理以及它们拥有怎样的 I/O 模型。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://github.com/rack/rack">Rack · A modular Ruby webserver interface</a></li>
  <li><a href="http://rack.github.io">Rack: a Ruby Webserver Interface</a></li>
  <li><a href="http://rubydoc.info/github/rack/rack/master/file/SPEC">Rack interface specification</a></li>
  <li><a href="http://guides.rubyonrails.org/rails_on_rack.html">Rails on Rack</a></li>
  <li><a href="http://railscasts.com/episodes/151-rack-middleware">Rack Middleware</a></li>
  <li><a href="http://chneukirchen.org/blog/archive/2007/02/introducing-rack.html">Introducing Rack</a></li>
  <li><a href="https://stackoverflow.com/questions/4113299/ruby-on-rails-server-options">Ruby on Rails Server options</a></li>
</ul>


        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
            
                
            
                
            
                
            
                
            

            <!-- Add Disqus Comments -->
            

        </footer>

    </article>

</main>
<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story no-cover" href="/blogs/rack-webrick">
            <section class="post">
                <h2>浅谈 WEBrick 的多线程模型</h2>
                <p>+ [谈谈 Rack 协议与实现](https://draveness.me/rack) + [浅谈 WEBrick 的多线程模型](https://draveness.me/rack-webrick) + [浅谈 Thin 的事件驱动模型](https://draveness.me/rack-thin) + [浅谈 Unicorn...</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev no-cover" href="/blogs/git-comments-initialize">
            <section class="post">
                <h2>自动初始化 Gitalk 和 Gitment 评论</h2>
                <p>之前的博客一直都使用 Disqus 作为评论系统，然后因为 Disqus 在国内无法访问，很多读者都只能通过邮件的方式咨询一些问题，昨天觉得长痛不如短痛，直接将博客的评论迁移到了 Gitalk，最开始选择了使用 Gitment 作为评论系统，但是由于其开发者很久没有维护、代码七个月也没有更新，所以就选择了有更多人维护的 Gitalk 作为目前博客的评论系统。 无论是 Gitalk 还是 Gitment 都只能手动初始化所有文章的评论或者一个一个点开界面，作者觉得这件事情非常麻烦，所以手动抓了一下...</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/blogs/">Brightness</a> &copy; 2018</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-69281367-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/blogs/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/blogs/assets/js/index.js"></script>

</body>
</html>
