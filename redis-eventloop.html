<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>Redis 中的事件循环</title>
    <meta name="description" content="A beautiful narrative written with the world's most elegant publishing platform. The story begins here." />

    <!-- Mobile Meta -->
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Brand icon -->
    <link rel="shortcut icon" href="/blogs/assets/images/favicon.ico" >

    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/blogs/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/blogs/assets/css/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- Ghost outputs important style and meta data with this tag -->
        <link rel="canonical" href="/blogs//redis-eventloop" />
    <meta name="referrer" content="origin" />
    <link rel="next" href="/blogs/page2/" />

    <meta property="og:site_name" content="Brightness" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Redis 中的事件循环" />
    <meta property="og:description" content="A beautiful narrative written with the world's most elegant publishing platform. The story begins here." />
    <meta property="og:url" content="/blogs//redis-eventloop" />
    <meta property="og:image" content="/blogs/assets/images/cover1.jpg" />

    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Redis 中的事件循环" />
    <meta name="twitter:description" content="A beautiful narrative written with the world's most elegant publishing platform. The story begins here." />
    <meta name="twitter:url" content="/blogs//redis-eventloop" />
    <meta name="twitter:image:src" content="/blogs/assets/images/cover1.jpg" />

    <script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "Website",
    "publisher": "Brightness",
    "name": "Redis 中的事件循环",
    "url": "/blogs//redis-eventloop",
    "image": "/blogs/assets/images/cover1.jpg",
    "description": "A beautiful narrative written with the world's most elegant publishing platform. The story begins here."
}
    </script>

    <meta name="generator" content="Jekyll 3.0.0" />
    <link rel="alternate" type="application/rss+xml" title="Brightness" href="/blogs/feed.xml" />


</head>
<body class="home-template nav-closed">

    <!-- The blog navigation links -->
    <div class="nav">
    <h3 class="nav-title">Menu</h3>
    <a href="#" class="nav-close">
        <span class="hidden">Close</span>
    </a>
    <ul>
        <li class="nav-home " role="presentation"><a href="/blogs/">Home</a></li>
        <li class="nav-about " role="presentation"><a href="/blogs/about">About</a></li>
        <li class="nav-fables " role="presentation"><a href="/blogs/tag/fables">Fables</a></li>
        <li class="nav-speeches " role="presentation"><a href="/blogs/tag/speeches">Speeches</a></li>
        <li class="nav-fiction " role="presentation"><a href="/blogs/tag/fiction">Fiction</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/casper">Casper</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/edgar">Edgar</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/abraham">Abraham</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/martin">Martin</a></li>
        <li class="nav-author " role="presentation"><a href="/blogs/author/lewis">Lewis</a></li>
    </ul>
    <a class="subscribe-button icon-feed" href="/blogs/feed.xml">Subscribe</a>
</div>
<span class="nav-cover"></span>


    <div class="site-wrapper">

        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The comment above "< default" means - insert everything in this file into -->
    <!-- the [body] of the default.hbs template, which contains our header/footer. -->

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<header class="main-header post-head no-cover">
    <nav class="main-nav  clearfix">
        
        
    </nav>
</header>

<main class="content" role="main">

    <article class="">

        <header class="post-header">
            <h1 class="post-title">Redis 中的事件循环</h1>
            <section class="post-meta">
            <!-- <a href='/blogs/'></a> -->

            
                
            
                
            
                
            
                
            
                
            
            <time class="post-date" datetime="2016-12-09">09 Dec 2016</time>
                <!-- [[tags prefix=" on "]] -->
                
                on
                
                    
                       <a href='/blogs/tag/redis'>Redis</a>,
                    
                
                    
                       <a href='/blogs/tag/server'>Server</a>,
                    
                
                    
                       <a href='/blogs/tag/database'>Database</a>,
                    
                
                    
                       <a href='/blogs/tag/nosql'>Nosql</a>
                    
                
                
            </section>
        </header>

        <section class="post-content">

            <p>在目前的很多服务中，由于需要持续接受客户端或者用户的输入，所以需要一个事件循环来等待并处理外部事件，这篇文章主要会介绍 Redis 中的事件循环是如何处理事件的。</p>

<p>在文章中，我们会先从 Redis 的实现中分析事件是如何被处理的，然后用更具象化的方式了解服务中的不同模块是如何交流的。</p>

<h2 id="aeeventloop">aeEventLoop</h2>

<p>在分析具体代码之前，先了解一下在事件处理中处于核心部分的 <code class="highlighter-rouge">aeEventLoop</code> 到底是什么：</p>

<p><img src="https://img.draveness.me/2016-12-09-reids-eventloop.png-1000width" alt="reids-eventloop" /></p>

<p><code class="highlighter-rouge">aeEventLoop</code> 在 Redis 就是负责保存待处理文件事件和时间事件的结构体，其中保存大量事件执行的上下文信息，同时持有三个事件数组：</p>

<ul>
  <li><code class="highlighter-rouge">aeFileEvent</code></li>
  <li><code class="highlighter-rouge">aeTimeEvent</code></li>
  <li><code class="highlighter-rouge">aeFiredEvent</code></li>
</ul>

<p><code class="highlighter-rouge">aeFileEvent</code> 和 <code class="highlighter-rouge">aeTimeEvent</code> 中会存储监听的文件事件和时间事件，而最后的 <code class="highlighter-rouge">aeFiredEvent</code> 用于存储待处理的文件事件，我们会在后面的章节中介绍它们是如何工作的。</p>

<h3 id="redis-服务中的-eventloop">Redis 服务中的 EventLoop</h3>

<p>在 <code class="highlighter-rouge">redis-server</code> 启动时，首先会初始化一些 redis 服务的配置，最后会调用 <code class="highlighter-rouge">aeMain</code> 函数陷入 <code class="highlighter-rouge">aeEventLoop</code> 循环中，等待外部事件的发生：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>

    <span class="n">aeMain</span><span class="p">(</span><span class="n">server</span><span class="p">.</span><span class="n">el</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">aeMain</code> 函数其实就是一个封装的 <code class="highlighter-rouge">while</code> 循环，循环中的代码会一直运行直到 <code class="highlighter-rouge">eventLoop</code> 的 <code class="highlighter-rouge">stop</code> 被设置为 <code class="highlighter-rouge">true</code>：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">aeMain</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">stop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">beforesleep</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">beforesleep</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">);</span>
        <span class="n">aeProcessEvents</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">AE_ALL_EVENTS</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>它会不停尝试调用 <code class="highlighter-rouge">aeProcessEvents</code> 对可能存在的多种事件进行处理，而 <code class="highlighter-rouge">aeProcessEvents</code> 就是实际用于处理事件的函数：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">aeProcessEvents</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">processed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">numevents</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_TIME_EVENTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_FILE_EVENTS</span><span class="p">))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">maxfd</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span>
        <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_TIME_EVENTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_DONT_WAIT</span><span class="p">)))</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">timeval</span> <span class="o">*</span><span class="n">tvp</span><span class="p">;</span>

        <span class="cp">#1：计算 I/O 多路复用的等待时间 tvp
</span>
        <span class="n">numevents</span> <span class="o">=</span> <span class="n">aeApiPoll</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">tvp</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numevents</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">aeFileEvent</span> <span class="o">*</span><span class="n">fe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">fd</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">mask</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">fd</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">rfired</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_READABLE</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">rfired</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">fe</span><span class="o">-&gt;</span><span class="n">rfileProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">,</span><span class="n">mask</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_WRITABLE</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rfired</span> <span class="o">||</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">wfileProc</span> <span class="o">!=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">rfileProc</span><span class="p">)</span>
                    <span class="n">fe</span><span class="o">-&gt;</span><span class="n">wfileProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">,</span><span class="n">mask</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">processed</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">AE_TIME_EVENTS</span><span class="p">)</span> <span class="n">processed</span> <span class="o">+=</span> <span class="n">processTimeEvents</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">processed</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>上面的代码省略了 I/O 多路复用函数的等待时间，不过不会影响我们对代码的理解，整个方法大体由两部分代码组成，一部分处理文件事件，另一部分处理时间事件。</p>

<blockquote>
  <p>Redis 中会处理两种事件：时间事件和文件事件。</p>
</blockquote>

<h3 id="文件事件">文件事件</h3>

<p>在一般情况下，<code class="highlighter-rouge">aeProcessEvents</code> 都会先<strong>计算最近的时间事件发生所需要等待的时间</strong>，然后调用 <code class="highlighter-rouge">aeApiPoll</code> 方法在这段时间中等待事件的发生，在这段时间中如果发生了文件事件，就会优先处理文件事件，否则就会一直等待，直到最近的时间事件需要触发：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numevents</span> <span class="o">=</span> <span class="n">aeApiPoll</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">tvp</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numevents</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">aeFileEvent</span> <span class="o">*</span><span class="n">fe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">fd</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">mask</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">fired</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">fd</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rfired</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_READABLE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">rfired</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">fe</span><span class="o">-&gt;</span><span class="n">rfileProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">,</span><span class="n">mask</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_WRITABLE</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rfired</span> <span class="o">||</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">wfileProc</span> <span class="o">!=</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">rfileProc</span><span class="p">)</span>
            <span class="n">fe</span><span class="o">-&gt;</span><span class="n">wfileProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">,</span><span class="n">mask</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">processed</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>文件事件如果绑定了对应的读/写事件，就会执行对应的对应的代码，并传入事件循环、文件描述符、数据以及掩码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fe</span><span class="o">-&gt;</span><span class="n">rfileProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">,</span><span class="n">mask</span><span class="p">);</span>
<span class="n">fe</span><span class="o">-&gt;</span><span class="n">wfileProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="n">fe</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">,</span><span class="n">mask</span><span class="p">);</span>
</code></pre></div></div>

<p>其中 <code class="highlighter-rouge">rfileProc</code> 和 <code class="highlighter-rouge">wfileProc</code> 就是在文件事件被创建时传入的函数指针：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">aeCreateFileEvent</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">,</span> <span class="n">aeFileProc</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">clientData</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">aeFileEvent</span> <span class="o">*</span><span class="n">fe</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">events</span><span class="p">[</span><span class="n">fd</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">aeApiAddEvent</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">AE_ERR</span><span class="p">;</span>
    <span class="n">fe</span><span class="o">-&gt;</span><span class="n">mask</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_READABLE</span><span class="p">)</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">rfileProc</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">AE_WRITABLE</span><span class="p">)</span> <span class="n">fe</span><span class="o">-&gt;</span><span class="n">wfileProc</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span>
    <span class="n">fe</span><span class="o">-&gt;</span><span class="n">clientData</span> <span class="o">=</span> <span class="n">clientData</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&gt;</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">maxfd</span><span class="p">)</span>
        <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">maxfd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">AE_OK</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>需要注意的是，传入的 <code class="highlighter-rouge">proc</code> 函数会在对应的 <code class="highlighter-rouge">mask</code> 位事件发生时执行。</p>

<h3 id="时间事件">时间事件</h3>

<p>在 Redis 中会发生两种时间事件：</p>

<ul>
  <li>一种是定时事件，每隔一段时间会执行一次；</li>
  <li>另一种是非定时事件，只会在某个时间点执行一次；</li>
</ul>

<p>时间事件的处理在 <code class="highlighter-rouge">processTimeEvents</code> 中进行，我们会分三部分分析这个方法的实现：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">processTimeEvents</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">processed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">aeTimeEvent</span> <span class="o">*</span><span class="n">te</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">maxId</span><span class="p">;</span>
    <span class="kt">time_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">&lt;</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">lastTime</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">te</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">timeEventHead</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">te</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">te</span><span class="o">-&gt;</span><span class="n">when_sec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">te</span> <span class="o">=</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">lastTime</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
</code></pre></div></div>

<p>由于对系统时间的调整会影响当前时间的获取，进而影响时间事件的执行；如果系统时间先被设置到了未来的时间，又设置成正确的值，这就会导致<strong>时间事件会随机延迟一段时间执行</strong>，也就是说，时间事件不会按照预期的安排尽早执行，而 <code class="highlighter-rouge">eventLoop</code> 中的 <code class="highlighter-rouge">lastTime</code> 就是用于检测上述情况的变量：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">aeEventLoop</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">time_t</span> <span class="n">lastTime</span><span class="p">;</span>     <span class="cm">/* Used to detect system clock skew */</span>
    <span class="p">...</span>
<span class="p">}</span> <span class="n">aeEventLoop</span><span class="p">;</span>
</code></pre></div></div>

<p>如果发现了系统时间被改变（小于上次 <code class="highlighter-rouge">processTimeEvents</code> 函数执行的开始时间），就会强制所有时间事件尽早执行。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">te</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">timeEventHead</span><span class="p">;</span>
    <span class="n">maxId</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">timeEventNextId</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">te</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">long</span> <span class="n">now_sec</span><span class="p">,</span> <span class="n">now_ms</span><span class="p">;</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">id</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">te</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">AE_DELETED_EVENT_ID</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">aeTimeEvent</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
                <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">timeEventHead</span> <span class="o">=</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">te</span><span class="o">-&gt;</span><span class="n">finalizerProc</span><span class="p">)</span>
                <span class="n">te</span><span class="o">-&gt;</span><span class="n">finalizerProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">);</span>
            <span class="n">zfree</span><span class="p">(</span><span class="n">te</span><span class="p">);</span>
            <span class="n">te</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>Redis 处理时间事件时，不会在当前循环中直接移除不再需要执行的事件，而是会在当前循环中将时间事件的 <code class="highlighter-rouge">id</code> 设置为 <code class="highlighter-rouge">AE_DELETED_EVENT_ID</code>，然后再下一个循环中删除，并执行绑定的 <code class="highlighter-rouge">finalizerProc</code>。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="n">aeGetTime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now_sec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">now_ms</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">now_sec</span> <span class="o">&gt;</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">when_sec</span> <span class="o">||</span>
            <span class="p">(</span><span class="n">now_sec</span> <span class="o">==</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">when_sec</span> <span class="o">&amp;&amp;</span> <span class="n">now_ms</span> <span class="o">&gt;=</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">when_ms</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>

            <span class="n">id</span> <span class="o">=</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
            <span class="n">retval</span> <span class="o">=</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">timeProc</span><span class="p">(</span><span class="n">eventLoop</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">clientData</span><span class="p">);</span>
            <span class="n">processed</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">AE_NOMORE</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">aeAddMillisecondsToNow</span><span class="p">(</span><span class="n">retval</span><span class="p">,</span><span class="o">&amp;</span><span class="n">te</span><span class="o">-&gt;</span><span class="n">when_sec</span><span class="p">,</span><span class="o">&amp;</span><span class="n">te</span><span class="o">-&gt;</span><span class="n">when_ms</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">te</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">AE_DELETED_EVENT_ID</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">te</span><span class="p">;</span>
        <span class="n">te</span> <span class="o">=</span> <span class="n">te</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">processed</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>在移除不需要执行的时间事件之后，我们就开始通过比较时间来判断是否需要调用 <code class="highlighter-rouge">timeProc</code> 函数，<code class="highlighter-rouge">timeProc</code> 函数的返回值 <code class="highlighter-rouge">retval</code> 为时间事件执行的时间间隔：</p>

<ul>
  <li><code class="highlighter-rouge">retval == AE_NOMORE</code>：将时间事件的 <code class="highlighter-rouge">id</code> 设置为 <code class="highlighter-rouge">AE_DELETED_EVENT_ID</code>，等待下次 <code class="highlighter-rouge">aeProcessEvents</code> 执行时将事件清除；</li>
  <li><code class="highlighter-rouge">retval != AE_NOMORE</code>：修改当前时间事件的执行时间并重复利用当前的时间事件；</li>
</ul>

<p>以使用 <code class="highlighter-rouge">aeCreateTimeEvent</code> 一个创建的简单时间事件为例：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">aeCreateTimeEvent</span><span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="n">el</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">showThroughput</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="nb">NULL</span><span class="p">)</span>
</code></pre></div></div>

<p>时间事件对应的函数 <code class="highlighter-rouge">showThroughput</code> 在每次执行时会返回一个数字，也就是该事件发生的时间间隔：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">showThroughput</span><span class="p">(</span><span class="k">struct</span> <span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">clientData</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kt">float</span> <span class="n">dt</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)(</span><span class="n">mstime</span><span class="p">()</span><span class="o">-</span><span class="n">config</span><span class="p">.</span><span class="n">start</span><span class="p">)</span><span class="o">/</span><span class="mi">1000</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">rps</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">config</span><span class="p">.</span><span class="n">requests_finished</span><span class="o">/</span><span class="n">dt</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%s: %.2f</span><span class="se">\r</span><span class="s">"</span><span class="p">,</span> <span class="n">config</span><span class="p">.</span><span class="n">title</span><span class="p">,</span> <span class="n">rps</span><span class="p">);</span>
    <span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">250</span><span class="p">;</span> <span class="cm">/* every 250ms */</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这样就不需要重新 <code class="highlighter-rouge">malloc</code> 一块相同大小的内存，提高了时间事件处理的性能，并减少了内存的使用量。</p>

<p>我们对 Redis 中对时间事件的处理以流程图的形式简单总结一下：</p>

<p><img src="https://img.draveness.me/2016-12-09-process-time-event.png-1000width" alt="process-time-event" /></p>

<p>创建时间事件的方法实现其实非常简单，在这里不想过多分析这个方法，唯一需要注意的就是时间事件的 <code class="highlighter-rouge">id</code> 跟数据库中的大多数主键都是递增的：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="kt">long</span> <span class="nf">aeCreateTimeEvent</span><span class="p">(</span><span class="n">aeEventLoop</span> <span class="o">*</span><span class="n">eventLoop</span><span class="p">,</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">milliseconds</span><span class="p">,</span>
        <span class="n">aeTimeProc</span> <span class="o">*</span><span class="n">proc</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">clientData</span><span class="p">,</span>
        <span class="n">aeEventFinalizerProc</span> <span class="o">*</span><span class="n">finalizerProc</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">id</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">timeEventNextId</span><span class="o">++</span><span class="p">;</span>
    <span class="n">aeTimeEvent</span> <span class="o">*</span><span class="n">te</span><span class="p">;</span>

    <span class="n">te</span> <span class="o">=</span> <span class="n">zmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">te</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">te</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">AE_ERR</span><span class="p">;</span>
    <span class="n">te</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">id</span><span class="p">;</span>
    <span class="n">aeAddMillisecondsToNow</span><span class="p">(</span><span class="n">milliseconds</span><span class="p">,</span><span class="o">&amp;</span><span class="n">te</span><span class="o">-&gt;</span><span class="n">when_sec</span><span class="p">,</span><span class="o">&amp;</span><span class="n">te</span><span class="o">-&gt;</span><span class="n">when_ms</span><span class="p">);</span>
    <span class="n">te</span><span class="o">-&gt;</span><span class="n">timeProc</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span>
    <span class="n">te</span><span class="o">-&gt;</span><span class="n">finalizerProc</span> <span class="o">=</span> <span class="n">finalizerProc</span><span class="p">;</span>
    <span class="n">te</span><span class="o">-&gt;</span><span class="n">clientData</span> <span class="o">=</span> <span class="n">clientData</span><span class="p">;</span>
    <span class="n">te</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">timeEventHead</span><span class="p">;</span>
    <span class="n">eventLoop</span><span class="o">-&gt;</span><span class="n">timeEventHead</span> <span class="o">=</span> <span class="n">te</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">id</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="事件的处理">事件的处理</h2>

<blockquote>
  <p>上一章节我们已经从代码的角度对 Redis 中事件的处理有一定的了解，在这里，我想从更高的角度来观察 Redis 对于事件的处理是怎么进行的。</p>
</blockquote>

<p>整个 Redis 服务在启动之后会陷入一个巨大的 while 循环，不停地执行 <code class="highlighter-rouge">processEvents</code> 方法处理文件事件 fe 和时间事件 te 。</p>

<blockquote>
  <p>有关 Redis 中的 I/O 多路复用模块可以看这篇文章 <a href="http://draveness.me/redis-io-multiplexing/">Redis 和 I/O 多路复用</a>。</p>
</blockquote>

<p>当文件事件触发时会被标记为 “红色” 交由 <code class="highlighter-rouge">processEvents</code> 方法处理，而时间事件的处理都会交给 <code class="highlighter-rouge">processTimeEvents</code> 这一子方法：</p>

<p><img src="https://img.draveness.me/2016-12-09-redis-eventloop-proces-event.png-1000width" alt="redis-eventloop-proces-event" /></p>

<p>在每个事件循环中 Redis 都会先处理文件事件，然后再处理时间事件直到整个循环停止，<code class="highlighter-rouge">processEvents</code> 和 <code class="highlighter-rouge">processTimeEvents</code> 作为 Redis 中发生事件的消费者，每次都会从“事件池”中拉去待处理的事件进行消费。</p>

<h3 id="文件事件的处理">文件事件的处理</h3>

<p>由于文件事件触发条件较多，并且 OS 底层实现差异性较大，底层的 I/O 多路复用模块使用了 <code class="highlighter-rouge">eventLoop-&gt;aeFiredEvent</code> 保存对应的文件描述符以及事件，将信息传递给上层进行处理，并抹平了底层实现的差异。</p>

<p>整个 I/O 多路复用模块在事件循环看来就是一个输入事件、输出 <code class="highlighter-rouge">aeFiredEvent</code> 数组的一个黑箱：</p>

<p><img src="https://img.draveness.me/2016-12-09-eventloop-file-event-in-redis.png-1000width" alt="eventloop-file-event-in-redis" /></p>

<p>在这个黑箱中，我们使用 <code class="highlighter-rouge">aeCreateFileEvent</code>、 <code class="highlighter-rouge">aeDeleteFileEvent</code> 来添加删除需要监听的文件描述符以及事件。</p>

<p>在对应事件发生时，当前单元格会“变色”表示发生了可读（黄色）或可写（绿色）事件，调用 <code class="highlighter-rouge">aeApiPoll</code> 时会把对应的文件描述符和事件放入 <code class="highlighter-rouge">aeFiredEvent</code> 数组，并在 <code class="highlighter-rouge">processEvents</code> 方法中执行事件对应的回调。</p>

<h3 id="时间事件的处理">时间事件的处理</h3>

<p>时间事件的处理相比文件事件就容易多了，每次 <code class="highlighter-rouge">processTimeEvents</code> 方法调用时都会对整个 <code class="highlighter-rouge">timeEventHead</code> 数组进行遍历：</p>

<p><img src="https://img.draveness.me/2016-12-09-process-time-events-in-redis.png-1000width" alt="process-time-events-in-redis" /></p>

<p>遍历的过程中会将时间的触发时间与当前时间比较，然后执行时间对应的 <code class="highlighter-rouge">timeProc</code>，并根据 <code class="highlighter-rouge">timeProc</code> 的返回值修改当前事件的参数，并在下一个循环的遍历中移除不再执行的时间事件。</p>

<h2 id="总结">总结</h2>

<blockquote>
  <p>笔者对于文章中两个模块的展示顺序考虑了比较久的时间，最后还是觉得，目前这样的顺序更易于理解。</p>
</blockquote>

<p>Redis 对于事件的处理方式十分精巧，通过传入函数指针以及返回值的方式，将时间事件移除的控制权交给了需要执行的处理器 <code class="highlighter-rouge">timeProc</code>，在 <code class="highlighter-rouge">processTimeEvents</code> 设置 <code class="highlighter-rouge">aeApiPoll</code> 超时时间也十分巧妙，充分地利用了每一次事件循环，防止过多的无用的空转，并且保证了该方法不会阻塞太长时间。</p>

<p>事件循环的机制并不能时间事件准确地在某一个时间点一定执行，往往会比实际约定处理的时间稍微晚一些。</p>

<h2 id="reference">Reference</h2>

<ul>
  <li><a href="https://redis.io/topics/internals-rediseventlib">Redis Event Library</a></li>
  <li><a href="http://key-value-stories.blogspot.com/2015/01/redis-core-implementation.html">Redis Core Implementation</a></li>
  <li><a href="http://draveness.me/redis-io-multiplexing/">Redis 和 I/O 多路复用</a></li>
  <li><a href="http://redisbook.com">Redis 设计与实现</a></li>
</ul>

<h2 id="其它">其它</h2>

<blockquote>

  <p>Source: http://draveness.me/redis-eventloop</p>
</blockquote>


        </section>

        <footer class="post-footer">

            <!-- Everything inside the #author tags pulls data from the author -->
            <!-- #author-->
            
                
            
                
            
                
            
                
            
                
            

            <!-- Add Disqus Comments -->
            

        </footer>

    </article>

</main>
<aside class="read-next">

    <!-- [[! next_post ]] -->
    
        <a class="read-next-story no-cover" href="/blogs/redis-cli">
            <section class="post">
                <h2>Redis 是如何处理命令的（客户端）</h2>
                <p>在使用 Redis 的过程中经常会好奇，在 Redis-Cli 中键入 `SET KEY MSG` 并回车之后，Redis 客户端和服务是如何对命令进行解析处理的，而在内部的实现过程是什么样的。 这两篇文章会分别介绍 Redis 客户端和服务端分别对命令是如何处理的，本篇文章介绍的是 Redis 客户端如何处理输入的命令、向服务发送命令以及取得服务端回复并输出到终端等过程。...</p>
            </section>
        </a>
    
    <!-- [[! /next_post ]] -->
    <!-- [[! prev_post ]] -->
    
        <a class="read-next-story prev no-cover" href="/blogs/redis-io-multiplexing">
            <section class="post">
                <h2>Redis 和 I/O 多路复用</h2>
                <p>最近在看 UNIX 网络编程并研究了一下 Redis 的实现，感觉 Redis 的源代码十分适合阅读和分析，其中 I/O 多路复用（mutiplexing）部分的实现非常干净和优雅，在这里想对这部分的内容进行简单的整理。 几种 I/O 模型 为什么 Redis 中要使用...</p>
            </section>
        </a>
    
    <!-- [[! /prev_post ]] -->
</aside>

<!-- /post -->


        <!-- The tiny footer at the very bottom -->
        <footer class="site-footer clearfix">
          <section class="copyright"><a href="/blogs/">Brightness</a> &copy; 2018</section>
          <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> using <a href="https://github.com/jekyller/jasper">Jasper</a></section>
        </footer>
    </div>
    <!-- highlight.js -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.3.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <!-- jQuery needs to come before `` so that jQuery can be used in code injection -->
    <script type="text/javascript" src="//code.jquery.com/jquery-1.12.0.min.js"></script>
    <!-- Ghost outputs important scripts and data with this tag -->
    <!--  -->
    <!-- Add Google Analytics  -->
        <!-- Google Analytics Tracking code -->
     <script>
	    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	    ga('create', 'UA-69281367-1', 'auto');
	    ga('send', 'pageview');

     </script>
    <!-- Fitvids makes video embeds responsive and awesome -->
    <script type="text/javascript" src="/blogs/assets/js/jquery.fitvids.js"></script>
    <!-- The main JavaScript file for Casper -->
    <script type="text/javascript" src="/blogs/assets/js/index.js"></script>

</body>
</html>
