<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>brightphone.github.io/blogs/</title>
   
   <link></link>
   <description>A beautiful narrative written with the world's most elegant publishing platform. The story begins here.</description>
   <language>en-uk</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Prolog 列表和运算符 <4></title>
	  <link>/blogs//prolog-lie-biao-he-yun-suan-fu-4</link>
	  <author></author>
	  <pubDate>2015-04-10T06:36:10+00:00</pubDate>
	  <guid>/blogs//prolog-lie-biao-he-yun-suan-fu-4</guid>
	  <description><![CDATA[
	     <p>今天我们在这篇 post 中介绍一下列表和运算符, 相信熟悉或者玩过函数式编程语言的朋友可能已经在函数式编程中掌握了列表, 而今天我带来的是逻辑式编程语言 Prolog 中的列表, 以及它的使用.</p>

<p>当然我还会在今天简单介绍一下 Prolog 中的运算符(Arithmetic). 不过这一部分的内容还是很简单的, 我们主要关注的部分就是 List.</p>

<p>##列表</p>

<p>列表, 这个在函数式编程中非常常见的数据结构, 今天在逻辑式编程中也逐渐崭露头角.</p>

<p>###什么是列表?</p>

<blockquote>
  <p>A list is just a plain old list of items.</p>
</blockquote>

<p>列表其实就是一些项目的序列.</p>

<p>在 Prolog 中的列表也与其他语言中有所不同, 我们下面来举一个例子.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[hello, hi, bye, 1, [[[[1]]]], [], buy(book), [X, 2], 1]
</code></pre></div></div>

<p>这个简单的例子实际上为我们提供了很多很多的信息:</p>

<ol>
  <li>我们使用 <code class="highlighter-rouge">[]</code> 来”包裹”一些元素来表示列表.</li>
  <li>列表可以含有各种不同类型的元素, 包括 atom, variable, complex term, number.</li>
  <li>列表中的元素是可以重复的, 与集合不同.</li>
  <li>列表可以是空的(empty list), 也就是 <code class="highlighter-rouge">[]</code>.</li>
  <li>列表是可以无限嵌套的.</li>
</ol>

<p>###列表的组成</p>

<p>Prolog 的列表与 Functional Programming 中的列表一样, 都由 <code class="highlighter-rouge">head</code> 和 <code class="highlighter-rouge">tail</code> 组成.</p>

<ul>
  <li><code class="highlighter-rouge">head</code> 就是列表的头部, 如果列表<strong>非空</strong>, 那么 <code class="highlighter-rouge">head</code> 就是列表的第一个元素.</li>
  <li><code class="highlighter-rouge">tail</code> 就是列表的尾部, 如果列表<strong>非空</strong>, 那么 <code class="highlighter-rouge">tail</code> 就是列表去掉第一个元素后剩下的元素构成的<strong>列表</strong>.</li>
</ul>

<p>在这里有一点需要注意的就是 <code class="highlighter-rouge">head</code> 一定是元素, 而 <code class="highlighter-rouge">tail</code> 一定是列表, 这一点有很大的不同, 相信各位会在之后的科普中逐一了解.</p>

<p>既然我们介绍了列表的组成, 那么有一个非常重要的操作符我们不得不提, 这个操作符在操作列表中是非常关键的, 也就是 <code class="highlighter-rouge">|</code>.</p>

<p>这个操作符到底是怎么用呢, 我们来看一段代码就知道了:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- [Head|Tail] = [1,2,3,4,5].
</code></pre></div></div>

<p>这段代码会返回</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Head = 1,
Tail = [2, 3, 4, 5].
</code></pre></div></div>

<p>我们可以看到 <code class="highlighter-rouge">|</code> 操作符将列表分成了两个部分, 分别是 <code class="highlighter-rouge">Head</code> 和 <code class="highlighter-rouge">Tail</code>, <code class="highlighter-rouge">|</code> 成功地将列表分成了两个部分, 这就是它的作用, 而如果你在 Prolog 中输入如下查询:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- [X,Y|Z] = [1,2,3,4,5].
X = 1,
Y = 2,
Z = [3, 4, 5].
</code></pre></div></div>

<p>这就是 <code class="highlighter-rouge">|</code> 更加高级的使用, 当然我们也可以匿名变量, 来代替一些我们不需要使用的变量:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- [A,B,_,C,D|E] = [1,2,3,4,5].
A = 1,
B = 2,
C = 4,
D = 5,
E = [].
</code></pre></div></div>

<p>我们对于 <code class="highlighter-rouge">|</code> 的演示就先到这里, 接下来我们使用它来完成一些更加高级的操作.</p>

<p>###列表的操作</p>

<p>我们经常需要各种各样的操作来处理列表, 而这样的操作往往都是递归的, 接下来将实现一些重要的列表中的递归操作.</p>

<ul>
  <li>member</li>
  <li>append</li>
  <li>reverse</li>
</ul>

<p>####member</p>

<p>在列表的使用中, 需要来查看一个元素是否属于一个列表, 也就是 <code class="highlighter-rouge">member(E,List)</code>. 在软件或者程序的构建中, 我们需要一些底层的抽象, 为实现更复杂的抽象制作出一些中间材料, 而 <code class="highlighter-rouge">member/2</code> 就是其中之一.</p>

<p>我们怎么样才能实现它呢?</p>

<p>列表其实是一种递归的数据结构, 它由 <code class="highlighter-rouge">head</code> 和 <code class="highlighter-rouge">tail</code> 组成, 而每一个非空的 <code class="highlighter-rouge">tail</code> 也都由另一个 <code class="highlighter-rouge">newhead</code> 和 <code class="highlighter-rouge">newtail</code> 构成, 在这里, 只需要不断提取列表的 <code class="highlighter-rouge">head</code> 然后与 <code class="highlighter-rouge">X</code> 对比, 直到列表为空或者找到匹配元素为止就完成了这个操作.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>member(X,[X|T]).
member(X,[H|T]):-member(X,T).
</code></pre></div></div>

<p>这就是 <code class="highlighter-rouge">member</code> 的实现, 然后我们就可以再 Prolog 中测试一下了:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- member(3,[1,2,3,4,5]).
true .
</code></pre></div></div>

<p>当然我们也可以使用匿名变量重写 <code class="highlighter-rouge">member</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>member(X,[X|_]).
member(X,[_|T]):-member(X,T).
</code></pre></div></div>

<p>####append</p>

<p><code class="highlighter-rouge">append/3</code> 在 Prolog 中是一个经典的操作, 它的三个参数都是列表, 我们先来演示一下 <code class="highlighter-rouge">append</code> 是怎样使用的.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>append([1,2,3],[4,5,6],X).
X = [1, 2, 3, 4, 5, 6].
</code></pre></div></div>

<p><code class="highlighter-rouge">append</code> 就是将第二个列表拼接到第一个列表的后面, 第三个参数就是返回的列表.</p>

<p>下面我们来定义一下 <code class="highlighter-rouge">append(L1,L2,L3)</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>append([],L,L).
append([H|T],L2,[H|L3]):-append(T,L2,L3).
</code></pre></div></div>

<p>这是一个递归地定义, 它递归地将 <code class="highlighter-rouge">L1</code> 中的元素依次放到 <code class="highlighter-rouge">L3</code> 中直到 <code class="highlighter-rouge">L1</code> 为空时, 返回 <code class="highlighter-rouge">L2</code>. 这样整个 <code class="highlighter-rouge">append</code> 操作就完成了.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>append([a,b,c],[1,2,3],_G510)
append([b,c],  [1,2,3],_G523)
append([c],    [1,2,3],_G554)
append([],     [1,2,3],_G519)
append([],     [1,2,3],[1,2,3])
append([c],    [1,2,3],[c,1,2,3])
append([b,c],  [1,2,3],[b,c,1,2,3])
append([]a,b,c,[1,2,3],[a,b,c,1,2,3])

X = [a, b, c, 1, 2, 3].
</code></pre></div></div>

<p>我们一步一步的追踪 <code class="highlighter-rouge">append</code> 操作的过程, 这样相信这个操作的过程就很容易理解了.</p>

<p>####reverse</p>

<p>接下来我们介绍另一个断言(predicate) <code class="highlighter-rouge">reverse</code> . 它的作用就是将一个列表反转, 我们为什么要实现一个操作呢, 当操作列表的时候, 经常使用 <code class="highlighter-rouge">[H|_] = L</code> 来获取列表的头部, 但是列表的最后一个元素确实非常难以获得的, 这样就有了 <code class="highlighter-rouge">reverse</code> 操作诞生的原因.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reverse([1,2,3,4],Result).
Result = [4, 3, 2, 1].
</code></pre></div></div>

<p>在这里我们使用两种方法来实现 <code class="highlighter-rouge">reverse</code></p>

<p>#####递归实现 (使用<code class="highlighter-rouge">append</code>)</p>

<p><code class="highlighter-rouge">reverse</code> 的实现也应该是递归的, 先分析一下如何将一个列表反转.</p>

<ol>
  <li>如果需要 <code class="highlighter-rouge">reverse</code> 一个空列表, 那就直接返回一个空列表, 这是递归的边界条件.</li>
  <li>如果需要 <code class="highlighter-rouge">reverse</code> 一个列表 <code class="highlighter-rouge">[H|T]</code>, 只需要将反转 <code class="highlighter-rouge">[T]</code> 的结果接到 <code class="highlighter-rouge">H</code> 的后面.</li>
</ol>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reverse([],[]).
reverse([H|T],R) :-
	reverse(T,RT),
    append(RT,[H],R).
</code></pre></div></div>

<p>这个 <code class="highlighter-rouge">reverse</code> 的实现很简单, 但是它的效率很低, 因为 <code class="highlighter-rouge">append</code> 的运行效率就是极低的, 需要一种更加高效的 <code class="highlighter-rouge">reverse</code> 实现.</p>

<p>#####迭代实现 (使用 <code class="highlighter-rouge">Acc</code>)</p>

<p>更加优秀的方法就是使用一个累计器, 这里使用 <code class="highlighter-rouge">Acc</code>, 当你发现一个递归的断言或者说函数的效率十分的低效时, 使用迭代的方式, 添加一个累计器往往能成倍的提高程序或者代码的运行效率.</p>

<p>这里直接实现 <code class="highlighter-rouge">reverse</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reverse([H|T],A,R) :-
	reverse(T,[H|A],R).
reverse([],A,A).
reverse(L,R) :-
	reverse(L,[],R).
</code></pre></div></div>

<p>我们先实现一个具有累计器版本的 <code class="highlighter-rouge">reverse/3</code>, 然后再实现正常版本的 <code class="highlighter-rouge">reverse/2</code>.</p>

<p>##运算符</p>

<p>相信到目前为止, 已经对 Prolog 中的列表有了充分的了解, 而 Prolog 中的运算与其他的语言中有很大的不同, 如果你在 Prolog 中输入:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- 6 = 2 + 4.
false.
</code></pre></div></div>

<p>Prolog 会返回 <code class="highlighter-rouge">false</code> 这是为什么呢, 因为 Prolog 在比较的时候不会对 <code class="highlighter-rouge">+</code> 两边的公式进行运算, 所以可以说是”字符串”之间的比较. 那在 Prolog 中如何比较两个公式呢, 我们使用 <code class="highlighter-rouge">is</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- 6 is 2 + 4.
true.
</code></pre></div></div>

<p>同样我们如果输入:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- X = 3+2.
X = 3+2.
</code></pre></div></div>

<p><code class="highlighter-rouge">X</code> 也不会被初始化为 <code class="highlighter-rouge">5</code> 而是 <code class="highlighter-rouge">3+2</code>.</p>

<p>当我们把 <code class="highlighter-rouge">=</code> 替换为 <code class="highlighter-rouge">is</code> 时, 才会得到想要的结果.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- X is 3+2.
X = 5.
</code></pre></div></div>

<p>当然我们也可以使用 <code class="highlighter-rouge">is</code> 来定义一些更加复杂的断言,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>add_3_and_double(X,Y) :-
	Y is (X+3)*2.
</code></pre></div></div>

<p>然后我们问 Prolog:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- add_3_and_double(1,X).
X = 8.
</code></pre></div></div>

<p>Prolog 与其他语言不同的地方就在于 <code class="highlighter-rouge">is</code> 的使用, 其他部分并没有什么显著的不同. 接下来将展示几个使用运算符和列表的断言.</p>

<p>###len</p>

<p><code class="highlighter-rouge">len</code> 是一个计算列表长度的断言, 它的实现很简单.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>len([],0).
len([_|T],N) :-
	len(T,X),
    N is N+1.
</code></pre></div></div>

<p>当列表为空时就会返回 <code class="highlighter-rouge">1</code>, 是递归的边界条件, 而当列表不为空的时候, <code class="highlighter-rouge">X</code> 就会 <code class="highlighter-rouge">+1</code>.</p>

<p>###max</p>

<p><code class="highlighter-rouge">max</code> 会返回列表中最大的元素, 同样地, 使用两个操作符来实现这个断言.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>accMax([H|T],A,Max):-
    H &gt; A,
    accMax(T,H,Max).
accMax([H|T],A,Max):-
    H=&lt;A,
    accMax(T,A,Max).
accMax([],A,A).
max(List,Max):-
	[H|_] = List,
	accMax(List,H,Max).
</code></pre></div></div>

<p>到这里我们对于这部分的介绍就到这里了.</p>

	  ]]></description>
	</item>


</channel>
</rss>
